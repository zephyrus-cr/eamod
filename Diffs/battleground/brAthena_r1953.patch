Index: src/char/char.c
===================================================================
--- src/char/char.c	(revision 1953)
+++ src/char/char.c	(working copy)
@@ -28,12 +28,13 @@
 #include "int_guild.h"
 #include "int_homun.h"
 #include "int_mercenary.h"
-#include "int_elemental.h"
-#include "int_party.h"
-#include "int_storage.h"
-#include "char.h"
-#include "inter.h"
-
+#include "int_elemental.h"
+#include "int_party.h"
+#include "int_storage.h"
+#include "int_mail.h"
+#include "char.h"
+#include "inter.h"
+
 #include <sys/types.h>
 #include <time.h>
 #include <signal.h>
@@ -46,12 +47,13 @@
 #define CHAR_CONF_NAME  "conf/char_brathena.conf"
 #define LAN_CONF_NAME   "conf/subnet_brathena.conf"
 #define SQL_CONF_NAME   "conf/inter_brathena.conf"
-
-char char_db[256] = "char";
-char scdata_db[256] = "sc_data";
-char cart_db[256] = "cart_inventory";
-char inventory_db[256] = "inventory";
-char charlog_db[256] = "charlog";
+
+char char_db[256] = "char";
+char scdata_db[256] = "sc_data";
+char skillcooldown_db[256] = "skillcooldown";
+char cart_db[256] = "cart_inventory";
+char inventory_db[256] = "inventory";
+char charlog_db[256] = "charlog";
 char storage_db[256] = "storage";
 char interlog_db[256] = "interlog";
 char reg_db[256] = "global_reg_value";
@@ -62,25 +64,27 @@
 char guild_castle_db[256] = "guild_castle";
 char guild_expulsion_db[256] = "guild_expulsion";
 char guild_member_db[256] = "guild_member";
-char guild_position_db[256] = "guild_position";
-char guild_skill_db[256] = "guild_skill";
-char guild_storage_db[256] = "guild_storage";
-char party_db[256] = "party";
-char pet_db[256] = "pet";
-char mail_db[256] = "mail"; // MAIL SYSTEM
+char guild_position_db[256] = "guild_position";
+char guild_skill_db[256] = "guild_skill";
+char guild_storage_db[256] = "guild_storage";
+char rentstorage_db[256] = "rentstorage"; // [ZephStorage]
+char party_db[256] = "party";
+char pet_db[256] = "pet";
+char mail_db[256] = "mail"; // MAIL SYSTEM
 char auction_db[256] = "auction"; // Auctions System
 char friend_db[256] = "friends";
 char hotkey_db[256] = "hotkey";
 char quest_db[256] = "quest";
 char homunculus_db[256] = "homunculus";
 char skill_homunculus_db[256] = "skill_homunculus";
-char mercenary_db[256] = "mercenary";
-char mercenary_owner_db[256] = "mercenary_owner";
-char ragsrvinfo_db[256] = "ragsrvinfo";
+char mercenary_db[256] = "mercenary";
+char mercenary_owner_db[256] = "mercenary_owner";
+char ragsrvinfo_db[256] = "ragsrvinfo";
+char achievement_db[256] = "achievement";
+
+// show loading/saving messages
+int save_log = 1;
 
-// show loading/saving messages
-int save_log = 1;
-
 static DBMap *char_db_; // int char_id -> struct mmo_charstatus*
 
 char db_path[1024] = "db";
@@ -160,6 +164,12 @@
 int start_armor = 2301;
 int guild_exp_rate = 100;
 
+int guild_base_members = 16;
+int guild_add_members = 6;
+
+int bg_regular_rewards[3] = { 0, 0, 0 };
+int bg_ranked_rewards[3] = { 0, 0, 0 };
+
 // Sistema de código PIN
 #define PINCODE_OK 0
 #define PINCODE_ASK 1
@@ -193,12 +203,20 @@
 int fame_list_size_chemist = MAX_FAME_LIST;
 int fame_list_size_smith = MAX_FAME_LIST;
 int fame_list_size_taekwon = MAX_FAME_LIST;
+int fame_list_size_pvprank = MAX_FAME_LIST; // [Zephyrus]
 
+int fame_list_size_bgrank = MAX_FAME_LIST;
+int fame_list_size_bg = MAX_FAME_LIST;
+
 // Char-server-side stored fame lists [DracoRPG]
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list pvprank_fame_list[MAX_FAME_LIST]; // [Zephyrus]
 
+struct fame_list bgrank_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+
 // check for exit signal
 // 0 is saving complete
 // other is char_id
@@ -495,12 +513,21 @@
 		if(!memitemdata_to_sql(p->storage.items, MAX_STORAGE, p->account_id, TABLE_STORAGE))
 			strcat(save_status, " storage");
 		else
-			errors++;
-	}
-
-	if(
-	    (p->base_exp != cp->base_exp) || (p->base_level != cp->base_level) ||
-	    (p->job_level != cp->job_level) || (p->job_exp != cp->job_exp) ||
+			errors++;
+	}
+
+	//map rentstorage data
+	if( memcmp(p->ext_storage.items, cp->ext_storage.items, sizeof(p->ext_storage.items)) )
+	{
+		if( !memitemdata_to_sql(p->ext_storage.items, MAX_EXTRA_STORAGE, p->account_id, TABLE_EXT_STORAGE))
+			strcat(save_status, " rentstorage");
+		else
+			errors++;
+	}
+
+	if (
+		(p->base_exp != cp->base_exp) || (p->base_level != cp->base_level) ||
+		(p->job_level != cp->job_level) || (p->job_exp != cp->job_exp) ||
 	    (p->zeny != cp->zeny) ||
 	    (p->last_point.map != cp->last_point.map) ||
 	    (p->last_point.x != cp->last_point.x) || (p->last_point.y != cp->last_point.y) ||
@@ -510,32 +537,33 @@
 	    (p->str != cp->str) || (p->agi != cp->agi) || (p->vit != cp->vit) ||
 	    (p->int_ != cp->int_) || (p->dex != cp->dex) || (p->luk != cp->luk) ||
 	    (p->option != cp->option) ||
-	    (p->party_id != cp->party_id) || (p->guild_id != cp->guild_id) ||
+	    (p->party_id != cp->party_id) || (p->guild_id != cp->guild_id) || (p->faction_id != cp->faction_id) ||
 	    (p->pet_id != cp->pet_id) || (p->weapon != cp->weapon) || (p->hom_id != cp->hom_id) ||
 	    (p->ele_id != cp->ele_id) || (p->shield != cp->shield) || (p->head_top != cp->head_top) ||
 	    (p->head_mid != cp->head_mid) || (p->head_bottom != cp->head_bottom) || (p->delete_date != cp->delete_date) ||
-	    (p->rename != cp->rename) || (p->robe != cp->robe) || (p->character_moves != cp->character_moves)
+	    (p->rename != cp->rename) || (p->robe != cp->robe) || (p->character_moves != cp->character_moves) || (p->playtime != cp->playtime)
 	) {
 		//Save status
 		if(SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `base_level`='%d', `job_level`='%d',"
 		                          "`base_exp`='%u', `job_exp`='%u', `zeny`='%d',"
 		                          "`max_hp`='%d',`hp`='%d',`max_sp`='%d',`sp`='%d',`status_point`='%d',`skill_point`='%d',"
 		                          "`str`='%d',`agi`='%d',`vit`='%d',`int`='%d',`dex`='%d',`luk`='%d',"
-		                          "`option`='%d',`party_id`='%d',`guild_id`='%d',`pet_id`='%d',`homun_id`='%d',`elemental_id`='%d',"
+		                          "`option`='%d',`party_id`='%d',`guild_id`='%d',`pet_id`='%d',`homun_id`='%d',`elemental_id`='%d',`faction_id`='%d',"
 		                          "`weapon`='%d',`shield`='%d',`head_top`='%d',`head_mid`='%d',`head_bottom`='%d',"
 		                          "`last_map`='%s',`last_x`='%d',`last_y`='%d',`save_map`='%s',`save_x`='%d',`save_y`='%d', `rename`='%d',"
-		                          "`delete_date`='%lu',`robe`='%d',`moves`='%d'"
+		                          "`delete_date`='%lu',`robe`='%d',`moves`='%d',`playtime`='%u'"
 		                          " WHERE  `account_id`='%d' AND `char_id` = '%d'",
 		                          char_db, p->base_level, p->job_level,
 		                          p->base_exp, p->job_exp, p->zeny,
 		                          p->max_hp, p->hp, p->max_sp, p->sp, p->status_point, p->skill_point,
 		                          p->str, p->agi, p->vit, p->int_, p->dex, p->luk,
-		                          p->option, p->party_id, p->guild_id, p->pet_id, p->hom_id, p->ele_id,
+		                          p->option, p->party_id, p->guild_id, p->pet_id, p->hom_id, p->ele_id, p->faction_id,
 		                          p->weapon, p->shield, p->head_top, p->head_mid, p->head_bottom,
 		                          mapindex_id2name(p->last_point.map), p->last_point.x, p->last_point.y,
 		                          mapindex_id2name(p->save_point.map), p->save_point.x, p->save_point.y, p->rename,
 		                          (unsigned long)p->delete_date,  // FIXME: platform-dependent size
 		                          p->robe,p->character_moves,
+								  p->playtime,
 		                          p->account_id, p->char_id)) {
 			Sql_ShowDebug(sql_handle);
 			errors++;
@@ -565,12 +593,176 @@
 			Sql_ShowDebug(sql_handle);
 			errors++;
 		} else
-			strcat(save_status, " status2");
-	}
-
-	/* Mercenary Owner */
-	if((p->mer_id != cp->mer_id) ||
-	   (p->arch_calls != cp->arch_calls) || (p->arch_faith != cp->arch_faith) ||
+			strcat(save_status, " status2");
+	}
+
+	/* Player PVP Event Ranking */
+	if( memcmp(&p->pvp, &cp->pvp, sizeof(struct s_killrank)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_pvp` (`char_id`, `kill_count`, `death_count`, `score`) VALUES ('%d', '%d', '%d', '%d')", p->char_id, p->pvp.kill_count, p->pvp.death_count, p->pvp.score) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " pvprank");
+	}
+
+	/* Player PK Ranking */
+	if( memcmp(&p->pk, &cp->pk, sizeof(struct s_killrank)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_pk` (`char_id`, `kill_count`, `death_count`, `score`) VALUES ('%d', '%d', '%d', '%d')", p->char_id, p->pk.kill_count, p->pk.death_count, p->pk.score) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " pkrank");
+	}
+
+	/* Player Battleground Stadistics */
+	if( memcmp(&p->bgstats, &cp->bgstats, sizeof(struct s_battleground_stats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`)"
+			" VALUES "
+			"('%d',"
+			"'%u','%u','%u',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%u','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d')",
+			p->char_id,
+			p->bgstats.top_damage, p->bgstats.damage_done, p->bgstats.damage_received,
+			p->bgstats.skulls,p->bgstats.ti_wins,p->bgstats.ti_lost,p->bgstats.ti_tie,
+			p->bgstats.eos_flags,p->bgstats.eos_bases,p->bgstats.eos_wins,p->bgstats.eos_lost,p->bgstats.eos_tie,
+			p->bgstats.boss_killed,p->bgstats.boss_damage,p->bgstats.boss_flags,p->bgstats.boss_wins,p->bgstats.boss_lost,p->bgstats.boss_tie,
+			p->bgstats.dom_bases,p->bgstats.dom_off_kills,p->bgstats.dom_def_kills,p->bgstats.dom_wins,p->bgstats.dom_lost,p->bgstats.dom_tie,
+			p->bgstats.td_kills,p->bgstats.td_deaths,p->bgstats.td_wins,p->bgstats.td_lost,p->bgstats.td_tie,
+			p->bgstats.sc_stole,p->bgstats.sc_captured,p->bgstats.sc_droped,p->bgstats.sc_wins,p->bgstats.sc_lost,p->bgstats.sc_tie,
+			p->bgstats.ctf_taken,p->bgstats.ctf_captured,p->bgstats.ctf_droped,p->bgstats.ctf_wins,p->bgstats.ctf_lost,p->bgstats.ctf_tie,
+			p->bgstats.emperium_kill,p->bgstats.barricade_kill,p->bgstats.gstone_kill,p->bgstats.cq_wins,p->bgstats.cq_lost,
+			p->bgstats.ru_captures,p->bgstats.ru_wins,p->bgstats.ru_lost,
+			p->bgstats.kill_count,p->bgstats.death_count,p->bgstats.win,p->bgstats.lost,p->bgstats.tie,p->bgstats.leader_win,p->bgstats.leader_lost,p->bgstats.leader_tie,p->bgstats.deserter,p->bgstats.score,p->bgstats.points,p->bgstats.rank_points,p->bgstats.rank_games,
+			p->bgstats.sp_heal_potions, p->bgstats.hp_heal_potions, p->bgstats.yellow_gemstones, p->bgstats.red_gemstones, p->bgstats.blue_gemstones, p->bgstats.poison_bottles, p->bgstats.acid_demostration, p->bgstats.acid_demostration_fail,
+			p->bgstats.support_skills_used, p->bgstats.healing_done, p->bgstats.wrong_support_skills_used, p->bgstats.wrong_healing_done,
+			p->bgstats.sp_used, p->bgstats.zeny_used, p->bgstats.spiritb_used, p->bgstats.ammo_used) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " bgstats");
+	}
+
+	/* WoE Stadistics */
+	if( memcmp(&p->wstats, &cp->wstats, sizeof(struct s_woestats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_wstats` (`char_id`, `kill_count`, `death_count`, `score`, `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`) "
+			"VALUES ('%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u')",
+			p->char_id, p->wstats.kill_count, p->wstats.death_count, p->wstats.score, p->wstats.top_damage, p->wstats.damage_done, p->wstats.damage_received, p->wstats.emperium_damage, p->wstats.guardian_damage, p->wstats.barricade_damage, p->wstats.gstone_damage,
+			p->wstats.emperium_kill, p->wstats.guardian_kill, p->wstats.barricade_kill, p->wstats.gstone_kill,
+			p->wstats.sp_heal_potions, p->wstats.hp_heal_potions, p->wstats.yellow_gemstones, p->wstats.red_gemstones, p->wstats.blue_gemstones, p->wstats.poison_bottles, p->wstats.acid_demostration, p->wstats.acid_demostration_fail,
+			p->wstats.support_skills_used, p->wstats.healing_done, p->wstats.wrong_support_skills_used, p->wstats.wrong_healing_done,
+			p->wstats.sp_used, p->wstats.zeny_used, p->wstats.spiritb_used, p->wstats.ammo_used) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " woestats");
+	}
+
+	/* Skill Usage */
+	if( memcmp(&p->skillcount, &cp->skillcount, sizeof(p->skillcount)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `skill_count` WHERE `char_id` = '%d'", p->char_id) )
+		{
+			Sql_ShowDebug(sql_handle); // Clear Data
+			errors++;
+		}
+		StringBuf_Clear(&buf);
+		StringBuf_Printf(&buf, "INSERT INTO `skill_count` (`char_id`,`id`,`count`) VALUES ");
+		//insert here.
+		for( i = 0, count = 0; i < MAX_SKILL_TREE; ++i )
+		{
+			if( p->skillcount[i].id && p->skillcount[i].count > 0 )
+			{
+				if( count )
+					StringBuf_AppendStr(&buf, ",");
+				StringBuf_Printf(&buf, "('%d','%d','%d')", char_id, p->skillcount[i].id, p->skillcount[i].count);
+				++count;
+			}
+		}
+		if( count )
+		{
+			if( SQL_ERROR == Sql_QueryStr(sql_handle, StringBuf_Value(&buf)) )
+			{
+				Sql_ShowDebug(sql_handle);
+				errors++;
+			}
+		}
+		strcat(save_status, " skillcount");
+	}
+
+	/* BG Skill Usage */
+	if( memcmp(&p->bg_skillcount, &cp->bg_skillcount, sizeof(p->bg_skillcount)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `bg_skill_count` WHERE `char_id` = '%d'", p->char_id) )
+		{
+			Sql_ShowDebug(sql_handle); // Clear Data
+			errors++;
+		}
+		StringBuf_Clear(&buf);
+		StringBuf_Printf(&buf, "INSERT INTO `bg_skill_count` (`char_id`,`id`,`count`) VALUES ");
+		//insert here.
+		for( i = 0, count = 0; i < MAX_SKILL_TREE; ++i )
+		{
+			if( p->bg_skillcount[i].id && p->bg_skillcount[i].count > 0 )
+			{
+				if( count )
+					StringBuf_AppendStr(&buf, ",");
+				StringBuf_Printf(&buf, "('%d','%d','%d')", char_id, p->bg_skillcount[i].id, p->bg_skillcount[i].count);
+				++count;
+			}
+		}
+		if( count )
+		{
+			if( SQL_ERROR == Sql_QueryStr(sql_handle, StringBuf_Value(&buf)) )
+			{
+				Sql_ShowDebug(sql_handle);
+				errors++;
+			}
+		}
+		strcat(save_status, " bg_skillcount");
+	}
+
+	/* Mercenary Owner */
+	if( (p->mer_id != cp->mer_id) ||
+		(p->arch_calls != cp->arch_calls) || (p->arch_faith != cp->arch_faith) ||
 	   (p->spear_calls != cp->spear_calls) || (p->spear_faith != cp->spear_faith) ||
 	   (p->sword_calls != cp->sword_calls) || (p->sword_faith != cp->sword_faith)) {
 		if(mercenary_owner_tosql(char_id, p))
@@ -734,8 +926,9 @@
 		case TABLE_INVENTORY:     tablename = inventory_db;     selectoption = "char_id";    break;
 		case TABLE_CART:          tablename = cart_db;          selectoption = "char_id";    break;
 		case TABLE_STORAGE:       tablename = storage_db;       selectoption = "account_id"; break;
-		case TABLE_GUILD_STORAGE: tablename = guild_storage_db; selectoption = "guild_id";   break;
-		default:
+	case TABLE_GUILD_STORAGE: tablename = guild_storage_db; selectoption = "guild_id";   break;
+	case TABLE_EXT_STORAGE:   tablename = rentstorage_db;   selectoption = "account_id"; break;
+	default:
 			ShowError(read_message("Source.char.char_memitemdata_to_sql"));
 			return 1;
 	}
@@ -744,14 +937,14 @@
 	// The following code compares inventory with current database values
 	// and performs modification/deletion/insertion only on relevant rows.
 	// This approach is more complicated than a trivial delete&insert, but
-	// it significantly reduces cpu load on the database server.
+	// it significantly reduces cpu load on the database server.
+
+	StringBuf_Init(&buf);
+	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `unique_id`, `bound`, `favorite`");
+	for( j = 0; j < MAX_SLOTS; ++j )
+		StringBuf_Printf(&buf, ", `card%d`", j);
+	StringBuf_Printf(&buf, " FROM `%s` WHERE `%s`='%d'", tablename, selectoption, id);
 
-	StringBuf_Init(&buf);
-	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`");
-	for(j = 0; j < MAX_SLOTS; ++j)
-		StringBuf_Printf(&buf, ", `card%d`", j);
-	StringBuf_Printf(&buf, " FROM `%s` WHERE `%s`='%d'", tablename, selectoption, id);
-
 	stmt = SqlStmt_Malloc(sql_handle);
 	if(SQL_ERROR == SqlStmt_PrepareStr(stmt, StringBuf_Value(&buf))
 	   ||  SQL_ERROR == SqlStmt_Execute(stmt)) {
@@ -766,25 +959,30 @@
 	SqlStmt_BindColumn(stmt, 2, SQLDT_SHORT,     &item.amount,      0, NULL, NULL);
 	SqlStmt_BindColumn(stmt, 3, SQLDT_USHORT,    &item.equip,       0, NULL, NULL);
 	SqlStmt_BindColumn(stmt, 4, SQLDT_CHAR,      &item.identify,    0, NULL, NULL);
-	SqlStmt_BindColumn(stmt, 5, SQLDT_CHAR,      &item.refine,      0, NULL, NULL);
-	SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,      &item.attribute,   0, NULL, NULL);
-	SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,      &item.expire_time, 0, NULL, NULL);
-	for(j = 0; j < MAX_SLOTS; ++j)
-		SqlStmt_BindColumn(stmt, 8+j, SQLDT_SHORT, &item.card[j], 0, NULL, NULL);
+	SqlStmt_BindColumn(stmt, 5, SQLDT_CHAR,      &item.refine,      0, NULL, NULL);
+	SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,      &item.attribute,   0, NULL, NULL);
+	SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,      &item.expire_time, 0, NULL, NULL);
+	SqlStmt_BindColumn(stmt, 8, SQLDT_ULONGLONG, &item.unique_id,      0, NULL, NULL);
+	SqlStmt_BindColumn(stmt, 9, SQLDT_CHAR,      &item.bound,       0, NULL, NULL);
+	SqlStmt_BindColumn(stmt,10, SQLDT_CHAR,      &item.favorite,    0, NULL, NULL);
+	for( j = 0; j < MAX_SLOTS; ++j )
+		SqlStmt_BindColumn(stmt, 11+j, SQLDT_SHORT, &item.card[j], 0, NULL, NULL);
+
+	// bit array indicating which inventory items have already been matched
+	flag = (bool*) aCalloc(max, sizeof(bool));
 
-	// bit array indicating which inventory items have already been matched
-	flag = (bool *) aCalloc(max, sizeof(bool));
-
 	while(SQL_SUCCESS == SqlStmt_NextRow(stmt)) {
 		found = false;
 		// search for the presence of the item in the char's inventory
 		for(i = 0; i < max; ++i) {
-			// skip empty and already matched entries
-			if(items[i].nameid == 0 || flag[i])
-				continue;
-
-			if(items[i].nameid == item.nameid
-			   &&  items[i].card[0] == item.card[0]
+			// skip empty and already matched entries
+			if( items[i].nameid == 0 || flag[i] )
+				continue;
+			if( items[i].unique_id && items[i].unique_id != item.unique_id )
+				continue;
+
+			if( items[i].nameid == item.nameid
+			&&  items[i].card[0] == item.card[0]
 			   &&  items[i].card[2] == item.card[2]
 			   &&  items[i].card[3] == item.card[3]
 			  ) { //They are the same item.
@@ -795,13 +993,16 @@
 				   items[i].identify == item.identify &&
 				   items[i].refine == item.refine &&
 				   items[i].attribute == item.attribute &&
-				   items[i].expire_time == item.expire_time)
-					;   //Do nothing.
+				    items[i].unique_id == item.unique_id &&
+				    items[i].expire_time == item.expire_time &&
+					items[i].favorite == item.favorite &&
+					items[i].bound == item.bound )
+				;	//Do nothing - Same data on DB and Memory
 				else {
 					// update all fields.
 					StringBuf_Clear(&buf);
-					StringBuf_Printf(&buf, "UPDATE `%s` SET `amount`='%d', `equip`='%d', `identify`='%d', `refine`='%d',`attribute`='%d', `expire_time`='%u'",
-					                 tablename, items[i].amount, items[i].equip, items[i].identify, items[i].refine, items[i].attribute, items[i].expire_time);
+					StringBuf_Printf(&buf, "UPDATE `%s` SET `amount`='%d', `equip`='%d', `identify`='%d', `refine`='%d',`attribute`='%d', `expire_time`='%u', `unique_id`='%"PRIu64"', `bound`='%d', `favorite`='%d'",
+						tablename, items[i].amount, items[i].equip, items[i].identify, items[i].refine, items[i].attribute, items[i].expire_time, items[i].unique_id, items[i].bound, items[i].favorite);
 					for(j = 0; j < MAX_SLOTS; ++j)
 						StringBuf_Printf(&buf, ", `card%d`=%d", j, items[i].card[j]);
 					StringBuf_Printf(&buf, " WHERE `id`='%d' LIMIT 1", item.id);
@@ -824,14 +1025,14 @@
 			}
 		}
 	}
-	SqlStmt_Free(stmt);
+	SqlStmt_Free(stmt);
+
+	StringBuf_Clear(&buf);
+	StringBuf_Printf(&buf, "INSERT INTO `%s`(`%s`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `unique_id`, `bound`, `favorite`", tablename, selectoption);
+	for( j = 0; j < MAX_SLOTS; ++j )
+		StringBuf_Printf(&buf, ", `card%d`", j);
+	StringBuf_AppendStr(&buf, ") VALUES ");
 
-	StringBuf_Clear(&buf);
-	StringBuf_Printf(&buf, "INSERT INTO `%s`(`%s`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `unique_id`", tablename, selectoption);
-	for(j = 0; j < MAX_SLOTS; ++j)
-		StringBuf_Printf(&buf, ", `card%d`", j);
-	StringBuf_AppendStr(&buf, ") VALUES ");
-
 	found = false;
 	// insert non-matched items into the db as new items
 	for(i = 0; i < max; ++i) {
@@ -841,15 +1042,15 @@
 
 		if(found)
 			StringBuf_AppendStr(&buf, ",");
-		else
-			found = true;
+		else
+			found = true;
+
+		StringBuf_Printf(&buf, "('%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%"PRIu64"', '%d', '%d'",
+			id, items[i].nameid, items[i].amount, items[i].equip, items[i].identify, items[i].refine, items[i].attribute, items[i].expire_time, items[i].unique_id, items[i].bound, items[i].favorite);
+		for( j = 0; j < MAX_SLOTS; ++j )
+			StringBuf_Printf(&buf, ", '%d'", items[i].card[j]);
+		StringBuf_AppendStr(&buf, ")");
 
-		StringBuf_Printf(&buf, "('%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%"PRIu64"'",
-		                 id, items[i].nameid, items[i].amount, items[i].equip, items[i].identify, items[i].refine, items[i].attribute, items[i].expire_time, items[i].unique_id);
-		for(j = 0; j < MAX_SLOTS; ++j)
-			StringBuf_Printf(&buf, ", '%d'", items[i].card[j]);
-		StringBuf_AppendStr(&buf, ")");
-
 		updateLastUid(items[i].unique_id); // Unique Non Stackable Item ID
 	}
 	dbUpdateUid(sql_handle); // Unique Non Stackable Item ID
@@ -1093,12 +1294,32 @@
 
 	SqlStmt_Free(stmt);
 	return j;
-}
-
-//=====================================================================================================
-int mmo_char_fromsql(int char_id, struct mmo_charstatus *p, bool load_everything)
-{
-	int i,j;
+}
+
+//=====================================================================================================
+static void char_ip_premium(uint32 ip, struct mmo_charstatus* p)
+{
+	char* data = NULL;
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `level` FROM `ippremium` WHERE `ip` = '%s'", ip2str(ip, NULL)) )
+	{
+		Sql_ShowDebug(sql_handle);
+		p->iprank = 0;
+		return;
+	}
+
+	if( SQL_SUCCESS == Sql_NextRow(sql_handle) )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL);
+		if( (p->iprank = atoi(data)) > 0 )
+			ShowStatus("IP Premium System: CharID %d Name %s using level %d.", p->char_id, p->name, p->iprank);
+	}
+
+	Sql_FreeResult(sql_handle);
+}
+
+int mmo_char_fromsql(int char_id, struct mmo_charstatus* p, bool load_everything)
+{
+	int i,j;
 	char t_msg[128] = "";
 	struct mmo_charstatus *cp;
 	StringBuf buf;
@@ -1106,12 +1327,13 @@
 	char last_map[MAP_NAME_LENGTH_EXT];
 	char save_map[MAP_NAME_LENGTH_EXT];
 	char point_map[MAP_NAME_LENGTH_EXT];
-	struct point tmp_point;
-	struct item tmp_item;
-	struct s_skill tmp_skill;
-	struct s_friend tmp_friend;
-#ifdef HOTKEY_SAVING
-	struct hotkey tmp_hotkey;
+	struct point tmp_point;
+	struct item tmp_item;
+	struct s_skill tmp_skill;
+	struct s_skillcount tmp_skillcount;
+	struct s_friend tmp_friend;
+#ifdef HOTKEY_SAVING
+	struct hotkey tmp_hotkey;
 	int hotkey_num;
 #endif
 
@@ -1131,7 +1353,7 @@
 	                                "`str`,`agi`,`vit`,`int`,`dex`,`luk`,`max_hp`,`hp`,`max_sp`,`sp`,"
 	                                "`status_point`,`skill_point`,`option`,`karma`,`manner`,`party_id`,`guild_id`,`pet_id`,`homun_id`,`elemental_id`,`hair`,"
 	                                "`hair_color`,`clothes_color`,`weapon`,`shield`,`head_top`,`head_mid`,`head_bottom`,`last_map`,`last_x`,`last_y`,"
-	                                "`save_map`,`save_x`,`save_y`,`partner_id`,`father`,`mother`,`child`,`fame`,`rename`,`delete_date`,`robe`, `moves`"
+	                                "`save_map`,`save_x`,`save_y`,`partner_id`,`father`,`mother`,`child`,`fame`,`rename`,`delete_date`,`robe`,`moves`,`playtime`,`faction_id`"
 	                                " FROM `%s` WHERE `char_id`=? LIMIT 1", char_db)
 	   ||  SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
 	   ||  SQL_ERROR == SqlStmt_Execute(stmt)
@@ -1188,6 +1410,8 @@
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 50, SQLDT_UINT32, &p->delete_date, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 51, SQLDT_SHORT,  &p->robe, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_USHORT, &p->character_moves, 0, NULL, NULL)
+	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_UINT,   &p->playtime, 0, NULL, NULL)
+	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 53, SQLDT_INT,	   &p->faction_id, 0, NULL, NULL)
 	  ) {
 		SqlStmt_ShowDebug(stmt);
 		SqlStmt_Free(stmt);
@@ -1224,13 +1448,13 @@
 	}
 	strcat(t_msg, " memo");
 
-	//read inventory
-	//`inventory` (`id`,`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, `expire_time`, `favorite`, `unique_id`)
-	StringBuf_Init(&buf);
-	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `favorite`, `unique_id`");
-	for(i = 0; i < MAX_SLOTS; ++i)
-		StringBuf_Printf(&buf, ", `card%d`", i);
-	StringBuf_Printf(&buf, " FROM `%s` WHERE `char_id`=? LIMIT %d", inventory_db, MAX_INVENTORY);
+	//read inventory
+	//`inventory` (`id`,`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, `expire_time`, `favorite`, `unique_id`)
+	StringBuf_Init(&buf);
+	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `favorite`, `unique_id`, `bound`");
+	for( i = 0; i < MAX_SLOTS; ++i )
+		StringBuf_Printf(&buf, ", `card%d`", i);
+	StringBuf_Printf(&buf, " FROM `%s` WHERE `char_id`=? LIMIT %d", inventory_db, MAX_INVENTORY);
 
 	if(SQL_ERROR == SqlStmt_PrepareStr(stmt, StringBuf_Value(&buf))
 	   ||  SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
@@ -1241,27 +1465,28 @@
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 3, SQLDT_USHORT,    &tmp_item.equip, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 4, SQLDT_CHAR,      &tmp_item.identify, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 5, SQLDT_CHAR,      &tmp_item.refine, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,      &tmp_item.attribute, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,      &tmp_item.expire_time, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 8, SQLDT_CHAR,      &tmp_item.favorite, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 9, SQLDT_ULONGLONG, &tmp_item.unique_id, 0, NULL, NULL))
-		SqlStmt_ShowDebug(stmt);
-	for(i = 0; i < MAX_SLOTS; ++i)
-		if(SQL_ERROR == SqlStmt_BindColumn(stmt, 10+i, SQLDT_SHORT, &tmp_item.card[i], 0, NULL, NULL))
-			SqlStmt_ShowDebug(stmt);
-
-	for(i = 0; i < MAX_INVENTORY && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,      &tmp_item.attribute, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,      &tmp_item.expire_time, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 8, SQLDT_CHAR,      &tmp_item.favorite, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 9, SQLDT_ULONGLONG, &tmp_item.unique_id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt,10, SQLDT_CHAR,      &tmp_item.bound, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+	for( i = 0; i < MAX_SLOTS; ++i )
+		if( SQL_ERROR == SqlStmt_BindColumn(stmt, 11+i, SQLDT_SHORT, &tmp_item.card[i], 0, NULL, NULL) )
+			SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_INVENTORY && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
 		memcpy(&p->inventory[i], &tmp_item, sizeof(tmp_item));
 
 	strcat(t_msg, " inventory");
 
-	//read cart
-	//`cart_inventory` (`id`,`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, expire_time`, `unique_id`)
-	StringBuf_Clear(&buf);
-	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `unique_id`");
-	for(j = 0; j < MAX_SLOTS; ++j)
-		StringBuf_Printf(&buf, ", `card%d`", j);
-	StringBuf_Printf(&buf, " FROM `%s` WHERE `char_id`=? LIMIT %d", cart_db, MAX_CART);
+	//read cart
+	//`cart_inventory` (`id`,`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, expire_time`, `unique_id`)
+	StringBuf_Clear(&buf);
+	StringBuf_AppendStr(&buf, "SELECT `id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `expire_time`, `unique_id`, `bound`, `favorite`");
+	for( j = 0; j < MAX_SLOTS; ++j )
+		StringBuf_Printf(&buf, ", `card%d`", j);
+	StringBuf_Printf(&buf, " FROM `%s` WHERE `char_id`=? LIMIT %d", cart_db, MAX_CART);
 
 	if(SQL_ERROR == SqlStmt_PrepareStr(stmt, StringBuf_Value(&buf))
 	   ||  SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
@@ -1271,26 +1496,32 @@
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 2, SQLDT_SHORT,       &tmp_item.amount, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 3, SQLDT_USHORT,      &tmp_item.equip, 0, NULL, NULL)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 4, SQLDT_CHAR,        &tmp_item.identify, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 5, SQLDT_CHAR,        &tmp_item.refine, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,        &tmp_item.attribute, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,        &tmp_item.expire_time, 0, NULL, NULL)
-	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 8, SQLDT_ULONGLONG,   &tmp_item.unique_id, 0, NULL, NULL))
-		SqlStmt_ShowDebug(stmt);
-	for(i = 0; i < MAX_SLOTS; ++i)
-		if(SQL_ERROR == SqlStmt_BindColumn(stmt, 9+i, SQLDT_SHORT, &tmp_item.card[i], 0, NULL, NULL))
-			SqlStmt_ShowDebug(stmt);
-
-	for(i = 0; i < MAX_CART && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 5, SQLDT_CHAR,        &tmp_item.refine, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 6, SQLDT_CHAR,        &tmp_item.attribute, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 7, SQLDT_UINT,        &tmp_item.expire_time, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 8, SQLDT_ULONGLONG,   &tmp_item.unique_id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 9, SQLDT_CHAR,        &tmp_item.bound, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt,10, SQLDT_CHAR,        &tmp_item.favorite, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+	for( i = 0; i < MAX_SLOTS; ++i )
+		if( SQL_ERROR == SqlStmt_BindColumn(stmt, 11+i, SQLDT_SHORT, &tmp_item.card[i], 0, NULL, NULL) )
+			SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_CART && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
 		memcpy(&p->cart[i], &tmp_item, sizeof(tmp_item));
 	strcat(t_msg, " cart");
 
 	//read storage
-	storage_fromsql(p->account_id, &p->storage);
-	strcat(t_msg, " storage");
-
-	//read skill
-	//`skill` (`char_id`, `id`, `lv`)
-	if(SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `lv`,`flag` FROM `%s` WHERE `char_id`=? LIMIT %d", skill_db, MAX_SKILL)
+	storage_fromsql(p->account_id, &p->storage);
+	strcat(t_msg, " storage");
+
+	//read rentstorage
+	ext_storage_fromsql(p->account_id, &p->ext_storage);
+	strcat(t_msg, " rentstorage");
+
+	//read skill
+	//`skill` (`char_id`, `id`, `lv`)
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `lv`,`flag` FROM `%s` WHERE `char_id`=? LIMIT %d", skill_db, MAX_SKILL)
 	   ||  SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
 	   ||  SQL_ERROR == SqlStmt_Execute(stmt)
 	   ||  SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &tmp_skill.id, 0, NULL, NULL)
@@ -1341,14 +1572,191 @@
 		else
 			ShowWarning(read_message("Source.char.char_mmo_char_fromsql_s4"), hotkey_num, tmp_hotkey.type, tmp_hotkey.id, tmp_hotkey.lv, p->name, p->account_id, p->char_id);
 	}
-	strcat(t_msg, " hotkeys");
-#endif
+	strcat(t_msg, " hotkeys");
+#endif
+
+	/* Character PVP Ranking */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `kill_count`, `death_count`, `score` FROM `char_pvp` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &p->pvp.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &p->pvp.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 2, SQLDT_USHORT, &p->pvp.score, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->pvp.score = 2000; // Base Score
+	}
+	strcat(t_msg, " pvprank");
+
+	/* Character PK Ranking */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `kill_count`, `death_count`, `score` FROM `char_pk` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &p->pk.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &p->pk.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 2, SQLDT_USHORT, &p->pk.score, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		; // Database Error or Row don't exists
+	}
+	strcat(t_msg, " pkrank");
+
+	/* Character Battleground Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`,`damage_done`,`damage_received`,`skulls`,`ti_wins`,`ti_lost`,`ti_tie`,`eos_flags`,`eos_bases`,`eos_wins`,`eos_lost`,`eos_tie`,`boss_killed`,`boss_damage`,`boss_flags`,`boss_wins`,`boss_lost`,`boss_tie`,`td_kills`,`td_deaths`,`td_wins`,`td_lost`,`td_tie`,`sc_stole`,`sc_captured`,`sc_droped`,`sc_wins`,`sc_lost`,`sc_tie`,`ctf_taken`,`ctf_captured`,`ctf_droped`,`ctf_wins`,`ctf_lost`,`ctf_tie`,`emperium_kill`,`barricade_kill`,`gstone_kill`,`cq_wins`,`cq_lost`,`kill_count`,`death_count`,`win`,`lost`,`tie`,`leader_win`,`leader_lost`,`leader_tie`,`deserter`,`score`,`points`,`sp_heal_potions`,`hp_heal_potions`,`yellow_gemstones`,`red_gemstones`,`blue_gemstones`,`poison_bottles`,`acid_demostration`,`acid_demostration_fail`,`support_skills_used`,`healing_done`,`wrong_support_skills_used`,`wrong_healing_done`,`sp_used`,`zeny_used`,`spiritb_used`,`ammo_used`,`rank_points`,`rank_games`,`ru_wins`,`ru_lost`,`ru_captures`,`dom_bases`,`dom_off_kills`,`dom_def_kills`,`dom_wins`,`dom_lost`,`dom_tie` FROM `char_bg` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT,   &p->bgstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT,   &p->bgstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT,   &p->bgstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_USHORT, &p->bgstats.skulls, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_USHORT, &p->bgstats.ti_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_USHORT, &p->bgstats.ti_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_USHORT, &p->bgstats.ti_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->bgstats.eos_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->bgstats.eos_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->bgstats.eos_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->bgstats.eos_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_USHORT, &p->bgstats.eos_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_USHORT, &p->bgstats.boss_killed, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT,   &p->bgstats.boss_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_USHORT, &p->bgstats.boss_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_USHORT, &p->bgstats.boss_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_USHORT, &p->bgstats.boss_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_USHORT, &p->bgstats.boss_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_USHORT, &p->bgstats.td_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_USHORT, &p->bgstats.td_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_USHORT, &p->bgstats.td_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_USHORT, &p->bgstats.td_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_USHORT, &p->bgstats.td_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_USHORT, &p->bgstats.sc_stole, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_USHORT, &p->bgstats.sc_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_USHORT, &p->bgstats.sc_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_USHORT, &p->bgstats.sc_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->bgstats.sc_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->bgstats.sc_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->bgstats.ctf_taken, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->bgstats.ctf_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->bgstats.ctf_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 32, SQLDT_USHORT, &p->bgstats.ctf_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 33, SQLDT_USHORT, &p->bgstats.ctf_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 34, SQLDT_USHORT, &p->bgstats.ctf_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 35, SQLDT_USHORT, &p->bgstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 36, SQLDT_USHORT, &p->bgstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 37, SQLDT_USHORT, &p->bgstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 38, SQLDT_USHORT, &p->bgstats.cq_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 39, SQLDT_USHORT, &p->bgstats.cq_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 40, SQLDT_USHORT, &p->bgstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 41, SQLDT_USHORT, &p->bgstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 42, SQLDT_USHORT, &p->bgstats.win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 43, SQLDT_USHORT, &p->bgstats.lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 44, SQLDT_USHORT, &p->bgstats.tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 45, SQLDT_USHORT, &p->bgstats.leader_win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 46, SQLDT_USHORT, &p->bgstats.leader_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 47, SQLDT_USHORT, &p->bgstats.leader_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 48, SQLDT_USHORT, &p->bgstats.deserter, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 49, SQLDT_USHORT, &p->bgstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 50, SQLDT_USHORT, &p->bgstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 51, SQLDT_UINT,   &p->bgstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_UINT,   &p->bgstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 53, SQLDT_UINT,   &p->bgstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 54, SQLDT_UINT,   &p->bgstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 55, SQLDT_UINT,   &p->bgstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 56, SQLDT_UINT,   &p->bgstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 57, SQLDT_UINT,   &p->bgstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 58, SQLDT_UINT,   &p->bgstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 59, SQLDT_UINT,   &p->bgstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 60, SQLDT_UINT,   &p->bgstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 61, SQLDT_UINT,   &p->bgstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 62, SQLDT_UINT,   &p->bgstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 63, SQLDT_UINT,   &p->bgstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 64, SQLDT_UINT,   &p->bgstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 65, SQLDT_UINT,   &p->bgstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 66, SQLDT_UINT,   &p->bgstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 67, SQLDT_USHORT, &p->bgstats.rank_points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 68, SQLDT_USHORT, &p->bgstats.rank_games, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 69, SQLDT_USHORT, &p->bgstats.ru_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 70, SQLDT_USHORT, &p->bgstats.ru_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 71, SQLDT_USHORT, &p->bgstats.ru_captures, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 72, SQLDT_USHORT, &p->bgstats.dom_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 73, SQLDT_USHORT, &p->bgstats.dom_off_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 74, SQLDT_USHORT, &p->bgstats.dom_def_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 75, SQLDT_USHORT, &p->bgstats.dom_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 76, SQLDT_USHORT, &p->bgstats.dom_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 77, SQLDT_USHORT, &p->bgstats.dom_tie, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->bgstats.score = 2000;
+	}
+	strcat(t_msg, " bgstats");
+
+	/* Character WoE Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, `emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, `sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, `support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, `sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score` FROM `char_wstats` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT, &p->wstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT, &p->wstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT, &p->wstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_UINT, &p->wstats.emperium_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_UINT, &p->wstats.guardian_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_UINT, &p->wstats.barricade_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_UINT, &p->wstats.gstone_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->wstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->wstats.guardian_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->wstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->wstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_UINT, &p->wstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_UINT, &p->wstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT, &p->wstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_UINT, &p->wstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_UINT, &p->wstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_UINT, &p->wstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_UINT, &p->wstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_UINT, &p->wstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_UINT, &p->wstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_UINT, &p->wstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_UINT, &p->wstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_UINT, &p->wstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_UINT, &p->wstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_UINT, &p->wstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_UINT, &p->wstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_UINT, &p->wstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->wstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->wstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->wstats.score, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->wstats.score = 2000;
+	}
+	strcat(t_msg, " woestats");
+
+	/* Skill Usage */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `count` FROM `skill_count` WHERE `char_id` = ? LIMIT %d", MAX_SKILL_TREE)
+	||	SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+	||	SQL_ERROR == SqlStmt_Execute(stmt)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &tmp_skillcount.id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &tmp_skillcount.count, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_SKILL_TREE && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
+		memcpy(&p->skillcount[i], &tmp_skillcount, sizeof(tmp_skillcount));
+
+	/* BG Skill Usage */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `count` FROM `bg_skill_count` WHERE `char_id` = ? LIMIT %d", MAX_SKILL_TREE)
+	||	SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+	||	SQL_ERROR == SqlStmt_Execute(stmt)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &tmp_skillcount.id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &tmp_skillcount.count, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_SKILL_TREE && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
+		memcpy(&p->bg_skillcount[i], &tmp_skillcount, sizeof(tmp_skillcount));
+	strcat(t_msg, " skillcount");
+
+	/* Mercenary Owner DataBase */
+	mercenary_owner_fromsql(char_id, p);
+	strcat(t_msg, " mercenary");
 
-	/* Mercenary Owner DataBase */
-	mercenary_owner_fromsql(char_id, p);
-	strcat(t_msg, " mercenary");
 
-
 	if(save_log) ShowInfo(read_message("Source.char.char_save_log"), char_id, p->name, t_msg);  //ok. all data load successfuly!
 	SqlStmt_Free(stmt);
 	StringBuf_Destroy(&buf);
@@ -1422,13 +1830,170 @@
 			Sql_ShowDebug(sql_handle);
 	}
 
-	return 0;
-}
+	return 0;
+}
+
+//-----------------------------------
+// Save Character Data into SQL File
+//-----------------------------------
+int char_dump2sql(int char_id)
+{	
+	char filename[128], esc_name[NAME_LENGTH*2+1], str[32], esc_str[65], value[256], esc_value[513];
+	struct mmo_charstatus cp;
+	struct item *i_data;
+	struct s_skill *s_data;
+	char* data;
+
+	int i = 0;
+	FILE* fp;
+
+	if( mmo_char_fromsql(char_id, &cp, true) == 0 )
+		return 0; // Non existant or error.
+
+	sprintf(filename, "dumps/%d_%d.sql", cp.account_id, char_id);
+	if( (fp = fopen(filename, "w")) == NULL )
+		return 0;
+
+	Sql_EscapeStringLen(sql_handle, esc_name, cp.name, strnlen(cp.name, NAME_LENGTH));
+	fprintf(fp, "-- Character Information --\n");
+	fprintf(fp, "INSERT INTO `char` "
+		"(`account_id`, `char_num`, `name`, `class`, `base_level`, `job_level`, `base_exp`, `job_exp`, `zeny`, `str`, `agi`, `vit`, `int`, `dex`, `luk`, `max_hp`, `hp`, `max_sp`, `sp`, `status_point`, `skill_point`, `option`, `karma`, `manner`, `party_id`, `guild_id`, `pet_id`, `homun_id`, `hair`, `hair_color`, `clothes_color`, `weapon`, `shield`, `head_top`, `head_mid`, `head_bottom`, `last_map`, `last_x`, `last_y`, `save_map`, `save_x`, `save_y`, `partner_id`, `online`, `father`, `mother`, `child`, `fame`, `playtime`)"
+		" VALUES "
+		"('ACC', '%d', '@%s', '%d', '%d', '%d', '%u', '%u', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%d', '%d', '%s', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u');\n",
+		cp.slot, esc_name, cp.class_, cp.base_level, cp.job_level, cp.base_exp, cp.job_exp, cp.zeny, cp.str, cp.agi, cp.vit, cp.int_, cp.dex, cp.luk, cp.max_hp, cp.hp, cp.max_sp, cp.sp, cp.status_point, cp.skill_point, cp.option, cp.karma, cp.manner, 0, 0, 0, 0, cp.hair, cp.hair_color, cp.clothes_color, cp.weapon, cp.shield, cp.head_top, cp.head_mid, cp.head_bottom, mapindex_id2name(cp.last_point.map), cp.last_point.x, cp.last_point.y, mapindex_id2name(cp.save_point.map), cp.save_point.x, cp.save_point.y, 0, 0, 0, 0, 0, cp.fame, cp.playtime);
+
+	if( cp.hom_id )
+	{ // Homunculus Backup
+		struct s_homunculus hd;
+		if( mapif_homunculus_load(cp.hom_id, &hd) )
+		{
+			Sql_EscapeStringLen(sql_handle, esc_name, hd.name, strnlen(hd.name, NAME_LENGTH));
+
+			fprintf(fp, "-- Homunculus Information --\n");
+			fprintf(fp, "INSERT INTO `homunculus` "
+				"(`char_id`, `class`,`name`,`level`,`exp`,`intimacy`,`hunger`, `str`, `agi`, `vit`, `int`, `dex`, `luk`, `hp`,`max_hp`,`sp`,`max_sp`,`skill_point`, `rename_flag`, `vaporize`) "
+				"VALUES "
+				"('CHR', '%d', '%s', '%d', '%u', '%u', '%d', '%d', %d, '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d');\n\n",
+				hd.class_, esc_name, hd.level, hd.exp, hd.intimacy, hd.hunger, hd.str, hd.agi, hd.vit, hd.int_, hd.dex, hd.luk, hd.hp, hd.max_hp, hd.sp, hd.max_sp, hd.skillpts, hd.rename_flag, hd.vaporize);
+			
+			i = 0;
+			while( i < MAX_HOMUNSKILL )
+			{
+				if( hd.hskill[i].id > 0 )
+					fprintf(fp, "INSERT INTO `skill_homunculus` (`homun_id`, `id`, `lv`) VALUES ('HOM', '%d', '%d');\n", hd.hskill[i].id, hd.hskill[i].lv);
+
+				i++;
+			}
+		}
+	}
+
+	if( !char_new )
+	{ // Backup Account Information
+		fprintf(fp, "\n-- Account Storage --\n");
+		i = 0;
+		while( i < MAX_STORAGE && cp.storage.items[i].nameid > 0 )
+		{
+			i_data = &cp.storage.items[i];
+
+			fprintf(fp, "INSERT INTO `storage` "
+				"(`account_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, `expire_time`, `unique_id`, `bound`)"
+				" VALUES "
+				"('ACC', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%"PRIu64"', '%d');\n",
+				i_data->nameid, i_data->amount, i_data->equip, i_data->identify, i_data->refine, i_data->attribute, i_data->card[0], i_data->card[1], i_data->card[2], i_data->card[3], i_data->expire_time, i_data->unique_id, i_data->bound);
+			i++;
+		}
+
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `storage` WHERE `account_id` = '%d'", cp.account_id) )
+			Sql_ShowDebug(sql_handle); // Clear Storage Data to Avoid Multiple Backups.
+
+		fprintf(fp, "\n-- Global Reg Value Account Level --\n");
+		if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `str`, `value` FROM `%s` WHERE `type` = 2 AND `account_id` = '%d'", reg_db, cp.account_id) )
+			Sql_ShowDebug(sql_handle);
+
+		while( SQL_SUCCESS == Sql_NextRow(sql_handle) )
+		{
+			Sql_GetData(sql_handle, 0, &data, NULL); safestrncpy(str, data, sizeof(str));
+			Sql_EscapeStringLen(sql_handle, esc_str, str, strnlen(str, 32));
+
+			Sql_GetData(sql_handle, 1, &data, NULL); safestrncpy(value, data, sizeof(value));
+			Sql_EscapeStringLen(sql_handle, esc_value, value, strnlen(value, 256));
+
+			fprintf(fp, "INSERT INTO `global_reg_value` (`char_id`, `str`, `value`, `type`, `account_id`) VALUES ('0', '%s', '%s', '2', 'ACC');\n",
+				esc_str, esc_value);
+		}
+
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `global_reg_value` WHERE `account_id` = '%d' AND `type` = 2", cp.account_id) )
+			Sql_ShowDebug(sql_handle); // Clear Global Reg Value Data to Avoid Multiple Backups.
+
+		fprintf(fp, "\n\n-- End of Account Related Backup --\n\n\n");
+	}
+
+	i = 0;
+	fprintf(fp, "\n-- Character Inventory --\n\n");
+	while( i < MAX_INVENTORY && cp.inventory[i].nameid > 0 )
+	{
+		i_data = &cp.inventory[i];
+
+		fprintf(fp, "INSERT INTO `inventory` "
+			"(`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, `expire_time`, `unique_id`, `bound`)"
+			" VALUES "
+			"('CHR', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%"PRIu64"', '%d');\n",
+			i_data->nameid, i_data->amount, i_data->equip, i_data->identify, i_data->refine, i_data->attribute, i_data->card[0], i_data->card[1], i_data->card[2], i_data->card[3], i_data->expire_time, i_data->unique_id, i_data->bound);
+		i++;
+	}
+
+	fprintf(fp, "\n-- Character Cart Inventory --\n\n");
+	i = 0;
+	while( i < MAX_CART && cp.cart[i].nameid > 0 )
+	{
+		i_data = &cp.cart[i];
+
+		fprintf(fp, "INSERT INTO `cart_inventory` "
+			"(`char_id`, `nameid`, `amount`, `equip`, `identify`, `refine`, `attribute`, `card0`, `card1`, `card2`, `card3`, `expire_time`, `unique_id`, `bound`)"
+			" VALUES "
+			"('CHR', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%"PRIu64"', '%d');\n",
+			i_data->nameid, i_data->amount, i_data->equip, i_data->identify, i_data->refine, i_data->attribute, i_data->card[0], i_data->card[1], i_data->card[2], i_data->card[3], i_data->expire_time, i_data->unique_id, i_data->bound);
+		i++;
+	}
+
+	fprintf(fp, "\n-- Character Skills --\n\n");
+	i = 0;
+	while( i < MAX_SKILL )
+	{
+		if( cp.skill[i].id > 0 )
+		{
+			s_data = &cp.skill[i];
+			fprintf(fp, "INSERT INTO `skill` (`char_id`, `id`, `lv`) VALUES ('CHR', '%d', '%d');\n", s_data->id, s_data->lv);
+		}
+		i++;
+	}
+
+	fprintf(fp, "\n-- Character Global Reg Value --\n\n");
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `str`, `value` FROM `%s` WHERE `type` = 3 AND `char_id` = '%d'", reg_db, char_id) )
+		Sql_ShowDebug(sql_handle);
+
+	while( SQL_SUCCESS == Sql_NextRow(sql_handle) )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL); safestrncpy(str, data, sizeof(str));
+		Sql_EscapeStringLen(sql_handle, esc_str, str, strnlen(str, 32));
+
+		Sql_GetData(sql_handle, 1, &data, NULL); safestrncpy(value, data, sizeof(value));
+		Sql_EscapeStringLen(sql_handle, esc_value, value, strnlen(value, 256));
+
+		fprintf(fp, "INSERT INTO `global_reg_value` (`char_id`, `str`, `value`, `type`, `account_id`) VALUES ('CHR', '%s', '%s', '3', '0');\n",
+			esc_str, esc_value);
+	}
+
+	Sql_FreeResult(sql_handle);
+
+	fclose(fp);
+	return 1;
+}
+
+int check_char_name(char * name, char * esc_name)
+{
+	int i;
 
-int check_char_name(char *name, char *esc_name)
-{
-	int i;
-
 	// check length of character name
 	if(name[0] == '\0')
 		return -2; // empty character name
@@ -1440,13 +2005,13 @@
 		return -2;
 	// check content of character name
 	if(remove_control_chars(name))
-		return -2; // control chars in name
-
-	// check for reserved names
-	if(strcmpi(name, main_chat_nick) == 0 || strcmpi(name, wisp_server_name) == 0)
-		return -1; // nick reserved for internal server messages
-
-	// Check Authorised letters/symbols in the name of the character
+		return -2; // control chars in name
+
+	// check for reserved names
+	if( !strcmpi(name, wisp_server_name) || name[0] == '#' )
+		return -1; // nick reserved for internal server messages
+
+	// Check Authorised letters/symbols in the name of the character
 	if(char_name_option == 1) {
 		// only letters/symbols in char_name_letters are authorised
 		for(i = 0; i < NAME_LENGTH && name[i]; i++)
@@ -1581,13 +2146,13 @@
 
 /*----------------------------------------------------------------------------------------------------------*/
 /* Divorce Players */
-/*----------------------------------------------------------------------------------------------------------*/
-int divorce_char_sql(int partner_id1, int partner_id2)
-{
-	unsigned char buf[64];
-
-	if(SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `partner_id`='0' WHERE `char_id`='%d' OR `char_id`='%d' LIMIT 2", char_db, partner_id1, partner_id2))
-		Sql_ShowDebug(sql_handle);
+/*----------------------------------------------------------------------------------------------------------*/
+int divorce_char_sql(int partner_id1, int partner_id2)
+{
+	unsigned char buf[10];
+
+	if( SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `partner_id`='0' WHERE `char_id`='%d' OR `char_id`='%d' LIMIT 2", char_db, partner_id1, partner_id2) )
+		Sql_ShowDebug(sql_handle);
 	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE (`nameid`='%d' OR `nameid`='%d') AND (`char_id`='%d' OR `char_id`='%d') LIMIT 2", inventory_db, WEDDING_RING_M, WEDDING_RING_F, partner_id1, partner_id2))
 		Sql_ShowDebug(sql_handle);
 
@@ -1597,12 +2162,36 @@
 	mapif_sendall(buf,10);
 
 	return 0;
-}
-
-/*----------------------------------------------------------------------------------------------------------*/
-/* Delete char - davidsiaw */
-/*----------------------------------------------------------------------------------------------------------*/
-/* Returns 0 if successful
+}
+
+/*----------------------------------------------------------------------------------------------------------*/
+/* Item Removal */
+/*----------------------------------------------------------------------------------------------------------*/
+int char_item_remove4all(int nameid)
+{
+	unsigned char buf[4];
+	ShowInfo("Destroying item ID %d on all Users...\n", nameid);
+
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `nameid` = '%d'", inventory_db, nameid) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `nameid` = '%d'", cart_db, nameid) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `nameid` = '%d'", storage_db, nameid) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `nameid` = '%d'", rentstorage_db, nameid) )
+		Sql_ShowDebug(sql_handle);
+
+	WBUFW(buf,0) = 0x2b2b;
+	WBUFW(buf,2) = nameid;
+	mapif_sendall(buf,4);
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------------------------------------*/
+/* Delete char - davidsiaw */
+/*----------------------------------------------------------------------------------------------------------*/
+/* Returns 0 if successful
  * Returns < 0 for error
  */
 int delete_char_sql(int char_id)
@@ -1643,13 +2232,15 @@
 	   || (char_del_level < 0 && base_level <= -char_del_level)
 	  ) {
 		ShowInfo(read_message("Source.char.char_delete_char_sql_s2"), name, base_level);
-		return -1;
-	}
+			return -1;
+	}
+
+	char_dump2sql(char_id); // [Zephyrus] Backup previous to delete
+
+	/* Divorce [Wizputer] */
+	if( partner_id )
+		divorce_char_sql(char_id, partner_id);
 
-	/* Divorce [Wizputer] */
-	if(partner_id)
-		divorce_char_sql(char_id, partner_id);
-
 	/* De-addopt [Zephyrus] */
 	if(father_id || mother_id) {
 		// Char is Baby
@@ -1690,13 +2281,35 @@
 	if(elemental_id)
 		mapif_elemental_delete(elemental_id);
 
-	/* remove mercenary data */
-	mercenary_owner_delete(char_id);
+	/* remove mercenary data */
+	mercenary_owner_delete(char_id);
+
+	/* Char Ranking */
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_pvp` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_pk` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_bg` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_bg_log` WHERE `killer_id` = '%d' OR `killed_id` = '%d'", char_id, char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_wstats` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_woe_log` WHERE `killer_id` = '%d' OR `killed_id` = '%d'", char_id, char_id) )
+		Sql_ShowDebug(sql_handle);
+
+	/* Quest Data */
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id` = '%d'", quest_db, char_id) )
+		Sql_ShowDebug(sql_handle);
+
+	/* Achievement Data */
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id` = '%d'", achievement_db, char_id) )
+		Sql_ShowDebug(sql_handle);
+
+	/* delete char's friends list */
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id` = '%d'", friend_db, char_id) )
+		Sql_ShowDebug(sql_handle);
 
-	/* delete char's friends list */
-	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id` = '%d'", friend_db, char_id))
-		Sql_ShowDebug(sql_handle);
-
 	/* delete char from other's friend list */
 	//NOTE: Won't this cause problems for people who are already online? [Skotlex]
 	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `friend_id` = '%d'", friend_db, char_id))
@@ -2477,81 +3090,152 @@
 	memset(smith_fame_list, 0, sizeof(smith_fame_list));
 	memset(chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset(pvprank_fame_list, 0, sizeof(pvprank_fame_list));
+	memset(bgrank_fame_list, 0, sizeof(bgrank_fame_list));
+	memset(bg_fame_list, 0, sizeof(bg_fame_list));
 	// Build Blacksmith ranking list
 	if(SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", char_db, JOB_BLACKSMITH, JOB_WHITESMITH, JOB_BABY_BLACKSMITH, JOB_MECHANIC, JOB_MECHANIC_T, JOB_BABY_MECHANIC, fame_list_size_smith))
 		Sql_ShowDebug(sql_handle);
 	for(i = 0; i < fame_list_size_smith && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i) {
-		// char_id
-		Sql_GetData(sql_handle, 0, &data, NULL);
-		smith_fame_list[i].id = atoi(data);
-		// fame
-		Sql_GetData(sql_handle, 1, &data, &len);
-		smith_fame_list[i].fame = atoi(data);
-		// name
-		Sql_GetData(sql_handle, 2, &data, &len);
-		memcpy(smith_fame_list[i].name, data, min(len, NAME_LENGTH));
+		Sql_GetData(sql_handle, 0, &data, NULL); smith_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); smith_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(smith_fame_list[i].name, data, min(len, NAME_LENGTH));
 	}
 	// Build Alchemist ranking list
 	if(SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", char_db, JOB_ALCHEMIST, JOB_CREATOR, JOB_BABY_ALCHEMIST, JOB_GENETIC, JOB_GENETIC_T, JOB_BABY_GENETIC, fame_list_size_chemist))
 		Sql_ShowDebug(sql_handle);
 	for(i = 0; i < fame_list_size_chemist && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i) {
-		// char_id
-		Sql_GetData(sql_handle, 0, &data, NULL);
-		chemist_fame_list[i].id = atoi(data);
-		// fame
-		Sql_GetData(sql_handle, 1, &data, &len);
-		chemist_fame_list[i].fame = atoi(data);
-		// name
-		Sql_GetData(sql_handle, 2, &data, &len);
-		memcpy(chemist_fame_list[i].name, data, min(len, NAME_LENGTH));
+		Sql_GetData(sql_handle, 0, &data, NULL); chemist_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); chemist_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(chemist_fame_list[i].name, data, min(len, NAME_LENGTH));
 	}
 	// Build Taekwon ranking list
 	if(SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", char_db, JOB_TAEKWON, fame_list_size_taekwon))
 		Sql_ShowDebug(sql_handle);
 	for(i = 0; i < fame_list_size_taekwon && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i) {
-		// char_id
-		Sql_GetData(sql_handle, 0, &data, NULL);
-		taekwon_fame_list[i].id = atoi(data);
-		// fame
-		Sql_GetData(sql_handle, 1, &data, &len);
-		taekwon_fame_list[i].fame = atoi(data);
-		// name
-		Sql_GetData(sql_handle, 2, &data, &len);
-		memcpy(taekwon_fame_list[i].name, data, min(len, NAME_LENGTH));
+		Sql_GetData(sql_handle, 0, &data, NULL); taekwon_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); taekwon_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(taekwon_fame_list[i].name, data, min(len, NAME_LENGTH));
 	}
+	// Build PK Rank ranking list [Zephyrus]
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_pk`.`char_id`, `char_pk`.`score`, `%s`.`name` FROM `char_pk` LEFT JOIN `%s` ON `%s`.`char_id` = `char_pk`.`char_id` WHERE `char_pk`.`score` > '0' ORDER BY `char_pk`.`score` DESC LIMIT 0,%d", char_db, char_db, char_db, fame_list_size_pvprank) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_pvprank && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL); pvprank_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); pvprank_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(pvprank_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
 	Sql_FreeResult(sql_handle);
+	// Build BG Rank ranking list [Zephyrus]
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_bg`.`char_id`, `char_bg`.`rank_points`, `%s`.`name` FROM `char_bg` LEFT JOIN `%s` ON `%s`.`char_id` = `char_bg`.`char_id` WHERE `char_bg`.`rank_points` > '0' ORDER BY `char_bg`.`rank_points` DESC LIMIT 0,%d", char_db, char_db, char_db, fame_list_size_bgrank) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bgrank && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL); bgrank_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); bgrank_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(bgrank_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
+	Sql_FreeResult(sql_handle);
+	// Build BG Normal ranking list [Zephyrus]
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_bg`.`char_id`, `char_bg`.`points`, `%s`.`name` FROM `char_bg` LEFT JOIN `%s` ON `%s`.`char_id` = `char_bg`.`char_id` WHERE `char_bg`.`points` > '0' ORDER BY `char_bg`.`points` DESC LIMIT 0,%d", char_db, char_db, char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL); bg_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); bg_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(bg_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
+	Sql_FreeResult(sql_handle);
 }
 
+// Send map-servers a single fame ranking list
+int char_send_fame_list_single(int fd, int type)
+{
+	int len = 6, i, size;
+	unsigned char buf[6 + MAX_FAME_LIST * sizeof(struct fame_list)];
+	struct fame_list* list;
+
+	switch(type)
+	{
+		case 1:  size = fame_list_size_smith;   list = smith_fame_list;   break;
+		case 2:  size = fame_list_size_chemist; list = chemist_fame_list; break;
+		case 3:  size = fame_list_size_taekwon; list = taekwon_fame_list; break;
+		case 4:  size = fame_list_size_pvprank; list = pvprank_fame_list; break;
+		case 5:  size = fame_list_size_bgrank;  list = bgrank_fame_list;  break;
+		case 6:  size = fame_list_size_bg;      list = bg_fame_list;      break;
+		default: return 0;
+	}
+
+	WBUFW(buf,0) = 0x2b2c;
+	WBUFW(buf,4) = type;
+	for( i = 0; i < size && list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	WBUFW(buf,2) = len;
+
+	if( fd != -1 )
+		mapif_send(fd, buf, len);
+	else
+		mapif_sendall(buf, len);
+	return 0;
+}
+
 // Send map-servers the fame ranking lists
 int char_send_fame_list(int fd)
 {
-	int i, len = 8;
-	unsigned char buf[32000];
+	int i, len = 14;
+	unsigned char buf[14 + 6 * MAX_FAME_LIST * sizeof(struct fame_list)];
 
-	WBUFW(buf,0) = 0x2b1b;
+	for( i = 0; i < fame_list_size_bg && bg_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&bg_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	// add bgrank's block length
+	WBUFW(buf,12) = len;
 
-	for(i = 0; i < fame_list_size_smith && smith_fame_list[i].id; i++) {
-		memcpy(WBUFP(buf, len), &smith_fame_list[i], sizeof(struct fame_list));
+	for( i = 0; i < fame_list_size_bgrank && bgrank_fame_list[i].id; i++ ) {
+		memcpy(WBUFP(buf,len),&bgrank_fame_list[i],sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
+	// add bgrank's block length
+	WBUFW(buf,10) = len;
+
+	for( i = 0; i < fame_list_size_pvprank && pvprank_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&pvprank_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	// add pvprank's block length
+	WBUFW(buf,8) = len;
+
+	for( i = 0; i < fame_list_size_smith && smith_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&smith_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
 	// add blacksmith's block length
-	WBUFW(buf, 6) = len;
+	WBUFW(buf,6) = len;
 
-	for(i = 0; i < fame_list_size_chemist && chemist_fame_list[i].id; i++) {
-		memcpy(WBUFP(buf, len), &chemist_fame_list[i], sizeof(struct fame_list));
+	for( i = 0; i < fame_list_size_chemist && chemist_fame_list[i].id; i++ ) {
+		memcpy(WBUFP(buf,len),&chemist_fame_list[i],sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
 	// add alchemist's block length
-	WBUFW(buf, 4) = len;
+	WBUFW(buf,4) = len;
 
-	for(i = 0; i < fame_list_size_taekwon && taekwon_fame_list[i].id; i++) {
-		memcpy(WBUFP(buf, len), &taekwon_fame_list[i], sizeof(struct fame_list));
+	for( i = 0; i < fame_list_size_taekwon && taekwon_fame_list[i].id; i++ ) {
+		memcpy(WBUFP(buf,len),&taekwon_fame_list[i],sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
-	// add total packet length
-	WBUFW(buf, 2) = len;
+	// Header
+	WBUFW(buf,0) = 0x2b1b;
+	WBUFW(buf,2) = len;
 
-	if(fd != -1)
+	if( fd != -1 )
 		mapif_send(fd, buf, len);
 	else
 		mapif_sendall(buf, len);
@@ -2566,12 +3250,94 @@
 	WBUFB(buf,2) = type;
 	WBUFB(buf,3) = index;
 	WBUFL(buf,4) = fame;
-	mapif_sendall(buf, 8);
-}
-
-//Loads a character's name and stores it in the buffer given (must be NAME_LENGTH in size)
-//Returns 1 on found, 0 on not found (buffer is filled with Unknown char name)
-int char_loadName(int char_id, char *name)
+	mapif_sendall(buf, 8);
+}
+
+/*----------------------------------------------------------------------------------------------------------*/
+/* Ranking Reset */
+/*----------------------------------------------------------------------------------------------------------*/
+int char_ranking_reset(int type)
+{
+	unsigned char buf[4];
+
+	ShowInfo("Ranking Reset Request from Map Server...\n");
+	switch( type )
+	{
+	case 0:
+		if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `char_wstats`") )
+			Sql_ShowDebug(sql_handle);
+		if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `char_woe_log`") )
+			Sql_ShowDebug(sql_handle); // Kill log cleanup
+		if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `skill_count`") )
+			Sql_ShowDebug(sql_handle);
+		break;
+	case 1:
+		if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `char_bg`") )
+			Sql_ShowDebug(sql_handle); // Data Cleanup
+		else
+		{ // Trophy Updates
+			struct item it;
+			const char* position[] = { "1st", "2nd", "3rd" };
+			const char* medal[] = { "bg_gold", "bg_silver", "bg_bronze" };
+			char title[40], body[200];
+			int i;
+
+			memset(&it,0,sizeof(it));
+			it.amount = it.identify = 1;
+
+			for( i = 0; i < 3; i++ )
+			{ // Ranked Rewards
+				if( !bgrank_fame_list[i].id )
+					continue;
+
+				it.nameid = bg_ranked_rewards[i];
+				sprintf(title,"%s Place Ranked Battleground",position[i]);
+				sprintf(body,"Congratulations, you won the %s place in the Battleground Ranked Matchs of the week.",position[i]);
+				mail_sendmail(0,"Server",bgrank_fame_list[i].id,bgrank_fame_list[i].name,title,body,0,(bg_ranked_rewards[i] ? &it : NULL));
+				if( SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `%s` = `%s` + 1 WHERE `char_id` = '%d'", char_db, medal[i], medal[i], bgrank_fame_list[i].id) )
+					Sql_ShowDebug(sql_handle);
+			}
+
+			for( i = 0; i < 3; i++ )
+			{ // Regular Rewards
+				if( !bg_fame_list[i].id )
+					continue;
+
+				it.nameid = bg_regular_rewards[i];
+				sprintf(title,"%s Place Regular Battleground",position[i]);
+				sprintf(body,"Congratulations, you won the %s place in the Battleground Regular Matchs of the week.",position[i]);
+				mail_sendmail(0,"Server",bg_fame_list[i].id,bg_fame_list[i].name,title,body,0,(bg_regular_rewards[i] ? &it : NULL));
+				if( SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `%s` = `%s` + 1 WHERE `char_id` = '%d'", char_db, medal[i], medal[i], bg_fame_list[i].id) )
+					Sql_ShowDebug(sql_handle);
+			}
+
+			if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `char_bg_log`") )
+				Sql_ShowDebug(sql_handle); // Kill log cleanup
+
+			memset(bgrank_fame_list, 0, sizeof(bgrank_fame_list)); // Reset BG Ranked
+			memset(bg_fame_list, 0, sizeof(bg_fame_list)); // Reset BG Normal
+
+			// Send Lists to Map Servers
+			char_send_fame_list_single(-1,5);
+			char_send_fame_list_single(-1,6);
+		}
+		break;
+	case 2:
+		if( SQL_ERROR == Sql_Query(sql_handle, "TRUNCATE TABLE `char_pvp`") )
+			Sql_ShowDebug(sql_handle);
+		break;
+	}
+
+	WBUFW(buf,0) = 0x2b29;
+	WBUFW(buf,2) = type;
+	mapif_sendall(buf,4);
+
+	return 0;
+}
+
+//Loads a character's name and stores it in the buffer given (must be NAME_LENGTH in size)
+//Returns 1 on found, 0 on not found (buffer is filled with Unknown char name)
+int char_loadName(int char_id, char* name)
 {
 	char *data;
 	size_t len;
@@ -2770,12 +3536,58 @@
 					Sql_FreeResult(sql_handle);
 #endif
 					RFIFOSKIP(fd, 10);
-				}
-				break;
-
-			case 0x2afe: //set MAP user count
-				if(RFIFOREST(fd) < 4)
-					return 0;
+		}
+		break;
+
+		case 0x2b0a: //Request skillcooldown data
+			if (RFIFOREST(fd) < 10)
+				return 0;
+		{
+			int aid, cid;
+			aid = RFIFOL(fd,2);
+			cid = RFIFOL(fd,6);
+			if( SQL_ERROR == Sql_Query(sql_handle, "SELECT skill, tick FROM `%s` WHERE `account_id` = '%d' AND `char_id`='%d'",
+				skillcooldown_db, aid, cid) )
+			{
+				Sql_ShowDebug(sql_handle);
+				break;
+			}
+			if( Sql_NumRows(sql_handle) > 0 )
+			{
+				int count;
+				char* data;
+				struct skill_cooldown_data scd;
+
+				WFIFOHEAD(fd,14 + MAX_SKILLCOOLDOWN * sizeof(struct skill_cooldown_data));
+				WFIFOW(fd,0) = 0x2b0b;
+				WFIFOL(fd,4) = aid;
+				WFIFOL(fd,8) = cid;
+				for( count = 0; count < MAX_SKILLCOOLDOWN && SQL_SUCCESS == Sql_NextRow(sql_handle); ++count )
+				{
+					Sql_GetData(sql_handle, 0, &data, NULL); scd.skill_id = atoi(data);
+					Sql_GetData(sql_handle, 1, &data, NULL); scd.tick = atoi(data);
+					memcpy(WFIFOP(fd,14+count*sizeof(struct skill_cooldown_data)), &scd, sizeof(struct skill_cooldown_data));
+				}
+				if( count >= MAX_SKILLCOOLDOWN )
+					ShowWarning("Too many skillcooldowns for %d:%d, some of them were not loaded.\n", aid, cid);
+				if( count > 0 )
+				{
+					WFIFOW(fd,2) = 14 + count * sizeof(struct skill_cooldown_data);
+					WFIFOW(fd,12) = count;
+					WFIFOSET(fd,WFIFOW(fd,2));
+					//Clear the data once loaded.
+					if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `account_id` = '%d' AND `char_id`='%d'", skillcooldown_db, aid, cid) )
+						Sql_ShowDebug(sql_handle);
+				}
+			}
+			Sql_FreeResult(sql_handle);
+			RFIFOSKIP(fd, 10);
+		}
+		break;
+
+		case 0x2afe: //set MAP user count
+			if (RFIFOREST(fd) < 4)
+				return 0;
 				if(RFIFOW(fd,2) != server[id].users) {
 					server[id].users = RFIFOW(fd,2);
 					ShowInfo(read_message("Source.char.char_parse_frommap_s6"), server[id].users, id);
@@ -3114,12 +3926,15 @@
 					int fame_pos;
 
 					switch(type) {
-						case 1:  size = fame_list_size_smith;   list = smith_fame_list;   break;
-						case 2:  size = fame_list_size_chemist; list = chemist_fame_list; break;
-						case 3:  size = fame_list_size_taekwon; list = taekwon_fame_list; break;
-						default: size = 0;                      list = NULL;              break;
-					}
-
+				case 1:  size = fame_list_size_smith;   list = smith_fame_list;   break;
+				case 2:  size = fame_list_size_chemist; list = chemist_fame_list; break;
+				case 3:  size = fame_list_size_taekwon; list = taekwon_fame_list; break;
+				case 4:  size = fame_list_size_pvprank; list = pvprank_fame_list; break;
+				case 5:  size = fame_list_size_bgrank;  list = bgrank_fame_list;  break;
+				case 6:  size = fame_list_size_bg;      list = bg_fame_list;      break;
+				default: size = 0;                      list = NULL;              break;
+			}
+
 					ARR_FIND(0, size, player_pos, list[player_pos].id == cid);// position of the player
 					ARR_FIND(0, size, fame_pos, list[fame_pos].fame <= fame);// where the player should be
 
@@ -3141,13 +3956,13 @@
 							// already in the list
 							if(fame_pos == size)
 								--fame_pos;// move to the end of the list
-							ARR_MOVE(player_pos, fame_pos, list, struct fame_list);
-							list[fame_pos].fame = fame;
-						}
-						char_send_fame_list(-1);
-					}
-
-					RFIFOSKIP(fd,11);
+					ARR_MOVE(player_pos, fame_pos, list, struct fame_list);
+					list[fame_pos].fame = fame;
+				}
+				char_send_fame_list_single(-1,type); // [Zephyrus] Update to send only the modified list
+			}
+
+			RFIFOSKIP(fd,11);
 				}
 				break;
 
@@ -3157,12 +3972,37 @@
 					return 0;
 
 				divorce_char_sql(RFIFOL(fd,2), RFIFOL(fd,6));
-				RFIFOSKIP(fd,10);
-				break;
-
-			case 0x2b16: // Receive rates [Wizputer]
-				if(RFIFOREST(fd) < 14)
-					return 0;
+			RFIFOSKIP(fd,10);
+		break;
+
+		// Ranking Reset
+		case 0x2b28:
+			if( RFIFOREST(fd) < 4 )
+				return 0;
+
+			char_ranking_reset(RFIFOW(fd,2));
+			RFIFOSKIP(fd,4);
+		break;
+
+		case 0x2b2a:
+			if( RFIFOREST(fd) < 4 )
+				return 0;
+			
+			char_item_remove4all(RFIFOW(fd,2));
+			RFIFOSKIP(fd,4);
+		break;
+
+		case 0x2b2d: // char2dumpfile
+			if (RFIFOREST(fd) < 6)
+				return 0;
+			
+			char_dump2sql((int)RFIFOL(fd,2));
+			RFIFOSKIP(fd,6);
+		break;
+
+		case 0x2b16: // Receive rates [Wizputer]
+			if( RFIFOREST(fd) < 14 )
+				return 0;
 				{
 					char esc_server_name[sizeof(server_name)*2+1];
 
@@ -3233,12 +4073,43 @@
 					}
 #endif
 					RFIFOSKIP(fd, RFIFOW(fd, 2));
-				}
-				break;
-
-			case 0x2b23: // map-server alive packet
-				WFIFOHEAD(fd,2);
-				WFIFOW(fd,0) = 0x2b24;
+		}
+		break;
+
+		case 0x2b15: //Request to save skill cooldown data
+			if( RFIFOREST(fd) < 4 || RFIFOREST(fd) < RFIFOW(fd,2) )
+				return 0;
+		{
+			int count, aid, cid;
+			aid = RFIFOL(fd,4);
+			cid = RFIFOL(fd,8);
+			count = RFIFOW(fd,12);
+			if( count > 0 )
+			{
+				struct skill_cooldown_data data;
+				StringBuf buf;
+				int i;
+
+				StringBuf_Init(&buf);
+				StringBuf_Printf(&buf, "INSERT INTO `%s` (`account_id`, `char_id`, `skill`, `tick`) VALUES ", skillcooldown_db);
+				for( i = 0; i < count; ++i )
+				{
+					memcpy(&data,RFIFOP(fd,14+i*sizeof(struct skill_cooldown_data)),sizeof(struct skill_cooldown_data));
+					if( i > 0 )
+						StringBuf_AppendStr(&buf, ", ");
+					StringBuf_Printf(&buf, "('%d','%d','%d','%d')", aid, cid, data.skill_id, data.tick);
+				}
+				if( SQL_ERROR == Sql_QueryStr(sql_handle, StringBuf_Value(&buf)) )
+					Sql_ShowDebug(sql_handle);
+				StringBuf_Destroy(&buf);
+			}
+			RFIFOSKIP(fd,RFIFOW(fd,2));
+		}
+		break;
+
+		case 0x2b23: // map-server alive packet
+			WFIFOHEAD(fd,2);
+			WFIFOW(fd,0) = 0x2b24;
 				WFIFOSET(fd,2);
 				RFIFOSKIP(fd,2);
 				break;
@@ -3280,10 +4151,12 @@
 					   node->sex == sex /*&&
                 node->ip == ip*/) {
 						// auth ok
-						cd->sex = sex;
-
-						WFIFOHEAD(fd,25 + sizeof(struct mmo_charstatus));
-						WFIFOW(fd,0) = 0x2afd;
+				cd->sex = sex;
+
+				char_ip_premium(ip, cd);
+
+				WFIFOHEAD(fd,25 + sizeof(struct mmo_charstatus));
+				WFIFOW(fd,0) = 0x2afd;
 						WFIFOW(fd,2) = 25 + sizeof(struct mmo_charstatus);
 						WFIFOL(fd,4) = account_id;
 						WFIFOL(fd,8) = node->login_id1;
@@ -4715,12 +5588,14 @@
 		else if(!strcmpi(w1,"inventory_db"))
 			safestrncpy(inventory_db, w2, sizeof(inventory_db));
 		else if(!strcmpi(w1,"charlog_db"))
-			safestrncpy(charlog_db, w2, sizeof(charlog_db));
-		else if(!strcmpi(w1,"storage_db"))
-			safestrncpy(storage_db, w2, sizeof(storage_db));
-		else if(!strcmpi(w1,"reg_db"))
-			safestrncpy(reg_db, w2, sizeof(reg_db));
-		else if(!strcmpi(w1,"skill_db"))
+			safestrncpy(charlog_db, w2, sizeof(charlog_db));
+		else if(!strcmpi(w1,"storage_db"))
+			safestrncpy(storage_db, w2, sizeof(storage_db));
+		else if(!strcmpi(w1,"rentstorage_db")) // [ZephStorage]
+			safestrncpy(rentstorage_db, w2, sizeof(rentstorage_db));
+		else if(!strcmpi(w1,"reg_db"))
+			safestrncpy(reg_db, w2, sizeof(reg_db));
+		else if(!strcmpi(w1,"skill_db"))
 			safestrncpy(skill_db, w2, sizeof(skill_db));
 		else if(!strcmpi(w1,"interlog_db"))
 			safestrncpy(interlog_db, w2, sizeof(interlog_db));
@@ -4873,12 +5748,18 @@
 		} else if(strcmpi(w1, "start_armor") == 0) {
 			start_armor = atoi(w2);
 			if(start_armor < 0)
-				start_armor = 0;
-		} else if(strcmpi(w1,"log_char")==0) {      //log char or not [devil]
-			log_char = atoi(w2);
-		} else if(strcmpi(w1, "unknown_char_name") == 0) {
-			safestrncpy(unknown_char_name, w2, sizeof(unknown_char_name));
-			unknown_char_name[NAME_LENGTH-1] = '\0';
+				start_armor = 0;
+		} else if(strcmpi(w1,"log_char")==0) {		//log char or not [devil]
+			log_char = atoi(w2);
+
+		} else if (strcmpi(w1, "guild_base_members") == 0) {
+			guild_base_members = atoi(w2);
+		} else if (strcmpi(w1, "guild_add_members") == 0) {
+			guild_add_members = atoi(w2);
+
+		} else if (strcmpi(w1, "unknown_char_name") == 0) {
+			safestrncpy(unknown_char_name, w2, sizeof(unknown_char_name));
+			unknown_char_name[NAME_LENGTH-1] = '\0';
 		} else if(strcmpi(w1, "name_ignoring_case") == 0) {
 			name_ignoring_case = (bool)config_switch(w2);
 		} else if(strcmpi(w1, "char_name_option") == 0) {
@@ -4918,7 +5799,21 @@
 				ShowWarning(read_message("Source.char.char_config_read_s8"), MAX_FAME_LIST);
 				fame_list_size_taekwon = MAX_FAME_LIST;
 			}
-		} else if(strcmpi(w1, "guild_exp_rate") == 0) {
+
+		} else if (strcmpi(w1, "bg_regular_rewards") == 0 ) {
+			int i;
+			memset(bg_regular_rewards, 0, sizeof(bg_regular_rewards));
+			sscanf(w2, "%d,%d,%d", &bg_regular_rewards[0], &bg_regular_rewards[1], &bg_regular_rewards[2]);
+			for( i = 0; i < 3; i++ )
+				if( bg_regular_rewards[i] < 0 ) bg_regular_rewards[i] = 0;
+		} else if (strcmpi(w1, "bg_ranked_rewards") == 0 ) {
+			int i;
+			memset(bg_ranked_rewards, 0, sizeof(bg_ranked_rewards));
+			sscanf(w2, "%d,%d,%d", &bg_ranked_rewards[0], &bg_ranked_rewards[1], &bg_ranked_rewards[2]);
+			for( i = 0; i < 3; i++ )
+				if( bg_ranked_rewards[i] < 0 ) bg_ranked_rewards[i] = 0;
+
+		} else if (strcmpi(w1, "guild_exp_rate") == 0) {
 			guild_exp_rate = atoi(w2);
 		} else if (strcmpi(w1, "pincode_enabled") == 0) {
 			pincode_enabled = config_switch(w2);
Index: src/char/char.h
===================================================================
--- src/char/char.h	(revision 1953)
+++ src/char/char.h	(working copy)
@@ -34,13 +34,14 @@
 
 enum {
     TABLE_INVENTORY,
-    TABLE_CART,
-    TABLE_STORAGE,
-    TABLE_GUILD_STORAGE,
-};
+	TABLE_CART,
+	TABLE_STORAGE,
+	TABLE_GUILD_STORAGE,
+	TABLE_EXT_STORAGE,
+};
+
+int memitemdata_to_sql(const struct item items[], int max, int id, int tableswitch);
 
-int memitemdata_to_sql(const struct item items[], int max, int id, int tableswitch);
-
 int mapif_sendall(unsigned char *buf,unsigned int len);
 int mapif_sendallwos(int fd,unsigned char *buf,unsigned int len);
 int mapif_send(int fd,unsigned char *buf,unsigned int len);
@@ -61,12 +62,13 @@
 extern char char_db[256];
 extern char scdata_db[256];
 extern char cart_db[256];
-extern char inventory_db[256];
-extern char charlog_db[256];
-extern char storage_db[256];
-extern char interlog_db[256];
-extern char reg_db[256];
-extern char skill_db[256];
+extern char inventory_db[256];
+extern char charlog_db[256];
+extern char storage_db[256];
+extern char rentstorage_db[256]; // [ZephStorage]
+extern char interlog_db[256];
+extern char reg_db[256];
+extern char skill_db[256];
 extern char memo_db[256];
 extern char guild_db[256];
 extern char guild_alliance_db[256];
@@ -83,13 +85,16 @@
 extern char quest_db[256];
 extern char homunculus_db[256];
 extern char skill_homunculus_db[256];
-extern char mercenary_db[256];
-extern char mercenary_owner_db[256];
-extern char ragsrvinfo_db[256];
-
-extern int db_use_sqldbs; // added for sql item_db read for char server [Valaris]
-
-extern int guild_exp_rate;
-extern int log_inter;
-
-#endif /* _CHAR_SQL_H_ */
+extern char mercenary_db[256];
+extern char mercenary_owner_db[256];
+extern char ragsrvinfo_db[256];
+extern char achievement_db[256];
+
+extern int db_use_sqldbs; // added for sql item_db read for char server [Valaris]
+
+extern int guild_exp_rate;
+extern int log_inter;
+extern int guild_base_members;
+extern int guild_add_members;
+
+#endif /* _CHAR_SQL_H_ */
Index: src/char/int_auction.c
===================================================================
--- src/char/int_auction.c	(revision 1953)
+++ src/char/int_auction.c	(working copy)
@@ -58,15 +58,15 @@
 	SqlStmt *stmt;
 
 	if(!auction)
-		return;
+		return;
+
+	StringBuf_Init(&buf);
+	StringBuf_Printf(&buf, "UPDATE `%s` SET `seller_id` = '%d', `seller_name` = ?, `buyer_id` = '%d', `buyer_name` = ?, `price` = '%d', `buynow` = '%d', `hours` = '%d', `timestamp` = '%lu', `nameid` = '%d', `item_name` = ?, `type` = '%d', `refine` = '%d', `attribute` = '%d', `unique_id` = '%"PRIu64"'",
+		auction_db, auction->seller_id, auction->buyer_id, auction->price, auction->buynow, auction->hours, (unsigned long)auction->timestamp, auction->item.nameid, auction->type, auction->item.refine, auction->item.attribute, auction->item.unique_id);
+	for( j = 0; j < MAX_SLOTS; j++ )
+		StringBuf_Printf(&buf, ", `card%d` = '%d'", j, auction->item.card[j]);
+	StringBuf_Printf(&buf, " WHERE `auction_id` = '%d'", auction->auction_id);
 
-	StringBuf_Init(&buf);
-	StringBuf_Printf(&buf, "UPDATE `%s` SET `seller_id` = '%d', `seller_name` = ?, `buyer_id` = '%d', `buyer_name` = ?, `price` = '%d', `buynow` = '%d', `hours` = '%d', `timestamp` = '%lu', `nameid` = '%d', `item_name` = ?, `type` = '%d', `refine` = '%d', `attribute` = '%d'",
-	                 auction_db, auction->seller_id, auction->buyer_id, auction->price, auction->buynow, auction->hours, (unsigned long)auction->timestamp, auction->item.nameid, auction->type, auction->item.refine, auction->item.attribute);
-	for(j = 0; j < MAX_SLOTS; j++)
-		StringBuf_Printf(&buf, ", `card%d` = '%d'", j, auction->item.card[j]);
-	StringBuf_Printf(&buf, " WHERE `auction_id` = '%d'", auction->auction_id);
-
 	stmt = SqlStmt_Malloc(sql_handle);
 	if(SQL_SUCCESS != SqlStmt_PrepareStr(stmt, StringBuf_Value(&buf))
 	   ||  SQL_SUCCESS != SqlStmt_BindParam(stmt, 0, SQLDT_STRING, auction->seller_name, strnlen(auction->seller_name, NAME_LENGTH))
@@ -143,12 +143,24 @@
 	WBUFW(buf,0) = 0x3854;
 	WBUFL(buf,2) = char_id;
 	WBUFL(buf,6) = result;
-	mapif_sendall(buf,7);
-}
-
-static int auction_end_timer(int tid, unsigned int tick, int id, intptr_t data)
-{
-	struct auction_data *auction;
+	mapif_sendall(buf,7);
+}
+
+static void mapif_Auction_data(struct auction_data *auction, unsigned char result)
+{ // Send Auction data to map servers
+	unsigned char buf[sizeof(struct auction_data) + 5];
+	int len = sizeof(struct auction_data) + 5;
+
+	WBUFW(buf,0) = 0x3856;
+	WBUFW(buf,2) = len;
+	WBUFB(buf,4) = result;
+	memcpy(WBUFP(buf,5), auction, sizeof(struct auction_data));
+	mapif_sendall(buf,len);
+}
+
+static int auction_end_timer(int tid, unsigned int tick, int id, intptr_t data)
+{
+	struct auction_data *auction;
 	if((auction = (struct auction_data *)idb_get(auction_db_, id)) != NULL) {
 		if(auction->buyer_id) {
 			mail_sendmail(0, read_message("Source.char.auction_end_timer_s1"), auction->buyer_id, auction->buyer_name, read_message("Source.char.auction_end_timer_s2"), read_message("Source.char.auction_end_timer_s3"), 0, &auction->item);
@@ -158,11 +170,12 @@
 			mail_sendmail(0, read_message("Source.char.auction_end_timer_s1"), auction->seller_id, auction->seller_name, read_message("Source.char.auction_end_timer_s2"), read_message("Source.char.auction_end_timer_s5"), 0, &auction->item);
 
 		ShowInfo(read_message("Source.char.auction_end_timer_s6"), auction->auction_id);
+
+		auction->auction_end_timer = INVALID_TIMER;
+		mapif_Auction_data(auction, 2);
+		auction_delete(auction);
+	}
 
-		auction->auction_end_timer = INVALID_TIMER;
-		auction_delete(auction);
-	}
-
 	return 0;
 }
 
@@ -443,16 +456,20 @@
 		mail_sendmail(0, read_message("Source.char.auction_end_timer_s1"), auction->buyer_id, auction->buyer_name, read_message("Source.char.auction_end_timer_s2"), read_message("Source.char.auction_mapif_pAuction_bid_s3"), 0, &auction->item);
 		mapif_Auction_message(char_id, 6); // You have won the auction
 		mail_sendmail(0, read_message("Source.char.auction_end_timer_s1"), auction->seller_id, auction->seller_name, read_message("Source.char.auction_end_timer_s2"), read_message("Source.char.auction_mapif_pAuction_bid_s4"), auction->buynow, NULL);
+
+		mapif_Auction_data(auction, 1);
+		auction_delete(auction);
+	}
+	else
+	{
+		auction_save(auction);
+		mapif_Auction_data(auction, 0);
+		mapif_Auction_bid(fd, char_id, 0, 1); // You have successfully bid in the auction
+	}
+
+	return;
+}
 
-		auction_delete(auction);
-		return;
-	}
-
-	auction_save(auction);
-
-	mapif_Auction_bid(fd, char_id, 0, 1); // You have successfully bid in the auction
-}
-
 /*==========================================
  * Packets From Map Server
  *------------------------------------------*/
Index: src/char/int_guild.c
===================================================================
--- src/char/int_guild.c	(revision 1953)
+++ src/char/int_guild.c	(working copy)
@@ -225,7 +225,30 @@
 			Sql_ShowDebug(sql_handle);
 		StringBuf_Destroy(&buf);
 	}
+	
+	if( flag&GS_RANKING )
+	{
+		strcat(t_info, " ranking");
+		for( i = 0; i < RANK_CASTLES; i++ )
+		{
+			if( g->castle[i].changed )
+			{
+				if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `guild_rank` (`guild_id`, `castle_id`, "
+					"`capture`, `emperium`, `treasure`, `top_eco`, `top_def`, `invest_eco`, `invest_def`, `offensive_score`, `defensive_score`, "
+					"`posesion_time`, `zeny_eco`, `zeny_def`, `skill_battleorder`, `skill_regeneration`, `skill_restore`, `skill_emergencycall`, "
+					"`off_kill`, `off_death`, `def_kill`, `def_death`, `ext_kill`, `ext_death`, `ali_kill`, `ali_death`) "
+					"VALUES ('%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d')",
+					g->guild_id, i,
+					g->castle[i].capture, g->castle[i].emperium, g->castle[i].treasure, g->castle[i].top_eco, g->castle[i].top_def, g->castle[i].invest_eco, g->castle[i].invest_def, g->castle[i].offensive_score, g->castle[i].defensive_score,
+					g->castle[i].posesion_time, g->castle[i].zeny_eco, g->castle[i].zeny_def, g->castle[i].skill_battleorder, g->castle[i].skill_regeneration, g->castle[i].skill_restore, g->castle[i].skill_emergencycall,
+					g->castle[i].off.kill_count, g->castle[i].off.death_count, g->castle[i].def.kill_count, g->castle[i].def.death_count, g->castle[i].ext.kill_count, g->castle[i].ext.death_count, g->castle[i].ali.kill_count, g->castle[i].ali.death_count) )
+					Sql_ShowDebug(sql_handle);
 
+				g->castle[i].changed = false;
+			}
+		}
+	}
+
 	if(flag&GS_MEMBER) {
 		struct guild_member *m;
 
@@ -354,12 +377,13 @@
 	if(SQL_SUCCESS != Sql_NextRow(sql_handle))
 		return NULL;// Guild does not exists.
 
-	CREATE(g, struct guild, 1);
-
-	g->guild_id = guild_id;
-	Sql_GetData(sql_handle,  0, &data, &len); memcpy(g->name, data, min(len, NAME_LENGTH));
-	Sql_GetData(sql_handle,  1, &data, &len); memcpy(g->master, data, min(len, NAME_LENGTH));
-	Sql_GetData(sql_handle,  2, &data, NULL); g->guild_lv = atoi(data);
+	CREATE(g, struct guild, 1);
+
+	g->guild_id = guild_id;
+	g->war_tick = 0;
+	Sql_GetData(sql_handle,  0, &data, &len); memcpy(g->name, data, min(len, NAME_LENGTH));
+	Sql_GetData(sql_handle,  1, &data, &len); memcpy(g->master, data, min(len, NAME_LENGTH));
+	Sql_GetData(sql_handle,  2, &data, NULL); g->guild_lv = atoi(data);
 	Sql_GetData(sql_handle,  3, &data, NULL); g->connect_member = atoi(data);
 	Sql_GetData(sql_handle,  4, &data, NULL); g->max_member = atoi(data);
 	if(g->max_member > MAX_GUILD) {
@@ -395,10 +419,70 @@
 		else if(*data >= 'A' && *data <= 'F')
 			*p |= *data - 'A' + 10;
 		++data;
-	}
-
-	// load guild member info
-	if(SQL_ERROR == Sql_Query(sql_handle, "SELECT `account_id`,`char_id`,`hair`,`hair_color`,`gender`,`class`,`lv`,`exp`,`exp_payper`,`online`,`position`,`name` "
+	}
+
+	/* Guild Ranking */
+	for( i = 0; i < RANK_CASTLES; i++ )
+		g->castle[i].changed = true;
+
+	if( SQL_ERROR == Sql_Query(sql_handle,
+		"SELECT "
+		"`castle_id`, `capture`, `emperium`, `treasure`, `top_eco`, `top_def`, `invest_eco`, `invest_def`, `offensive_score`, `defensive_score`, "
+		"`posesion_time`, `zeny_eco`, `zeny_def`, `skill_battleorder`, `skill_regeneration`, `skill_restore`, `skill_emergencycall`, "
+		"`off_kill`, `off_death`, `def_kill`, `def_death`, `ext_kill`, `ext_death`, `ali_kill`, `ali_death` "
+		"FROM `guild_rank` WHERE `guild_id` = '%d'", g->guild_id) )
+		Sql_ShowDebug(sql_handle);
+	else
+	{
+		while( SQL_SUCCESS == Sql_NextRow(sql_handle) )
+		{
+			Sql_GetData(sql_handle, 0, &data, NULL); i = atoi(data);
+			if( i >= RANK_CASTLES || i < 0 )
+				continue;
+
+			Sql_GetData(sql_handle, 1, &data, NULL); g->castle[i].capture = atoi(data);
+			Sql_GetData(sql_handle, 2, &data, NULL); g->castle[i].emperium = atoi(data);
+			Sql_GetData(sql_handle, 3, &data, NULL); g->castle[i].treasure = atoi(data);
+			Sql_GetData(sql_handle, 4, &data, NULL); g->castle[i].top_eco = atoi(data);
+			Sql_GetData(sql_handle, 5, &data, NULL); g->castle[i].top_def = atoi(data);
+			Sql_GetData(sql_handle, 6, &data, NULL); g->castle[i].invest_eco = atoi(data);
+			Sql_GetData(sql_handle, 7, &data, NULL); g->castle[i].invest_def = atoi(data);
+			Sql_GetData(sql_handle, 8, &data, NULL); g->castle[i].offensive_score = atoi(data);
+			Sql_GetData(sql_handle, 9, &data, NULL); g->castle[i].defensive_score = atoi(data);
+
+			Sql_GetData(sql_handle,10, &data, NULL); g->castle[i].posesion_time = strtoul(data, NULL, 0);
+			Sql_GetData(sql_handle,11, &data, NULL); g->castle[i].zeny_eco = strtoul(data, NULL, 0);
+			Sql_GetData(sql_handle,12, &data, NULL); g->castle[i].zeny_def = strtoul(data, NULL, 0);
+
+			Sql_GetData(sql_handle,13, &data, NULL); g->castle[i].skill_battleorder = atoi(data);
+			Sql_GetData(sql_handle,14, &data, NULL); g->castle[i].skill_regeneration = atoi(data);
+			Sql_GetData(sql_handle,15, &data, NULL); g->castle[i].skill_restore = atoi(data);
+			Sql_GetData(sql_handle,16, &data, NULL); g->castle[i].skill_emergencycall = atoi(data);
+
+			Sql_GetData(sql_handle,17, &data, NULL); g->castle[i].off.kill_count = atoi(data);
+			Sql_GetData(sql_handle,18, &data, NULL); g->castle[i].off.death_count = atoi(data);
+			Sql_GetData(sql_handle,19, &data, NULL); g->castle[i].def.kill_count = atoi(data);
+			Sql_GetData(sql_handle,20, &data, NULL); g->castle[i].def.death_count = atoi(data);
+			Sql_GetData(sql_handle,21, &data, NULL); g->castle[i].ext.kill_count = atoi(data);
+			Sql_GetData(sql_handle,22, &data, NULL); g->castle[i].ext.death_count = atoi(data);
+			Sql_GetData(sql_handle,23, &data, NULL); g->castle[i].ali.kill_count = atoi(data);
+			Sql_GetData(sql_handle,24, &data, NULL); g->castle[i].ali.death_count = atoi(data);
+
+			g->castle[i].changed = false;
+		}
+	}
+
+	for( i = 0; i < RANK_CASTLES; i++ )
+	{
+		if( !g->castle[i].changed )
+			continue;
+
+		g->castle[i].offensive_score = 2000;
+		g->save_flag |= GS_RANKING;
+	}
+
+	// load guild member info
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `account_id`,`char_id`,`hair`,`hair_color`,`gender`,`class`,`lv`,`exp`,`exp_payper`,`online`,`position`,`name` "
 	                          "FROM `%s` WHERE `guild_id`='%d' ORDER BY `position`", guild_member_db, guild_id)) {
 		Sql_ShowDebug(sql_handle);
 		aFree(g);
@@ -453,12 +537,13 @@
 	for(i = 0; i < MAX_GUILDALLIANCE && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i) {
 		struct guild_alliance *a = &g->alliance[i];
 
-		Sql_GetData(sql_handle, 0, &data, NULL); a->opposition = atoi(data);
-		Sql_GetData(sql_handle, 1, &data, NULL); a->guild_id = atoi(data);
-		Sql_GetData(sql_handle, 2, &data, &len); memcpy(a->name, data, min(len, NAME_LENGTH));
-	}
-
-	//printf("- Read guild_expulsion %d from sql \n",guild_id);
+		Sql_GetData(sql_handle, 0, &data, NULL); a->opposition = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, NULL); a->guild_id = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); memcpy(a->name, data, min(len, NAME_LENGTH));
+		a->war = false;
+	}
+
+	//printf("- Read guild_expulsion %d from sql \n",guild_id);
 	if(SQL_ERROR == Sql_Query(sql_handle, "SELECT `account_id`,`name`,`mes` FROM `%s` WHERE `guild_id`='%d'", guild_expulsion_db, guild_id)) {
 		Sql_ShowDebug(sql_handle);
 		aFree(g);
@@ -809,7 +894,7 @@
 	g->next_exp = nextexp;
 
 	// Set the max number of members, Guild Extention skill - currently adds 6 to max per skill lv.
-	g->max_member = 16 + guild_checkskill(g, GD_EXTENSION) * 6;
+	g->max_member = guild_base_members + guild_checkskill(g, GD_EXTENSION) * guild_add_members;
 	if(g->max_member > MAX_GUILD) {
 		ShowError(read_message("Source.char.guild_calcinfo_s1"), g->guild_id, g->name, g->max_member, MAX_GUILD);
 		g->max_member = MAX_GUILD;
@@ -1044,12 +1129,23 @@
 	memcpy(WBUFP(buf,6),g->mes1,MAX_GUILDMES1);
 	memcpy(WBUFP(buf,66),g->mes2,MAX_GUILDMES2);
 	mapif_sendall(buf,186);
-	return 0;
-}
-
-// Send emblem data
-int mapif_guild_emblem(struct guild *g)
-{
+	return 0;
+}
+
+// [Zephyrus] Guild Rank
+int mapif_Guild_Save_Score(int guild_id, int index)
+{
+	unsigned char buf[8];
+	WBUFW(buf,0) = 0x3844;
+	WBUFL(buf,2) = guild_id;
+	WBUFW(buf,6) = index;
+	mapif_sendall(buf,8);
+	return 0;
+}
+
+// Send emblem data
+int mapif_guild_emblem(struct guild *g)
+{
 	unsigned char buf[12 + sizeof(g->emblem_data)];
 	WBUFW(buf,0)=0x383f;
 	WBUFW(buf,2)=g->emblem_len+12;
@@ -1139,18 +1235,24 @@
 		g->position[i].modified = GS_POSITION_MODIFIED;
 	}
 
-	// Initialize guild property
-	g->max_member=16;
-	g->average_lv=master->lv;
-	g->connect_member=1;
-
-	for(i=0; i<MAX_GUILDSKILL; i++)
-		g->skill[i].id=i + GD_SKILLBASE;
-	g->guild_id= -1; //Request to create guild.
-
-	// Create the guild
-	if(!inter_guild_tosql(g,GS_BASIC|GS_POSITION|GS_SKILL|GS_MEMBER)) {
-		//Failed to Create guild....
+	// Initialize guild property
+	g->max_member = guild_base_members;
+	g->average_lv = master->lv;
+	g->connect_member = 1;
+	g->guild_lv = 1;
+	for( i = 0; i < RANK_CASTLES; i++ )
+	{
+		g->castle[i].offensive_score = 2000;
+		g->castle[i].changed = true;
+	}
+
+	for(i=0;i<MAX_GUILDSKILL;i++)
+		g->skill[i].id=i + GD_SKILLBASE;
+	g->guild_id= -1; //Request to create guild.
+
+	// Create the guild
+	if (!inter_guild_tosql(g,GS_BASIC|GS_POSITION|GS_SKILL|GS_MEMBER|GS_RANKING)) {
+		//Failed to Create guild....
 		ShowError(read_message("Source.char.guild_mapif_parse_createguild_s6"), g->name, g->master);
 		mapif_guild_created(fd,account_id,NULL);
 		aFree(g);
@@ -1354,13 +1456,16 @@
 	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `guild_id` = '%d'", guild_skill_db, guild_id))
 		Sql_ShowDebug(sql_handle);
 
-	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `guild_id` = '%d'", guild_expulsion_db, guild_id))
-		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `guild_id` = '%d'", guild_expulsion_db, guild_id) )
+		Sql_ShowDebug(sql_handle);
+
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `guild_rank` WHERE `guild_id` = '%d'", guild_id) )
+		Sql_ShowDebug(sql_handle);
+
+	//printf("- Update guild %d of char\n",guild_id);
+	if( SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `guild_id`='0' WHERE `guild_id`='%d'", char_db, guild_id) )
+		Sql_ShowDebug(sql_handle);
 
-	//printf("- Update guild %d of char\n",guild_id);
-	if(SQL_ERROR == Sql_Query(sql_handle, "UPDATE `%s` SET `guild_id`='0' WHERE `guild_id`='%d'", char_db, guild_id))
-		Sql_ShowDebug(sql_handle);
-
 	mapif_guild_broken(guild_id,0);
 
 	if(log_inter)
@@ -1761,12 +1866,26 @@
 // - Can analyzed only one by one packet
 // Data packet length that you set to inter.c
 //- Shouldn't do checking and packet length, RFIFOSKIP is done by the caller
-// Must Return
-//      1 : ok
-//  0 : error
-int inter_guild_parse_frommap(int fd)
-{
-	RFIFOHEAD(fd);
+// Must Return
+//	1 : ok
+//  0 : error
+
+int mapif_parse_Guild_Save_Score(int fd, int guild_id, int index, struct guild_rank_data *grd)
+{
+	struct guild *g;
+	if( index < 0 || index >= RANK_CASTLES )
+		return 0;
+	if( (g = inter_guild_fromsql(guild_id)) == NULL )
+		return 0;
+	memcpy(&g->castle[index], grd, sizeof(struct guild_rank_data));
+	g->save_flag |= GS_RANKING;
+
+	return mapif_Guild_Save_Score(guild_id, index);
+}
+
+int inter_guild_parse_frommap(int fd)
+{
+	RFIFOHEAD(fd);
 	switch(RFIFOW(fd,0)) {
 		case 0x3030: mapif_parse_CreateGuild(fd,RFIFOL(fd,4),(char *)RFIFOP(fd,8),(struct guild_member *)RFIFOP(fd,32)); break;
 		case 0x3031: mapif_parse_GuildInfo(fd,RFIFOL(fd,2)); break;
@@ -1782,12 +1901,13 @@
 		case 0x303C: mapif_parse_GuildSkillUp(fd,RFIFOL(fd,2),RFIFOL(fd,6),RFIFOL(fd,10),RFIFOL(fd,14)); break;
 		case 0x303D: mapif_parse_GuildAlliance(fd,RFIFOL(fd,2),RFIFOL(fd,6),RFIFOL(fd,10),RFIFOL(fd,14),RFIFOB(fd,18)); break;
 		case 0x303E: mapif_parse_GuildNotice(fd,RFIFOL(fd,2),(const char *)RFIFOP(fd,6),(const char *)RFIFOP(fd,66)); break;
-		case 0x303F: mapif_parse_GuildEmblem(fd,RFIFOW(fd,2)-12,RFIFOL(fd,4),RFIFOL(fd,8),(const char *)RFIFOP(fd,12)); break;
-		case 0x3040: mapif_parse_GuildCastleDataLoad(fd,RFIFOW(fd,2),(int *)RFIFOP(fd,4)); break;
-		case 0x3041: mapif_parse_GuildCastleDataSave(fd,RFIFOW(fd,2),RFIFOB(fd,4),RFIFOL(fd,5)); break;
-
-		default:
-			return 0;
+	case 0x303F: mapif_parse_GuildEmblem(fd,RFIFOW(fd,2)-12,RFIFOL(fd,4),RFIFOL(fd,8),(const char*)RFIFOP(fd,12)); break;
+	case 0x3040: mapif_parse_GuildCastleDataLoad(fd,RFIFOW(fd,2),(int *)RFIFOP(fd,4)); break;
+	case 0x3041: mapif_parse_GuildCastleDataSave(fd,RFIFOW(fd,2),RFIFOB(fd,4),RFIFOL(fd,5)); break;
+	case 0x3042: mapif_parse_Guild_Save_Score(fd,RFIFOL(fd,4),RFIFOW(fd,8),(struct guild_rank_data *)RFIFOP(fd,10)); break;
+
+	default:
+		return 0;
 	}
 
 	return 1;
Index: src/char/int_guild.h
===================================================================
--- src/char/int_guild.h	(revision 1953)
+++ src/char/int_guild.h	(working copy)
@@ -25,13 +25,14 @@
 	GS_EXPULSION = 0x0010,
 	GS_SKILL = 0x0020,
 	GS_EMBLEM = 0x0040,
-	GS_CONNECT = 0x0080,
-	GS_LEVEL = 0x0100,
-	GS_MES = 0x0200,
-	GS_MASK = 0x03FF,
-	GS_BASIC_MASK = (GS_BASIC | GS_EMBLEM | GS_CONNECT | GS_LEVEL | GS_MES),
-	GS_REMOVE = 0x8000,
-};
+	GS_CONNECT = 0x0080,
+	GS_LEVEL = 0x0100,
+	GS_MES = 0x0200,
+	GS_RANKING = 0x0400,
+	GS_MASK = 0x07FF,
+	GS_BASIC_MASK = (GS_BASIC | GS_EMBLEM | GS_CONNECT | GS_LEVEL | GS_MES),
+	GS_REMOVE = 0x8000,
+};
 
 struct guild;
 struct guild_castle;
Index: src/char/int_mail.c
===================================================================
--- src/char/int_mail.c	(revision 1953)
+++ src/char/int_mail.c	(working copy)
@@ -74,8 +74,9 @@
 		Sql_GetData(sql_handle,13, &data, NULL); item->attribute = atoi(data);
 		Sql_GetData(sql_handle,14, &data, NULL); item->identify = atoi(data);
 		Sql_GetData(sql_handle,15, &data, NULL); item->unique_id = strtoull(data, NULL, 10);
-		item->expire_time = 0;
-
+		item->expire_time = 0;
+		item->bound = 0;
+
 		for(j = 0; j < MAX_SLOTS; j++) {
 			Sql_GetData(sql_handle, 16 + j, &data, NULL);
 			item->card[j] = atoi(data);
@@ -186,8 +187,9 @@
 		Sql_GetData(sql_handle,13, &data, NULL); msg->item.attribute = atoi(data);
 		Sql_GetData(sql_handle,14, &data, NULL); msg->item.identify = atoi(data);
 		Sql_GetData(sql_handle,15, &data, NULL); msg->item.unique_id = strtoull(data, NULL, 10);
-		msg->item.expire_time = 0;
-
+		msg->item.expire_time = 0;
+		msg->item.bound = 0;
+
 		for(j = 0; j < MAX_SLOTS; j++) {
 			Sql_GetData(sql_handle,16 + j, &data, NULL);
 			msg->item.card[j] = atoi(data);
@@ -239,14 +241,14 @@
 static bool mail_DeleteAttach(int mail_id)
 {
 	StringBuf buf;
-	int i;
+	int i;
+
+	StringBuf_Init(&buf);
+	StringBuf_Printf(&buf, "UPDATE `%s` SET `zeny` = '0', `nameid` = '0', `amount` = '0', `refine` = '0', `attribute` = '0', `identify` = '0', `unique_id` = '0'", mail_db);
+	for (i = 0; i < MAX_SLOTS; i++)
+		StringBuf_Printf(&buf, ", `card%d` = '0'", i);
+	StringBuf_Printf(&buf, " WHERE `id` = '%d'", mail_id);
 
-	StringBuf_Init(&buf);
-	StringBuf_Printf(&buf, "UPDATE `%s` SET `zeny` = '0', `nameid` = '0', `amount` = '0', `refine` = '0', `attribute` = '0', `identify` = '0'", mail_db);
-	for(i = 0; i < MAX_SLOTS; i++)
-		StringBuf_Printf(&buf, ", `card%d` = '0'", i);
-	StringBuf_Printf(&buf, " WHERE `id` = '%d'", mail_id);
-
 	if(SQL_ERROR == Sql_Query(sql_handle, StringBuf_Value(&buf))) {
 		Sql_ShowDebug(sql_handle);
 		StringBuf_Destroy(&buf);
Index: src/char/int_storage.c
===================================================================
--- src/char/int_storage.c	(revision 1953)
+++ src/char/int_storage.c	(working copy)
@@ -48,14 +48,14 @@
 
 	memset(p, 0, sizeof(struct storage_data)); //clean up memory
 	p->storage_amount = 0;
+
+	// storage {`account_id`/`id`/`nameid`/`amount`/`equip`/`identify`/`refine`/`attribute`/`card0`/`card1`/`card2`/`card3`}
+	StringBuf_Init(&buf);
+	StringBuf_AppendStr(&buf, "SELECT `id`,`nameid`,`amount`,`equip`,`identify`,`refine`,`attribute`,`expire_time`,`unique_id`,`bound`");
+	for( j = 0; j < MAX_SLOTS; ++j )
+		StringBuf_Printf(&buf, ",`card%d`", j);
+	StringBuf_Printf(&buf, " FROM `%s` WHERE `account_id`='%d' ORDER BY `nameid`", storage_db, account_id);
 
-	// storage {`account_id`/`id`/`nameid`/`amount`/`equip`/`identify`/`refine`/`attribute`/`card0`/`card1`/`card2`/`card3`}
-	StringBuf_Init(&buf);
-	StringBuf_AppendStr(&buf, "SELECT `id`,`nameid`,`amount`,`equip`,`identify`,`refine`,`attribute`,`expire_time`,`unique_id`");
-	for(j = 0; j < MAX_SLOTS; ++j)
-		StringBuf_Printf(&buf, ",`card%d`", j);
-	StringBuf_Printf(&buf, " FROM `%s` WHERE `account_id`='%d' ORDER BY `nameid`", storage_db, account_id);
-
 	if(SQL_ERROR == Sql_Query(sql_handle, StringBuf_Value(&buf)))
 		Sql_ShowDebug(sql_handle);
 
@@ -72,20 +72,70 @@
 		Sql_GetData(sql_handle, 6, &data, NULL); item->attribute = atoi(data);
 		Sql_GetData(sql_handle, 7, &data, NULL); item->expire_time = (unsigned int)atoi(data);
 		Sql_GetData(sql_handle, 8, &data, NULL); item->unique_id = strtoull(data, NULL, 10);
+		Sql_GetData(sql_handle, 9, &data, NULL); item->bound = atoi(data);
 		for(j = 0; j < MAX_SLOTS; ++j) {
-			Sql_GetData(sql_handle, 9+j, &data, NULL); item->card[j] = atoi(data);
+			Sql_GetData(sql_handle, 10+j, &data, NULL); item->card[j] = atoi(data);
 		}
 	}
 	p->storage_amount = i;
 	Sql_FreeResult(sql_handle);
 
 	ShowInfo(read_message("Source.char.storage_fromsql"), account_id, p->storage_amount);
-	return 1;
-}
-
-/// Save guild_storage data to sql
-int guild_storage_tosql(int guild_id, struct guild_storage *p)
-{
+	return 1;
+}
+
+// DB -> storage data conversion
+int ext_storage_fromsql(int account_id, struct extra_storage_data *p)
+{
+	StringBuf buf;
+	struct item* item;
+	char* data;
+	int i;
+	int j;
+
+	memset(p, 0, sizeof(struct extra_storage_data)); //clean up memory
+	p->storage_amount = 0;
+
+	// storage {`account_id`/`id`/`nameid`/`amount`/`equip`/`identify`/`refine`/`attribute`/`card0`/`card1`/`card2`/`card3`}
+	StringBuf_Init(&buf);
+	StringBuf_AppendStr(&buf, "SELECT `id`,`nameid`,`amount`,`equip`,`identify`,`refine`,`attribute`,`expire_time`,`unique_id`,`bound`");
+	for( j = 0; j < MAX_SLOTS; ++j )
+		StringBuf_Printf(&buf, ",`card%d`", j);
+	StringBuf_Printf(&buf, " FROM `%s` WHERE `account_id`='%d' ORDER BY `nameid`", rentstorage_db, account_id);
+
+	if( SQL_ERROR == Sql_Query(sql_handle, StringBuf_Value(&buf)) )
+		Sql_ShowDebug(sql_handle);
+
+	StringBuf_Destroy(&buf);
+
+	for( i = 0; i < MAX_EXTRA_STORAGE && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		item = &p->items[i];
+		Sql_GetData(sql_handle, 0, &data, NULL); item->id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, NULL); item->nameid = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, NULL); item->amount = atoi(data);
+		Sql_GetData(sql_handle, 3, &data, NULL); item->equip = atoi(data);
+		Sql_GetData(sql_handle, 4, &data, NULL); item->identify = atoi(data);
+		Sql_GetData(sql_handle, 5, &data, NULL); item->refine = atoi(data);
+		Sql_GetData(sql_handle, 6, &data, NULL); item->attribute = atoi(data);
+		Sql_GetData(sql_handle, 7, &data, NULL); item->expire_time = (unsigned int)atoi(data);
+		Sql_GetData(sql_handle, 8, &data, NULL); item->unique_id = strtoull(data, NULL, 10);
+		Sql_GetData(sql_handle, 9, &data, NULL); item->bound = atoi(data);
+		for( j = 0; j < MAX_SLOTS; ++j )
+		{
+			Sql_GetData(sql_handle, 10+j, &data, NULL); item->card[j] = atoi(data);
+		}
+	}
+	p->storage_amount = i;
+	Sql_FreeResult(sql_handle);
+
+	ShowInfo("rentstorage load complete from DB - id: %d (total: %d)\n", account_id, p->storage_amount);
+	return 1;
+}
+
+/// Save guild_storage data to sql
+int guild_storage_tosql(int guild_id, struct guild_storage* p)
+{
 	memitemdata_to_sql(p->items, MAX_GUILD_STORAGE, guild_id, TABLE_GUILD_STORAGE);
 	ShowInfo(read_message("Source.char.storage_gtosql"), guild_id);
 	return 0;
@@ -127,6 +177,7 @@
 		Sql_GetData(sql_handle, 6, &data, NULL); item->attribute = atoi(data);
 		Sql_GetData(sql_handle, 7, &data, NULL); item->unique_id = strtoull(data, NULL, 10);
 		item->expire_time = 0;
+		item->bound = 0;
 		for(j = 0; j < MAX_SLOTS; ++j) {
 			Sql_GetData(sql_handle, 8+j, &data, NULL); item->card[j] = atoi(data);
 		}
@@ -154,15 +205,21 @@
 int inter_storage_delete(int account_id)
 {
 	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `account_id`='%d'", storage_db, account_id))
+		Sql_ShowDebug(sql_handle);
+	return 0;
+}
+int inter_rentstorage_delete(int account_id) // [ZephStorage]
+{
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `account_id`='%d'", rentstorage_db, account_id) )
+		Sql_ShowDebug(sql_handle);
+	return 0;
+}
+int inter_guild_storage_delete(int guild_id)
+{
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `guild_id`='%d'", guild_storage_db, guild_id) )
 		Sql_ShowDebug(sql_handle);
 	return 0;
 }
-int inter_guild_storage_delete(int guild_id)
-{
-	if(SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `guild_id`='%d'", guild_storage_db, guild_id))
-		Sql_ShowDebug(sql_handle);
-	return 0;
-}
 
 //---------------------------------------------------------
 // packet from map server
Index: src/char/int_storage.h
===================================================================
--- src/char/int_storage.h	(revision 1953)
+++ src/char/int_storage.h	(working copy)
@@ -15,21 +15,24 @@
 *****************************************************************************/ 
 
 #ifndef _INT_STORAGE_SQL_H_
-#define _INT_STORAGE_SQL_H_
-
-struct storage_data;
-struct guild_storage;
-
-int inter_storage_sql_init(void);
-void inter_storage_sql_final(void);
-int inter_storage_delete(int account_id);
-int inter_guild_storage_delete(int guild_id);
-
-int inter_storage_parse_frommap(int fd);
-
-//Exported for use in the TXT-SQL converter.
-int storage_fromsql(int account_id, struct storage_data* p);
-int storage_tosql(int account_id,struct storage_data *p);
-int guild_storage_tosql(int guild_id, struct guild_storage *p);
-
+#define _INT_STORAGE_SQL_H_
+
+struct storage_data;
+struct ext_storage_data;
+struct guild_storage;
+
+int inter_storage_sql_init(void);
+void inter_storage_sql_final(void);
+int inter_storage_delete(int account_id);
+int inter_rentstorage_delete(int account_id); // [ZephStorage]
+int inter_guild_storage_delete(int guild_id);
+
+int inter_storage_parse_frommap(int fd);
+
+//Exported for use in the TXT-SQL converter.
+int storage_fromsql(int account_id, struct storage_data* p);
+int ext_storage_fromsql(int account_id, struct extra_storage_data *p);
+int storage_tosql(int account_id,struct storage_data *p);
+int guild_storage_tosql(int guild_id, struct guild_storage *p);
+
 #endif /* _INT_STORAGE_SQL_H_ */
Index: src/char/inter.c
===================================================================
--- src/char/inter.c	(revision 1953)
+++ src/char/inter.c	(working copy)
@@ -30,12 +30,13 @@
 #include "int_homun.h"
 #include "int_mercenary.h"
 #include "int_mail.h"
-#include "int_auction.h"
-#include "int_quest.h"
-#include "int_elemental.h"
-
-#include <stdio.h>
-#include <string.h>
+#include "int_auction.h"
+#include "int_quest.h"
+#include "int_elemental.h"
+#include "int_achievement.h"
+
+#include <stdio.h>
+#include <string.h>
 #include <stdlib.h>
 
 #include <sys/stat.h> // for stat/lstat/fstat - [Dekamaster/Ultimate GM Tool]
@@ -57,21 +58,20 @@
 static struct accreg *accreg_pt;
 unsigned int party_share_level = 10;
 unsigned int party_family_share_level = 150;
-char main_chat_nick[16] = "Main";
 
 char tmp_db_name[32] = "db";
 
 // recv. packet list
 int inter_recv_packet_length[] = {
 	-1,-1, 7,-1, -1,13,36, (2 + 4 + 4 + 4 + NAME_LENGTH),  0, 0, 0, 0,  0, 0,  0, 0,    // 3000-
-	6,-1, 0, 0,  0, 0, 0, 0, 10,-1, 0, 0,  0, 0,  0, 0,    // 3010-
-	-1,10,-1,14, 14,19, 6,-1, 14,14, 0, 0,  0, 0,  0, 0,    // 3020- Party
-	-1, 6,-1,-1, 55,19, 6,-1, 14,-1,-1,-1, 18,19,186,-1,    // 3030-
-	-1, 9, 0, 0,  0, 0, 0, 0,  7, 6,10,10, 10,-1,  0, 0,    // 3040-
-	-1,-1,10,10,  0,-1, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,    // 3050-  Auction System [Zephyrus]
-	6,-1, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,    // 3060-  Quest system [Kevin] [Inkfish]
-	-1,10, 6,-1,  0, 0, 0, 0,  0, 0, 0, 0, -1,10,  6,-1,    // 3070-  Mercenary packets [Zephyrus], Elemental packets [pakpil]
-	48,14,-1, 6,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,    // 3080-
+	 6,-1, 0, 0,  0, 0, 0, 0, 10,-1, 0, 0,  0, 0,  0, 0,	// 3010-
+	-1,10,-1,14, 14,19, 6,-1, 14,14, 0, 0,  0, 0,  0, 0,	// 3020- Party
+	-1, 6,-1,-1, 55,19, 6,-1, 14,-1,-1,-1, 18,19,186,-1,	// 3030-
+	-1, 9,-1, 0, 10, 6,-1, 0,  7, 6,10,10, 10,-1,  0, 0,	// 3040-  [Zephyrus] 0x3042 Guild Rank
+	-1,-1,10,10,  0,-1, 0, 0,  0, 0, 6,-1,  0, 0,  0, 0,	// 3050-  Auction System [Zephyrus] + Achievement System
+	 6,-1, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,	// 3060-  Quest system [Kevin] [Inkfish]
+	-1,10, 6,-1,  0, 0, 0, 0,  0, 0, 0, 0, -1,10,  6,-1,	// 3070-  Mercenary packets [Zephyrus], Elemental packets [pakpil]
+	48,14,-1, 6,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,	// 3080-
 	-1,10,-1, 6,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,    // 3090-  Homunculus packets [albator]
 };
 
@@ -750,8 +750,6 @@
 			party_family_share_level = atoi(w2);
 		else if(!strcmpi(w1,"log_inter"))
 			log_inter = atoi(w2);
-		else if(!strcmpi(w1,"main_chat_nick"))
-			safestrncpy(main_chat_nick, w2, sizeof(main_chat_nick));
 		else if(!strcmpi(w1,"db_name"))
 			safestrncpy(tmp_db_name, w2, sizeof(tmp_db_name));
 		else if(!strcmpi(w1,"import"))
@@ -1243,12 +1241,13 @@
 			   || inter_homunculus_parse_frommap(fd)
 			   || inter_mercenary_parse_frommap(fd)
 			   || inter_elemental_parse_frommap(fd)
-			   || inter_mail_parse_frommap(fd)
-			   || inter_auction_parse_frommap(fd)
-			   || inter_quest_parse_frommap(fd)
-			  )
-				break;
-			else
+		  || inter_mail_parse_frommap(fd)
+		  || inter_auction_parse_frommap(fd)
+		  || inter_quest_parse_frommap(fd)
+		  || inter_achievement_parse_frommap(fd)
+		   )
+			break;
+		else
 				return 0;
 	}
 
Index: src/char/inter.h
===================================================================
--- src/char/inter.h	(revision 1953)
+++ src/char/inter.h	(working copy)
@@ -37,7 +37,6 @@
 extern Sql* sql_handle;
 extern Sql* lsql_handle;
 
-extern char main_chat_nick[16];
 extern char tmp_db_name[32];
 
 int inter_accreg_tosql(int account_id, int char_id, struct accreg* reg, int type);
Index: src/char/Makefile.in
===================================================================
--- src/char/Makefile.in	(revision 1953)
+++ src/char/Makefile.in	(working copy)
@@ -13,14 +13,14 @@
 LIBCONFIG_INCLUDE = -I../../3rdparty/libconfig
 
 COMMON_SQL_OBJ = ../common/obj_sql/sql.o
-COMMON_H = ../common/sql.h
-
-CHAR_OBJ = obj_sql/char.o obj_sql/inter.o obj_sql/int_party.o obj_sql/int_guild.o \
-	obj_sql/int_storage.o obj_sql/int_pet.o obj_sql/int_homun.o obj_sql/int_mail.o obj_sql/int_auction.o obj_sql/int_quest.o obj_sql/int_mercenary.o obj_sql/int_elemental.o
-CHAR_H = char.h inter.h int_party.h int_guild.h int_storage.h int_pet.h int_homun.h int_mail.h int_auction.h int_quest.h int_mercenary.h int_elemental.h
-
-HAVE_MYSQL=@HAVE_MYSQL@
-ifeq ($(HAVE_MYSQL),yes)
+COMMON_H = ../common/sql.h
+
+CHAR_OBJ = obj_sql/char.o obj_sql/inter.o obj_sql/int_party.o obj_sql/int_guild.o \
+	obj_sql/int_storage.o obj_sql/int_pet.o obj_sql/int_homun.o obj_sql/int_achievement.o obj_sql/int_mail.o obj_sql/int_auction.o obj_sql/int_quest.o obj_sql/int_mercenary.o obj_sql/int_elemental.o
+CHAR_H = char.h inter.h int_party.h int_guild.h int_storage.h int_pet.h int_homun.h int_mail.h int_auction.h int_quest.h int_mercenary.h int_achievement.h int_elemental.h
+
+HAVE_MYSQL=@HAVE_MYSQL@
+ifeq ($(HAVE_MYSQL),yes)
 	CHAR_SERVER_SQL_DEPENDS=obj_sql $(CHAR_OBJ) ../common/obj_sql/common_sql.a ../common/obj_all/common.a $(MT19937AR_OBJ)
 else
 	CHAR_SERVER_SQL_DEPENDS=needs_mysql
Index: src/common/mmo.h
===================================================================
--- src/common/mmo.h	(revision 1953)
+++ src/common/mmo.h	(working copy)
@@ -14,13 +14,13 @@
 * \todo ?                                                                    *  
 *****************************************************************************/
 
-#ifndef _MMO_H_
-#define _MMO_H_
-
-#include "cbasetypes.h"
-#include <time.h>
-
-// server->client protocol version
+#ifndef	_MMO_H_
+#define	_MMO_H_
+
+#include "../common/cbasetypes.h"
+#include <time.h>
+
+// server->client protocol version
 //        0 - pre-?
 //        1 - ?                    - 0x196
 //        2 - ?                    - 0x78, 0x79
@@ -80,7 +80,7 @@
 #define MAX_HOTKEYS 38
 #endif
 
-#define MAX_MAP_PER_SERVER 1500 // Increased to allow creation of Instance Maps
+#define MAX_MAP_PER_SERVER 2500 // Increased to allow creation of Instance Maps
 #define MAX_INVENTORY 100
 //Max number of characters per account. Note that changing this setting alone is not enough if the client is not hexed to support more characters as well.
 #define MAX_CHARS 9
@@ -93,6 +93,7 @@
 #define MAX_FAME 1000000000
 #define MAX_CART 100
 #define MAX_SKILL 5100
+#define MAX_SKILL_TREE 84
 #define GLOBAL_REG_NUM 256   // max permanent character variables per char
 #define ACCOUNT_REG_NUM 64   // max permanent local account variables per account
 #define ACCOUNT_REG2_NUM 16  // max permanent global account variables per account
@@ -102,6 +103,7 @@
 #define MIN_WALK_SPEED 0
 #define MAX_WALK_SPEED 1000
 #define MAX_STORAGE 600
+#define MAX_EXTRA_STORAGE 100 // Extra Storage Size
 #define MAX_GUILD_STORAGE 600
 #define MAX_PARTY 12
 #define MAX_GUILD 16+10*6   // increased max guild members +6 per 1 extension levels [Lupus]
@@ -135,13 +137,14 @@
 //For Map Names, which the client considers to be 16 in length including the .gat extension
 #define MAP_NAME_LENGTH (11 + 1)
 #define MAP_NAME_LENGTH_EXT (MAP_NAME_LENGTH + 4)
+
+#define MAX_FRIENDS 40
+#define MAX_MEMOPOINTS 3
+#define MAX_SKILLCOOLDOWN 20
+
+//Size of the fame list arrays.
+#define MAX_FAME_LIST 10
 
-#define MAX_FRIENDS 40
-#define MAX_MEMOPOINTS 3
-
-//Size of the fame list arrays.
-#define MAX_FAME_LIST 10
-
 //Limits to avoid ID collision with other game objects
 #define START_ACCOUNT_NUM 2000000
 #define END_ACCOUNT_NUM 100000000
@@ -173,12 +176,16 @@
 #define EL_SKILLBASE 8401
 #define MAX_ELESKILLTREE 3
 #define MAX_ELEMENTAL_CLASS 30
-#define EL_CLASS_BASE 2114
-#define EL_CLASS_MAX (EL_CLASS_BASE+MAX_ELEMENTAL_CLASS-1)
-
-enum item_types {
-    IT_HEALING = 0,
-    IT_UNKNOWN, //1
+#define EL_CLASS_BASE 2114
+#define EL_CLASS_MAX (EL_CLASS_BASE+MAX_ELEMENTAL_CLASS-1)
+
+//Achievement System
+#define ACHIEVEMENT_MAX 50
+#define ACHIEVEMENT_OBJETIVE_MAX 5
+
+enum item_types {
+	IT_HEALING = 0,
+	IT_UNKNOWN, //1
     IT_USABLE,  //2
     IT_ETC,     //3
     IT_WEAPON,  //4
@@ -211,13 +218,13 @@
 	unsigned short equip; // location(s) where item is equipped (using enum equip_pos for bitmasking)
 	char identify;
 	char refine;
-	char attribute;
-	short card[MAX_SLOTS];
-	unsigned int expire_time;
-	char favorite;
-	uint64 unique_id;
-};
-
+	char attribute;
+	short card[MAX_SLOTS];
+	unsigned int expire_time;
+	char bound, favorite;
+	uint64 unique_id;
+};
+
 struct point {
 	unsigned short map;
 	short x,y;
@@ -253,17 +260,27 @@
 //For saving status changes across sessions. [Skotlex]
 struct status_change_data {
 	unsigned short type; //SC_type
-	long val1, val2, val3, val4, tick; //Remaining duration.
-};
-
-struct storage_data {
-	int storage_amount;
-	struct item items[MAX_STORAGE];
-};
-
-struct guild_storage {
-	int dirty;
-	int guild_id;
+	long val1, val2, val3, val4, tick; //Remaining duration.
+};
+
+struct skill_cooldown_data {
+	unsigned short skill_id;
+	long tick;
+};
+
+struct storage_data {
+	int storage_amount;
+	struct item items[MAX_STORAGE];
+};
+
+struct extra_storage_data {
+	int storage_amount;
+	struct item items[MAX_EXTRA_STORAGE];
+};
+
+struct guild_storage {
+	int dirty;
+	int guild_id;
 	short storage_status;
 	short storage_amount;
 	struct item items[MAX_GUILD_STORAGE];
@@ -343,6 +360,137 @@
 };
 #endif
 
+struct s_killrank {
+	unsigned short
+		kill_count,
+		death_count;
+	int score;
+};
+
+struct s_battleground_stats {
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received,
+		boss_damage;
+	unsigned short
+		// Triple Inferno
+		skulls,
+		ti_wins, ti_lost, ti_tie,
+		// Tierra EoS
+		eos_flags,
+		eos_bases,
+		eos_wins, eos_lost, eos_tie,
+		// Tierra Bossnia
+		boss_killed,
+		boss_flags,
+		boss_wins, boss_lost, boss_tie,
+		// Tierra Domination
+		dom_bases,
+		dom_off_kills,
+		dom_def_kills,
+		dom_wins, dom_lost, dom_tie,
+		// Flavius TD
+		td_kills,
+		td_deaths,
+		td_wins, td_lost, td_tie,
+		// Flavius SC
+		sc_stole,
+		sc_captured,
+		sc_droped,
+		sc_wins, sc_lost, sc_tie,
+		// Flavius CTF
+		ctf_taken,
+		ctf_captured,
+		ctf_droped,
+		ctf_wins, ctf_lost, ctf_tie,
+		// Conquest
+		emperium_kill,
+		barricade_kill,
+		gstone_kill,
+		cq_wins, cq_lost,
+		// Rush
+		ru_captures,
+		ru_wins, ru_lost;
+
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	unsigned short
+		kill_count,
+		death_count,
+		win, lost, tie,
+		leader_win, leader_lost, leader_tie,
+		deserter, rank_games;
+
+	int score, points, rank_points;
+};
+
+struct s_woestats {
+	int score;
+	unsigned short
+		kill_count,
+		death_count;
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received;
+	unsigned int
+		emperium_damage,
+		guardian_damage,
+		barricade_damage,
+		gstone_damage;
+	unsigned short
+		emperium_kill,
+		guardian_kill,
+		barricade_kill,
+		gstone_kill;
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+};
+
+struct s_skillcount {
+	unsigned short id,count;
+};
+
+/////////////////////////////////////////////////////////////
+// Achievement System
+/////////////////////////////////////////////////////////////
+struct s_achievement {
+	int id;
+	int count[ACHIEVEMENT_OBJETIVE_MAX];
+	bool completed;
+};
+
 struct mmo_charstatus {
 	int char_id;
 	int account_id;
@@ -351,7 +499,7 @@
 	int mother;
 	int child;
 
-	unsigned int base_exp,job_exp;
+	unsigned int base_exp,job_exp,bg_exp;
 	int zeny;
 
 	short class_;
@@ -361,13 +509,16 @@
 	short manner;
 	unsigned char karma;
 	short hair,hair_color,clothes_color;
-	int party_id,guild_id,pet_id,hom_id,mer_id,ele_id;
+	int party_id,guild_id,pet_id,hom_id,mer_id,ele_id,faction_id;
 	int fame;
 
 	// Mercenary Guilds Rank
 	int arch_faith, arch_calls;
 	int spear_faith, spear_calls;
 	int sword_faith, sword_calls;
+	
+	time_t last_tick;
+	unsigned int playtime;
 
 	short weapon; // enum weapon_type
 	short shield; // view-id
@@ -381,10 +532,18 @@
 
 	uint32 mapip;
 	uint16 mapport;
+	
+	// Ranking Data
+	struct s_killrank pvp, pk;
+	struct s_battleground_stats bgstats;
+	struct s_skillcount bg_skillcount[MAX_SKILL_TREE]; // BG Limited
+	struct s_woestats wstats;
+	struct s_skillcount skillcount[MAX_SKILL_TREE]; // WoE Limited
 
 	struct point last_point,save_point,memo_point[MAX_MEMOPOINTS];
 	struct item inventory[MAX_INVENTORY],cart[MAX_CART];
 	struct storage_data storage;
+	struct extra_storage_data ext_storage;
 	struct s_skill skill[MAX_SKILL];
 
 	struct s_friend friends[MAX_FRIENDS]; //New friend system [Skotlex]
@@ -392,6 +551,7 @@
 	struct hotkey hotkeys[MAX_HOTKEYS];
 #endif
 	bool show_equip;
+	unsigned char iprank;
 	short rename;
 
 	time_t delete_date;
@@ -496,24 +656,55 @@
 };
 
 struct guild_alliance {
-	int opposition;
-	int guild_id;
+	int opposition;
+	int guild_id;
+	char name[NAME_LENGTH];
+	bool war;
+};
+
+struct guild_expulsion {
 	char name[NAME_LENGTH];
-};
-
-struct guild_expulsion {
-	char name[NAME_LENGTH];
 	char mes[40];
 	int account_id;
 };
 
 struct guild_skill {
-	int id,lv;
-};
-
-struct guild {
-	int guild_id;
-	short guild_lv, connect_member, max_member, average_lv;
+	int id,lv;
+};
+
+#define RANK_CASTLES 34 // eAMod Setting for Castle Ranking
+
+struct guild_rank_data {
+	unsigned short
+		capture, // Number of times you have captured this castle
+		emperium, // Number of times you have break an emperium on this castle
+		treasure, // Number of opened treasures
+		top_eco, // Max economy reach on this castle
+		top_def, // Max defense reach on this castle
+		invest_eco, // Total of Economy points
+		invest_def, // Total of Defense points
+		offensive_score,
+		defensive_score;
+	unsigned int
+		posesion_time,
+		zeny_eco,
+		zeny_def;
+	unsigned short
+		skill_battleorder,
+		skill_regeneration,
+		skill_restore,
+		skill_emergencycall;
+	struct {
+		unsigned int
+			kill_count,
+			death_count;
+	} off, def, ext, ali;
+	bool changed;
+};
+
+struct guild {
+	int guild_id;
+	short guild_lv, connect_member, max_member, average_lv;
 	uint64 exp;
 	unsigned int next_exp;
 	int skill_point;
@@ -524,13 +715,19 @@
 	int emblem_len,emblem_id;
 	char emblem_data[2048];
 	struct guild_alliance alliance[MAX_GUILDALLIANCE];
-	struct guild_expulsion expulsion[MAX_GUILDEXPULSION];
-	struct guild_skill skill[MAX_GUILDSKILL];
-
-	unsigned short save_flag; // for TXT saving
-};
-
-struct guild_castle {
+	struct guild_expulsion expulsion[MAX_GUILDEXPULSION];
+	struct guild_skill skill[MAX_GUILDSKILL];
+
+	struct guild_rank_data castle[RANK_CASTLES];
+
+	int skill_block_timer[MAX_GUILDSKILL];
+
+	unsigned short save_flag; // for TXT saving
+	bool war;
+	time_t war_tick;
+};
+
+struct guild_castle {
 	int castle_id;
 	int mapindex;
 	char castle_name[NAME_LENGTH];
@@ -541,12 +738,13 @@
 	int triggerE;
 	int triggerD;
 	int nextTime;
-	int payTime;
-	int createTime;
-	int visibleC;
-	struct {
-		unsigned visible : 1;
-		int id; // object id
+	int payTime;
+	int createTime;
+	int visibleC;
+	time_t capture_tick; // [WoE Ranking] 
+	struct {
+		unsigned visible : 1;
+		int id; // object id
 	} guardian[MAX_GUARDIANS];
 	int *temp_guardians; // ids of temporary guardians (mobs)
 	int temp_guardians_max;
Index: src/common/utils.h
===================================================================
--- src/common/utils.h	(revision 1953)
+++ src/common/utils.h	(working copy)
@@ -27,12 +27,30 @@
 void findfile(const char *p, const char *pat, void (func)(const char *));
 bool exists(const char *filename);
 
-//Caps values to min/max
-#define cap_value(a, min, max) ((a >= max) ? max : (a <= min) ? min : a)
-
-/// calculates the value of A / B, in percent (rounded down)
-unsigned int get_percentage(const unsigned int A, const unsigned int B);
-
+//Caps values to min/max
+#define cap_value(a, min, max) ((a >= max) ? max : (a <= min) ? min : a)
+
+#define add2limit(a, b, max) \
+	do { \
+		if( (max - a) < b ) { \
+			a = max; \
+		} else { \
+			a += b; \
+		} \
+	} while(0)
+
+#define sub2limit(a, b, min) \
+	do { \
+		if( (b + min) > a ) { \
+			a = min; \
+		} else { \
+			a -= b; \
+		} \
+	} while(0)
+
+/// calculates the value of A / B, in percent (rounded down)
+unsigned int get_percentage(const unsigned int A, const unsigned int B);
+
 //////////////////////////////////////////////////////////////////////////
 // byte word dword access [Shinomori]
 //////////////////////////////////////////////////////////////////////////
Index: src/config/const.h
===================================================================
--- src/config/const.h	(revision 1953)
+++ src/config/const.h	(working copy)
@@ -16,8 +16,10 @@
 
 #ifndef _RRCONFIGS_CONST_
 #define _RRCONFIGS_CONST_
-
-/**
+
+#include "../config/secure.h"
+
+/**
  * Checagens de segurança para tempo de intervalo nos diálogos com npcs.
  **/
 #if SECURE_NPCTIMEOUT_INTERVAL <= 0
Index: src/map/atcommand.c
===================================================================
--- src/map/atcommand.c	(revision 1953)
+++ src/map/atcommand.c	(working copy)
@@ -26,13 +26,15 @@
 #include "../common/strlib.h"
 #include "../common/utils.h"
 #include "../common/conf.h"
-
-#include "atcommand.h"
-#include "battle.h"
-#include "chat.h"
-#include "clif.h"
-#include "chrif.h"
-#include "duel.h"
+
+#include "atcommand.h"
+#include "battle.h"
+#include "battleground.h"
+#include "chat.h"
+#include "channel.h"
+#include "clif.h"
+#include "chrif.h"
+#include "duel.h"
 #include "intif.h"
 #include "itemdb.h"
 #include "log.h"
@@ -53,12 +55,14 @@
 #include "script.h"
 #include "storage.h"
 #include "trade.h"
-#include "unit.h"
-#include "mapreg.h"
-#include "quest.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "unit.h"
+#include "mapreg.h"
+#include "quest.h"
+#include "achievement.h"
+#include "faction.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
@@ -463,13 +467,19 @@
 	    sscanf(message, "%15[^,],%hd,%hd", map_name, &x, &y) < 1)) {
 
 		clif_displaymessage(fd, msg_txt(909)); // Please enter a map (usage: @warp/@rura/@mapmove <mapname> <x> <y>).
-		return -1;
-	}
+			return -1;
+	}
+
+	if( battle_config.pvpmode_nowarp_cmd && sd->state.pvpmode )
+	{
+		clif_displaymessage(sd->fd,"You can not use @go while on PVP Mode.");
+		return -1;
+	}
+
+	mapindex = mapindex_name2id(map_name);
+	if (mapindex)
+		m = map_mapindex2mapid(mapindex);
 
-	mapindex = mapindex_name2id(map_name);
-	if(mapindex)
-		m = map_mapindex2mapid(mapindex);
-
 	if(!mapindex) {  // m < 0 means on different server! [Kevin]
 		clif_displaymessage(fd, msg_txt(1)); // Map not found.
 		return -1;
@@ -892,14 +902,14 @@
 		return -1;
 	}
 
-	if(sd->npc_id || sd->state.vending || sd->state.buyingstore || sd->state.trading)
-		return -1;
+	if (sd->npc_id || sd->state.vending || sd->state.buyingstore || sd->state.trading)
+		return -1;
+
+	if (sd->state.storage_flag == 1 || sd->state.storage_flag == 3) {
+		clif_displaymessage(fd, msg_txt(250));
+		return -1;
+	}
 
-	if(sd->state.storage_flag == 1) {
-		clif_displaymessage(fd, msg_txt(250));
-		return -1;
-	}
-
 	if(sd->state.storage_flag == 2) {
 		clif_displaymessage(fd, msg_txt(251));
 		return -1;
@@ -1168,13 +1178,13 @@
 /*==========================================
  * @item command (usage: @item <name/id_of_item> <quantity>) (modified by [Yor] for pet_egg)
  *------------------------------------------*/
-ACMD_FUNC(item)
-{
-	char item_name[100];
-	int number = 0, item_id, flag = 0;
-	struct item item_tmp;
-	struct item_data *item_data;
-	int get_count, i;
+ACMD_FUNC(item)
+{
+	char item_name[100];
+	int number = 0, item_id, flag = 0, type = 0;
+	struct item item_tmp;
+	struct item_data *item_data;
+	int get_count, i;
 	nullpo_retr(-1, sd);
 
 	memset(item_name, '\0', sizeof(item_name));
@@ -1193,27 +1203,71 @@
 	if((item_data = itemdb_searchname(item_name)) == NULL &&
 	   (item_data = itemdb_exists(atoi(item_name))) == NULL) {
 		clif_displaymessage(fd, msg_txt(19)); // Invalid item ID or name.
-		return -1;
-	}
+		return -1;
+	}
+
+	if( !strcmpi(command+1,"bounditem") )
+		type = 1;
+	else if( !strcmpi(command+1,"costumeitem") )
+	{
+		if( !battle_config.costume_reserved_char_id )
+		{
+			clif_displaymessage(fd, "Costume convertion is disable. Set a value for costume_reserved_char_id on your eAmod.conf file.");
+			return -1;
+		}
+		if( !(item_data->equip&EQP_HEAD_LOW) &&
+			!(item_data->equip&EQP_HEAD_MID) &&
+			!(item_data->equip&EQP_HEAD_TOP) &&
+			!(item_data->equip&EQP_COS_HEAD_LOW) &&
+			!(item_data->equip&EQP_COS_HEAD_MID) &&
+			!(item_data->equip&EQP_COS_HEAD_TOP) )
+		{
+			clif_displaymessage(fd, "You cannot costume this item. Costume only work for headgears");
+			return -1;
+		}
+		type = 2;
+	}
+
+	item_id = item_data->nameid;
+	get_count = number;
+	//Check if it's stackable.
+	if( !itemdb_isstackable2(item_data) )
+	{
+		if( type == 1 && (item_data->type == IT_PETEGG || item_data->type == IT_PETARMOR) )
+		{
+			clif_displaymessage(fd, "Cannot create bounded pet eggs or pet armors.");
+			return -1;
+		}
+		get_count = 1;
+	}
+	else if( type == 1 )
+	{
+		clif_displaymessage(fd, "Cannot create bounded stackable items.");
+		return -1;
+	}
+
+	for( i = 0; i < number; i += get_count )
+	{
+		// if not pet egg
+		if( !pet_create_egg(sd, item_id) )
+		{
+			memset(&item_tmp, 0, sizeof(item_tmp));
+			item_tmp.nameid = item_id;
+			item_tmp.identify = 1;
+			if( type == 1 )
+				item_tmp.bound = 1;
+			else if( type == 2 )
+			{ // Costume Item
+				item_tmp.card[0] = CARD0_CREATE;
+				item_tmp.card[2] = GetWord(battle_config.costume_reserved_char_id, 0);
+				item_tmp.card[3] = GetWord(battle_config.costume_reserved_char_id, 1);
+			}
+
+			if( (flag = pc_additem(sd, &item_tmp, get_count,LOG_TYPE_COMMAND)) )
+				clif_additem(sd, 0, 0, flag);
+		}
+	}
 
-	item_id = item_data->nameid;
-	get_count = number;
-	//Check if it's stackable.
-	if(!itemdb_isstackable2(item_data))
-		get_count = 1;
-
-	for(i = 0; i < number; i += get_count) {
-		// if not pet egg
-		if(!pet_create_egg(sd, item_id)) {
-			memset(&item_tmp, 0, sizeof(item_tmp));
-			item_tmp.nameid = item_id;
-			item_tmp.identify = 1;
-
-			if((flag = pc_additem(sd, &item_tmp, get_count, LOG_TYPE_COMMAND)))
-				clif_additem(sd, 0, 0, flag);
-		}
-	}
-
 	if(flag == 0)
 		clif_displaymessage(fd, msg_txt(18)); // Item created.
 	return 0;
@@ -1224,13 +1278,13 @@
  *------------------------------------------*/
 ACMD_FUNC(item2)
 {
-	struct item item_tmp;
-	struct item_data *item_data;
-	char item_name[100];
-	int item_id, number = 0;
-	int identify = 0, refine = 0, attr = 0;
-	int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
-	nullpo_retr(-1, sd);
+	struct item item_tmp;
+	struct item_data *item_data;
+	char item_name[100];
+	int item_id, number = 0, bound = 0;
+	int identify = 0, refine = 0, attr = 0;
+	int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
+	nullpo_retr(-1, sd);
 
 	memset(item_name, '\0', sizeof(item_name));
 
@@ -1248,51 +1302,77 @@
 
 	item_id = 0;
 	if((item_data = itemdb_searchname(item_name)) != NULL ||
-	   (item_data = itemdb_exists(atoi(item_name))) != NULL)
-		item_id = item_data->nameid;
-
-	if (item_id > 500) {
-		int flag = 0;
-		int loop, get_count, i;
-		loop = 1;
-		get_count = number;
-		if(item_data->type == IT_WEAPON || item_data->type == IT_ARMOR ||
-		   item_data->type == IT_PETEGG || item_data->type == IT_PETARMOR) {
-			loop = number;
-			get_count = 1;
-			if(item_data->type == IT_PETEGG) {
-				identify = 1;
-				refine = 0;
-			}
-			if(item_data->type == IT_PETARMOR)
-				refine = 0;
-			if(refine > MAX_REFINE)
-				refine = MAX_REFINE;
-		} else {
-			identify = 1;
-			refine = attr = 0;
-		}
-		for(i = 0; i < loop; i++) {
-			memset(&item_tmp, 0, sizeof(item_tmp));
-			item_tmp.nameid = item_id;
-			item_tmp.identify = identify;
+	    (item_data = itemdb_exists(atoi(item_name))) != NULL)
+		item_id = item_data->nameid;
+
+	if( item_id > 500 )
+	{
+		int flag = 0;
+		int loop, get_count, i;
+
+		if( !strcmpi(command+1,"bounditem2") )
+			bound = 1;
+
+		if( !itemdb_isstackable2(item_data) )
+		{
+			if( bound && (item_data->type == IT_PETEGG || item_data->type == IT_PETARMOR) )
+			{
+				clif_displaymessage(fd, "Cannot create bounded pet eggs or pet armors.");
+				return -1;
+			}
+
+			loop = number;
+			get_count = 1;
+			if( item_data->type == IT_PETEGG )
+			{
+				identify = 1;
+				refine = 0;
+			}
+			if( item_data->type == IT_PETARMOR )
+				refine = 0;
+			if( refine > MAX_REFINE )
+				refine = MAX_REFINE;
+		}
+		else
+		{
+			if( bound )
+			{
+				clif_displaymessage(fd, "Cannot create bounded stackable items.");
+				return -1;
+			}
+
+			loop = 1;
+			get_count = number;
+			identify = 1;
+			refine = attr = 0;
+		}
+
+		for( i = 0; i < loop; i++ )
+		{
+			memset(&item_tmp, 0, sizeof(item_tmp));
+			item_tmp.nameid = item_id;
+			item_tmp.identify = identify;
 			item_tmp.refine = refine;
 			item_tmp.attribute = attr;
 			item_tmp.card[0] = c1;
-			item_tmp.card[1] = c2;
-			item_tmp.card[2] = c3;
-			item_tmp.card[3] = c4;
-			if((flag = pc_additem(sd, &item_tmp, get_count, LOG_TYPE_COMMAND)))
-				clif_additem(sd, 0, 0, flag);
-		}
+			item_tmp.card[1] = c2;
+			item_tmp.card[2] = c3;
+			item_tmp.card[3] = c4;
+			item_tmp.bound = bound;
+
+			if( (flag = pc_additem(sd, &item_tmp, get_count,LOG_TYPE_COMMAND)) )
+				clif_additem(sd, 0, 0, flag);
+		}
+
+		if (flag == 0)
+			clif_displaymessage(fd, msg_txt(18)); // Item created.
+	}
+	else
+	{
+		clif_displaymessage(fd, msg_txt(19)); // Invalid item ID or name.
+		return -1;
+	}
 
-		if(flag == 0)
-			clif_displaymessage(fd, msg_txt(18)); // Item created.
-	} else {
-		clif_displaymessage(fd, msg_txt(19)); // Invalid item ID or name.
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -1546,12 +1626,14 @@
 /*==========================================
  *
  *------------------------------------------*/
-static int atcommand_pvpon_sub(struct block_list *bl,va_list ap)
-{
-	TBL_PC *sd = (TBL_PC *)bl;
-	if(sd->pvp_timer == INVALID_TIMER) {
-		sd->pvp_timer = add_timer(gettick() + 200, pc_calc_pvprank_timer, sd->bl.id, 0);
-		sd->pvp_rank = 0;
+static int atcommand_pvpon_sub(struct block_list *bl,va_list ap)
+{
+	TBL_PC* sd = (TBL_PC*)bl;
+	if (sd->state.pvpmode)
+		pc_pvpmodeoff(sd, 1, 1);
+	if (sd->pvp_timer == INVALID_TIMER) {
+		sd->pvp_timer = add_timer(gettick() + 200, pc_calc_pvprank_timer, sd->bl.id, 0);
+		sd->pvp_rank = 0;
 		sd->pvp_lastusers = 0;
 		sd->pvp_point = 5;
 		sd->pvp_won = 0;
@@ -1796,12 +1878,18 @@
 
 	if(map[sd->bl.m].flag.nogo && !pc_has_permission(sd, PC_PERM_WARP_ANYWHERE)) {
 		clif_displaymessage(sd->fd,msg_txt(995)); // You cannot use @go on this map.
-		return 0;
-	}
-
-	memset(map_name, '\0', sizeof(map_name));
-	memset(atcmd_output, '\0', sizeof(atcmd_output));
-
+		return 0;
+	}
+
+	if( battle_config.pvpmode_nowarp_cmd && sd->state.pvpmode )
+	{
+		clif_displaymessage(sd->fd,"You can not use @go while on PVP Mode.");
+		return -1;
+	}
+ 
+	memset(map_name, '\0', sizeof(map_name));
+	memset(atcmd_output, '\0', sizeof(atcmd_output));
+
 	// get the number
 	town = atoi(message);
 
@@ -2115,14 +2203,14 @@
 		return -1;
 	}
 
-	refine = cap_value(refine, -MAX_REFINE, MAX_REFINE);
-
-	count = 0;
-	for(j = 0; j < EQI_MAX-1; j++) {
-		if((i = sd->equip_index[j]) < 0)
+	refine = cap_value(refine, -MAX_REFINE, MAX_REFINE);
+
+	count = 0;
+	for (j = 0; j < EQI_MAX_BONUS; j++) {
+		if ((i = sd->equip_index[j]) < 0)
+			continue;
+		if(j == EQI_HAND_R && sd->equip_index[EQI_HAND_L] == i)
 			continue;
-		if(j == EQI_HAND_R && sd->equip_index[EQI_HAND_L] == i)
-			continue;
 		if(j == EQI_HEAD_MID && sd->equip_index[EQI_HEAD_LOW] == i)
 			continue;
 		if(j == EQI_HEAD_TOP && (sd->equip_index[EQI_HEAD_MID] == i || sd->equip_index[EQI_HEAD_LOW] == i))
@@ -3313,37 +3401,47 @@
 }
 /*==========================================
  *
- *------------------------------------------*/
-ACMD_FUNC(agitstart)
-{
-	nullpo_retr(-1, sd);
-	if(agit_flag == 1) {
-		clif_displaymessage(fd, msg_txt(73)); // War of Emperium is currently in progress.
-		return -1;
-	}
+ *------------------------------------------*/
+ACMD_FUNC(agitstart)
+{
+	int i;
+
+	nullpo_retr(-1, sd);
+	if (agit_flag == 1) {
+		clif_displaymessage(fd, msg_txt(73)); // War of Emperium is currently in progress.
+		return -1;
+	}
+
+	if( (i = atoi(message)) > 0 )
+		woe_set = i;
+
+	agit_flag = 1;
+	guild_agit_start();
+	clif_displaymessage(fd, msg_txt(72)); // War of Emperium has been initiated.
 
-	agit_flag = 1;
-	guild_agit_start();
-	clif_displaymessage(fd, msg_txt(72)); // War of Emperium has been initiated.
-
 	return 0;
 }
 
 /*==========================================
  *
- *------------------------------------------*/
-ACMD_FUNC(agitstart2)
-{
-	nullpo_retr(-1, sd);
-	if(agit2_flag == 1) {
-		clif_displaymessage(fd, msg_txt(404)); // "War of Emperium SE is currently in progress."
-		return -1;
-	}
+ *------------------------------------------*/
+ACMD_FUNC(agitstart2)
+{
+	int i;
+
+	nullpo_retr(-1, sd);
+	if (agit2_flag == 1) {
+		clif_displaymessage(fd, msg_txt(404)); // "War of Emperium SE is currently in progress."
+		return -1;
+	}
+
+	if( (i = atoi(message)) > 0 )
+		woe_set = i;
+
+	agit2_flag = 1;
+	guild_agit2_start();
+	clif_displaymessage(fd, msg_txt(403)); // "War of Emperium SE has been initiated."
 
-	agit2_flag = 1;
-	guild_agit2_start();
-	clif_displaymessage(fd, msg_txt(403)); // "War of Emperium SE has been initiated."
-
 	return 0;
 }
 
@@ -3355,14 +3453,15 @@
 	nullpo_retr(-1, sd);
 	if(agit_flag == 0) {
 		clif_displaymessage(fd, msg_txt(75)); // War of Emperium is currently not in progress.
-		return -1;
-	}
-
-	agit_flag = 0;
-	guild_agit_end();
-	clif_displaymessage(fd, msg_txt(74)); // War of Emperium has been ended.
-
-	return 0;
+		return -1;
+	}
+
+	guild_agit_end();
+	agit_flag = 0;
+	woe_set = 0;
+	clif_displaymessage(fd, msg_txt(74)); // War of Emperium has been ended.
+
+	return 0;
 }
 
 /*==========================================
@@ -3373,14 +3472,15 @@
 	nullpo_retr(-1, sd);
 	if(agit2_flag == 0) {
 		clif_displaymessage(fd, msg_txt(406)); // "War of Emperium SE is currently not in progress."
-		return -1;
-	}
-
-	agit2_flag = 0;
-	guild_agit2_end();
-	clif_displaymessage(fd, msg_txt(405)); // "War of Emperium SE has been ended."
-
-	return 0;
+		return -1;
+	}
+
+	guild_agit2_end();
+	agit2_flag = 0;
+	woe_set = 0;
+	clif_displaymessage(fd, msg_txt(405)); // "War of Emperium SE has been ended."
+
+	return 0;
 }
 
 /*==========================================
@@ -3662,12 +3762,14 @@
 ACMD_FUNC(reloadbattleconf)
 {
 	struct Battle_Config prev_config;
-	memcpy(&prev_config, &battle_config, sizeof(prev_config));
-
-	battle_config_read(BATTLE_CONF_FILENAME);
-
-	if(prev_config.item_rate_mvp          != battle_config.item_rate_mvp
-	   ||  prev_config.item_rate_common       != battle_config.item_rate_common
+	memcpy(&prev_config, &battle_config, sizeof(prev_config));
+
+	battle_config_read(BATTLE_CONF_FILENAME);
+	// It can cause serius problems if we change this setting while server is UP.
+	battle_config.anti_mayapurple_hack = prev_config.anti_mayapurple_hack;
+
+	if( prev_config.item_rate_mvp          != battle_config.item_rate_mvp
+	||  prev_config.item_rate_common       != battle_config.item_rate_common
 	   ||  prev_config.item_rate_common_boss  != battle_config.item_rate_common_boss
 	   ||  prev_config.item_rate_card         != battle_config.item_rate_card
 	   ||  prev_config.item_rate_card_boss    != battle_config.item_rate_card_boss
@@ -3821,21 +3923,34 @@
 	if(map[m_id].flag.pvp_nightmaredrop)
 		strcat(atcmd_output, msg_txt(1050)); // NightmareDrop |
 	if(map[m_id].flag.pvp_nocalcrank)
-		strcat(atcmd_output, msg_txt(1051)); // NoCalcRank |
-	clif_displaymessage(fd, atcmd_output);
-
-	strcpy(atcmd_output,msg_txt(1052)); // GvG Flags:
-	if(map[m_id].flag.gvg)
-		strcat(atcmd_output, msg_txt(1053)); // GvG ON |
+		strcat(atcmd_output, msg_txt(1051)); // NoCalcRank |
+	clif_displaymessage(fd, atcmd_output);
+
+	if (map[m_id].flag.pvp_event)
+	{
+		sprintf(atcmd_output,"PVP Event Flag: x1 %d | x2 %d | y1 %d | y2 %d", map[m_id].pvpe_x1, map[m_id].pvpe_x2, map[m_id].pvpe_y1, map[m_id].pvpe_y2);
+		clif_displaymessage(fd, atcmd_output);
+	}
+
+	strcpy(atcmd_output,msg_txt(1052)); // GvG Flags:
+	if (map[m_id].flag.gvg)
+		strcat(atcmd_output, msg_txt(1053)); // GvG ON |
 	if(map[m_id].flag.gvg_dungeon)
 		strcat(atcmd_output, msg_txt(1054)); // GvG Dungeon |
 	if(map[m_id].flag.gvg_castle)
-		strcat(atcmd_output, msg_txt(1055)); // GvG Castle |
-	if(map[m_id].flag.gvg_noparty)
-		strcat(atcmd_output, msg_txt(1056)); // NoParty |
-	clif_displaymessage(fd, atcmd_output);
-
-	strcpy(atcmd_output,msg_txt(1057)); // Teleport Flags:
+		strcat(atcmd_output, msg_txt(1055)); // GvG Castle |
+	if (map[m_id].flag.gvg_noparty)
+		strcat(atcmd_output, msg_txt(1056)); // NoParty |
+	if (map[m_id].flag.woe_set)
+	{
+		char output[64];
+		sprintf(output,"WoE Set %d | ", map[m_id].flag.woe_set);
+		strcat(atcmd_output, output);
+	}
+
+	clif_displaymessage(fd, atcmd_output);
+
+	strcpy(atcmd_output,msg_txt(1057)); // Teleport Flags:
 	if(map[m_id].flag.noteleport)
 		strcat(atcmd_output, msg_txt(1058)); // NoTeleport |
 	if(map[m_id].flag.monster_noteleport)
@@ -3847,12 +3962,14 @@
 	if(map[m_id].flag.noreturn)
 		strcat(atcmd_output, msg_txt(1062)); // NoReturn |
 	if(map[m_id].flag.nogo)
-		strcat(atcmd_output, msg_txt(1063)); // NoGo |
-	if(map[m_id].flag.nomemo)
-		strcat(atcmd_output, msg_txt(1064)); // NoMemo |
-	clif_displaymessage(fd, atcmd_output);
-
-	sprintf(atcmd_output, msg_txt(1065),  // No Exp Penalty: %s | No Zeny Penalty: %s
+		strcat(atcmd_output, msg_txt(1063)); // NoGo |
+	if (map[m_id].flag.nomemo)
+		strcat(atcmd_output, msg_txt(1064)); // NoMemo |
+	if (map[m_id].flag.blocked)
+		strcat(atcmd_output, "Blocked | ");
+	clif_displaymessage(fd, atcmd_output);
+
+	sprintf(atcmd_output, msg_txt(1065),  // No Exp Penalty: %s | No Zeny Penalty: %s
 	        (map[m_id].flag.noexppenalty) ? msg_txt(1066) : msg_txt(1067), (map[m_id].flag.nozenypenalty) ? msg_txt(1066) : msg_txt(1067)); // On / Off
 	clif_displaymessage(fd, atcmd_output);
 
@@ -4765,13 +4882,16 @@
 		clif_displaymessage(fd, msg_txt(123)); // Monster/NPC name/id not found.
 		return -1;
 	}
-
-	iter = mapit_getallusers();
-	for(pl_sd = (TBL_PC *)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC *)mapit_next(iter))
-		pc_disguise(pl_sd, mob_id);
-	mapit_free(iter);
-
-	clif_displaymessage(fd, msg_txt(122)); // Disguise applied.
+
+	iter = mapit_getallusers();
+	for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+	{
+		if( !pc_isriding(pl_sd) )
+			pc_disguise(pl_sd, mob_id);
+	}
+	mapit_free(iter);
+
+	clif_displaymessage(fd, msg_txt(122)); // Disguise applied.
 	return 0;
 }
 
@@ -5355,13 +5475,37 @@
 	for(i = 0; i < found; i++) { /* partials */
 		clif_displaymessage(fd, partials[i]);
 	}
-	
-	return 0;
-}
-
-/*==========================================
- * @useskill by [MouseJstr]
- * A way of using skills without having to find them in the skills menu
+
+	return 0;
+}
+/*==========================================
+ * @blockskill
+ * Block/UnBlock Skill Usage
+ *------------------------------------------*/
+ACMD_FUNC(blockskill)
+{
+	int idx = atoi(message);
+	if( (idx = skill_get_index(idx)) > 0 )
+	{
+		skill_db[idx].blocked = !skill_db[idx].blocked;
+		if( skill_db[idx].blocked )
+			sprintf(atcmd_output, "Blocked usage of Skill %d: %s", idx, skill_db[idx].desc);
+		else
+			sprintf(atcmd_output, "Allowed usage of Skill %d: %s", idx, skill_db[idx].desc);
+
+		clif_displaymessage(fd, atcmd_output);
+		return 0;
+	}
+	else
+	{
+		clif_displaymessage(fd, "Skill not found...");
+		return -1;
+	}
+}
+
+/*==========================================
+ * @useskill by [MouseJstr]
+ * A way of using skills without having to find them in the skills menu
  *------------------------------------------*/
 ACMD_FUNC(useskill)
 {
@@ -5492,13 +5636,13 @@
 	item_tmp.card[0] = 255;
 	item_tmp.card[2] = sd->status.partner_id;
 	item_tmp.card[3] = sd->status.partner_id >> 16;
-
-	if((flag = pc_additem(sd,&item_tmp,1,LOG_TYPE_COMMAND))) {
-		clif_additem(sd,0,0,flag);
-		map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-	}
-}
-
+
+	if((flag = pc_additem(sd,&item_tmp,1,LOG_TYPE_COMMAND))) {
+		clif_additem(sd,0,0,flag);
+		map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,sd->status.guild_id,0);
+	}
+}
+
 /*==========================================
  * @marry by [MouseJstr], fixed by Lupus
  * Marry two players
@@ -5632,18 +5776,33 @@
 
 	if(!message[0]) {
 		clif_displaymessage(fd, msg_txt(1183)); // Usage: @changegm <guild_member_name>
-		return -1;
-	}
+		return -1;
+	}
+
+	if( agit_flag || agit2_flag ) // No dejar cambiar de GM en WOE [Tab]
+	{
+		clif_displaymessage(fd, "You cannot ChangeGM when War of Emperium is active.");
+		return -1;
+	}
+
+	if((pl_sd=map_nick2sd((char *) message)) == NULL || pl_sd->status.guild_id != sd->status.guild_id) {
+		clif_displaymessage(fd, msg_txt(1184)); // Target character must be online and be a guild member.
+		return -1;
+	}
+
+	if( !battle_config.super_woe_enable && battle_config.at_changegm_cost && sd->status.zeny < battle_config.at_changegm_cost )
+	{
+		memset(atcmd_output, '\0', sizeof(atcmd_output));
+
+		sprintf(atcmd_output, "You don't have enough zeny to transfer GM. Cost %d zeny.", battle_config.at_changegm_cost);
+		clif_displaymessage(fd, atcmd_output);
+		return -1;
+	}
+
+	guild_gm_change(sd->status.guild_id, pl_sd);
+	return 0;
+}
 
-	if((pl_sd=map_nick2sd((char *) message)) == NULL || pl_sd->status.guild_id != sd->status.guild_id) {
-		clif_displaymessage(fd, msg_txt(1184)); // Target character must be online and be a guild member.
-		return -1;
-	}
-
-	guild_gm_change(sd->status.guild_id, pl_sd);
-	return 0;
-}
-
 /*==========================================
  * @changeleader by Skotlex
  * Changes the leader of a party.
@@ -5703,129 +5862,174 @@
 	return 0;
 }
 
-/*==========================================
- * @autoloot by Upa-Kun
- * Turns on/off AutoLoot for a specific player
- *------------------------------------------*/
-ACMD_FUNC(autoloot)
-{
-	int rate;
-	nullpo_retr(-1, sd);
-	// autoloot command without value
-	if(!message || !*message) {
-		if(sd->state.autoloot)
-			rate = 0;
-		else
-			rate = 10000;
-	} else {
-		double drate;
-		drate = atof(message);
-		rate = (int)(drate*100);
-	}
-	if(rate < 0) rate = 0;
-	if(rate > 10000) rate = 10000;
-
-	sd->state.autoloot = rate;
-	if(sd->state.autoloot) {
-		snprintf(atcmd_output, sizeof atcmd_output, msg_txt(1187),((double)sd->state.autoloot)/100.); // Autolooting items with drop rates of %0.02f%% and below.
-		clif_displaymessage(fd, atcmd_output);
-	} else
-		clif_displaymessage(fd, msg_txt(1188)); // Autoloot is now off.
-
-	return 0;
+/*==========================================
+ * @autoloot by Zephyrus
+ *------------------------------------------*/
+ACMD_FUNC(autoloot)
+{
+	int p = 0;
+	char subcmd[100], data[100];
+	memset(subcmd, '\0', sizeof(subcmd));
+	memset(data, '\0', sizeof(data));
+
+	if( !message || !*message )
+	{ // Normal Autoloot usage
+		if( sd->aloot.rate )
+		{
+			sd->aloot.rate = 0;
+			clif_displaymessage(fd, msg_txt(877));
+		}
+		else
+		{
+			sd->aloot.rate = 10000;
+			clif_displaymessage(fd, msg_txt(878));
+		}
+
+		clif_displaymessage(fd, msg_txt(879));
+		return 0;
+	}
+
+	if( (p = sscanf(message, "%99s %99[^\n]", subcmd, data)) < 1 )
+	{
+		clif_displaymessage(fd, msg_txt(879));
+		return -1;
+	}
+
+	if( !strcmp(subcmd, "rate") )
+	{ // Set autoloot rate value
+		int rate;
+		if( p < 2 )
+		{
+			clif_displaymessage(fd, msg_txt(880));
+			return -1;
+		}
+
+		rate = (int)(atof(data) * 100);
+		sd->aloot.rate = cap_value(rate, 0, 10000);
+
+		if( sd->aloot.rate )
+		{
+			snprintf(atcmd_output, sizeof(atcmd_output), msg_txt(881),((double)sd->aloot.rate)/100.);
+			clif_displaymessage(fd, atcmd_output);
+		}
+		else
+			clif_displaymessage(fd, msg_txt(877));
+	}
+	else if( !strcmp(subcmd, "clear") )
+	{
+		memset(&sd->aloot, 0, sizeof(sd->aloot));
+		clif_displaymessage(fd, msg_txt(882));
+	}
+	else if( !strcmp(subcmd, "info") )
+	{
+		int i, c = 0;
+		struct item_data *it = NULL;
+
+		snprintf(atcmd_output, sizeof(atcmd_output), msg_txt(881),((double)sd->aloot.rate)/100.);
+		clif_displaymessage(fd, atcmd_output);
+		for( i = 0; i < MAX_AUTOLOOTID; i++ )
+		{
+			if( sd->aloot.nameid[i] == 0 || (it = itemdb_exists(sd->aloot.nameid[i])) == NULL )
+				continue;
+
+			snprintf(atcmd_output, sizeof(atcmd_output), msg_txt(883), it->jname, it->nameid);
+			clif_displaymessage(fd, atcmd_output);
+			c++;
+		}
+
+		snprintf(atcmd_output, sizeof(atcmd_output), msg_txt(884), c, MAX_AUTOLOOTID);
+		clif_displaymessage(fd, atcmd_output);
+	}
+	else if( !strcmp(subcmd, "item") )
+	{
+		int i, j;
+		struct item_data *it = NULL;
+
+		if( p < 2 )
+		{
+			clif_displaymessage(fd, msg_txt(885));
+			return -1;
+		}
+
+		ARR_FIND(0, MAX_AUTOLOOTID, i, sd->aloot.nameid[i] == 0);
+		if( i == MAX_AUTOLOOTID )
+		{
+			clif_displaymessage(fd, msg_txt(886));
+			return -1;
+		}
+
+		if( (it = itemdb_exists(atoi(data))) == NULL )
+			it = itemdb_searchname(data);
+
+		if( !it )
+		{
+			clif_displaymessage(fd, msg_txt(885));
+			return -1;
+		}
+
+		ARR_FIND(0, MAX_AUTOLOOTID, j, sd->aloot.nameid[i] == it->nameid);
+		if( j < MAX_AUTOLOOTID )
+		{
+			clif_displaymessage(fd, msg_txt(887));
+			return -1;
+		}
+
+		sd->aloot.nameid[i] = it->nameid;
+		snprintf(atcmd_output, sizeof(atcmd_output), msg_txt(883), it->jname, it->nameid);
+		clif_displaymessage(fd, atcmd_output);
+	}
+	else if( !strcmp(subcmd, "help") )
+	{
+		clif_displaymessage(fd, msg_txt(888));
+		clif_displaymessage(fd, msg_txt(889));
+		clif_displaymessage(fd, msg_txt(890));
+		clif_displaymessage(fd, msg_txt(891));
+	}
+	else
+	{
+		clif_displaymessage(fd, msg_txt(879));
+		return -1;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * @ddrop
+ * Turns on/off Drop information display
+ *------------------------------------------*/
+ACMD_FUNC(displaydrop)
+{
+	int rate;
+	double drate;
+	nullpo_retr(-1, sd);
+
+	if( !message || !*message )
+	{
+		if (sd->state.displaydrop)
+			rate = 0;
+		else
+			rate = 10000;
+	}
+	else
+	{
+		drate = atof(message);
+		rate = (int)(drate*100);
+	}
+
+	rate = cap_value(rate,0,10000);
+	sd->state.displaydrop = rate;
+
+	if( sd->state.displaydrop )
+	{
+		snprintf(atcmd_output, sizeof atcmd_output, "Displaying information about dropped items with %0.02f%% drop rate and below.",((double)sd->state.displaydrop)/100.);
+		clif_displaymessage(fd, atcmd_output);
+	}
+	else
+		clif_displaymessage(fd, "Information about dropped items is no longer displayed.");
+
+	return 0;
 }
-
-/*==========================================
- * @alootid
- *------------------------------------------*/
-ACMD_FUNC(autolootitem)
-{
-	struct item_data *item_data = NULL;
-	int i;
-	int action = 3; // 1=add, 2=remove, 3=help+list (default), 4=reset
-
-	if(message && *message) {
-		if(message[0] == '+') {
-			message++;
-			action = 1;
-		} else if(message[0] == '-') {
-			message++;
-			action = 2;
-		} else if(!strcmp(message,"reset"))
-			action = 4;
-	}
-
-	if(action < 3) { // add or remove
-		if((item_data = itemdb_exists(atoi(message))) == NULL)
-			item_data = itemdb_searchname(message);
-		if(!item_data) {
-			// No items founds in the DB with Id or Name
-			clif_displaymessage(fd, msg_txt(1189)); // Item not found.
-			return -1;
-		}
-	}
-
-	switch(action) {
-		case 1:
-			ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] == item_data->nameid);
-			if(i != AUTOLOOTITEM_SIZE) {
-				clif_displaymessage(fd, msg_txt(1190)); // You're already autolooting this item.
-				return -1;
-			}
-			ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] == 0);
-			if(i == AUTOLOOTITEM_SIZE) {
-				clif_displaymessage(fd, msg_txt(1191)); // Your autolootitem list is full. Remove some items first with @autolootid -<item name or ID>.
-				return -1;
-			}
-			sd->state.autolootid[i] = item_data->nameid; // Autoloot Activated
-			sprintf(atcmd_output, msg_txt(1192), item_data->name, item_data->jname, item_data->nameid); // Autolooting item: '%s'/'%s' {%d}
-			clif_displaymessage(fd, atcmd_output);
-			sd->state.autolooting = 1;
-			break;
-		case 2:
-			ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] == item_data->nameid);
-			if(i == AUTOLOOTITEM_SIZE) {
-				clif_displaymessage(fd, msg_txt(1193)); // You're currently not autolooting this item.
-				return -1;
-			}
-			sd->state.autolootid[i] = 0;
-			sprintf(atcmd_output, msg_txt(1194), item_data->name, item_data->jname, item_data->nameid); // Removed item: '%s'/'%s' {%d} from your autolootitem list.
-			clif_displaymessage(fd, atcmd_output);
-			ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] != 0);
-			if(i == AUTOLOOTITEM_SIZE) {
-				sd->state.autolooting = 0;
-			}
-			break;
-		case 3:
-			sprintf(atcmd_output, msg_txt(1195), AUTOLOOTITEM_SIZE); // You can have %d items on your autolootitem list.
-			clif_displaymessage(fd, atcmd_output);
-			clif_displaymessage(fd, msg_txt(1196)); // To add an item to the list, use "@alootid +<item name or ID>". To remove an item, use "@alootid -<item name or ID>".
-			clif_displaymessage(fd, msg_txt(1197)); // "@alootid reset" will clear your autolootitem list.
-			ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] != 0);
-			if(i == AUTOLOOTITEM_SIZE) {
-				clif_displaymessage(fd, msg_txt(1198)); // Your autolootitem list is empty.
-			} else {
-				clif_displaymessage(fd, msg_txt(1199)); // Items on your autolootitem list:
-				for(i = 0; i < AUTOLOOTITEM_SIZE; i++) {
-					if(sd->state.autolootid[i] == 0)
-						continue;
-					if(!(item_data = itemdb_exists(sd->state.autolootid[i]))) {
-						ShowDebug("Nao existe item %d na lista de autolootitem (account_id: %d, char_id: %d)", sd->state.autolootid[i], sd->status.account_id, sd->status.char_id);
-						continue;
-					}
-					sprintf(atcmd_output, "'%s'/'%s' {%d}", item_data->name, item_data->jname, item_data->nameid);
-					clif_displaymessage(fd, atcmd_output);
-				}
-			}
-			break;
-		case 4:
-			memset(sd->state.autolootid, 0, sizeof(sd->state.autolootid));
-			clif_displaymessage(fd, msg_txt(1200)); // Your autolootitem list has been reset.
-			sd->state.autolooting = 0;
-			break;
-	}
-	return 0;
-}
 /**
  * No longer available, keeping here just in case it's back someday. [Ind]
  **/
@@ -6522,12 +6726,48 @@
 	for(iter_sd = (TBL_PC *)mapit_first(iter); mapit_exists(iter); iter_sd = (TBL_PC *)mapit_next(iter))
 		clif_refresh(iter_sd);
 	mapit_free(iter);
-	return 0;
-}
-
-/*==========================================
- * @identify
- * => GM's magnifier.
+	return 0;
+}
+
+ACMD_FUNC(autorefresh)
+{
+	int time; // Default Min Value.
+	nullpo_retr(-1,sd);
+
+	if( !message || !*message )
+		clif_displaymessage(fd,"Please, enter a value between 30 to 300 seconds or off to disable it. Usage @autorefresh <seconds/off>");
+	else if( !strcmpi(message,"off") )
+	{
+		if( sd->sc.data[SC_AUTOREFRESH] )
+		{
+			status_change_end(&sd->bl,SC_AUTOREFRESH,INVALID_TIMER);
+			clif_displaymessage(fd,"-- AutoRefresh disabled --");
+			return 0;
+		}
+
+		clif_displaymessage(fd,"AutoRefresh is not Enable.");
+	}
+	else if( (time = atoi(message)) < 30 || time > 300 )
+		clif_displaymessage(fd,"Please, enter a value between 30 to 300 seconds");
+	else
+	{
+		if( sd->sc.data[SC_AUTOREFRESH] )
+			sprintf(atcmd_output,"Adjusting AutoRefresh to execute each %d seconds.",time);
+		else
+			sprintf(atcmd_output,"Starting AutoRefresh to execute each %d seconds.",time);
+		
+		clif_displaymessage(fd,atcmd_output);
+		sc_start(NULL,&sd->bl,SC_AUTOREFRESH,100,time,INVALID_TIMER);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+/*==========================================
+ * @identify
+ * => GM's magnifier.
  *------------------------------------------*/
 ACMD_FUNC(identify)
 {
@@ -6613,12 +6853,16 @@
  *------------------------------------------*/
 ACMD_FUNC(mobinfo)
 {
-	unsigned char msize[3][7] = {"Small", "Medium", "Large"};
-	unsigned char mrace[12][11] = {"Formless", "Undead", "Beast", "Plant", "Insect", "Fish", "Demon", "Demi-Human", "Angel", "Dragon", "Boss", "Non-Boss"};
-	unsigned char melement[10][8] = {"Neutral", "Water", "Earth", "Fire", "Wind", "Poison", "Holy", "Dark", "Ghost", "Undead"};
-	char atcmd_output2[CHAT_SIZE_MAX];
-	struct item_data *item_data;
-	struct mob_db *mob, *mob_array[MAX_SEARCH];
+	unsigned char msize[3][7] = {"Small", "Medium", "Large"};
+	unsigned char mrace[12][11] = {"Formless", "Undead", "Beast", "Plant", "Insect", "Fish", "Demon", "Demi-Human", "Angel", "Dragon", "Boss", "Non-Boss"};
+	unsigned char melement[10][8] = {"Neutral", "Water", "Earth", "Fire", "Wind", "Poison", "Holy", "Dark", "Ghost", "Undead"};
+
+	unsigned int mmodei[15] = { MD_CANMOVE, MD_LOOTER, MD_AGGRESSIVE, MD_ASSIST, MD_CASTSENSOR_IDLE, MD_BOSS, MD_PLANT, MD_CANATTACK, MD_DETECTOR, MD_CASTSENSOR_CHASE, MD_CHANGECHASE, MD_ANGRY, MD_CHANGETARGET_MELEE, MD_CHANGETARGET_CHASE, MD_TARGETWEAK };
+	unsigned char mmode[15][20] = {"Can Move", "Looter", "Aggresive", "Assist", "Cast Sensor Idle", "Boss", "Plant", "Can Attack", "Detector", "Cast Sensor Chase", "Change Chase", "Angry", "Change Target Melee", "Change Target Chase", "Target Weak"};
+
+	char atcmd_output2[CHAT_SIZE_MAX];
+	struct item_data *item_data;
+	struct mob_db *mob, *mob_array[MAX_SEARCH];
 	int count;
 	int i, j, k;
 	unsigned int base_exp, job_exp;
@@ -6665,18 +6909,41 @@
 		else
 			sprintf(atcmd_output, msg_txt(1241), mob->name, mob->jname, mob->sprite, mob->vd.class_); // Monster: '%s'/'%s'/'%s' (%d)
 		clif_displaymessage(fd, atcmd_output);
-		sprintf(atcmd_output, msg_txt(1242), mob->lv, mob->status.max_hp, base_exp, job_exp, MOB_HIT(mob), MOB_FLEE(mob)); //  Lv:%d  HP:%d  Base EXP:%u  Job EXP:%u  HIT:%d  FLEE:%d
+		sprintf(atcmd_output, msg_txt(1242), mob->lv, mob->status.max_hp, mob->base_exp, mob->job_exp,MOB_HIT(mob), MOB_FLEE(mob)); //  Lv:%d  HP:%d  Base EXP:%u  Job EXP:%u  HIT:%d  FLEE:%d
 		clif_displaymessage(fd, atcmd_output);
-		sprintf(atcmd_output, msg_txt(1243), //  DEF:%d  MDEF:%d  STR:%d  AGI:%d  VIT:%d  INT:%d  DEX:%d  LUK:%d
-		        mob->status.def, mob->status.mdef,mob->status.str, mob->status.agi,
-		        mob->status.vit, mob->status.int_, mob->status.dex, mob->status.luk);
+		sprintf(atcmd_output, msg_txt(1243),
+			mob->status.def, mob->status.def2, mob->status.mdef, mob->status.mdef2, mob->status.str, mob->status.agi,
+			mob->status.vit, mob->status.int_, mob->status.dex, mob->status.luk);
 		clif_displaymessage(fd, atcmd_output);
 
 		sprintf(atcmd_output, msg_txt(1244), //  ATK:%d~%d  Range:%d~%d~%d  Size:%s  Race: %s  Element: %s (Lv:%d)
 		        mob->status.rhw.atk, mob->status.rhw.atk2, mob->status.rhw.range,
-		        mob->range2 , mob->range3, msize[mob->status.size],
-		        mrace[mob->status.race], melement[mob->status.def_ele], mob->status.ele_lv);
+			mob->range2 , mob->range3, msize[mob->status.size],
+			mrace[mob->status.race], melement[mob->status.def_ele], mob->status.ele_lv);
 		clif_displaymessage(fd, atcmd_output);
+		// Extra Settings
+		if( mob->ffa )
+			clif_displaymessage(fd, "- Free For All Monster");
+		if( mob->hunting )
+			clif_displaymessage(fd, "- Hunting Mission Enable Monster");
+		// modes
+		clif_displaymessage(fd, " Modes:");
+		strcpy(atcmd_output, " ");
+		j = 0;
+		for( i = 0; i < 15; i++ )
+		{
+			if( mob->status.mode&mmodei[i] )
+			{
+				sprintf(atcmd_output2, " - %s", mmode[i]);
+				strcat(atcmd_output, atcmd_output2);
+				if( ++j % 3 == 0 )
+				{
+					clif_displaymessage(fd, atcmd_output);
+					strcpy(atcmd_output, " ");
+				}
+			}
+		}
+		if( j % 3 != 0 ) clif_displaymessage(fd, atcmd_output);
 		// drops
 		clif_displaymessage(fd, msg_txt(1245)); //  Drops:
 		strcpy(atcmd_output, " ");
@@ -7152,16 +7419,17 @@
 		sprintf(atcmd_output, msg_txt(269), MAX_SEARCH, count); // Displaying first %d out of %d matches
 		clif_displaymessage(fd, atcmd_output);
 		count = MAX_SEARCH;
-	}
-	for(i = 0; i < count; i++) {
-		item_data = item_array[i];
-		sprintf(atcmd_output, msg_txt(1277), // Item: '%s'/'%s'[%d] (%d) Type: %s | Extra Effect: %s
-		        item_data->name,item_data->jname,item_data->slot,item_data->nameid,
-		        itemdb_typename(item_data->type),
-		        (item_data->script==NULL)? msg_txt(1278) : msg_txt(1279) // None / With script
-		       );
-		clif_displaymessage(fd, atcmd_output);
-
+	}
+	for (i = 0; i < count; i++) {
+		item_data = item_array[i];
+		sprintf(atcmd_output, msg_txt(1277),
+			item_data->name,item_data->jname,item_data->slot,item_data->nameid,
+			itemdb_typename(item_data->type),
+			(item_data->script==NULL)? msg_txt(1278) : msg_txt(1279), // None / With script
+			item_data->ancient ? "Yes" : "No"
+		);
+		clif_displaymessage(fd, atcmd_output);
+
 		sprintf(atcmd_output, msg_txt(1280), item_data->value_buy, item_data->value_sell, item_data->weight/10.);  // NPC Buy:%dz, Sell:%dz | Weight: %.1f
 		clif_displaymessage(fd, atcmd_output);
 
@@ -7215,7 +7483,7 @@
 			clif_displaymessage(fd, atcmd_output);
 
 			for(j=0; j < MAX_SEARCH && item_data->mob[j].chance > 0; j++) {
-				sprintf(atcmd_output, "- %s (%02.02f%%)", mob_db(item_data->mob[j].id)->jname, item_data->mob[j].chance/100.);
+				sprintf(atcmd_output, "- %s (%02.02f%%) %02.02f%% Base -", mob_db(item_data->mob[j].id)->jname, item_data->mob[j].chance/100., item_data->mob[j].bchance/100.);
 				clif_displaymessage(fd, atcmd_output);
 			}
 		}
@@ -7641,13 +7909,494 @@
 
 	sd->state.showdelay = 1;
 	clif_displaymessage(fd, msg_txt(1321)); // Skill delay failures are now shown.
-	return 0;
-}
-
-/*==========================================
- * Duel organizing functions [LuzZza]
- *
- * @duel [limit|nick] - create a duel
+	return 0;
+}
+
+ACMD_FUNC(showcast)
+{
+	sd->state.showcast = 1;
+	clif_displaymessage(fd, "Skill casting time will be show the next time.");
+
+	return 0;
+}
+
+ACMD_FUNC(showcastdelay)
+{
+	sd->state.showcastdelay = 1;
+	clif_displaymessage(fd, "Skill delay time will be show the next time.");
+
+	return 0;
+}
+
+/*==========================================
+ * Activar o desactivar modo Resident Evil. [Tab]
+ *------------------------------------------*/
+ACMD_FUNC(residente)
+{
+	int Rtype = 0;
+
+	nullpo_retr(-1, sd);
+
+	if (!message || !*message) {
+		if (map[sd->bl.m].flag.residentevil > 0)
+			map[sd->bl.m].flag.residentevil = 0;
+		else
+			map[sd->bl.m].flag.residentevil = 1; // Default is 1
+	} else {
+		if (sscanf(message,"%d", &Rtype) < 1) {
+			clif_displaymessage(fd, "Use @undeadmode <Type>. 0=OFF, 1=ON (Noexp Nodrop), 2=ON (Exp and Drop)");
+			return -1;
+		}
+
+		if (Rtype < 0) Rtype = 0; else if (Rtype > 2) Rtype = 2;
+
+		switch (Rtype) {
+			case 0:
+				map[sd->bl.m].flag.residentevil = 0;
+				break;
+			case 1:
+				map[sd->bl.m].flag.residentevil = 1;
+				break;
+			case 2:
+				map[sd->bl.m].flag.residentevil = 2;
+				break;
+		}
+	}
+
+	switch (map[sd->bl.m].flag.residentevil) {
+		case 0:
+			clif_displaymessage(fd, "INFO GM: Undead Mode OFF.");
+			break;
+		case 1:
+			clif_displaymessage(fd, "INFO GM: Undead Mode ON (No Exp no Drop).");
+			break;
+		case 2:
+			clif_displaymessage(fd, "INFO GM: Undead Mode ON (Exp and Drop).");
+			break;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Activar o desactivar modo contador muertos. [Tab]
+ *------------------------------------------*/
+ACMD_FUNC(contadormuertes)
+{
+	int cnt_var0 = 0, cnt_var1 = 0;
+	char mensaje[1024];
+	nullpo_retr(-1, sd);
+
+	if( !message || !*message || sscanf(message, "%d %d", &cnt_var0, &cnt_var1) < 1 || cnt_var0 < 0 || cnt_var1 < 0 )
+	{ //Defensa de Midgard XXX / YYY Ejercitos Invasores
+		if( map[sd->bl.m].flag.diecounter )
+		{
+			sprintf (mensaje, "[ Players %d / %d Monsters ]", map[sd->bl.m].pjmuertos, map[sd->bl.m].mobmuertos);
+			clif_broadcast(&sd->bl, mensaje, strlen(mensaje) + 1, 0, ALL_SAMEMAP);
+		}
+		else
+		{
+			clif_displaymessage(fd, "Kill Counter System (Players vs Mobs)");
+			clif_displaymessage(fd, "Usage @mapdeadcounter <Players Lives> <Mobs Lives>");
+			clif_displaymessage(fd, "Use only @mapdeadcounter to boradcast current status.");
+			clif_displaymessage(fd, "Max Lives limited to 20.000.");
+		}
+		return -1;
+	}
+
+	cnt_var0 = cap_value(cnt_var0, 1, 20000);
+	cnt_var1 = cap_value(cnt_var1, 1, 20000);
+
+	if( map[sd->bl.m].flag.diecounter && (cnt_var0 < 1 || cnt_var1 < 1) )
+	{
+		clif_displaymessage(fd, "Kill Counter System disable.");
+		map[sd->bl.m].flag.diecounter = 0;
+		map[sd->bl.m].pjmuertos = 0;
+		map[sd->bl.m].mobmuertos = 0;
+	}
+	else
+	{
+		clif_displaymessage(fd, "Kill Counter System Enable.");
+		map[sd->bl.m].flag.diecounter = 1;
+		map[sd->bl.m].pjmuertos = cnt_var0;
+		map[sd->bl.m].mobmuertos = cnt_var1;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Activar o desactivar penalty en mapa. [Tab]
+ *------------------------------------------*/
+ACMD_FUNC(exppenalty)
+{
+	nullpo_retr(-1, sd);
+
+	if (map[sd->bl.m].flag.noexppenalty) {
+		clif_displaymessage(fd, "Exp penalty enabled on the current Map.");
+		map[sd->bl.m].flag.noexppenalty = 0;
+	} else {
+		clif_displaymessage(fd, "Exp penalty disabled on the current Map.");
+		map[sd->bl.m].flag.noexppenalty = 1;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Comando para configurar bonus a gusto [Tab]
+ *------------------------------------------*/
+ACMD_FUNC(maspowerr)
+{
+	int masp_var0 = 0, masp_var1 = 0, masp_var2 = 0, masp_var3 = 0, masp_var4 = 0, masp_var5 = 0, masp_var6 = 0;
+	nullpo_retr(-1, sd);
+
+	if (!message || !*message || sscanf(message, "%d %d %d %d %d %d %d", &masp_var0, &masp_var1, &masp_var2, &masp_var3, &masp_var4, &masp_var5, &masp_var6) < 1 || masp_var0 < 0 || masp_var1 < 0 || masp_var2 < 0 || masp_var3 < 0 || masp_var4 < 0 || masp_var5 < 0  || masp_var6 < 0) {
+		clif_displaymessage(fd, "- Usage @power <Enable ? 0 = no 1 = yes> <str> <agi> <vit> <int> <dex> <luk>");
+		clif_displaymessage(fd, "- Max value for Stats is 3000.");
+		return -1;
+	}
+	if (masp_var0) { // Si es para activar... entonces...
+		sd->gm_power = 1;
+		clif_displaymessage(fd, "- Game Master Power Enable -");
+
+		sd->gm_stats[0] = cap_value(masp_var1, 0, 3000);
+		sd->gm_stats[1] = cap_value(masp_var2, 0, 3000);
+		sd->gm_stats[2] = cap_value(masp_var3, 0, 3000);
+		sd->gm_stats[3] = cap_value(masp_var4, 0, 3000);
+		sd->gm_stats[4] = cap_value(masp_var5, 0, 3000);
+		sd->gm_stats[5] = cap_value(masp_var6, 0, 3000);
+	} else { // Si es para cualquier otro caso... entonces...
+		sd->gm_power = 0;
+		clif_displaymessage(fd, "- Game Master Power Disable -");
+	}
+	status_calc_pc(sd,0); // Recalcula status
+
+	return 0;
+}
+
+/*==========================================
+ * Comando para Corazón de Ciudad [Zephyrus]
+ *------------------------------------------
+ */
+void cityheart_sub(int id, const int master_id)
+{
+	struct mob_data *md = BL_CAST(BL_MOB,map_id2bl(id));
+
+	if (md) {
+		md->master_id = master_id;
+		clif_misceffect(&md->bl,344);
+	}
+
+	return;
+}
+
+ACMD_FUNC(cityheart)
+{
+	int allied = 0, hpmas = 0, master_id = 0;
+	char name[NAME_LENGTH];
+	struct mob_data *md;
+
+	nullpo_retr(-1, sd);
+
+	if (sscanf(message, "%d %d %23[^\n]", &allied, &hpmas, name) < 2) {
+		clif_displaymessage(fd, "Usage @cityheart <allied to players ? 0 : 1> <Max HP> <Name>");
+		return -1;
+	}
+
+	hpmas = cap_value(hpmas,1,10000000);
+	allied = cap_value(allied,0,1);
+
+	// Creación del Corazón
+	md = (struct mob_data *)map_id2bl(mob_once_spawn_especial(sd, "this", sd->bl.x, sd->bl.y, name, MOBID_EMPERIUM, 1, "", hpmas, 0, allied, false, 0, 1, true, false, true, 0, 0, 0, false, 0, 0));
+	if (md) {
+		clif_misceffect(&md->bl,344);
+		master_id = md->bl.id;
+	} else {
+		clif_displaymessage(fd, "Cannot create the City Heart. Please check your position.");
+		return -1;
+	}
+
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x, sd->bl.y + 5, "North Guardian", 1674, 1, "", hpmas, 2, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x, sd->bl.y - 5, "South Guardian", 1674, 1, "", hpmas, 2, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x + 5, sd->bl.y, "East Guardian", 1674, 1, "", hpmas, 2, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x - 5, sd->bl.y, "West Guardian", 1674, 1, "", hpmas, 2, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x + 5, sd->bl.y + 5, "Stone", 1674, 1, "", hpmas, 1, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x + 5, sd->bl.y - 5, "Stone", 1674, 1, "", hpmas, 1, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x - 5, sd->bl.y + 5, "Stone", 1674, 1, "", hpmas, 1, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+	cityheart_sub(mob_once_spawn_especial(sd, "this", sd->bl.x - 5, sd->bl.y - 5, "Stone", 1674, 1, "", hpmas, 1, allied, false, 0, 0, false, false, true, 0, 0, 0, false, 0, 0), master_id);
+
+	return 0;
+}
+
+/*==========================================
+ * Special Mob Summons
+ *------------------------------------------*/
+ACMD_FUNC(mobdemolition)
+{
+	int amount = 0, type = 0, power = 0, ratio = 0;
+
+	nullpo_retr(-1, sd);
+
+	if (!message || !*message || (sscanf(message, "%d %d %d %d", &type, &amount, &ratio, &power) < 4)) {
+		// Modo de Uso
+		clif_displaymessage(fd, "Usage @mobdemolition <Damage who? 0 = all 1 = only mobs> <Amount> <Area> <Power>");
+		return -1;
+	}
+
+	amount = cap_value(amount,1,20);
+	ratio = cap_value(ratio,1,20);
+	power = cap_value(power,1,1000000);
+
+	mob_demolition (sd->bl.m, sd->bl.x, sd->bl.y, (short)ratio, type, amount, power);
+	return 0;
+}
+
+ACMD_FUNC(mobevent)
+{
+	char name[NAME_LENGTH];
+	int mob_id = 0, range, x = 0, y = 0;
+	int number = 1, tamano = 0, hpmas = 0, slaves = 0, spawntipo = 0, showkill = 0, mostrarhp = 0, pasawarps = 0, aliado = 0, hprateannounce = 0, noexpnodrop = 1, item_drop = 0, item_amount = 0;
+	int count, i, k;
+	short mx, my;
+	struct mob_data *md;
+
+	nullpo_retr(-1, sd);
+
+	if( !message || !*message || (sscanf(message, "%23s %d %d %d %d %d %d %d %d %d %d %d %d %d", name, &number, &hpmas, &tamano, &aliado, &spawntipo, &slaves, &pasawarps, &mostrarhp, &hprateannounce, &showkill, &noexpnodrop, &item_drop, &item_amount) < 1) )
+	{ // Modo de Uso
+		clif_displaymessage(fd, "================================================================================");
+		clif_displaymessage(fd, "@mobevent <name/id> <amount> <HP> ...");
+		clif_displaymessage(fd, "... <size> 0 normal | 1 small | 2 big");
+		clif_displaymessage(fd, "... <type> | 0 : Normal Mob aggresive status.");
+		clif_displaymessage(fd, ".......... | 1 : PC Allied / Enemy vs Mob Type 0 and 2.");
+		clif_displaymessage(fd, ".......... | 2 : PC and MOB Type 1 Enemy (Aggresive).");
+		clif_displaymessage(fd, ".......... | 3 : Ignores PC and PC cannot attack it / Aggresive vs MOD type 1.");
+		clif_displaymessage(fd, "... <spawn position> 0 random | 1 your current pos");
+		clif_displaymessage(fd, "... <Slaves?> 0 Allow to summon it if the mob can | 1 no slaves allowed");
+		clif_displaymessage(fd, "... <warps> 0 cannot use warps | 1 can use map warps | 2 and warp skill too");
+		clif_displaymessage(fd, "... <showHP?> 0 Normal | 1 HpMeter Bar | 2 Current/MaxHP | 3 Percent");
+		clif_displaymessage(fd, "... <HPrateAnnounce?> 0 off | 1 each 10% less or more HP a map announce appears");
+		clif_displaymessage(fd, "... <AnnounceKiller?> 0 off | 1 Map announce of the killer of the mob");
+		clif_displaymessage(fd, "... <NoExpnoDrop?> 0 off | 1 on (No exp and job awards)");
+		clif_displaymessage(fd, "... <Item ID> Item to be droped when killed (Use -1 to do Item rain event)");
+		clif_displaymessage(fd, "... <Item Amount> Amount of previous Item to be droped when killed");
+		clif_displaymessage(fd, "================================================================================");
+		return -1;
+	}
+
+	if( (mob_id = atoi(name)) == 0 )
+		mob_id = mobdb_searchname(name);
+
+	if( mob_id == 0 || mobdb_checkid(mob_id) == 0 )
+	{
+		clif_displaymessage(fd, msg_txt(40)); // Invalid monster ID or name.
+		return -1;
+	}
+
+	if( battle_config.atc_spawn_quantity_limit >= 1 && number > battle_config.atc_spawn_quantity_limit )
+		number = battle_config.atc_spawn_quantity_limit;
+
+	hpmas = cap_value(hpmas, 0, 10000000);
+	tamano = cap_value(tamano, 0, 2);
+	aliado = cap_value(aliado, 0, 3);
+	spawntipo = cap_value(spawntipo, 0, 1);
+	slaves = cap_value(slaves, 0, 1);
+	pasawarps = cap_value(pasawarps, 0, 2);
+
+	mostrarhp = cap_value(mostrarhp, 0, 3);
+	hprateannounce = cap_value(hprateannounce, 0, 1);
+	showkill = cap_value(showkill, 0, 1);
+	noexpnodrop = cap_value(noexpnodrop, 0, 1);
+
+	// Aditional Drop Event
+	if( item_drop > 0 )
+	{
+		if( !itemdb_exists(item_drop) )
+		{
+			clif_displaymessage(fd, msg_txt(19)); // Invalid item ID or name.
+			return -1;
+		}
+		else
+			item_amount = cap_value(item_amount, 1, 200);
+	}
+	else
+		item_amount = 0;
+
+
+	count = 0;
+	range = (int)sqrt((float)number) +2;
+	range = range * 2 + 5; // calculation of an odd number (+ 4 area around)
+	if( spawntipo )
+	{
+		mx = sd->bl.x;
+		my = sd->bl.y;
+	}
+
+	for( i = 0; i < number; i++ )
+	{
+		if( !spawntipo )
+			map_search_freecell(&sd->bl, 0, &mx, &my, range, range, 0);
+
+		k = mob_once_spawn_especial(sd, "this", mx, my, "--ja--", mob_id, 1, "",
+			hpmas, tamano, aliado, slaves, pasawarps, mostrarhp, hprateannounce, showkill, noexpnodrop, 0, item_drop, item_amount, false, 0, 0);
+
+		if( (md = (struct mob_data *)map_id2bl(k)) )
+			count ++;
+	}
+
+	if( count != 0 )
+		if( number == count )
+			clif_displaymessage(fd, msg_txt(39)); // All monster summoned!
+		else
+		{
+			sprintf(atcmd_output, msg_txt(240), count); // %d monster(s) summoned!
+			clif_displaymessage(fd, atcmd_output);
+		}
+	else
+	{
+		clif_displaymessage(fd, msg_txt(40)); // Invalid monster ID or name.
+		return -1;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Comando para buscar un vendedor de X item [Zephyrus]
+ *------------------------------------------*/
+ACMD_FUNC(whosell)
+{
+	struct map_session_data *pl_sd, *b_sd[MAX_SEARCH];
+	struct s_mapiterator* iter;
+
+	struct item_data *item_array[MAX_SEARCH];
+	int total[MAX_SEARCH], amount[MAX_SEARCH];
+	unsigned int MinPrice[MAX_SEARCH], MaxPrice[MAX_SEARCH];
+	char output[256];
+	int i, j, count = 1;
+
+	if( !message || !*message )
+	{
+		clif_displaymessage(fd, "Please, enter Item name or its ID (usage: @whosell <item name or ID>).");
+		return -1;
+	}
+
+	if( (item_array[0] = itemdb_exists(atoi(message))) == NULL )
+		count = itemdb_searchname_array(item_array, MAX_SEARCH, message);
+
+	if( count < 1 )
+	{ // No items found
+		clif_displaymessage(fd, msg_txt(19));
+		return -1;
+	}
+
+	if( count > MAX_SEARCH ) count = MAX_SEARCH;
+
+	// Preparing Search Recorders
+	for( i = 0; i < MAX_SEARCH; i++ )
+	{
+		total[i] = amount[i] = MaxPrice[i] = 0;
+		MinPrice[i] = battle_config.vending_max_value + 1;
+		b_sd[i] = NULL;
+	}
+
+	iter = mapit_getallusers();
+	for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+	{
+		if( !pl_sd->vender_id ) continue;
+		for( i = 0; i < pl_sd->vend_num; i++ )
+		{ // Searching in the Vending List
+			for( j = 0; j < count; j++ )
+			{ // Compares with each search result
+				if( pl_sd->status.cart[pl_sd->vending[i].index].nameid != item_array[j]->nameid )
+					continue;
+
+				amount[j] += pl_sd->vending[i].amount;
+				total[j]++;
+
+				if( pl_sd->vending[i].value < MinPrice[j] )
+				{ // Best Price
+					MinPrice[j] = pl_sd->vending[i].value;
+					b_sd[j] = pl_sd;
+				}
+				if( pl_sd->vending[i].value > MaxPrice[j] )
+					MaxPrice[j] = pl_sd->vending[i].value;
+			}
+		}
+	}
+	mapit_free(iter);
+
+	for( i = 0; i < count; i++ )
+	{
+		if( total[i] > 0 && b_sd[i] != NULL )
+		{
+			sprintf(output, "[%d] El mejor precio de '%s' es %u por '%s' en %s <%d,%d>. Max %u. Encontrado en %d shops, %d en venta.", item_array[i]->nameid, item_array[i]->jname, MinPrice[i], b_sd[i]->status.name, map[b_sd[i]->bl.m].name, b_sd[i]->bl.x, b_sd[i]->bl.y, MaxPrice[i], total[i], amount[i]);
+			if( sd->bl.m == b_sd[i]->bl.m )
+				clif_viewpoint(sd, 1, 1, b_sd[i]->bl.x, b_sd[i]->bl.y, i, 0xFFFFFF);
+		}
+		else
+			sprintf(output, "[%d] '%s' no está en tiendas...", item_array[i]->nameid, item_array[i]->jname);
+
+		clif_displaymessage(sd->fd, output);
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Creación de items en el suelo, en un Area.
+ *------------------------------------------*/
+ACMD_FUNC(flooritem)
+{
+	char item_name[100];
+	int number = 0, count;
+	struct item_data *item_data;
+	nullpo_retr(-1, sd);
+
+	memset(item_name, '\0', sizeof(item_name));
+
+	if( !message || !*message || (
+		sscanf(message, "\"%99[^\"]\" %d", item_name, &number) < 1 &&
+		sscanf(message, "%99s %d", item_name, &number) < 1
+	)) {
+		clif_displaymessage(fd, "Usage: @flooritem <itemname/itemid> [quantity]");
+		return -1;
+	}
+
+	if( number <= 0 )
+		number = 1;
+
+	if ((item_data = itemdb_searchname(item_name)) == NULL &&
+	    (item_data = itemdb_exists(atoi(item_name))) == NULL)
+	{
+		clif_displaymessage(fd, msg_txt(19)); // Invalid item ID or name.
+		return -1;
+	}
+
+	count = map_addflooritem_area(&sd->bl, 0, 0, 0, item_data->nameid, number);
+
+	if( count != 0 )
+		if( number == count )
+			clif_displaymessage(fd, "All items created.");
+		else
+		{
+			sprintf(atcmd_output, "%d item(s) created.", count);
+			clif_displaymessage(fd, atcmd_output);
+		}
+	else {
+		clif_displaymessage(fd, "No items created!!.");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Duel organizing functions [LuzZza]
+ *
+ * @duel [limit|nick] - create a duel
  * @invite <nick> - invite player
  * @accept - accept invitation
  * @reject - reject invitation
@@ -7708,12 +8457,22 @@
 	if(sd->duel_invite > 0) {
 		// "Duel: @duel without @reject."
 		clif_displaymessage(fd, msg_txt(355));
-		return 0;
-	}
-
-	if(!duel_checktime(sd)) {
-		char output[CHAT_SIZE_MAX];
-		// "Duel: You can take part in duel only one time per %d minutes."
+		return 0;
+	}
+
+	if(sd->state.pvpmode) {
+		clif_displaymessage(fd, "You cannot Duel on PVP Mode.");
+		return 0;
+	}
+
+	if(sd->status.guild_id && guild_isatwar(sd->status.guild_id)) {
+		clif_displaymessage(fd, "You cannot Duel if your guild is at War.");
+		return 0;
+	}
+
+	if(!duel_checktime(sd)) {
+		char output[CHAT_SIZE_MAX];
+		// "Duel: You can take part in duel only one time per %d minutes."
 		sprintf(output, msg_txt(356), battle_config.duel_time_interval);
 		clif_displaymessage(fd, output);
 		return 0;
@@ -7764,12 +8523,22 @@
 	clif_displaymessage(fd, msg_txt(359)); // "Duel: You left the duel."
 	return 0;
 }
-
-ACMD_FUNC(accept)
-{
-	if(!duel_checktime(sd)) {
-		char output[CHAT_SIZE_MAX];
-		// "Duel: You can take part in duel only one time per %d minutes."
+
+ACMD_FUNC(accept)
+{
+	if(sd->state.pvpmode) {
+		clif_displaymessage(fd, "You cannot Duel on PVP Mode.");
+		return 0;
+	}
+
+	if(sd->status.guild_id && guild_isatwar(sd->status.guild_id)) {
+		clif_displaymessage(fd, "You cannot Duel if your guild is at War.");
+		return 0;
+	}
+
+	if(!duel_checktime(sd)) {
+		char output[CHAT_SIZE_MAX];
+		// "Duel: You can take part in duel only one time per %d minutes."
 		sprintf(output, msg_txt(356), battle_config.duel_time_interval);
 		clif_displaymessage(fd, output);
 		return 0;
@@ -7859,12 +8628,134 @@
 		}
 	}
 
-	return 0;
-}
-
-// @clone/@slaveclone/@evilclone <playername> [Valaris]
-ACMD_FUNC(clone)
-{
+	return 0;
+}
+
+ACMD_FUNC(gcash)
+{
+	int value = 0;
+	char user[NAME_LENGTH];
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+
+	if( !message || !*message || sscanf(message, "%d %23[^\r\n]", &value, user) != 2 )
+	{
+		clif_displaymessage(fd, "Usage: @gcash <amount> <user>.");
+		return -1;
+	}
+
+	if( (pl_sd = map_nick2sd(user)) == NULL )
+	{
+		clif_displaymessage(fd, msg_txt(3)); // Character not found.
+		return -1;
+	}
+
+	if( pc_has_permission(sd,PC_PERM_TRADE) )
+	{
+		clif_displaymessage(fd, "Your GM level don't allow you to give cash.");
+		return -1;
+	}
+
+	if( value <= 0 || sd->cashPoints < value )
+	{
+		sprintf(atcmd_output, "Invalid value. You have currently %d cash points.", sd->cashPoints);
+		clif_displaymessage(fd, atcmd_output);
+		return -1;
+	}
+
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't transfer Cash. Blocked with @security");
+		return 1;
+	}
+
+	sprintf(atcmd_output, "'%s' has transfered %d Cash Points to you.", sd->status.name, value);
+	clif_disp_onlyself(pl_sd, atcmd_output, strlen(atcmd_output));
+	sprintf(atcmd_output, "You have transfered %d Cash Points to '%s'.", value, pl_sd->status.name);
+	clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+
+	pc_paycash(sd, value, 0);
+	pc_getcash(pl_sd, value, 0);
+	
+	return 0;
+}
+
+ACMD_FUNC(gpoints)
+{
+	int value = 0;
+	char user[NAME_LENGTH];
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+
+	if( !message || !*message || sscanf(message, "%d %23[^\r\n]", &value, user) != 2 )
+	{
+		clif_displaymessage(fd, "Usage: @gpoints <amount> <user>.");
+		return -1;
+	}
+
+	if( (pl_sd = map_nick2sd(user)) == NULL )
+	{
+		clif_displaymessage(fd, msg_txt(3)); // Character not found.
+		return -1;
+	}
+
+	if( !pc_has_permission(sd,PC_PERM_TRADE) )
+	{
+		clif_displaymessage(fd, "Your GM level don't allow you to give free cash.");
+		return -1;
+	}
+
+	if( value <= 0 || sd->kafraPoints < value )
+	{
+		sprintf(atcmd_output, "Invalid value. You have currently %d kafra points.", sd->kafraPoints);
+		clif_displaymessage(fd, atcmd_output);
+		return -1;
+	}
+
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't transfer Points. Blocked with @security");
+		return 1;
+	}
+
+	sprintf(atcmd_output, "'%s' has transfered %d Kafra Points to you.", sd->status.name, value);
+	clif_disp_onlyself(pl_sd, atcmd_output, strlen(atcmd_output));
+	sprintf(atcmd_output, "You have transfered %d Kafra Points to '%s'.", value, pl_sd->status.name);
+	clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+
+	pc_paycash(sd, value, value);
+	pc_getcash(pl_sd, 0, value);
+	
+	return 0;
+}
+
+/*===================================
+ * Away message (@away, @aw) [LuzZza]
+ *-----------------------------------*/
+ACMD_FUNC(away)
+{
+	if(strlen(message) > 0) {
+		if(strlen(message) > 128)
+			return -1;
+		strcpy(sd->away_message, message);
+		//"Away automessage has been activated."
+		clif_displaymessage(fd, msg_txt(546));
+	} else {
+		if(strlen(sd->away_message) > 0) {
+			sd->away_message[0] = 0;
+			//"Away automessage has been disabled."
+			clif_displaymessage(fd, msg_txt(547));
+			return 0;
+		}
+		//"Usage: @away,@aw <message>. Enter empty message for disable it."
+		clif_displaymessage(fd, msg_txt(548));
+	}
+	return 0;
+}
+
+// @clone/@slaveclone/@evilclone <playername> [Valaris]
+ACMD_FUNC(clone)
+{
 	int x=0,y=0,flag=0,master=0,i=0;
 	struct map_session_data *pl_sd=NULL;
 
@@ -7917,63 +8808,110 @@
 	}
 	clif_displaymessage(fd, msg_txt(129+flag*2));   // Unable to spawn evil clone. Unable to spawn clone. Unable to spawn slave clone.
 	return 0;
-}
-
-/*===================================
- * Main chat [LuzZza]
- * Usage: @main <on|off|message>
- *-----------------------------------*/
-ACMD_FUNC(main)
-{
-	if(message[0]) {
-
-		if(strcmpi(message, "on") == 0) {
-			if(!sd->state.mainchat) {
-				sd->state.mainchat = 1;
-				clif_displaymessage(fd, msg_txt(380)); // Main chat has been activated.
-			} else {
-				clif_displaymessage(fd, msg_txt(381)); // Main chat already activated.
-			}
-		} else if(strcmpi(message, "off") == 0) {
-			if(sd->state.mainchat) {
-				sd->state.mainchat = 0;
-				clif_displaymessage(fd, msg_txt(382)); // Main chat has been disabled.
-			} else {
-				clif_displaymessage(fd, msg_txt(383)); // Main chat already disabled.
-			}
-		} else {
-			if(!sd->state.mainchat) {
-				sd->state.mainchat = 1;
-				clif_displaymessage(fd, msg_txt(380)); // Main chat has been activated.
-			}
-			if(sd->sc.data[SC_NOCHAT] && sd->sc.data[SC_NOCHAT]->val1&MANNER_NOCHAT) {
-				clif_displaymessage(fd, msg_txt(387));
-				return -1;
-			}
-
-			if(battle_config.min_chat_delay) {
-				if(DIFF_TICK(sd->cantalk_tick, gettick()) > 0)
-					return 0;
-				sd->cantalk_tick = gettick() + battle_config.min_chat_delay;
-			}
-
-			// send the message using inter-server system
-			intif_main_message(sd, message);
-		}
-
-	} else {
-
-		if(sd->state.mainchat)
-			clif_displaymessage(fd, msg_txt(384)); // Main chat currently enabled. Usage: @main <on|off>, @main <message>.
-		else
-			clif_displaymessage(fd, msg_txt(385)); // Main chat currently disabled. Usage: @main <on|off>, @main <message>.
-	}
-	return 0;
-}
-
-/*=====================================
- * Autorejecting Invites/Deals [LuzZza]
- * Usage: @noask
+}
+
+/*===================================
+ * Chat Channels [Zephyrus]
+ *-----------------------------------*/
+ACMD_FUNC(create)
+{
+	char room_name[NAME_LENGTH], room_pass[NAME_LENGTH];
+	memset(room_name, '\0', sizeof(room_name));
+	memset(room_pass, '\0', sizeof(room_pass));
+
+	if( !battle_config.channel_system_enable )
+	{
+		clif_displaymessage(fd, "Chat Channel System disabled.");
+		return -1;
+	}
+
+	if( !message || !*message || sscanf(message, "%23s %23[^\n]", room_name, room_pass) < 1 )
+	{
+		clif_displaymessage(fd, "Usage: @create <#channel_name> <optional_password>");
+		return -1;
+	}
+
+	if( !channel_create(sd, room_name, trim(room_pass), CHN_USER, 38, 0) )
+		return -1;
+
+	return 0;
+}
+
+ACMD_FUNC(join)
+{
+	char room_name[NAME_LENGTH], room_pass[NAME_LENGTH];
+	memset(room_name, '\0', sizeof(room_name));
+	memset(room_pass, '\0', sizeof(room_pass));
+
+	if( !battle_config.channel_system_enable )
+	{
+		clif_displaymessage(fd, "Chat Channel System disabled.");
+		return -1;
+	}
+
+	if( !message || !*message )
+	{ // Checks if the user has been invited to another channel
+		if( sd->channel_invite_timer != INVALID_TIMER )
+		{
+			channel_invite_accept(sd);
+			return 0;
+		}
+		else
+		{
+			clif_displaymessage(fd, "Usage: @join <#channel_name> <optional_password>");
+			return -1;
+		}
+	}
+
+	if( sscanf(message, "%23s %23[^\n]", room_name, room_pass) < 1 )
+	{
+		clif_displaymessage(fd, "Usage: @join <#channel_name> <optional_password>");
+		return -1;
+	}
+
+	if( DIFF_TICK(sd->canjoinchn_tick, gettick()) > 0 )
+	{
+		clif_displaymessage(sd->fd, msg_txt(807));
+		return -1;
+	}
+
+	channel_join(sd, room_name, room_pass, false);
+	return 0;
+}
+
+ACMD_FUNC(exit)
+{
+	if( !battle_config.channel_system_enable )
+	{
+		clif_displaymessage(fd, "Chat Channel System disabled.");
+		return -1;
+	}
+
+	if( !message || !*message )
+	{
+		clif_displaymessage(fd, "Usage: @exit <#channel_name>");
+		return -1;
+	}
+
+	channel_leave(sd, message, true);
+	return 0;
+}
+
+ACMD_FUNC(list)
+{
+	if( !battle_config.channel_system_enable )
+	{
+		clif_displaymessage(fd, "Chat Channel System disabled.");
+		return -1;
+	}
+
+	channel_list(sd);
+	return 0;
+}
+
+/*=====================================
+ * Autorejecting Invites/Deals [LuzZza]
+ * Usage: @noask
  *-------------------------------------*/
 ACMD_FUNC(noask)
 {
@@ -8015,12 +8953,122 @@
 	clif_displaymessage(fd, msg_txt(1324)); // Reset 'Feeling' maps.
 
 	return 0;
-}
-
-/*==========================================
- * AUCTION SYSTEM
- *------------------------------------------*/
-ACMD_FUNC(auction)
+}
+
+/*==========================================
+ * Modo PK para jugadores - Duelos abiertos sin necesidad de crear duelo
+ *------------------------------------------*/
+ACMD_FUNC(pvpmode)
+{
+	nullpo_retr(-1, sd);
+
+    if( sd->duel_group > 0 && !sd->state.pvpmode )
+	{
+    	clif_displaymessage(fd, msg_txt(848));
+    	return -1;
+    }
+
+	if( sd->state.pvpmode )
+		pc_pvpmodeoff(sd,0,1);
+	else
+		pc_pvpmode(sd);
+
+	return 0;
+}
+
+/*==========================================
+ * Comando buscador de Personas en Modo PK
+ *------------------------------------------*/
+static int atwhopk_sub(struct block_list *bl,va_list ap)
+{
+	int fd;
+	struct map_session_data *sd, *pl;
+	static int number=0;
+	char pl_info[100];
+
+	if( !ap )
+	{
+		number = 0;
+		return 0;
+	}
+	fd = va_arg(ap,int);
+	sd = va_arg(ap,struct map_session_data*);
+
+	pl = (TBL_PC*)bl; // Esto lo retorna el Map_foreachinmap
+
+	if( !pl->state.pvpmode || pl == sd )
+		return 0; // Ignora jugadores que no estén en Modo PK o al Mismo Jugador
+
+	if( fd )
+	{
+		sprintf(pl_info, msg_txt(849), pl->status.name, bl->x, bl->y, pl->status.pk.score);
+		clif_disp_onlyself(sd ,(const char*)pl_info,(int)strlen((const char*)pl_info));
+		clif_viewpoint(sd, 1, 0, bl->x, bl->y, ++number, 0xFF0000);
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(whopk)
+{
+	int map_id;
+	nullpo_retr(-1, sd);
+
+	if( !sd->state.pvpmode )
+	{
+		clif_displaymessage(fd, msg_txt(850) );
+		return -1;
+	}
+
+	map_id = sd->bl.m;
+	clif_displaymessage(fd, msg_txt(851) );
+	map_foreachinmap(atwhopk_sub, map_id, BL_PC, fd, sd);
+
+	atwhopk_sub(&sd->bl,0);
+
+	return 0;
+}
+
+/*==========================================
+ * Comando para abrir el Storage adicional
+ *------------------------------------------*/
+ACMD_FUNC(rentstorage)
+{
+	nullpo_retr(-1, sd);
+
+	if (sd->npc_id || sd->vender_id || sd->buyer_id || sd->state.trading || sd->state.storage_flag)
+		return -1;
+
+	if (ext_storage_open(sd) == 1)
+  	{	//Already open.
+		clif_displaymessage(fd, msg_txt(250));
+		return -1;
+	}
+	return 0;
+}
+
+/*==========================================
+ * Auras personalizadas
+ *------------------------------------------*/
+ACMD_FUNC(aura)
+{
+	int type;
+
+	type = atoi(message);
+	sprintf(atcmd_output, "Current Aura: %d", sd->user_aura);
+	clif_displaymessage(fd, atcmd_output);
+
+	sd->user_aura = type;
+	pc_setglobalreg(sd,"USERAURA",type);
+	pc_setpos(sd, sd->mapindex, sd->bl.x, sd->bl.y, CLR_TELEPORT);
+
+	return 0;
+}
+
+/*==========================================
+ * AUCTION SYSTEM
+ *------------------------------------------*/
+ACMD_FUNC(auction)
 {
 	nullpo_ret(sd);
 
@@ -8261,14 +9309,16 @@
 		{ "Vit - %3d", 0 },
 		{ "Int - %3d", 0 },
 		{ "Dex - %3d", 0 },
-		{ "Luk - %3d", 0 },
-		{ "Zeny - %d", 0 },
-		{ "Free SK Points - %d", 0 },
-		{ "JobChangeLvl (2nd) - %d", 0 },
-		{ "JobChangeLvl (3rd) - %d", 0 },
-		{ NULL, 0 }
-	};
-
+		{ "Luk - %3d", 0 },
+		{ "Zeny - %d", 0 },
+		{ "Free SK Points - %d", 0 },
+		{ "Used SK Points - %d", 0 },
+		{ "JobChangeLvl (2nd) - %d", 0 },
+		{ "JobChangeLvl (3rd) - %d", 0 },
+		{ "Attack Speed MS - %d", 0 },
+		{ NULL, 0 }
+	};
+
 	memset(job_jobname, '\0', sizeof(job_jobname));
 	memset(output, '\0', sizeof(output));
 
@@ -8285,15 +9335,17 @@
 	output_table[8].value = sd->status.vit;
 	output_table[9].value = sd->status.int_;
 	output_table[10].value = sd->status.dex;
-	output_table[11].value = sd->status.luk;
-	output_table[12].value = sd->status.zeny;
-	output_table[13].value = sd->status.skill_point;
-	output_table[14].value = sd->change_level_2nd;
-	output_table[15].value = sd->change_level_3rd;
+	output_table[11].value = sd->status.luk;
+	output_table[12].value = sd->status.zeny;
+	output_table[13].value = sd->status.skill_point;
+	output_table[14].value = pc_calc_skillpoint(sd);
+	output_table[15].value = sd->change_level_2nd;
+	output_table[16].value = sd->change_level_3rd;
+	output_table[17].value = status_get_adelay(&sd->bl);
+
+	sprintf(job_jobname, "Job - %s %s", job_name(sd->status.class_), "(level %d)");
+	sprintf(output, msg_txt(53), sd->status.name); // '%s' stats:
 
-	sprintf(job_jobname, "Job - %s %s", job_name(sd->status.class_), "(level %d)");
-	sprintf(output, msg_txt(53), sd->status.name); // '%s' stats:
-
 	clif_displaymessage(fd, output);
 
 	for(i = 0; output_table[i].format != NULL; i++) {
@@ -8301,12 +9353,68 @@
 		clif_displaymessage(fd, output);
 	}
 
-	return 0;
-}
-
-ACMD_FUNC(delitem)
-{
-	char item_name[100];
+	return 0;
+}
+
+ACMD_FUNC(myinfo)
+{
+	char output[CHAT_SIZE_MAX];
+	uint32 ip;
+	int i;
+
+	struct {
+		const char* format;
+		int value;
+	} output_table[] = {
+		{ "Cash Points - %d", 0 },
+		{ "Free/Kafra Points - %d", 0 },
+		{ NULL, 0 },
+		{ NULL, 0 },
+		{ NULL, 0 }
+	};
+
+	memset(output, '\0', sizeof(output));
+
+	//direct array initialization with variables is not standard C compliant.
+	output_table[0].value = sd->cashPoints;
+	output_table[1].value = sd->kafraPoints;
+	if( battle_config.myinfo_event_vote_points )
+	{
+		output_table[2].format = "Event Points - %d";
+		output_table[2].value = pc_readaccountreg(sd,"#EVENTPOINTS");
+		output_table[3].format = "Vote Points - %d";
+		output_table[3].value = pc_readaccountreg(sd,"#VOTEPOINTS");
+	}
+
+	sprintf(output, "'%s' Info:", sd->status.name); // '%s' stats:
+	clif_displaymessage(fd,output);
+
+	for( i = 0; output_table[i].format != NULL; i++ )
+	{
+		sprintf(output,output_table[i].format,output_table[i].value);
+		clif_displaymessage(fd,output);
+	}
+
+	if( pc_isPremium(sd) )
+	{
+		int tick = sd->Premium_Tick - (int)time(NULL), day, hour, minute, second;
+
+		clif_displaymessage(fd,"- Premium Account Enable -");
+		atcommand_expinfo_sub(tick, &day, &hour, &minute, &second);
+		sprintf(output,"Expires at - %d days, %02d:%02d:%02d", day, hour, minute, second);
+		clif_displaymessage(fd,output);
+	}
+
+	ip = session[sd->fd]->client_addr;
+	sprintf(output,"IP Address - %d.%d.%d.%d",CONVIP(ip));
+	clif_displaymessage(fd,output);
+
+	return 0;
+}
+
+ACMD_FUNC(delitem)
+{
+	char item_name[100];
 	int nameid, amount = 0, total, idx;
 	struct item_data *id;
 
@@ -8355,12 +9463,155 @@
 	}
 
 	return 0;
-}
-
-/*==========================================
- * Custom Fonts
- *------------------------------------------*/
-ACMD_FUNC(font)
+}
+
+/*==========================================
+ * Exp Gain Information
+ *------------------------------------------*/
+void atcommand_expinfo_sub(int time, int* day, int* hour, int* minute, int* second)
+{
+	*day = time / 86400; time -= *day * 84600;
+	*hour = time / 3600; time -= *hour * 3600;
+	*minute = time / 60; time -= *minute * 60;
+	*second = time;
+
+	*day = *day > 0 ? *day : 0;
+	*hour = *hour > 0 ? *hour : 0;
+	*minute = *minute > 0 ? *minute : 0;
+	*second = *second > 0 ? *second : 0;
+
+	return;
+}
+
+ACMD_FUNC(expinfo)
+{
+	unsigned int nextb, nextj, bexp_ps, jexp_ps, nextbt, nextjt;
+	int session_time, day = 0, hour = 0, minute = 0, second = 0;
+
+	nullpo_retr(-1,sd);
+
+	if( !strcmpi(message, "reset") )
+	{ // Restart Vars
+		sd->custom_data.session_base_exp = 0;
+		sd->custom_data.session_job_exp = 0;
+		sd->custom_data.session_start = last_tick;
+	}
+	else if( !strcmpi(message, "off") )
+	{
+		sd->state.showgain = 0;
+		clif_displaymessage(fd, msg_txt(864));
+
+		return 0;
+	}
+	else if( !strcmpi(message, "on") )
+	{
+		sd->state.showgain = 1;
+		clif_displaymessage(fd, msg_txt(865));
+
+		return 0;
+	}
+	else
+		clif_displaymessage(fd, msg_txt(866));
+
+	session_time = DIFF_TICK(last_tick, sd->custom_data.session_start);
+
+	atcommand_expinfo_sub(session_time, &day, &hour, &minute, &second);
+	sprintf(atcmd_output, msg_txt(867), day, hour, minute, second);
+	clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+
+	if( session_time <= 0 )
+		return 0;
+
+	nextb = pc_nextbaseexp(sd);
+	nextj = pc_nextjobexp(sd);
+
+	sprintf(atcmd_output, msg_txt(868), sd->custom_data.session_base_exp, sd->custom_data.session_job_exp);
+	clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+
+	if( nextb )
+	{ // Next Base lvl information
+		if( (bexp_ps = sd->custom_data.session_base_exp / session_time) < 1 )
+			sprintf(atcmd_output, msg_txt(869), bexp_ps);
+		else if( (nextbt = (nextb - sd->status.base_exp) / bexp_ps) < 604800 )
+		{
+			atcommand_expinfo_sub(nextbt, &day, &hour, &minute, &second);
+			if( day )
+				sprintf(atcmd_output, msg_txt(870), bexp_ps, day, hour, minute, second);
+			else
+				sprintf(atcmd_output, msg_txt(871), bexp_ps, hour, minute, second);
+		}
+		else
+			sprintf(atcmd_output, msg_txt(869), bexp_ps);
+
+		clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+	}
+
+	if( nextj )
+	{ // Next Job lvl information
+		if( (jexp_ps = sd->custom_data.session_job_exp / session_time) < 1 )
+			sprintf(atcmd_output, msg_txt(872), jexp_ps);
+		else if( (nextjt = (nextj - sd->status.job_exp) / jexp_ps) < 604800 )
+		{
+			atcommand_expinfo_sub(nextjt, &day, &hour, &minute, &second);
+			if( day )
+				sprintf(atcmd_output, msg_txt(873), jexp_ps, day, hour, minute, second);
+			else
+				sprintf(atcmd_output, msg_txt(874), jexp_ps, hour, minute, second);
+		}
+		else
+			sprintf(atcmd_output, msg_txt(872), jexp_ps);
+
+		clif_disp_onlyself(sd, atcmd_output, strlen(atcmd_output));
+	}
+
+	return 0;
+}
+/*==========================================
+ * Hunting Mission [Zephyrus]
+ *------------------------------------------*/
+ACMD_FUNC(mission)
+{
+	int i, c = 0;
+	nullpo_retr(-1,sd);
+
+	if( sd->hunting[0].mob_id == 0 )
+	{
+		clif_displaymessage(fd, "You are not hunting.");
+		return 0;
+	}
+
+	for( i = 0; i < 5; i++ )
+	{
+		if( sd->hunting[i].count < 1 )
+			continue;
+
+		sprintf(atcmd_output, "- Hunting %d '%s' (ID : %d)", sd->hunting[i].count, mob_db(sd->hunting[i].mob_id)->jname, sd->hunting[i].mob_id);
+		clif_displaymessage(fd, atcmd_output);
+
+		c = sd->hunting[i].count;
+	}
+
+	if( c < 1 )
+		clif_displaymessage(fd, "Hunting Mission Completed");
+	else if( sd->hunting_time < (int)time(NULL) )
+		clif_displaymessage(fd, "Hunting Mission Failed");
+	else
+	{
+		int tick = sd->hunting_time - (int)time(NULL),
+			day, hour, minute, second;
+
+		atcommand_expinfo_sub(tick, &day, &hour, &minute, &second);
+		sprintf(atcmd_output, "Time Left : %02d:%02d:%02d", hour, minute, second);
+		clif_displaymessage(fd, atcmd_output);
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Custom Fonts
+ *------------------------------------------*/
+ACMD_FUNC(font)
 {
 	int font_id;
 	nullpo_retr(-1,sd);
@@ -8385,12 +9636,778 @@
 		clif_displaymessage(fd, msg_txt(1361)); // Already using this font.
 
 	return 0;
-}
-
-/*==========================================
- * type: 1 = commands (@), 2 = charcommands (#)
- *------------------------------------------*/
-static void atcommand_commands_sub(struct map_session_data *sd, const int fd, AtCommandType type)
+}
+
+/*==========================================
+ * Char Data Backup Generation.
+ *------------------------------------------*/
+ACMD_FUNC(char2dump)
+{
+	int char_id;
+
+	nullpo_retr(-1,sd);
+
+	if( (char_id = atoi(message)) <= 0 )
+		return -1;
+
+	chrif_char2dumpfile(char_id);
+	clif_displaymessage(fd, "Requesting char server to do a backup of Char data");
+
+	return 0;
+}
+
+/*=========================================
+ * Item Security System
+ *-----------------------------------------*/
+ACMD_FUNC(security)
+{
+	nullpo_retr(-1,sd);
+	if( sd->npc_id || sd->vender_id || sd->buyer_id || sd->state.trading || sd->state.storage_flag )
+		return -1;
+
+	npc_event(sd,"SecuritySystem::OnSettings",0);
+	return 0;
+}
+
+/*==========================================
+ * Packet Filter
+ *------------------------------------------*/
+ACMD_FUNC(packetfilter)
+{
+	nullpo_retr(-1,sd);
+	if( !message || !*message )
+	{
+		clif_displaymessage(fd,"<<----- Packet Filtering Usage ----->>");
+		clif_displaymessage(fd,".   @packetfilter <options>");
+		clif_displaymessage(fd,".   C : To filter global chat messages.");
+		clif_displaymessage(fd,".   I : To filter item usage.");
+		clif_displaymessage(fd,".   - Samples");
+		clif_displaymessage(fd,".   @packetfilter CI : To filter the 2 options.");
+		clif_displaymessage(fd,".   @packetfilter off : To turn packet filter off.");
+	}
+	else if( !strcmpi(message,"off") )
+	{
+		sd->state.packet_filter = 0;
+		clif_displaymessage(fd,"<< Packet Filtering Off >>");
+	}
+	else
+	{
+		if( strstr(message,"C") )
+			sd->state.packet_filter |= 1;
+		if( strstr(message,"I") )
+			sd->state.packet_filter |= 2;
+
+		sprintf(atcmd_output,"<< Packet Filtering | Chat %s | Items %s >>", (sd->state.packet_filter&1) ? "ON" : "OFF", (sd->state.packet_filter&2) ? "ON" : "OFF");
+		clif_displaymessage(fd,atcmd_output);
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Guild Skill Usage for Guild Masters
+ *------------------------------------------*/
+ACMD_FUNC(guildskill)
+{
+	int i, skillnum = 0, skilllv = 0, idx;
+	unsigned int tick = gettick();
+	struct battleground_data *bg;
+	struct guild *g;
+
+	const struct { char skillstr[3]; int id; } skills[] = {
+		{ "BO",	10010 },
+		{ "RG",	10011 },
+		{ "RS",	10012 },
+		{ "EC",	10013 },
+	};
+
+	// Check for Skill ID
+	for( i = 0; i < ARRAYLENGTH(skills); i++ )
+	{
+		if( strncmpi(message, skills[i].skillstr, 3) == 0 )
+		{
+			skillnum = skills[i].id;
+			break;
+		}
+	}
+	if( !skillnum )
+	{
+		clif_displaymessage(fd, "Invalid Skill string. Use @guildskill EC/RS/RG/BO");
+		return -1;
+	}
+
+	idx = battle_config.guild_skills_separed_delay ? skillnum - GD_SKILLBASE : 0;
+	if( !map[sd->bl.m].flag.battleground )
+	{
+		if( (g = sd->state.gmaster_flag) != NULL )
+		{
+			if( g->skill_block_timer[idx] == INVALID_TIMER )
+				skilllv = guild_checkskill(g, skillnum);
+			else
+			{
+				guild_block_skill_status(g, skillnum);
+				skilllv = 0;
+			}
+		}
+		else
+		{
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}
+	}
+	else
+	{
+		if( (bg = sd->bmaster_flag) != NULL )
+		{
+			if( bg->skill_block_timer[idx] == INVALID_TIMER )
+				skilllv = bg_checkskill(bg, skillnum);
+			else
+			{
+				bg_block_skill_status(bg, skillnum);
+				skilllv = 0;
+			}
+		}
+		else
+		{
+			clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+			return -1;
+		}
+	}
+
+	if( pc_cant_act(sd) || pc_issit(sd) || skillnotok(skillnum, sd) || sd->ud.skilltimer != -1 || sd->sc.option&(OPTION_WEDDING|OPTION_XMAS|OPTION_SUMMER) || sd->state.only_walk || sd->sc.data[SC_BASILICA] )
+		return -1;
+
+	if( DIFF_TICK(tick, sd->ud.canact_tick) < 0 )
+		return -1;
+
+	if( sd->menuskill_id )
+	{
+		if( sd->menuskill_id == SA_TAMINGMONSTER )
+			sd->menuskill_id = sd->menuskill_val = 0; //Cancel pet capture.
+		else if( sd->menuskill_id != SA_AUTOSPELL )
+			return -1; //Can't use skills while a menu is open.
+	}
+
+	sd->skillitem = sd->skillitemlv = 0;
+	if( skilllv ) unit_skilluse_id(&sd->bl, sd->bl.id, skillnum, skilllv);
+	return 0;
+}
+
+/*==========================================
+ * Battleground Leader Commands
+ *------------------------------------------*/
+ACMD_FUNC(order)
+{
+	nullpo_retr(-1,sd);
+	if( !message || !*message )
+	{
+		clif_displaymessage(fd, "Please, enter a message (usage: @order <message>).");
+		return -1;
+	}
+
+	if( map[sd->bl.m].flag.battleground )
+	{
+		if( !sd->bmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+			return -1;
+		}
+		clif_broadcast2(&sd->bl, message, (int)strlen(message)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+	}
+	else
+	{
+		if( !sd->state.gmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}
+		clif_broadcast2(&sd->bl, message, (int)strlen(message)+1, 0xFF0000, 0x190, 20, 0, 0, GUILD);
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(leader)
+{
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->bmaster_flag )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( sd->ud.skilltimer != INVALID_TIMER )
+		clif_displaymessage(fd, "Command not allow while casting a skill.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the new Leader name (usage: @leader <name>).");
+	else if( (pl_sd = map_nick2sd((char *)message)) == NULL )
+		clif_displaymessage(fd, msg_txt(3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You are already the Team Leader.");
+	else
+	{ // Everytest OK!
+		sprintf(atcmd_output, "Team Leader transfered to [%s]", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+
+		sd->bmaster_flag->leader_char_id = pl_sd->status.char_id;
+		pl_sd->bmaster_flag = sd->bmaster_flag;
+		sd->bmaster_flag = NULL;
+
+		clif_charnameupdate(sd);
+		clif_charnameupdate(pl_sd);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(reportafk)
+{
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->bg_id )
+		clif_displaymessage(fd, "This command is reserved for Battleground Only.");
+	else if( !sd->bmaster_flag && battle_config.bg_reportafk_leaderonly )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the character name (usage: @reportafk <name>).");
+	else if( (pl_sd = map_nick2sd((char *)message)) == NULL )
+		clif_displaymessage(fd, msg_txt(3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You cannot kick yourself.");
+	else if( pl_sd->state.bg_afk == 0 )
+		clif_displaymessage(fd, "The player is not AFK on this Battleground.");
+	else
+	{ // Everytest OK!
+		struct battleground_data *bg;
+		if( (bg = bg_team_search(sd->bg_id)) == NULL )
+			return -1;
+
+		bg_team_leave(pl_sd,2);
+		clif_displaymessage(pl_sd->fd, "You have been kicked from Battleground because of your AFK status.");
+		pc_setpos(pl_sd,pl_sd->status.save_point.map,pl_sd->status.save_point.x,pl_sd->status.save_point.y,3);
+
+		sprintf(atcmd_output, "- AFK [%s] Kicked -", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, bg->color, 0x190, 20, 0, 0, BG);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(listenbg)
+{
+	if( sd->state.bg_listen )
+	{
+		sd->state.bg_listen = 0;
+		clif_displaymessage(fd, "You will not receive Battleground announcements.");
+	}
+	else
+	{
+		sd->state.bg_listen = 1;
+		clif_displaymessage(fd, "You will receive Battleground announcements.");
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(unboundall)
+{
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the character name (usage: @unboundall <name>).");
+	else if( (pl_sd = map_nick2sd((char *)message)) == NULL )
+		clif_displaymessage(fd, msg_txt(3)); // Character not found.
+	else
+	{ // Start Unbound process
+		int i, c = 0;
+		for( i = 0; i < MAX_INVENTORY; i++ )
+		{
+			if( pl_sd->status.inventory[i].nameid && pl_sd->status.inventory[i].bound )
+			{
+				pl_sd->status.inventory[i].bound = 0;
+				c++;
+			}
+		}
+
+		if( c )
+		{
+			sprintf(atcmd_output,"Unbounded %d inventory items.", c);
+			clif_displaymessage(fd, atcmd_output);
+			c = 0;
+		}
+
+		for( i = 0; i < MAX_CART; i++ )
+		{
+			if( pl_sd->status.cart[i].nameid && pl_sd->status.cart[i].bound )
+			{
+				pl_sd->status.cart[i].bound = 0;
+				c++;
+			}
+		}
+
+		if( c )
+		{
+			sprintf(atcmd_output,"Unbounded %d cart items.", c);
+			clif_displaymessage(fd, atcmd_output);
+			c = 0;
+		}
+
+		for( i = 0; i < MAX_STORAGE; i++ )
+		{
+			if( pl_sd->status.storage.items[i].nameid && pl_sd->status.storage.items[i].bound )
+			{
+				pl_sd->status.storage.items[i].bound = 0;
+				c++;
+			}
+		}
+
+		if( c )
+		{
+			sprintf(atcmd_output,"Unbounded %d storage items.", c);
+			clif_displaymessage(fd, atcmd_output);
+			c = 0;
+		}
+
+		for( i = 0; i < MAX_EXTRA_STORAGE; i++ )
+		{
+			if( pl_sd->status.ext_storage.items[i].nameid && pl_sd->status.ext_storage.items[i].bound )
+			{
+				pl_sd->status.ext_storage.items[i].bound = 0;
+				c++;
+			}
+		}
+
+		if( c )
+		{
+			sprintf(atcmd_output,"Unbounded %d ext storage items.", c);
+			clif_displaymessage(fd, atcmd_output);
+			c = 0;
+		}
+
+		clif_refresh(pl_sd);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(bgranked)
+{
+	int i;
+
+	clif_displaymessage(fd, "============= RANKED BATTLEGROUND FAME LIST =============");
+	for( i = 0; i < MAX_FAME_LIST && bgrank_fame_list[i].id; i++ )
+	{
+		sprintf(atcmd_output,"%d - %s - %d points",i+1,bgrank_fame_list[i].name,bgrank_fame_list[i].fame);
+		clif_displaymessage(fd, atcmd_output);
+	}
+	clif_displaymessage(fd, "============= RANKED BATTLEGROUND FAME LIST =============");
+	return 0;
+}
+
+ACMD_FUNC(bgregular)
+{
+	int i;
+
+	clif_displaymessage(fd, "============= REGULAR BATTLEGROUND FAME LIST =============");
+	for( i = 0; i < MAX_FAME_LIST && bg_fame_list[i].id; i++ )
+	{
+		sprintf(atcmd_output,"%d - %s - %d points",i+1,bg_fame_list[i].name,bg_fame_list[i].fame);
+		clif_displaymessage(fd, atcmd_output);
+	}
+	clif_displaymessage(fd, "============= REGULAR BATTLEGROUND FAME LIST =============");
+	return 0;
+}
+
+ACMD_FUNC(battleinfo)
+{
+	if( sd->state.battleinfo )
+	{
+		clif_displaymessage(fd, "- Battle Information Display OFF - Kill/Death -");
+		sd->state.battleinfo = 0;
+	}
+	else
+	{
+		clif_displaymessage(fd, "- Battle Information Display ON - Kill/Death -");
+		sd->state.battleinfo = 1;
+	}
+	return 0;
+}
+
+/*==========================================
+ * Ranking Reset
+ *------------------------------------------*/
+ACMD_FUNC(rankreset)
+{
+	int type;
+	nullpo_retr(-1, sd);
+
+	if( (type = atoi(message)) < 1 || type > 3 )
+	{
+		clif_displaymessage(fd, "Enter reset rank type. Usage: @rankreset <n>");
+		clif_displaymessage(fd, "n = 1 WoE | 2 BG | 3 PVP");
+		return -1;
+	}
+
+	pc_ranking_reset(type - 1, true);
+	clif_displaymessage(fd, "Reseting Ranking...");
+	return 0;
+}
+
+/*==========================================
+ * Item Remover
+ *------------------------------------------*/
+ACMD_FUNC(item_remove4all)
+{
+	int nameid;
+	nullpo_retr(-1, sd);
+
+	if( (nameid = atoi(message)) < 500 || !itemdb_exists(nameid) )
+	{
+		clif_displaymessage(fd, "Enter a Valid Item ID. Usage: @itemdestroy <itemid>");
+		return -1;
+	}
+
+	pc_item_remove4all(nameid,true);
+	clif_displaymessage(fd, "Destroying Item...");
+	return 0;
+}
+
+/*==========================================
+ * Fame Points
+ *------------------------------------------*/
+ACMD_FUNC(addfame)
+{
+	int fame = 0, type = 0;
+	nullpo_retr(-1, sd);
+
+	if( !message || !*message || sscanf(message, "%d %d", &type, &fame) < 2 )
+	{
+		clif_displaymessage(fd, "Usage: @addfame <type> <points>");
+		clif_displaymessage(fd, "- type : 0 Class (Alche/BS/TK) | 1 PK | 2 BG Ranked | 3 BG Regular");
+
+		return -1;
+	}
+
+	if( type < 0 || type > 3 )
+	{
+		clif_displaymessage(fd, "Invalid type : 0 Class (Alche/BS/TK) | 1 PK | 2 BG Ranked | 3 BG Regular");
+		return -1;
+	}
+
+	if( fame <= 0 )
+	{
+		clif_displaymessage(fd, "Invalid points. Positive value required.");
+		return -1;
+	}
+
+	pc_addfame(sd,fame,type);
+	return 0;
+}
+
+/*==========================================
+ * Visual Mob Info Mode
+ *------------------------------------------*/
+static int atcommand_viewmobinfo_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd;
+	struct mob_data *md;
+
+	nullpo_ret(bl);
+	nullpo_ret(md = (struct mob_data *)bl);
+	nullpo_ret(sd = va_arg(ap, struct map_session_data *));
+
+	clif_mobnameack(sd,md,0);
+	return 0;
+}
+
+ACMD_FUNC(viewmobinfo)
+{
+	nullpo_retr(-1,sd);
+	if( sd->state.view_mob_info )
+	{
+		sd->state.view_mob_info = 0;
+		clif_displaymessage(fd,"* Viewing mob info data - Disabled *");
+	}
+	else
+	{
+		sd->state.view_mob_info = 1;
+		clif_displaymessage(fd,"* Viewing mob info data - Enable *");
+	}
+
+	map_foreachinarea(atcommand_viewmobinfo_sub, sd->bl.m, sd->bl.x - AREA_SIZE, sd->bl.y - AREA_SIZE, sd->bl.x + AREA_SIZE, sd->bl.y + AREA_SIZE, BL_MOB, sd);
+	return 0;
+}
+
+/*==========================================
+ * Teleport On/Off
+ *------------------------------------------*/
+ACMD_FUNC(teleport)
+{
+	int mode;
+
+	if( !strcmpi(message,"on") )
+		mode = 1;
+	else if( !strcmpi(message,"off") )
+		mode = 0;
+	else
+	{
+		clif_displaymessage(fd,"Usage @mobtele / @pctele <on/off>");
+		return -1;
+	}
+
+	if( !strcmpi(command+1,"mobtele") )
+		map[sd->bl.m].flag.monster_noteleport = mode;
+	else if( !strcmpi(command+1,"pctele") )
+		map[sd->bl.m].flag.noteleport = mode;
+
+	sprintf(atcmd_output,"Setting : pc %d | monster %d", map[sd->bl.m].flag.noteleport, map[sd->bl.m].flag.monster_noteleport);
+	clif_displaymessage(fd,atcmd_output);
+	return 0;
+}
+
+/*==========================================
+ * Achievements
+ *------------------------------------------*/
+ACMD_FUNC(achievements)
+{
+	int i, j;
+	struct achievement_data *ad;
+	struct s_achievement *sad;
+	int x, y;
+	char rate[32];
+
+	if( sd->achievement_count <= 0 )
+	{
+		clif_displaymessage(fd,"You have no progress on any Achievement.");
+		return 0;
+	}
+
+	for( i = 0; i < sd->achievement_count; i++ )
+	{
+		sad = &sd->achievement[i];
+		if( !sad->id || (ad = achievement_search(sad->id)) == NULL )
+			continue;
+
+		if( sad->completed )
+			safestrncpy(rate,"100.00%",sizeof(rate));
+		else
+		{
+			x = 0;
+			y = 0;
+
+			for( j = 0; j < ad->objectives; j++ )
+			{
+				x += ad->ao[j].count;
+				y += sad->count[j];
+			}
+			if( x <= 0 )
+				safestrncpy(rate,"0.00%",sizeof(rate));
+			else
+				sprintf(rate,"%02.02f%%", (float)y * 100. / (float)x);
+		}
+
+		sprintf(atcmd_output,"[%d] %s. %s Completed.", ad->id, ad->name, rate);
+		clif_displaymessage(fd,atcmd_output);
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(achieve)
+{
+	int i, id = atoi(message);
+	struct achievement_data *ad;
+
+	if( id <= 0 || (ad = achievement_search(id)) == NULL || (i = achievement_index(sd,id)) < 0 )
+	{
+		clif_displaymessage(fd,"Achievement ID not found.");
+		return -1;
+	}
+
+	if( sd->achievement[i].completed )
+	{
+		clif_displaymessage(fd,"Achievement already completed.");
+		return -1;
+	}
+
+	achievement_complete(sd,ad);
+	return 0;
+}
+
+ACMD_FUNC(unachieve)
+{
+	int i, id = atoi(message);
+	struct achievement_data *ad;
+
+	if( id <= 0 || (ad = achievement_search(id)) == NULL )
+	{
+		clif_displaymessage(fd,"Achievement ID not found.");
+		return -1;
+	}
+
+	ARR_FIND(0,sd->achievement_count,i,sd->achievement[i].id == id);
+	if( i < sd->achievement_count )
+	{
+		if( sd->achievement_count-- < ACHIEVEMENT_MAX && sd->achievement[i+1].id )
+			memmove(&sd->achievement[i], &sd->achievement[i+1], sizeof(struct s_achievement)*(sd->achievement_count-i));
+
+		memset(&sd->achievement[sd->achievement_count],0,sizeof(struct s_achievement));
+		sd->save_achievement = true;
+		clif_displaymessage(fd,"Achievement removed at all from this Character.");
+	}
+	else
+		clif_displaymessage(fd,"Achievement not available for this Character.");
+
+	return 0;
+}
+
+ACMD_FUNC(reloadachievements)
+{
+	achievement_db_load(true);
+	clif_displaymessage(fd,"Achievement Database loaded.");
+	return 0;
+}
+
+/*==========================================
+ * Faction System
+ *------------------------------------------*/
+ACMD_FUNC(faction)
+{
+	int id = atoi(message);
+	struct faction_data* faction;
+
+	if( id <= 0 || (faction = faction_search(id)) == NULL )
+	{
+		clif_displaymessage(fd,"Faction not found. Use @faction <Faction ID>");
+		return -1;
+	}
+
+	sd->status.faction_id = id;
+	snprintf(atcmd_output,sizeof(atcmd_output),"- You have joined the faction [ %s ] -",faction->name);
+	clif_broadcast2(&sd->bl,atcmd_output,strlen(atcmd_output) + 1,0xFFA500,0x190,20,0,0,SELF);
+	status_calc_pc(sd,0);
+	sd->lang_id = faction->lang_id;
+
+	return 0;
+}
+
+ACMD_FUNC(language)
+{
+	int id = atoi(message);
+	struct lang_data* ld;
+
+	if( !strcmpi(message,"off") )
+	{
+		struct faction_data* faction = faction_search(sd->status.faction_id);
+		if( !faction || faction->lang_id == 0 )
+		{
+			sd->lang_id = 0;
+			clif_displaymessage(fd,"Now you will speak normally to everybody.");
+		}
+		else
+		{
+			if( faction->lang_id && (ld = lang_search(faction->lang_id)) != NULL )
+			{
+				sd->lang_id = faction->lang_id;
+				snprintf(atcmd_output,sizeof(atcmd_output),"Now you will speak and understand '%s' language.",ld->name);
+				clif_displaymessage(fd,atcmd_output);
+			}
+			else
+			{
+				sd->lang_id = 0;
+				clif_displaymessage(fd,"Now you will speak normally to everybody.");
+			}
+		}
+		return 0;
+	}
+
+	if( id <= 0 || (ld = lang_search(id)) == NULL || !ld->max_len )
+	{
+		clif_displaymessage(fd,"Invalid or Disabled Language. Use @language <Lang ID>");
+		return -1;
+	}
+
+	if( !pc_has_permission(sd,PC_PERM_JOIN_ALL_CHAT) && !(sd->lang_mastery&lang_pow[id-1]) )
+	{
+		sprintf(atcmd_output,"You don't know '%s'. Learn it with @learnlang %d",ld->name,id);
+		clif_displaymessage(fd,atcmd_output);
+		return -1;	
+	}
+
+	sd->lang_id = id;
+	snprintf(atcmd_output,sizeof(atcmd_output),"Now you will speak and understand '%s'.",ld->name);
+	clif_displaymessage(fd,atcmd_output);
+	return 0;
+}
+
+ACMD_FUNC(learnlang)
+{
+	int id = atoi(message);
+	struct lang_data* ld;
+
+	if( id <= 0 || (ld = lang_search(id)) == NULL )
+	{
+		clif_displaymessage(fd,"Invalid Language. Use @learnlang <Lang ID>");
+		return -1;
+	}
+
+	if( sd->lang_mastery&lang_pow[id-1] )
+	{
+		sprintf(atcmd_output,"You already know '%s'. Unlearn it with @unlearnlang %d",ld->name,id);
+		clif_displaymessage(fd,atcmd_output);
+		return -1;
+	}
+
+	sd->lang_mastery |= lang_pow[id-1];
+	pc_setglobalreg(sd,"eAmod_Languages",sd->lang_mastery);
+	snprintf(atcmd_output,sizeof(atcmd_output),"You learn how to speak '%s'. Use @language %d to use it.",ld->name,id);
+	clif_displaymessage(fd,atcmd_output);
+	return 0;
+}
+
+ACMD_FUNC(unlearnlang)
+{
+	int id = atoi(message);
+	struct lang_data* ld;
+
+	if( id <= 0 || (ld = lang_search(id)) == NULL )
+	{
+		clif_displaymessage(fd,"Invalid Language. Use @unlearnlang <Lang ID>");
+		return -1;
+	}
+
+	if( sd->lang_mastery&lang_pow[id-1] )
+	{
+		sd->lang_mastery &= ~lang_pow[id-1];
+		snprintf(atcmd_output,sizeof(atcmd_output),"Now you don't know to speak '%s'.",ld->name);
+		clif_displaymessage(fd,atcmd_output);
+		return 0;
+	}
+
+	sprintf(atcmd_output,"You don't know '%s'. Learn it with @learnlang %d",ld->name,id);
+	clif_displaymessage(fd,atcmd_output);
+	return -1;
+}
+
+ACMD_FUNC(say)
+{
+	if( !message || !*message || strlen(message) < 1 )
+	{
+		clif_displaymessage(fd,"Invalid Message. Use @say <Message>");
+		return -1;
+	}
+
+	memset(atcmd_output,0,sizeof(atcmd_output));
+	lang_convert(atcmd_output,message,sizeof(atcmd_output),sd->lang_id);
+	clif_displaymessage(fd,atcmd_output);
+	return 0;
+}
+
+/*==========================================
+ * type: 1 = commands (@), 2 = charcommands (#)
+ *------------------------------------------*/
+static void atcommand_commands_sub(struct map_session_data* sd, const int fd, AtCommandType type)
 {
 	char line_buff[CHATBOX_SIZE];
 	char *cur = line_buff;
@@ -8910,13 +10927,13 @@
 		ACMD_DEF(divorce),
 		ACMD_DEF(sound),
 		ACMD_DEF(undisguiseall),
-		ACMD_DEF(disguiseall),
-		ACMD_DEF(changelook),
-		ACMD_DEF(autoloot),
-		ACMD_DEF2("alootid", autolootitem),
-		ACMD_DEF(mobinfo),
-		ACMD_DEF(exp),
-		ACMD_DEF(version),
+		ACMD_DEF(disguiseall),
+		ACMD_DEF(changelook),
+		ACMD_DEF(autoloot),
+//		ACMD_DEF2("alootid", autolootitem), Removed by eAmod
+		ACMD_DEF(mobinfo),
+		ACMD_DEF(exp),
+		ACMD_DEF(version),
 		ACMD_DEF(mutearea),
 		ACMD_DEF(rates),
 		ACMD_DEF(iteminfo),
@@ -8936,13 +10953,13 @@
 		ACMD_DEF(partyoption),
 		ACMD_DEF(invite),
 		ACMD_DEF(duel),
-		ACMD_DEF(leave),
-		ACMD_DEF(accept),
-		ACMD_DEF(reject),
-		ACMD_DEF(main),
-		ACMD_DEF(clone),
-		ACMD_DEF2("slaveclone", clone),
-		ACMD_DEF2("evilclone", clone),
+		ACMD_DEF(leave),
+		ACMD_DEF(accept),
+		ACMD_DEF(reject),
+//		ACMD_DEF(main), Removed by eAmod
+		ACMD_DEF(clone),
+		ACMD_DEF2("slaveclone", clone),
+		ACMD_DEF2("evilclone", clone),
 		ACMD_DEF(tonpc),
 		ACMD_DEF(commands),
 		ACMD_DEF(noask),
@@ -8987,7 +11004,68 @@
 		ACMD_DEF(unloadnpcfile),
 		ACMD_DEF(cart),
 		ACMD_DEF(mount2),
-		ACMD_DEF(reload)
+		ACMD_DEF(reload),
+		/**
+		 * eAmod Commands
+		 **/
+		ACMD_DEF2("bounditem",item),
+		ACMD_DEF2("costumeitem",item),
+		ACMD_DEF2("bounditem2",item2),
+		ACMD_DEF(blockskill),
+		ACMD_DEF2("ddrop",displaydrop),
+		ACMD_DEF(autorefresh),
+		ACMD_DEF(showcast),
+		ACMD_DEF(showcastdelay),
+		ACMD_DEF2("undeadmode",residente),
+		ACMD_DEF2("mapdeadcounter",contadormuertes),
+		ACMD_DEF(exppenalty),
+		ACMD_DEF2("power",maspowerr),
+		ACMD_DEF(cityheart),
+		ACMD_DEF(mobdemolition),
+		ACMD_DEF(mobevent),
+		ACMD_DEF(whosell),
+		ACMD_DEF(flooritem),
+		ACMD_DEF(gcash),
+		ACMD_DEF(gpoints),
+		ACMD_DEF(away),
+		ACMD_DEF(create),
+		ACMD_DEF(join),
+		ACMD_DEF(exit),
+		ACMD_DEF(list),
+		ACMD_DEF(pvpmode),
+		ACMD_DEF(whopk),
+		ACMD_DEF(rentstorage),
+		ACMD_DEF(aura),
+		ACMD_DEF(myinfo),
+		ACMD_DEF(expinfo),
+		ACMD_DEF(mission),
+		ACMD_DEF(char2dump),
+		ACMD_DEF(security),
+		ACMD_DEF(packetfilter),
+		ACMD_DEF(guildskill),
+		ACMD_DEF(order),
+		ACMD_DEF(leader),
+		ACMD_DEF(reportafk),
+		ACMD_DEF(listenbg),
+		ACMD_DEF(unboundall),
+		ACMD_DEF(bgranked),
+		ACMD_DEF(bgregular),
+		ACMD_DEF(battleinfo),
+		ACMD_DEF(rankreset),
+		ACMD_DEF2("itemdestroy",item_remove4all),
+		ACMD_DEF(addfame),
+		ACMD_DEF(viewmobinfo),
+		ACMD_DEF2("pctele",teleport),
+		ACMD_DEF2("mobtele",teleport),
+		ACMD_DEF(achievements),
+		ACMD_DEF(achieve),
+		ACMD_DEF(unachieve),
+		ACMD_DEF2("reloadachievedb",reloadachievements),
+		ACMD_DEF(faction),
+		ACMD_DEF(language),
+		ACMD_DEF(learnlang),
+		ACMD_DEF(unlearnlang),
+		ACMD_DEF(say)
 	};
 	AtCommandInfo *atcommand;
 	int i;
Index: src/map/atcommand.h
===================================================================
--- src/map/atcommand.h	(revision 1953)
+++ src/map/atcommand.h	(working copy)
@@ -37,12 +37,13 @@
 
 bool is_atcommand(const int fd, struct map_session_data *sd, const char *message, int type);
 
-void do_init_atcommand(void);
-void do_final_atcommand(void);
-void atcommand_db_load_groups(int *group_ids);
-
-bool atcommand_exists(const char *name);
-
+void do_init_atcommand(void);
+void do_final_atcommand(void);
+void atcommand_db_load_groups(int* group_ids);
+void atcommand_expinfo_sub(int time, int* day, int* hour, int* minute, int* second); // Exp Gain Rates
+
+bool atcommand_exists(const char* name);
+
 const char *msg_txt(int msg_number);
 int msg_config_read(const char *cfgName);
 void do_final_msg(void);
Index: src/map/battle.c
===================================================================
--- src/map/battle.c	(revision 1953)
+++ src/map/battle.c	(working copy)
@@ -25,12 +25,13 @@
 #include "../common/strlib.h"
 #include "../common/utils.h"
 
-#include "map.h"
-#include "path.h"
-#include "pc.h"
-#include "status.h"
-#include "skill.h"
-#include "homunculus.h"
+#include "map.h"
+#include "path.h"
+#include "pc.h"
+#include "pc_groups.h"
+#include "status.h"
+#include "skill.h"
+#include "homunculus.h"
 #include "mercenary.h"
 #include "elemental.h"
 #include "mob.h"
@@ -39,12 +40,13 @@
 #include "pet.h"
 #include "guild.h"
 #include "party.h"
-#include "battle.h"
-#include "battleground.h"
-#include "chrif.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "battle.h"
+#include "battleground.h"
+#include "chrif.h"
+#include "faction.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
@@ -247,22 +249,22 @@
 		if(src && target->m == src->m &&
 		   (target->type != BL_PC || ((TBL_PC *)target)->invincible_timer == INVALID_TIMER) &&
 		   check_distance_bl(src, target, dat->distance)) { //Check to see if you haven't teleported. [Skotlex]
-			map_freeblock_lock();
-			status_fix_damage(src, target, dat->damage, dat->delay);
-			if(dat->attack_type && !status_isdead(target) && dat->additional_effects)
+			map_freeblock_lock();
+			status_fix_damage(src, target, dat->damage, dat->delay, dat->skill_id);
+			if( dat->attack_type && !status_isdead(target) && dat->additional_effects )
 				skill_additional_effect(src,target,dat->skill_id,dat->skill_lv,dat->attack_type,dat->dmg_lv,tick);
 			if(dat->dmg_lv > ATK_BLOCK && dat->attack_type)
 				skill_counter_additional_effect(src,target,dat->skill_id,dat->skill_lv,dat->attack_type,tick);
 			map_freeblock_unlock();
 		} else if(!src && dat->skill_id == CR_REFLECTSHIELD) {
 			/**
-			 * it was monster reflected damage, and the monster died, we pass the damage to the character as expected
-			 **/
-			map_freeblock_lock();
-			status_fix_damage(target, target, dat->damage, dat->delay);
-			map_freeblock_unlock();
-		}
-	}
+			 * it was monster reflected damage, and the monster died, we pass the damage to the character as expected
+			 **/
+			map_freeblock_lock();
+			status_fix_damage(target, target, dat->damage, dat->delay, dat->skill_id);
+			map_freeblock_unlock();
+		}
+	}
 	ers_free(delay_damage_ers, dat);
 	return 0;
 }
@@ -278,13 +280,13 @@
 
 	if(sc && sc->data[SC_DEVOTION] && damage > 0 && skill_id != PA_PRESSURE && skill_id != CR_REFLECTSHIELD)
 		damage = 0;
-
-	if(!battle_config.delay_battle_damage || amotion <= 1) {
-		map_freeblock_lock();
-		status_fix_damage(src, target, damage, ddelay); // We have to seperate here between reflect damage and others [icescope]
-		if(attack_type && !status_isdead(target) && additional_effects)
-			skill_additional_effect(src, target, skill_id, skill_lv, attack_type, dmg_lv, gettick());
-		if(dmg_lv > ATK_BLOCK && attack_type)
+
+	if ( !battle_config.delay_battle_damage || amotion <= 1 ) {
+		map_freeblock_lock();
+		status_fix_damage(src, target, damage, ddelay, skill_id); // We have to seperate here between reflect damage and others [icescope]
+		if( attack_type && !status_isdead(target) && additional_effects )
+			skill_additional_effect(src, target, skill_id, skill_lv, attack_type, dmg_lv, gettick());
+		if( dmg_lv > ATK_BLOCK && attack_type )
 			skill_counter_additional_effect(src, target, skill_id, skill_lv, attack_type, gettick());
 		map_freeblock_unlock();
 		return 0;
@@ -728,20 +730,35 @@
 int battle_calc_damage(struct block_list *src,struct block_list *bl,struct Damage *d,int damage,uint16 skill_id,uint16 skill_lv)
 {
 	struct map_session_data *sd = NULL;
-	struct status_change *sc;
-	struct status_change_entry *sce;
-	int div_ = d->div_, flag = d->flag;
-
-	nullpo_ret(bl);
-
+	struct status_change *sc;
+	struct status_change_entry *sce;
+	int div_ = d->div_, flag = d->flag;
+	struct block_list *s_bl;
+
+	nullpo_ret(bl);
+
 	if(!damage)
 		return 0;
-	if(battle_config.ksprotection && mob_ksprotected(src, bl))
-		return 0;
-
-	if(bl->type == BL_PC) {
-		sd=(struct map_session_data *)bl;
-		//Special no damage states
+	if( battle_config.ksprotection && mob_ksprotected(src, bl) )
+		return 0;
+
+	if( bl->type == BL_MOB )
+	{ // Event Emperiums works like GvG Emperiums
+		struct mob_data *md = BL_CAST(BL_MOB, bl);
+		if( md && md->option.is_event && md->class_ == MOBID_EMPERIUM && flag&BF_SKILL )
+			switch( skill_id )
+			{
+				case MO_TRIPLEATTACK:
+				case HW_GRAVITATION:
+					break;
+				default:
+					return 0;
+			}
+	}
+
+	if (bl->type == BL_PC) {
+		sd=(struct map_session_data *)bl;
+		//Special no damage states
 		if(flag&BF_WEAPON && sd->special_state.no_weapon_damage)
 			damage -= damage * sd->special_state.no_weapon_damage / 100;
 
@@ -831,14 +848,14 @@
 			else if(sce->val1 > 5 && sce->val1 <= 9)
 				delay = 200;
 			else
-				delay = 100;
-			unit_set_walkdelay(bl, gettick(), delay, 1);
+				delay = 100;
+			unit_set_walkdelay(bl, gettick(), delay, 1);
+
+			if(sc->data[SC_SHRINK] && !map[bl->m].flag.ancient && rnd()%100<5*sce->val1)
+				skill_blown(bl,src,skill_get_blewcount(CR_SHRINK,1),-1,0);
+			return 0;
+		}
 
-			if(sc->data[SC_SHRINK] && rnd()%100<5*sce->val1)
-				skill_blown(bl,src,skill_get_blewcount(CR_SHRINK,1),-1,0);
-			return 0;
-		}
-
 		if((sce = sc->data[SC_MILLENNIUMSHIELD]) && sce->val2 > 0 && damage > 0) {
 			clif_skill_nodamage(bl, bl, RK_MILLENNIUMSHIELD, 1, 1);
 			sce->val3 -= damage; // absorb damage
@@ -976,7 +993,9 @@
 		// Assumptio doubles the def & mdef on RE mode, otherwise gives a reduction on the final damage. [Igniz]
 #ifndef RENEWAL
 		if(sc->data[SC_ASSUMPTIO]) {
-			if(map_flag_vs(bl->m))
+			if( map_pvpevent(bl->m) )
+				damage = damage*4/5; //Receive 80% damage
+			else if( map_flag_vs(bl->m) )
 				damage = damage*2/3; //Receive 66% damage
 			else
 				damage >>= 1; //Receive 50% damage
@@ -1180,10 +1199,13 @@
                 if(sc->data[SC_STYLE_CHANGE]) {
                     TBL_HOM *hd = BL_CAST(BL_HOM,src); //when attacking
                     if(hd && (rnd()%100<(20+status_get_lv(bl)/5))) hom_addspiritball(hd, 10);
-                }
+		}
 	}
+	
+	if( !(src && (s_bl = battle_get_master(src)) != NULL) )
+		s_bl = src;
 
-	if(battle_config.pk_mode && sd && bl->type == BL_PC && damage && map[bl->m].flag.pvp) {
+	if( sd && damage && ((battle_config.pk_mode && map[bl->m].flag.pvp) || (s_bl && s_bl->type == BL_PC && (guild_wardamage(sd) || (((TBL_PC *)src)->state.pvpmode && battle_config.pvpmode_gvgreductions)))) ) {
 		if(flag & BF_SKILL) {  //Skills get a different reduction than non-skills. [Skotlex]
 			if(flag&BF_WEAPON)
 				damage = damage * battle_config.pk_weapon_damage_rate / 100;
@@ -1234,12 +1256,53 @@
 	}
 
 	return damage;
-}
-
-/*==========================================
- * Calculates BG related damage adjustments.
- *------------------------------------------*/
-int battle_calc_bg_damage(struct block_list *src, struct block_list *bl, int damage, int div_, uint16 skill_id, uint16 skill_lv, int flag)
+}
+
+/*==========================================
+ * Calculates PVP Event damage adjustments.
+ *------------------------------------------*/
+int battle_calc_pvpevent_damage(struct block_list *src, struct block_list *bl, int damage, int div_, int skill_num, int skill_lv, int flag)
+{
+	if( !damage )
+		return 0;
+
+	switch( skill_num )
+	{
+		case PA_PRESSURE:
+		case HW_GRAVITATION:
+		case NJ_ZENYNAGE:
+		//case RK_DRAGONBREATH:
+		//case GN_HELLS_PLANT_ATK:
+		//case KO_MUCHANAGE:
+			break;
+		default:
+			if( flag&BF_SKILL )
+			{ //Skills get a different reduction than non-skills. [Skotlex]
+				if( flag&BF_WEAPON )
+					damage = damage * battle_config.pvpevent_weapon_damage_rate/100;
+				if( flag&BF_MAGIC )
+					damage = damage * battle_config.pvpevent_magic_damage_rate/100;
+				if(	flag&BF_MISC )
+					damage = damage * battle_config.pvpevent_misc_damage_rate/100;
+			}
+			else
+			{ //Normal attacks get reductions based on range.
+				if( flag&BF_SHORT )
+					damage = damage * battle_config.pvpevent_short_damage_rate/100;
+				if( flag&BF_LONG )
+					damage = damage * battle_config.pvpevent_long_damage_rate/100;
+			}
+			
+			if( !damage ) damage = 1;
+	}
+
+	return damage;
+}
+
+/*==========================================
+ * Calculates BG related damage adjustments.
+ *------------------------------------------*/
+int battle_calc_bg_damage(struct block_list *src, struct block_list *bl, int damage, int div_, uint16 skill_id, uint16 skill_lv, int flag)
 {
 	if(!damage)
 		return 0;
@@ -1278,12 +1341,52 @@
 	}
 
 	return damage;
-}
-
-/*==========================================
- * Calculates GVG related damage adjustments.
- *------------------------------------------*/
-int battle_calc_gvg_damage(struct block_list *src,struct block_list *bl,int damage,int div_,uint16 skill_id,uint16 skill_lv,int flag)
+}
+
+/*==========================================
+ * Calculates Faction related damage adjustments.
+ *------------------------------------------*/
+int battle_calc_faction_damage(struct block_list *src, struct block_list *bl, int damage, int div_, int skill_num, int skill_lv, int flag)
+{
+	if( !damage )
+		return 0;
+	if( (bl && bl->type == BL_MOB) || (src && src->type == BL_MOB) )
+		return damage; // Damage from/to Monsters is not reduced
+
+	switch( skill_num )
+	{
+		case PA_PRESSURE:
+		case HW_GRAVITATION:
+		case NJ_ZENYNAGE:
+			break;
+		default:
+			if( flag&BF_SKILL )
+			{ //Skills get a different reduction than non-skills. [Skotlex]
+				if( flag&BF_WEAPON )
+					damage = damage * battle_config.faction_weapon_damage_rate/100;
+				if( flag&BF_MAGIC )
+					damage = damage * battle_config.faction_magic_damage_rate/100;
+				if(	flag&BF_MISC )
+					damage = damage * battle_config.faction_misc_damage_rate/100;
+			}
+			else
+			{ //Normal attacks get reductions based on range.
+				if( flag&BF_SHORT )
+					damage = damage * battle_config.faction_short_damage_rate/100;
+				if( flag&BF_LONG )
+					damage = damage * battle_config.faction_long_damage_rate/100;
+			}
+			
+			if( !damage ) damage = 1;
+	}
+
+	return damage;
+}
+
+/*==========================================
+ * Calculates GVG related damage adjustments.
+ *------------------------------------------*/
+int battle_calc_gvg_damage(struct block_list *src,struct block_list *bl,int damage,int div_,uint16 skill_id,uint16 skill_lv,int flag)
 {
 	struct mob_data *md = BL_CAST(BL_MOB, bl);
 	int class_ = status_get_class(bl);
@@ -1582,14 +1685,20 @@
 	if(skill) {
 		qty = skill_get_ammo_qty(skill, lv);
 		if(!qty) qty = 1;
-	}
+	}
+
+	if(sd->equip_index[EQI_AMMO]>=0) //Qty check should have been done in skill_check_condition
+	{ 
+		pc_delitem(sd,sd->equip_index[EQI_AMMO],qty,0,1,LOG_TYPE_CONSUME);
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.ammo_used, qty, UINT_MAX);
+		else if( sd->bg_id && map[sd->bl.m].flag.battleground )
+			add2limit(sd->status.bgstats.ammo_used, qty, UINT_MAX);
+	}
+
+	sd->state.arrow_atk = 0;
+}
 
-	if(sd->equip_index[EQI_AMMO]>=0) //Qty check should have been done in skill_check_condition
-		pc_delitem(sd,sd->equip_index[EQI_AMMO],qty,0,1,LOG_TYPE_CONSUME);
-
-	sd->state.arrow_atk = 0;
-}
-
 static int battle_range_type(
     struct block_list *src, struct block_list *target,
     uint16 skill_id, uint16 skill_lv)
@@ -1631,12 +1740,44 @@
 		if(sd->skillblown[i].id == skill_id)
 			return sd->skillblown[i].val;
 	}
-	return 0;
-}
-
-struct Damage battle_calc_magic_attack(struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
-struct Damage battle_calc_misc_attack(struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
-
+	return 0;
+}
+
+static int battle_SAD(struct map_session_data *sd, struct block_list *target, int skill_num)
+{
+	int dmg = 0;
+	int flag = map[sd->bl.m].flag.restricted?8*map[sd->bl.m].zone:0;
+
+	if(skill_db[skill_num].flag&1 && !map_flag_vs(sd->bl.m) ||
+		skill_db[skill_num].flag&2 && map[sd->bl.m].flag.pvp ||
+		skill_db[skill_num].flag&4 && map_flag_gvg(sd->bl.m) ||
+		skill_db[skill_num].flag&8 && map[sd->bl.m].flag.battleground ||
+		map[sd->bl.m].flag.restricted && skill_db[skill_num].flag&flag)
+	{
+		
+		switch(target->type)
+		{
+			case BL_PC:
+				dmg = skill_db[skill_num].pc_damage;
+				break;
+			case BL_MOB:
+				if(((TBL_MOB*)target)->status.mode&MD_BOSS)
+					dmg = skill_db[skill_num].boss_damage;
+				else
+					dmg = skill_db[skill_num].mob_damage;
+				break;
+			default:
+				dmg = skill_db[skill_num].other_damage;
+				break;
+		}
+	}
+		
+	return dmg;
+}
+
+struct Damage battle_calc_magic_attack(struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
+struct Damage battle_calc_misc_attack(struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
+
 //For quick div adjustment.
 #define damage_div_fix(dmg, div) { if (div > 1) (dmg)*=div; else if (div < 0) (div)*=-1; }
 /*==========================================
@@ -1676,17 +1817,17 @@
 		nullpo_info(NLP_MARK);
 		return wd;
 	}
-	//Initial flag
-	flag.rh=1;
-	flag.weapon=1;
-	flag.infdef=(tstatus->mode&MD_PLANT && skill_id != RA_CLUSTERBOMB
-#ifdef RENEWAL
-	             && skill_id != HT_FREEZINGTRAP
-#endif
-	             ?1:0);
-	if(target->type == BL_SKILL) {
-		TBL_SKILL *su = (TBL_SKILL *)target;
-		if(su->group && (su->group->skill_id == WM_REVERBERATION || su->group->skill_id == WM_POEMOFNETHERWORLD))
+	//Initial flag
+	flag.rh=1;
+	flag.weapon=1;
+	flag.infdef=((target->type == BL_MOB && ((TBL_MOB*)target)->state.inmunity) || (tstatus->mode&MD_PLANT && skill_id != RA_CLUSTERBOMB 
+#ifdef RENEWAL
+		&& skill_id != HT_FREEZINGTRAP
+#endif
+		))?1:0;
+	if( target->type == BL_SKILL){
+		TBL_SKILL *su = (TBL_SKILL*)target;
+		if( su->group && (su->group->skill_id == WM_REVERBERATION || su->group->skill_id == WM_POEMOFNETHERWORLD) )
 			flag.infdef = 1;
 	}
 
@@ -2011,13 +2152,13 @@
 					break;
 				case KN_PIERCE:
 				case ML_PIERCE:
-					hitrate += hitrate * 5 * skill_lv / 100;
-					break;
-				case AS_SONICBLOW:
-					if(sd && pc_checkskill(sd,AS_SONICACCEL)>0)
-						hitrate += hitrate * 50 / 100;
-					break;
-				case MC_CARTREVOLUTION:
+				hitrate += hitrate * 5 * skill_lv / 100;
+				break;
+			case AS_SONICBLOW:
+				if( sd && pc_checkskill(sd,AS_SONICACCEL) > 0 && !map[sd->bl.m].flag.ancient )
+					hitrate += hitrate * 50 / 100;
+				break;
+			case MC_CARTREVOLUTION:
 				case GN_CART_TORNADO:
 				case GN_CARTCANNON:
 					if(sd && pc_checkskill(sd, GN_REMODELING_CART))
@@ -3101,16 +3242,16 @@
 		}
 
 		switch(skill_id) {
-			case AS_SONICBLOW:
+			case AS_SONICBLOW:
+				if (sc && sc->data[SC_SPIRIT] &&
+					sc->data[SC_SPIRIT]->val2 == SL_ASSASIN)
+					ATK_ADDRATE(map_flag_gvg3(src->m)?25:100); //+25% dmg on woe/+100% dmg on nonwoe
+
+				if(sd && pc_checkskill(sd,AS_SONICACCEL)>0 && !map[sd->bl.m].flag.ancient)
+					ATK_ADDRATE(10);
+			break;
+			case CR_SHIELDBOOMERANG:
 				if(sc && sc->data[SC_SPIRIT] &&
-				   sc->data[SC_SPIRIT]->val2 == SL_ASSASIN)
-					ATK_ADDRATE(map_flag_gvg(src->m)?25:100); //+25% dmg on woe/+100% dmg on nonwoe
-
-				if(sd && pc_checkskill(sd,AS_SONICACCEL)>0)
-					ATK_ADDRATE(10);
-				break;
-			case CR_SHIELDBOOMERANG:
-				if(sc && sc->data[SC_SPIRIT] &&
 				   sc->data[SC_SPIRIT]->val2 == SL_CRUSADER)
 					ATK_ADDRATE(100);
 				break;
@@ -3124,6 +3265,9 @@
 			ATK_RATE(i);
 
 		if(sd) {
+		
+			ATK_ADDRATE(battle_SAD(sd,target,skill_id));
+		
 			if(skill_id && (i = pc_skillatk_bonus(sd, skill_id)))
 				ATK_ADDRATE(i);
 
@@ -3487,28 +3631,27 @@
 
 	if(wd.damage + wd.damage2) {
 		//There is a total damage value
-		if(!wd.damage2) {
+		if( wd.damage ) {
 			wd.damage = battle_calc_damage(src,target,&wd,wd.damage,skill_id,skill_lv);
 			if(map_flag_gvg2(target->m))
-				wd.damage=battle_calc_gvg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
+				wd.damage = battle_calc_gvg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
 			else if(map[target->m].flag.battleground)
-				wd.damage=battle_calc_bg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
-		} else if(!wd.damage) {
+				wd.damage = battle_calc_bg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
+			else if( map_pvpevent(target->m) )
+				wd.damage = battle_calc_pvpevent_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
+			else if( map[target->m].flag.fvf )
+				wd.damage = battle_calc_faction_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
+		} 
+		if( wd.damage2 ) {
 			wd.damage2 = battle_calc_damage(src,target,&wd,wd.damage2,skill_id,skill_lv);
 			if(map_flag_gvg2(target->m))
 				wd.damage2 = battle_calc_gvg_damage(src,target,wd.damage2,wd.div_,skill_id,skill_lv,wd.flag);
 			else if(map[target->m].flag.battleground)
-				wd.damage = battle_calc_bg_damage(src,target,wd.damage2,wd.div_,skill_id,skill_lv,wd.flag);
-		} else {
-			int d1 = wd.damage + wd.damage2,d2 = wd.damage2;
-			wd.damage = battle_calc_damage(src,target,&wd,d1,skill_id,skill_lv);
-			if(map_flag_gvg2(target->m))
-				wd.damage = battle_calc_gvg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
-			else if(map[target->m].flag.battleground)
-				wd.damage = battle_calc_bg_damage(src,target,wd.damage,wd.div_,skill_id,skill_lv,wd.flag);
-			wd.damage2 = d2*100/d1 * wd.damage/100;
-			if(wd.damage > 1 && wd.damage2 < 1) wd.damage2 = 1;
-			wd.damage-=wd.damage2;
+				wd.damage2 = battle_calc_bg_damage(src,target,wd.damage2,wd.div_,skill_id,skill_lv,wd.flag);
+			else if( map_pvpevent(target->m) )
+				wd.damage2 = battle_calc_pvpevent_damage(src,target,wd.damage2,wd.div_,skill_id,skill_lv,wd.flag);
+			else if( map[target->m].flag.fvf )
+				wd.damage2 = battle_calc_faction_damage(src,target,wd.damage2,wd.div_,skill_id,skill_lv,wd.flag);
 		}
 	}
 	//Reject Sword bugreport:4493 by Daegaladh
@@ -3518,13 +3661,13 @@
 	        ((TBL_PC *)src)->weapontype1 == W_1HSWORD ||
 	        ((TBL_PC *)src)->status.weapon == W_2HSWORD
 	    )) &&
-	   rnd()%100 < tsc->data[SC_REJECTSWORD]->val2
-	  ) {
-		ATK_RATER(50)
-		status_fix_damage(target,src,wd.damage,clif_damage(target,src,gettick(),0,0,wd.damage,0,0,0));
-		clif_skill_nodamage(target,target,ST_REJECTSWORD,tsc->data[SC_REJECTSWORD]->val1,1);
-		if(--(tsc->data[SC_REJECTSWORD]->val3) <= 0)
-			status_change_end(target, SC_REJECTSWORD, INVALID_TIMER);
+		rnd()%100 < tsc->data[SC_REJECTSWORD]->val2
+		) {
+		ATK_RATER(50)
+		status_fix_damage(target,src,wd.damage,clif_damage(target,src,gettick(),0,0,wd.damage,0,0,0),ST_REJECTSWORD);
+		clif_skill_nodamage(target,target,ST_REJECTSWORD,tsc->data[SC_REJECTSWORD]->val1,1);
+		if( --(tsc->data[SC_REJECTSWORD]->val3) <= 0 )
+			status_change_end(target, SC_REJECTSWORD, INVALID_TIMER);
 	}
 	if(skill_id == ASC_BREAKER) {   //Breaker's int-based damage (a misc attack?)
 		struct Damage md = battle_calc_misc_attack(src, target, skill_id, skill_lv, wflag);
@@ -3633,13 +3776,13 @@
 		sd->state.arrow_atk = 0;
 		ad.blewcount += battle_blewcount_bonus(sd, skill_id);
 	}
-
-	//Skill Range Criteria
-	ad.flag |= battle_range_type(src, target, skill_id, skill_lv);
-	flag.infdef=(tstatus->mode&MD_PLANT?1:0);
-	if(target->type == BL_SKILL) {
-		TBL_SKILL *su = (TBL_SKILL *)target;
-		if(su->group && (su->group->skill_id == WM_REVERBERATION || su->group->skill_id == WM_POEMOFNETHERWORLD))
+
+	//Skill Range Criteria
+	ad.flag |= battle_range_type(src, target, skill_id, skill_lv);
+	flag.infdef=((tstatus->mode&MD_PLANT || (target->type == BL_MOB && ((TBL_MOB*)target)->state.inmunity))?1:0);
+	if( target->type == BL_SKILL){
+		TBL_SKILL *su = (TBL_SKILL*)target;
+		if( su->group && (su->group->skill_id == WM_REVERBERATION || su->group->skill_id == WM_POEMOFNETHERWORLD) )
 			flag.infdef = 1;
 	}
 
@@ -4127,10 +4270,12 @@
 		}
 #ifdef RENEWAL
 		ad.damage = battle_calc_cardfix(BF_MAGIC, src, target, nk, s_ele, 0, ad.damage, 0, ad.flag);
-#endif
-		if(sd) {
-			//Damage bonuses
-			if((i = pc_skillatk_bonus(sd, skill_id)))
+#endif
+		if(sd) {
+			MATK_ADDRATE(battle_SAD(sd,target,skill_id));
+
+			//Damage bonuses
+			if ((i = pc_skillatk_bonus(sd, skill_id)))
 				ad.damage += ad.damage*i/100;
 			
 			if((i = battle_adjust_skill_damage(src->m,skill_id)))
@@ -4511,14 +4656,20 @@
 
 	md.damage =  battle_calc_cardfix(BF_MISC, src, target, nk, s_ele, 0, md.damage, 0, md.flag);
 
-	if(sd && (i = pc_skillatk_bonus(sd, skill_id)))
-		md.damage += md.damage*i/100;
+	if(sd ) {
+		md.damage = md.damage += md.damage * battle_SAD(sd,target,skill_id) / 100;
+ 
+		if( (i = pc_skillatk_bonus(sd, skill_id)) )
+			md.damage += (int64)md.damage*i/100;
+	}
 
 	if((i = battle_adjust_skill_damage(src->m,skill_id)))
 		md.damage = md.damage * i / 100;
 
 	if(md.damage < 0)
 		md.damage = 0;
+	else if(md.damage && target->type == BL_MOB && ((TBL_MOB*)target)->state.inmunity)
+		md.damage = 1;
 	else if(md.damage && tstatus->mode &MD_PLANT) {
 		switch(skill_id) {
 			case HT_LANDMINE:
@@ -4543,12 +4694,16 @@
 
 	md.damage=battle_calc_damage(src,target,&md,md.damage,skill_id,skill_lv);
 	if(map_flag_gvg2(target->m))
-		md.damage=battle_calc_gvg_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
-	else if(map[target->m].flag.battleground)
-		md.damage=battle_calc_bg_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
-
-	switch(skill_id) {
-		case RA_FIRINGTRAP:
+		md.damage=battle_calc_gvg_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
+	else if( map[target->m].flag.battleground )
+		md.damage=battle_calc_bg_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
+	else if( map_pvpevent(target->m) )
+		md.damage=battle_calc_pvpevent_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
+	if( map[target->m].flag.fvf )
+		md.damage=battle_calc_faction_damage(src,target,md.damage,md.div_,skill_id,skill_lv,md.flag);
+
+	switch( skill_id ) {
+		case RA_FIRINGTRAP:
 		case RA_ICEBOUNDTRAP:
 			if(md.damage == 1) break;
 		case RA_CLUSTERBOMB: {
@@ -4556,17 +4711,23 @@
 				wd = battle_calc_weapon_attack(src,target,skill_id,skill_lv,mflag);
 				md.damage += wd.damage;
 			}
-			break;
-		case NJ_ZENYNAGE:
-			if(sd) {
-				if(md.damage > sd->status.zeny)
-					md.damage = sd->status.zeny;
-				pc_payzeny(sd, md.damage,LOG_TYPE_STEAL,NULL);
-			}
-			break;
-	}
-
-	return md;
+			break;
+		case NJ_ZENYNAGE:
+			if( sd ) {
+				int j;
+				if( battle_config.skill_zeny2item && (j = pc_search_inventory(sd,battle_config.skill_zeny2item)) >= 0 )
+					pc_delitem(sd,j,1,0,0,LOG_TYPE_CONSUME);
+				else
+				{
+					if ( md.damage > sd->status.zeny )
+						md.damage=sd->status.zeny;
+					pc_payzeny(sd, md.damage,LOG_TYPE_STEAL,NULL);
+				}
+			}
+			break;
+	}
+
+	return md;
 }
 /*==========================================
  * Battle main entry, from skill_attack
@@ -4731,13 +4892,13 @@
 		map_freeblock_lock();
 		if(src->type == BL_PC)
 			battle_drain((TBL_PC *)src, bl, damage, damage, status_get_race(bl), is_boss(bl));
-		if(amotion)
-			battle_delay_damage(tick, amotion,src,bl,0,CR_REFLECTSHIELD,0,damage,ATK_DEF,0,true);
-		else
-			status_fix_damage(src,bl,damage,0);
-		clif_damage(bl,bl,tick,amotion,dmotion,damage,1,ATK_BLOCK,0);
-		skill_additional_effect(src, bl, CR_REFLECTSHIELD, 1, BF_WEAPON|BF_SHORT|BF_NORMAL,ATK_DEF,tick);
-		map_freeblock_unlock();
+		if( amotion )
+			battle_delay_damage(tick, amotion,src,bl,0,CR_REFLECTSHIELD,0,damage,ATK_DEF,0,true);
+		else
+			status_fix_damage(src,bl,damage,0,LG_REFLECTDAMAGE);
+		clif_damage(bl,bl,tick,amotion,dmotion,damage,1,ATK_BLOCK,0);
+		skill_additional_effect(src, bl, CR_REFLECTSHIELD, 1, BF_WEAPON|BF_SHORT|BF_NORMAL,ATK_DEF,tick);
+		map_freeblock_unlock();
 	}
 
 	return 0;
@@ -4977,7 +5138,7 @@
 			       (d_bl->type == BL_PC && ((TBL_PC *)d_bl)->devotion[sce->val2] == target->id)
 			   ) && check_distance_bl(target, d_bl, sce->val3)) {
 				clif_damage(d_bl, d_bl, gettick(), 0, 0, damage, 0, 0, 0);
-				status_fix_damage(NULL, d_bl, damage, 0);
+				status_fix_damage(NULL, d_bl, damage, 0, CR_DEVOTION);
 			} else
 				status_change_end(target, SC_DEVOTION, INVALID_TIMER);
 		} else if(tsc->data[SC_CIRCLE_OF_FIRE_OPTION] && (wd.flag&BF_SHORT) && target->type == BL_PC) {
@@ -5186,12 +5347,14 @@
 	struct block_list *s_bl = src, *t_bl = target;
 
 	nullpo_ret(src);
-	nullpo_ret(target);
-
-	m = target->m;
-
-	//t_bl/s_bl hold the 'master' of the attack, while src/target are the actual
-	//objects involved.
+	nullpo_ret(target);
+
+	m = target->m;
+	if( flag&BCT_ENEMY && (map_getcell(m,src->x,src->y,CELL_CHKBASILICA) || map_getcell(m,target->x,target->y,CELL_CHKBASILICA)) )
+		return -1;
+
+	//t_bl/s_bl hold the 'master' of the attack, while src/target are the actual
+	//objects involved.
 	if((t_bl = battle_get_master(target)) == NULL)
 		t_bl = target;
 
@@ -5307,12 +5470,14 @@
 				struct map_session_data *sd;
 				if(t_bl == s_bl) break;
 				sd = BL_CAST(BL_PC, t_bl);
-
-				if(sd->state.monster_ignore && flag&BCT_ENEMY)
-					return 0; // Global inminuty only to Attacks
-				if(sd->status.karma && s_bl->type == BL_PC && ((TBL_PC *)s_bl)->status.karma)
-					state |= BCT_ENEMY; // Characters with bad karma may fight amongst them
-				if(sd->state.killable) {
+
+			if( sd->state.monster_ignore && flag&BCT_ENEMY )
+				return 0; // Global inminuty only to Attacks
+			if( sd->state.pvpmode && s_bl->type == BL_PC && !((TBL_PC*)s_bl)->state.pvpmode )
+				return 0; // Cannot target
+			if( sd->status.karma && s_bl->type == BL_PC && ((TBL_PC*)s_bl)->status.karma )
+				state |= BCT_ENEMY; // Characters with bad karma may fight amongst them
+			if( sd->state.killable ) {
 					state |= BCT_ENEMY; // Everything can kill it
 					strip_enemy = 0;
 				}
@@ -5362,10 +5527,40 @@
 				if(pc_has_permission(sd, PC_PERM_NOT_ATTACK) && (t_bl->type != BL_NUL))
 					return 0;
 				if(s_bl != t_bl) {
+					if( t_bl->type == BL_MOB && ((TBL_MOB*)t_bl)->option.is_event )
+					{
+						struct mob_data *md = BL_CAST(BL_MOB,t_bl);
+
+						if( map[m].flag.gvg && md->option.guild_id && !sd->status.guild_id )
+							return 0;
+
+						if( md->option.is_war && (!sd->status.guild_id || !guild_isenemy(sd->status.guild_id,md->option.guild_id) ) )
+							return 0;
+
+						if( md->option.ai_type == 1 )
+							state |= BCT_PARTY;
+						else if( md->option.ai_type == 3 )
+							return 0;
+					}
 					if(sd->state.killer) {
 						state |= BCT_ENEMY; // Can kill anything
 						strip_enemy = 0;
-					} else if(sd->duel_group && !((!battle_config.duel_allow_pvp && map[m].flag.pvp) || (!battle_config.duel_allow_gvg && map_flag_gvg(m)))) {
+					} 
+					else if( sd->state.pvpmode )
+					{
+						if( t_bl->type == BL_PC && ((TBL_PC*)t_bl)->state.pvpmode )
+						{
+							if( sd->status.party_id && sd->status.party_id == status_get_party_id(t_bl) )
+							state |= BCT_PARTY;
+							else {
+								state |= BCT_ENEMY;
+								strip_enemy = 0;
+							}
+						}
+						else if( battle_config.pvpmode_onlypc )
+							return 0; // Can't target anything else
+					}					
+					else if(sd->duel_group && !((!battle_config.duel_allow_pvp && map[m].flag.pvp) || (!battle_config.duel_allow_gvg && map_flag_gvg(m)))) {
 						if(t_bl->type == BL_PC && (sd->duel_group == ((TBL_PC *)t_bl)->duel_group))
 							return (BCT_ENEMY&flag)?1:-1; // Duel targets can ONLY be your enemy, nothing else.
 						else
@@ -5382,6 +5577,36 @@
 				struct mob_data *md = BL_CAST(BL_MOB, s_bl);
 				if(!((agit_flag || agit2_flag) && map[m].flag.gvg_castle) && md->guardian_data && md->guardian_data->guild_id)
 					return 0; // Disable guardians/emperium owned by Guilds on non-woe times.
+					
+				if( md->option.is_event )
+				{
+					if( t_bl->type == BL_PC )
+					{
+						struct map_session_data *sd = BL_CAST(BL_PC, t_bl);
+						if( map[m].region_id && md->option.is_war && !map_flag_vs(m) && !guild_isenemy(md->option.guild_id, sd->status.guild_id) )
+							return 0; // War mobs ignores non enemy guilds
+						if( md->option.ai_type == 1 )
+							state |= BCT_PARTY;
+						else if( md->option.ai_type == 3 )
+							return 0;
+					}
+					else if( t_bl->type == BL_MOB && ((TBL_MOB*)t_bl)->option.is_event )
+					{ // Mob VS Mob
+						struct mob_data *t_md = BL_CAST(BL_MOB, t_bl);
+						if( map[m].flag.gvg && md->option.guild_id != t_md->option.guild_id && !guild_isallied(md->option.guild_id, t_md->option.guild_id) ) {
+							state |= BCT_ENEMY;
+							strip_enemy = 0;
+						}
+						else if( map[m].flag.pvp && md->option.party_id != t_md->option.party_id ) {
+							state |= BCT_ENEMY;
+							strip_enemy = 0;
+						}
+						else if( map[m].flag.fvf && md->option.faction_id != t_md->option.faction_id ) {
+							state |= BCT_ENEMY;
+							strip_enemy = 0;
+						}
+					}
+				}
 
 				if(!md->special_state.ai) {
 					//Normal mobs
@@ -5431,23 +5656,42 @@
 			tbg_id = bg_team_get_id(t_bl);
 		}
 		if(flag&(BCT_PARTY|BCT_ENEMY)) {
-			int s_party = status_get_party_id(s_bl);
-			if(s_party && s_party == status_get_party_id(t_bl) && !(map[m].flag.pvp && map[m].flag.pvp_noparty) && !(map_flag_gvg(m) && map[m].flag.gvg_noparty) && (!map[m].flag.battleground || sbg_id == tbg_id))
-				state |= BCT_PARTY;
+			int s_party = status_get_party_id(s_bl);
+			if( map[m].flag.battleground && sbg_id && sbg_id == tbg_id )
+				state |= BCT_PARTY; // On Battleground, same team works like Party
+			else if( !map[m].flag.battleground && s_party && s_party == status_get_party_id(t_bl) && !(map[m].flag.pvp && map[m].flag.pvp_noparty) && !(map_flag_gvg(m) && map[m].flag.gvg_noparty) && !map[m].flag.fvf )
+				state |= BCT_PARTY;
 			else
 				state |= BCT_ENEMY;
 		}
 		if(flag&(BCT_GUILD|BCT_ENEMY)) {
 			int s_guild = status_get_guild_id(s_bl);
-			int t_guild = status_get_guild_id(t_bl);
-			if(!(map[m].flag.pvp && map[m].flag.pvp_noguild) && s_guild && t_guild && (s_guild == t_guild || guild_isallied(s_guild, t_guild)) && (!map[m].flag.battleground || sbg_id == tbg_id))
-				state |= BCT_GUILD;
-			else
-				state |= BCT_ENEMY;
-		}
-		if(state&BCT_ENEMY && map[m].flag.battleground && sbg_id && sbg_id == tbg_id)
-			state &= ~BCT_ENEMY;
-
+			int t_guild = status_get_guild_id(t_bl);
+			if( map[m].flag.battleground && sbg_id && sbg_id == tbg_id )
+				state |= BCT_GUILD; // On Battleground, same team works like Guild
+			else if( !map[m].flag.battleground && s_guild && t_guild && (s_guild == t_guild || (!map[m].flag.gvg_noalliance && guild_isallied(s_guild, t_guild))) && !(map[m].flag.pvp && map[m].flag.pvp_noguild) && !map_pvpevent(m) && !map[m].flag.fvf )
+				state |= BCT_GUILD;
+			else if( map_blocked_woe(m) )
+				state |= BCT_GUILD;
+			else
+				state |= BCT_ENEMY;
+		}
+		if( state&BCT_ENEMY )
+		{
+			int id;
+			if( map[m].flag.battleground && sbg_id && sbg_id == tbg_id )
+				state &= ~BCT_ENEMY;
+			if( map[m].flag.fvf && (status_get_faction_id(s_bl) == status_get_faction_id(t_bl) || ((id = faction_get_alliance(s_bl)) > 0 && id == faction_get_alliance(t_bl))) )
+				state &= ~BCT_ENEMY;
+		}
+		if( s_bl->type == BL_PC && t_bl->type == BL_PC && map_pvpevent(m) && map[m].pvpe_area )
+		{ // Removes Enemy state if not on event area
+			if( s_bl->x < map[m].pvpe_x1 || s_bl->x > map[m].pvpe_x2 || s_bl->y < map[m].pvpe_y1 || s_bl->y > map[m].pvpe_y2 )
+				state &= ~BCT_ENEMY;
+			if( t_bl->x < map[m].pvpe_x1 || t_bl->x > map[m].pvpe_x2 || t_bl->y < map[m].pvpe_y1 || t_bl->y > map[m].pvpe_y2 )
+				state &= ~BCT_ENEMY;
+		}
+
 		if(state&BCT_ENEMY && battle_config.pk_mode && !map_flag_gvg(m) && s_bl->type == BL_PC && t_bl->type == BL_PC) {
 			// Prevent novice engagement on pk_mode (feature by Valaris)
 			TBL_PC *sd = (TBL_PC *)s_bl, *sd2 = (TBL_PC *)t_bl;
@@ -5463,6 +5707,14 @@
 	}//end map_flag_vs chk rivality
 	else {
 		//Non pvp/gvg, check party/guild settings.
+		if( battle_config.guild_wars && !map_flag_noguildwar(m) && !(agit_flag || agit2_flag) )
+		{
+			int s_guild = status_get_guild_id(s_bl);
+			int t_guild = status_get_guild_id(t_bl);
+
+			if( s_guild && t_guild && s_guild != t_guild && guild_isenemy(s_guild, t_guild) )
+				state |= BCT_ENEMY;
+		}
 		if(flag&BCT_PARTY || state&BCT_ENEMY) {
 			int s_party = status_get_party_id(s_bl);
 			if(s_party && s_party == status_get_party_id(t_bl))
@@ -5556,12 +5808,16 @@
 	{ "mvp_item_first_get_time",            &battle_config.mvp_item_first_get_time,         10000,  0,      INT_MAX,        },
 	{ "mvp_item_second_get_time",           &battle_config.mvp_item_second_get_time,        10000,  0,      INT_MAX,        },
 	{ "mvp_item_third_get_time",            &battle_config.mvp_item_third_get_time,         2000,   0,      INT_MAX,        },
-	{ "drop_rate0item",                     &battle_config.drop_rate0item,                  0,      0,      1,              },
-	{ "base_exp_rate",                      &battle_config.base_exp_rate,                   100,    0,      INT_MAX,        },
-	{ "job_exp_rate",                       &battle_config.job_exp_rate,                    100,    0,      INT_MAX,        },
-	{ "pvp_exp",                            &battle_config.pvp_exp,                         1,      0,      1,              },
-	{ "death_penalty_type",                 &battle_config.death_penalty_type,              0,      0,      2,              },
-	{ "death_penalty_base",                 &battle_config.death_penalty_base,              0,      0,      INT_MAX,        },
+	{ "drop_rate0item",                     &battle_config.drop_rate0item,                  0,      0,      1,              },
+	{ "base_exp_rate",                      &battle_config.base_exp_rate,                   100,    0,      INT_MAX,        },
+	{ "job_exp_rate",                       &battle_config.job_exp_rate,                    100,    0,      INT_MAX,        },
+	{ "base_exp_rate_boss",                 &battle_config.base_exp_rate_boss,              100,    0,      INT_MAX,        },
+	{ "job_exp_rate_boss",                  &battle_config.job_exp_rate_boss,               100,    0,      INT_MAX,        },
+	{ "base_exp_rate_bonus",                &battle_config.base_exp_rate_bonus,             0,      -100,   100,            },
+	{ "job_exp_rate_bonus",                 &battle_config.job_exp_rate_bonus,              0,      -100,   100,            },
+	{ "pvp_exp",                            &battle_config.pvp_exp,                         1,      0,      1,              },
+	{ "death_penalty_type",                 &battle_config.death_penalty_type,              0,      0,      2,              },
+	{ "death_penalty_base",                 &battle_config.death_penalty_base,              0,      0,      INT_MAX,        },
 	{ "death_penalty_job",                  &battle_config.death_penalty_job,               0,      0,      INT_MAX,        },
 	{ "zeny_penalty",                       &battle_config.zeny_penalty,                    0,      0,      INT_MAX,        },
 	{ "hp_rate",                            &battle_config.hp_rate,                         100,    1,      INT_MAX,        },
@@ -5576,15 +5832,17 @@
 	{ "view_range_rate",                    &battle_config.view_range_rate,                 100,    0,      INT_MAX,        },
 	{ "chase_range_rate",                   &battle_config.chase_range_rate,                100,    0,      INT_MAX,        },
 	{ "gtb_sc_immunity",                    &battle_config.gtb_sc_immunity,                 50,     0,      INT_MAX,        },
-	{ "guild_max_castles",                  &battle_config.guild_max_castles,               0,      0,      INT_MAX,        },
-	{ "guild_skill_relog_delay",            &battle_config.guild_skill_relog_delay,         0,      0,      1,              },
-	{ "emergency_call",                     &battle_config.emergency_call,                  11,     0,      31,             },
-	{ "atcommand_spawn_quantity_limit",     &battle_config.atc_spawn_quantity_limit,        100,    0,      INT_MAX,        },
-	{ "atcommand_slave_clone_limit",        &battle_config.atc_slave_clone_limit,           25,     0,      INT_MAX,        },
-	{ "partial_name_scan",                  &battle_config.partial_name_scan,               0,      0,      1,              },
-	{ "player_skillfree",                   &battle_config.skillfree,                       0,      0,      1,              },
-	{ "player_skillup_limit",               &battle_config.skillup_limit,                   1,      0,      1,              },
-	{ "weapon_produce_rate",                &battle_config.wp_rate,                         100,    0,      INT_MAX,        },
+	{ "guild_max_castles",                  &battle_config.guild_max_castles,               0,      0,      INT_MAX,        },
+	{ "guild_skill_relog_delay",            &battle_config.guild_skill_relog_delay,         0,      0,      1,              },
+	{ "emergency_call",                     &battle_config.emergency_call,                  11,     0,      31,             },
+	{ "guild_skills_separed_delay",         &battle_config.guild_skills_separed_delay,      0,      0,      1,              },
+	{ "atcommand_spawn_quantity_limit",     &battle_config.atc_spawn_quantity_limit,        100,    0,      INT_MAX,        },
+	{ "atcommand_slave_clone_limit",        &battle_config.atc_slave_clone_limit,           25,     0,      INT_MAX,        },
+	{ "partial_name_scan",                  &battle_config.partial_name_scan,               0,      0,      1,              },
+	{ "gm_channel_operator",                &battle_config.gm_channel_operator,             20,     0,      100,            },
+	{ "player_skillfree",                   &battle_config.skillfree,                       0,      0,      1,              },
+	{ "player_skillup_limit",               &battle_config.skillup_limit,                   1,      0,      1,              },
+	{ "weapon_produce_rate",                &battle_config.wp_rate,                         100,    0,      INT_MAX,        },
 	{ "potion_produce_rate",                &battle_config.pp_rate,                         100,    0,      INT_MAX,        },
 	{ "monster_active_enable",              &battle_config.monster_active_enable,           1,      0,      1,              },
 	{ "monster_damage_delay_rate",          &battle_config.monster_damage_delay_rate,       100,    0,      INT_MAX,        },
@@ -5600,12 +5858,13 @@
 	{ "force_random_spawn",                 &battle_config.force_random_spawn,              0,      0,      1,              },
 	{ "slaves_inherit_mode",                &battle_config.slaves_inherit_mode,             2,      0,      3,              },
 	{ "slaves_inherit_speed",               &battle_config.slaves_inherit_speed,            3,      0,      3,              },
-	{ "summons_trigger_autospells",         &battle_config.summons_trigger_autospells,      1,      0,      1,              },
-	{ "pc_damage_walk_delay_rate",          &battle_config.pc_walk_delay_rate,              20,     0,      INT_MAX,        },
-	{ "damage_walk_delay_rate",             &battle_config.walk_delay_rate,                 100,    0,      INT_MAX,        },
-	{ "multihit_delay",                     &battle_config.multihit_delay,                  80,     0,      INT_MAX,        },
-	{ "quest_skill_learn",                  &battle_config.quest_skill_learn,               0,      0,      1,              },
-	{ "quest_skill_reset",                  &battle_config.quest_skill_reset,               0,      0,      1,              },
+	{ "summons_trigger_autospells",         &battle_config.summons_trigger_autospells,      1,      0,      1,              },
+	{ "pc_damage_walk_delay_rate",          &battle_config.pc_walk_delay_rate,              20,     0,      INT_MAX,        },
+	{ "damage_walk_delay_rate",             &battle_config.walk_delay_rate,                 100,    0,      INT_MAX,        },
+	{ "damage_walk_delay_rate_boss",        &battle_config.walk_delay_rate_boss,            0,      0,      INT_MAX,        },
+	{ "multihit_delay",                     &battle_config.multihit_delay,                  80,     0,      INT_MAX,        },
+	{ "quest_skill_learn",                  &battle_config.quest_skill_learn,               0,      0,      1,              },
+	{ "quest_skill_reset",                  &battle_config.quest_skill_reset,               0,      0,      1,              },
 	{ "basic_skill_check",                  &battle_config.basic_skill_check,               1,      0,      1,              },
 	{ "guild_emperium_check",               &battle_config.guild_emperium_check,            1,      0,      1,              },
 	{ "guild_exp_limit",                    &battle_config.guild_exp_limit,                 50,     0,      99,             },
@@ -5679,12 +5938,14 @@
 	{ "weapon_defense_type",                &battle_config.weapon_defense_type,             0,      0,      INT_MAX,        },
 	{ "magic_defense_type",                 &battle_config.magic_defense_type,              0,      0,      INT_MAX,        },
 	{ "skill_reiteration",                  &battle_config.skill_reiteration,               BL_NUL, BL_NUL, BL_ALL,         },
-	{ "skill_nofootset",                    &battle_config.skill_nofootset,                 BL_PC,  BL_NUL, BL_ALL,         },
-	{ "player_cloak_check_type",            &battle_config.pc_cloak_check_type,             1,      0,      1|2|4,          },
-	{ "monster_cloak_check_type",           &battle_config.monster_cloak_check_type,        4,      0,      1|2|4,          },
-	{ "sense_type",                         &battle_config.estimation_type,                 1|2,    0,      1|2,            },
-	{ "gvg_short_attack_damage_rate",       &battle_config.gvg_short_damage_rate,           80,     0,      INT_MAX,        },
-	{ "gvg_long_attack_damage_rate",        &battle_config.gvg_long_damage_rate,            80,     0,      INT_MAX,        },
+	{ "skill_nofootset",                    &battle_config.skill_nofootset,                 BL_PC,  BL_NUL, BL_ALL,         },
+	{ "player_cloak_check_type",            &battle_config.pc_cloak_check_type,             1,      0,      1|2|4,          },
+	{ "monster_cloak_check_type",           &battle_config.monster_cloak_check_type,        4,      0,      1|2|4,          },
+	{ "pc_validate_items",                  &battle_config.pc_validate_items,               0,      0,      1               },
+	{ "pc_validate_stats",                  &battle_config.pc_validate_stats,               0,      0,      1               },
+	{ "sense_type",                         &battle_config.estimation_type,                 1|2,    0,      1|2,            },
+	{ "gvg_short_attack_damage_rate",       &battle_config.gvg_short_damage_rate,           80,     0,      INT_MAX,        },
+	{ "gvg_long_attack_damage_rate",        &battle_config.gvg_long_damage_rate,            80,     0,      INT_MAX,        },
 	{ "gvg_weapon_attack_damage_rate",      &battle_config.gvg_weapon_damage_rate,          60,     0,      INT_MAX,        },
 	{ "gvg_magic_attack_damage_rate",       &battle_config.gvg_magic_damage_rate,           60,     0,      INT_MAX,        },
 	{ "gvg_misc_attack_damage_rate",        &battle_config.gvg_misc_damage_rate,            60,     0,      INT_MAX,        },
@@ -5698,13 +5959,13 @@
 	{ "attack_direction_change",            &battle_config.attack_direction_change,         BL_ALL, BL_NUL, BL_ALL,         },
 	{ "land_skill_limit",                   &battle_config.land_skill_limit,                BL_ALL, BL_NUL, BL_ALL,         },
 	{ "monster_class_change_full_recover",  &battle_config.monster_class_change_recover,    1,      0,      1,              },
-	{ "produce_item_name_input",            &battle_config.produce_item_name_input,         0x1|0x2, 0,     0x9F,           },
-	{ "display_skill_fail",                 &battle_config.display_skill_fail,              2,      0,      1|2|4|8,        },
-	{ "chat_warpportal",                    &battle_config.chat_warpportal,                 0,      0,      1,              },
-	{ "mob_warp",                           &battle_config.mob_warp,                        0,      0,      1|2|4,          },
-	{ "dead_branch_active",                 &battle_config.dead_branch_active,              1,      0,      1,              },
-	{ "vending_max_value",                  &battle_config.vending_max_value,               10000000, 1,    MAX_ZENY,       },
-	{ "vending_over_max",                   &battle_config.vending_over_max,                1,      0,      1,              },
+	{ "produce_item_name_input",            &battle_config.produce_item_name_input,         0x1|0x2, 0,     0x9F,           },
+	{ "display_skill_fail",                 &battle_config.display_skill_fail,              2,      0,      1|2|4|8,        },
+	{ "chat_warpportal",                    &battle_config.chat_warpportal,                 0,      0,      1,              },
+	{ "mob_warp",                           &battle_config.mob_warp,                        0,      0,      1|2|4|8,          },
+	{ "dead_branch_active",                 &battle_config.dead_branch_active,              1,      0,      1,              },
+	{ "vending_max_value",                  &battle_config.vending_max_value,               10000000, 1,    MAX_ZENY,       },
+	{ "vending_over_max",                   &battle_config.vending_over_max,                1,      0,      1,              },
 	{ "show_steal_in_same_party",           &battle_config.show_steal_in_same_party,        0,      0,      1,              },
 	{ "party_hp_mode",                      &battle_config.party_hp_mode,                   0,      0,      1,              },
 	{ "show_party_share_picker",            &battle_config.party_show_share_picker,         1,      0,      1,              },
@@ -5840,12 +6101,13 @@
 	{ "mob_max_status_def",                 &battle_config.mob_max_sc_def,                  100,    0,      INT_MAX,        },
 	{ "sg_miracle_skill_ratio",             &battle_config.sg_miracle_skill_ratio,          1,      0,      10000,          },
 	{ "sg_angel_skill_ratio",               &battle_config.sg_angel_skill_ratio,            10,     0,      10000,          },
-	{ "autospell_stacking",                 &battle_config.autospell_stacking,              0,      0,      1,              },
-	{ "override_mob_names",                 &battle_config.override_mob_names,              0,      0,      2,              },
-	{ "min_chat_delay",                     &battle_config.min_chat_delay,                  0,      0,      INT_MAX,        },
-	{ "friend_auto_add",                    &battle_config.friend_auto_add,                 1,      0,      1,              },
-	{ "hom_rename",                         &battle_config.hom_rename,                      0,      0,      1,              },
-	{ "homunculus_show_growth",             &battle_config.homunculus_show_growth,          0,      0,      1,              },
+	{ "autospell_stacking",                 &battle_config.autospell_stacking,              0,      0,      1,              },
+	{ "override_mob_names",                 &battle_config.override_mob_names,              0,      0,      2,              },
+	{ "min_chat_delay",                     &battle_config.min_chat_delay,                  0,      0,      INT_MAX,        },
+	{ "channel_min_chat_delay",             &battle_config.channel_min_chat_delay,          1000,   0,      INT_MAX,        },
+	{ "friend_auto_add",                    &battle_config.friend_auto_add,                 1,      0,      1,              },
+	{ "hom_rename",                         &battle_config.hom_rename,                      0,      0,      1,              },
+	{ "homunculus_show_growth",             &battle_config.homunculus_show_growth,          0,      0,      1,              },
 	{ "homunculus_friendly_rate",           &battle_config.homunculus_friendly_rate,        100,    0,      INT_MAX,        },
 	{ "vending_tax",                        &battle_config.vending_tax,                     0,      0,      10000,          },
 	{ "day_duration",                       &battle_config.day_duration,                    0,      0,      INT_MAX,        },
@@ -5853,17 +6115,24 @@
 	{ "mob_remove_delay",                   &battle_config.mob_remove_delay,                60000,  1000,   INT_MAX,        },
 	{ "mob_active_time",                    &battle_config.mob_active_time,                 0,      0,      INT_MAX,        },
 	{ "boss_active_time",                   &battle_config.boss_active_time,                0,      0,      INT_MAX,        },
-	{ "sg_miracle_skill_duration",          &battle_config.sg_miracle_skill_duration,       3600000, 0,     INT_MAX,        },
-	{ "hvan_explosion_intimate",            &battle_config.hvan_explosion_intimate,         45000,  0,      100000,         },
-	{ "quest_exp_rate",                     &battle_config.quest_exp_rate,                  100,    0,      INT_MAX,        },
-	{ "at_mapflag",                         &battle_config.autotrade_mapflag,               0,      0,      1,              },
-	{ "at_timeout",                         &battle_config.at_timeout,                      0,      0,      INT_MAX,        },
-	{ "homunculus_autoloot",                &battle_config.homunculus_autoloot,             0,      0,      1,              },
-	{ "idle_no_autoloot",                   &battle_config.idle_no_autoloot,                0,      0,      INT_MAX,        },
-	{ "max_guild_alliance",                 &battle_config.max_guild_alliance,              3,      0,      3,              },
-	{ "ksprotection",                       &battle_config.ksprotection,                    5000,   0,      INT_MAX,        },
-	{ "auction_feeperhour",                 &battle_config.auction_feeperhour,              12000,  0,      INT_MAX,        },
-	{ "auction_maximumprice",               &battle_config.auction_maximumprice,            500000000, 0,   MAX_ZENY,       },
+	{ "sg_miracle_skill_duration",          &battle_config.sg_miracle_skill_duration,       3600000, 0,     INT_MAX,        },
+	{ "hvan_explosion_intimate",            &battle_config.hvan_explosion_intimate,         45000,  0,      100000,         },
+	{ "quest_exp_rate",                     &battle_config.quest_exp_rate,                  100,    0,      INT_MAX,        },
+// [Terra Custom Settings]
+	{ "at_mapflag",                         &battle_config.autotrade_mapflag,               0,      0,      1,              },
+	{ "at_timeout",                         &battle_config.at_timeout,                      0,      0,      INT_MAX,        },
+	{ "at_tax",                             &battle_config.at_tax,                          0,      0,      10000,          },
+	{ "homunculus_autoloot",                &battle_config.homunculus_autoloot,             0,      0,      1,              },
+	{ "idle_no_autoloot",                   &battle_config.idle_no_autoloot,                0,      0,      INT_MAX,        },
+	{ "max_guild_alliance",                 &battle_config.max_guild_alliance,              3,      0,      3,              },
+	{ "max_guild_opposition",               &battle_config.max_guild_opposition,            3,      0,      3,              },
+
+	{ "mob_graveyard",                      &battle_config.mob_graveyard,                   0,      0,      1,              },
+	{ "pc_graveyard",                       &battle_config.pc_graveyard,                    0,      0,      1,              },
+
+	{ "ksprotection",                       &battle_config.ksprotection,                    5000,   0,      INT_MAX,        },
+	{ "auction_feeperhour",                 &battle_config.auction_feeperhour,              12000,  0,      INT_MAX,        },
+	{ "auction_maximumprice",               &battle_config.auction_maximumprice,            500000000, 0,   MAX_ZENY,       },
 	{ "homunculus_auto_vapor",              &battle_config.homunculus_auto_vapor,           1,      0,      1,              },
 	{ "display_status_timers",              &battle_config.display_status_timers,           1,      0,      1,              },
 	{ "skill_add_heal_rate",                &battle_config.skill_add_heal_rate,             7,      0,      INT_MAX,        },
@@ -5878,20 +6147,97 @@
 	{ "searchstore_querydelay",             &battle_config.searchstore_querydelay,         10,      0,      INT_MAX,        },
 	{ "searchstore_maxresults",             &battle_config.searchstore_maxresults,         30,      1,      INT_MAX,        },
 	{ "display_party_name",                 &battle_config.display_party_name,              0,      0,      1,              },
-	{ "cashshop_show_points",               &battle_config.cashshop_show_points,            0,      0,      1,              },
-	{ "mail_show_status",                   &battle_config.mail_show_status,                0,      0,      2,              },
-	{ "client_limit_unit_lv",               &battle_config.client_limit_unit_lv,            0,      0,      BL_ALL,         },
-// BattleGround Settings
-	{ "bg_update_interval",                 &battle_config.bg_update_interval,              1000,   100,    INT_MAX,        },
-	{ "bg_short_attack_damage_rate",        &battle_config.bg_short_damage_rate,            80,     0,      INT_MAX,        },
+	{ "cashshop_show_points",               &battle_config.cashshop_show_points,            0,      0,      1,              },
+	{ "mail_show_status",                   &battle_config.mail_show_status,                0,      0,      2,              },
+	{ "client_limit_unit_lv",               &battle_config.client_limit_unit_lv,            0,      0,      BL_ALL,         },
+// [Flood Protection - Automute]
+	{ "chat_allowed_per_interval",          &battle_config.chat_allowed_per_interval,       0,      0,      INT_MAX,        },
+	{ "chat_time_interval",                 &battle_config.chat_time_interval,              0,      0,      INT_MAX,        },
+	{ "chat_flood_automute",                &battle_config.chat_flood_automute,             0,      0,      INT_MAX,        },
+// [Flood Protection - Automute]
+	{ "action_keyboard_limit",              &battle_config.action_keyboard_limit,           0,      0,      500,            },
+	{ "action_mouse_limit",                 &battle_config.action_mouse_limit,              0,      0,      500,            },
+	{ "action_dual_limit",                  &battle_config.action_dual_limit,               0,      0,      1000,           },
+// BattleGround Settings
+	{ "bg_update_interval",                 &battle_config.bg_update_interval,              1000,   100,    INT_MAX,        },
+	{ "bg_short_attack_damage_rate",        &battle_config.bg_short_damage_rate,            80,     0,      INT_MAX,        },
 	{ "bg_long_attack_damage_rate",         &battle_config.bg_long_damage_rate,             80,     0,      INT_MAX,        },
 	{ "bg_weapon_attack_damage_rate",       &battle_config.bg_weapon_damage_rate,           60,     0,      INT_MAX,        },
-	{ "bg_magic_attack_damage_rate",        &battle_config.bg_magic_damage_rate,            60,     0,      INT_MAX,        },
-	{ "bg_misc_attack_damage_rate",         &battle_config.bg_misc_damage_rate,             60,     0,      INT_MAX,        },
-	{ "bg_flee_penalty",                    &battle_config.bg_flee_penalty,                 20,     0,      INT_MAX,        },
-	/**
-	 * rAthena
-	 **/
+	{ "bg_magic_attack_damage_rate",        &battle_config.bg_magic_damage_rate,            60,     0,      INT_MAX,        },
+	{ "bg_misc_attack_damage_rate",         &battle_config.bg_misc_damage_rate,             60,     0,      INT_MAX,        },
+	{ "bg_flee_penalty",                    &battle_config.bg_flee_penalty,                 20,     0,      INT_MAX,        },
+	{ "bg_idle_announce",                   &battle_config.bg_idle_announce,                0,      0,      INT_MAX,        },
+	{ "bg_idle_autokick",                   &battle_config.bg_idle_autokick,                0,      0,      INT_MAX,        },
+	{ "bg_reserved_char_id",                &battle_config.bg_reserved_char_id,             999996, 0,      INT_MAX,        },
+	{ "bg_items_on_pvp",                    &battle_config.bg_items_on_pvp,                 1,      0,      1,              },
+	{ "bg_reward_rates",                    &battle_config.bg_reward_rates,                 100,    0,      INT_MAX,        },
+	{ "bg_ranking_bonus",                   &battle_config.bg_ranking_bonus,                0,      0,      100,            },
+	{ "bg_ranked_mode",                     &battle_config.bg_ranked_mode,                  0,      0,      1,              },
+	{ "bg_ranked_max_games",                &battle_config.bg_ranked_max_games,             50,     10,     100,            },
+	{ "bg_reportafk_leaderonly",            &battle_config.bg_reportafk_leaderonly,         1,      0,      1,              },
+	{ "bg_queue2team_balanced",             &battle_config.bg_queue2team_balanced,          1,      0,      1,              },
+	{ "bg_logincount_check",                &battle_config.bg_logincount_check,             1,      0,      1,              },
+	{ "bg_queue_onlytowns",                 &battle_config.bg_queue_onlytowns,              1,      0,      1,              },
+	{ "bg_eAmod_mode",                      &battle_config.bg_eAmod_mode,                   1,      0,      1,              },
+// Faction System
+	{ "faction_allow_party",                &battle_config.faction_allow_party,             1,      0,      1,              },
+	{ "faction_allow_guild",                &battle_config.faction_allow_guild,             1,      0,      1,              },
+	{ "faction_allow_chat",                 &battle_config.faction_allow_chat,              1,      0,      1,              },
+	{ "faction_allow_vending",              &battle_config.faction_allow_vending,           1,      0,      1,              },
+	{ "faction_allow_trade",                &battle_config.faction_allow_trade,             1,      0,      1,              },
+
+	{ "faction_short_attack_damage_rate",   &battle_config.faction_short_damage_rate,       80,     0,      INT_MAX,        },
+	{ "faction_long_attack_damage_rate",    &battle_config.faction_long_damage_rate,        80,     0,      INT_MAX,        },
+	{ "faction_weapon_attack_damage_rate",  &battle_config.faction_weapon_damage_rate,      60,     0,      INT_MAX,        },
+	{ "faction_magic_attack_damage_rate",   &battle_config.faction_magic_damage_rate,       60,     0,      INT_MAX,        },
+	{ "faction_misc_attack_damage_rate",    &battle_config.faction_misc_damage_rate,        60,     0,      INT_MAX,        },
+// Reserved Character Id's
+	{ "ancient_reserved_char_id",           &battle_config.ancient_reserved_char_id,        999997, 0,      INT_MAX,        },
+	{ "costume_reserved_char_id",           &battle_config.costume_reserved_char_id,        999998, 0,      INT_MAX,        },
+	{ "woe_reserved_char_id",               &battle_config.woe_reserved_char_id,            999999, 0,      INT_MAX,        },
+// PvP Event
+	{ "pvpevent_short_attack_damage_rate",  &battle_config.pvpevent_short_damage_rate,      80,     0,      INT_MAX,        },
+	{ "pvpevent_long_attack_damage_rate",   &battle_config.pvpevent_long_damage_rate,       80,     0,      INT_MAX,        },
+	{ "pvpevent_weapon_attack_damage_rate", &battle_config.pvpevent_weapon_damage_rate,     60,     0,      INT_MAX,        },
+	{ "pvpevent_magic_attack_damage_rate",  &battle_config.pvpevent_magic_damage_rate,      60,     0,      INT_MAX,        },
+	{ "pvpevent_misc_attack_damage_rate",   &battle_config.pvpevent_misc_damage_rate,       60,     0,      INT_MAX,        },
+	{ "pvpevent_flee_penalty",              &battle_config.pvpevent_flee_penalty,           20,     0,      INT_MAX,        },
+	{ "pvpevent_cashperkill",               &battle_config.pvpevent_cashperkill,            0,      0,      INT_MAX,        },
+
+	{ "channel_system_enable",              &battle_config.channel_system_enable,           0,      0,      1,              },
+	{ "channel_announces",                  &battle_config.channel_announces,               0,      0,      1|2|4|8|16,     },
+	{ "channel_announce_join",              &battle_config.channel_announce_join,           0,      0,      1,              },
+	{ "skill_zeny2item",                    &battle_config.skill_zeny2item,                 0,      0,      INT_MAX,        },
+
+	{ "myinfo_event_vote_points",           &battle_config.myinfo_event_vote_points,        0,      0,      1,              },
+	{ "vending_cash_id",                    &battle_config.vending_cash_id,                 0,      0,      INT_MAX,        },
+	{ "vending_zeny_id",                    &battle_config.vending_zeny_id,                 0,      0,      INT_MAX,        },
+
+	{ "pvpmode_onlypc",                     &battle_config.pvpmode_onlypc,                  1,      0,      1,              },
+	{ "pvpmode_gvgreductions",              &battle_config.pvpmode_gvgreductions,           0,      0,      1,              },
+	{ "pvpmode_expbonus",                   &battle_config.pvpmode_expbonus,                0,      0,      100,            },
+	{ "pvpmode_nowarp_cmd",                 &battle_config.pvpmode_nowarp_cmd,              0,      0,      1,              },
+	{ "pvpmode_enable_delay",               &battle_config.pvpmode_enable_delay,          120,      0,      INT_MAX,        },
+	{ "pvpmode_disable_delay",              &battle_config.pvpmode_disable_delay,          60,      0,      INT_MAX,        },
+
+	{ "guild_wars",                         &battle_config.guild_wars,                      0,      0,      1,              },
+	{ "region_display",                     &battle_config.region_display,                  1,      0,      1,              },
+	{ "super_woe_enable",                   &battle_config.super_woe_enable,                0,      0,      2,              },
+	{ "at_changegm_cost",                   &battle_config.at_changegm_cost,                0,      0,      INT_MAX,        },
+
+	{ "mob_slave_adddrop",                  &battle_config.mob_slave_adddrop,               0,      0,      1,              },
+	{ "reflect_damage_fix",                 &battle_config.reflect_damage_fix,              1|2,    0,      1|2,            },
+
+	{ "anti_mayapurple_hack",               &battle_config.anti_mayapurple_hack,            0,      0,      1,              },
+
+	// Premium Account System
+	{ "premium_group_id",                   &battle_config.premium_group_id,                0,      0,      INT_MAX,        },
+	{ "premium_bonusexp",                   &battle_config.premium_bonusexp,                0,      0,      INT_MAX,        },
+	{ "premium_dropboost",                  &battle_config.premium_dropboost,               0,      0,      INT_MAX,        },
+
+	/**
+	 * rAthena
+	 **/
 	{ "max_third_parameter",                &battle_config.max_third_parameter,             120,    10,     10000,          },
 	{ "max_baby_third_parameter",           &battle_config.max_baby_third_parameter,        108,    10,     10000,          },
 	{ "atcommand_max_stat_bypass",          &battle_config.atcommand_max_stat_bypass,       0,      0,      100,            },
Index: src/map/battle.h
===================================================================
--- src/map/battle.h	(revision 1953)
+++ src/map/battle.h	(working copy)
@@ -59,8 +59,10 @@
 // Final calculation Damage
 int battle_calc_damage(struct block_list *src,struct block_list *bl,struct Damage *d,int damage,uint16 skill_id,uint16 skill_lv);
 int battle_calc_gvg_damage(struct block_list *src,struct block_list *bl,int damage,int div_,uint16 skill_id,uint16 skill_lv,int flag);
-int battle_calc_bg_damage(struct block_list *src,struct block_list *bl,int damage,int div_,uint16 skill_id,uint16 skill_lv,int flag);
-
+int battle_calc_bg_damage(struct block_list *src,struct block_list *bl,int damage,int div_,uint16 skill_id,uint16 skill_lv,int flag);
+int battle_calc_pvpevent_damage(struct block_list *src, struct block_list *bl, int damage, int div_, int skill_num, int skill_lv, int flag);
+int battle_calc_faction_damage(struct block_list *src, struct block_list *bl, int damage, int div_, int skill_num, int skill_lv, int flag);
+
 enum {  // ?Flag of the final calculation
     BF_WEAPON   = 0x0001,
     BF_MAGIC    = 0x0002,
@@ -147,12 +149,14 @@
 	int item_second_get_time;
 	int item_third_get_time;
 	int mvp_item_first_get_time;
-	int mvp_item_second_get_time;
-	int mvp_item_third_get_time;
-	int base_exp_rate,job_exp_rate;
-	int drop_rate0item;
-	int death_penalty_type;
-	int death_penalty_base,death_penalty_job;
+	int mvp_item_second_get_time;
+	int mvp_item_third_get_time;
+	int base_exp_rate,job_exp_rate;
+	int base_exp_rate_boss,job_exp_rate_boss;
+	int base_exp_rate_bonus,job_exp_rate_bonus;
+	int drop_rate0item;
+	int death_penalty_type;
+	int death_penalty_base,death_penalty_job;
 	int pvp_exp;  // [MouseJstr]
 	int gtb_sc_immunity;
 	int zeny_penalty;
@@ -182,22 +186,24 @@
 	int mob_spawn_delay, plant_spawn_delay, boss_spawn_delay;   // [Skotlex]
 	int slaves_inherit_mode;
 	int slaves_inherit_speed;
-	int summons_trigger_autospells;
-	int pc_walk_delay_rate; //Adjusts can't walk delay after being hit for players. [Skotlex]
-	int walk_delay_rate; //Adjusts can't walk delay after being hit. [Skotlex]
-	int multihit_delay;  //Adjusts can't walk delay per hit on multi-hitting skills. [Skotlex]
-	int quest_skill_learn;
-	int quest_skill_reset;
+	int summons_trigger_autospells;
+	int pc_walk_delay_rate; //Adjusts can't walk delay after being hit for players. [Skotlex]
+	int walk_delay_rate; //Adjusts can't walk delay after being hit. [Skotlex]
+	int walk_delay_rate_boss; // Adjusts can't walk delay after bein hit por Boss monsters [Zephyrus]
+	int multihit_delay;  //Adjusts can't walk delay per hit on multi-hitting skills. [Skotlex]
+	int quest_skill_learn;
+	int quest_skill_reset;
 	int basic_skill_check;
 	int guild_emperium_check;
 	int guild_exp_limit;
 	int guild_max_castles;
-	int guild_skill_relog_delay;
-	int emergency_call;
-	int guild_aura;
-	int pc_invincible_time;
-
-	int pet_catch_rate;
+	int guild_skill_relog_delay;
+	int emergency_call;
+	int guild_aura;
+	int guild_skills_separed_delay;
+	int pc_invincible_time;
+
+	int pet_catch_rate;
 	int pet_rename;
 	int pet_friendly_rate;
 	int pet_hungry_delay_rate;
@@ -337,12 +343,15 @@
 	int backstab_bow_penalty;
 	int hp_rate;
 	int sp_rate;
-	int bone_drop;
-	int buyer_name;
-	int dancing_weaponswitch_fix;
-
-// eAthena additions
-	int night_at_start; // added by [Yor]
+	int bone_drop;
+	int buyer_name;
+	int dancing_weaponswitch_fix;
+	int gm_channel_operator;
+	int pc_validate_items;
+	int pc_validate_stats;
+
+// eAthena additions
+	int night_at_start; // added by [Yor]
 	int day_duration; // added by [Yor]
 	int night_duration; // added by [Yor]
 	int ban_hack_trade; // added by [Yor]
@@ -433,23 +442,38 @@
 	int sg_angel_skill_ratio;
 	int sg_miracle_skill_ratio;
 	int sg_miracle_skill_duration;
-	int autospell_stacking; //Enables autospell cards to stack. [Skotlex]
-	int override_mob_names; //Enables overriding spawn mob names with the mob_db names. [Skotlex]
-	int min_chat_delay; //Minimum time between client messages. [Skotlex]
-	int friend_auto_add; //When accepting friends, both get friended. [Skotlex]
-	int hvan_explosion_intimate;    // fix [albator]
-	int hom_rename;
-	int homunculus_show_growth ;    //[orn]
-	int homunculus_friendly_rate;
-	int quest_exp_rate;
-	int autotrade_mapflag;
-	int at_timeout;
-	int homunculus_autoloot;
-	int idle_no_autoloot;
-	int max_guild_alliance;
-	int ksprotection;
-	int auction_feeperhour;
-	int auction_maximumprice;
+	int autospell_stacking; //Enables autospell cards to stack. [Skotlex]
+	int override_mob_names; //Enables overriding spawn mob names with the mob_db names. [Skotlex]
+	int min_chat_delay; //Minimum time between client messages. [Skotlex]
+	int channel_min_chat_delay; //Minimum time between client channel messages.
+	int friend_auto_add; //When accepting friends, both get friended. [Skotlex]
+	int hvan_explosion_intimate;	// fix [albator]
+	int hom_rename;
+	int homunculus_show_growth ;	//[orn]
+	int homunculus_friendly_rate;
+	int quest_exp_rate;
+
+	// [Terra Custom Settings]
+	int autotrade_mapflag;
+	int at_timeout;
+	int at_tax;
+	int homunculus_autoloot;
+	int idle_no_autoloot;
+	int max_guild_alliance;
+	int max_guild_opposition;
+	int mob_graveyard;
+	int pc_graveyard;
+
+	int pvpmode_onlypc;
+	int pvpmode_gvgreductions;
+	int pvpmode_expbonus;
+	int pvpmode_nowarp_cmd;
+	int pvpmode_enable_delay;
+	int pvpmode_disable_delay;
+
+	int ksprotection;
+	int auction_feeperhour;
+	int auction_maximumprice;
 	int homunculus_auto_vapor;  //Keep Homunculus from Vaporizing when master dies. [L0ne_W0lf]
 	int display_status_timers;  //Show or hide skill buff/delay timers in recent clients [Sara]
 	int skill_add_heal_rate;    //skills that bHealPower has effect on [Inkfish]
@@ -467,18 +491,89 @@
 	int cashshop_show_points;
 	int mail_show_status;
 	int client_limit_unit_lv;
-	int hom_max_level;
-	int hom_S_max_level;
-
-	// [BattleGround Settings]
-	int bg_update_interval;
-	int bg_short_damage_rate;
+	int hom_max_level;
+	int hom_S_max_level;
+
+	// [Flood Protection - Automute]
+	int chat_allowed_per_interval;
+	int chat_time_interval;
+	int chat_flood_automute;
+
+	// [Action Limits]
+	int action_keyboard_limit;
+	int action_mouse_limit;
+	int action_dual_limit;
+
+	// [BattleGround Settings]
+	int bg_update_interval;
+	int bg_short_damage_rate;
 	int bg_long_damage_rate;
 	int bg_weapon_damage_rate;
 	int bg_magic_damage_rate;
 	int bg_misc_damage_rate;
 	int bg_flee_penalty;
+	
+	int bg_idle_announce;
+	int bg_idle_autokick;
+	int bg_reserved_char_id;
+	int bg_items_on_pvp;
+	int bg_reward_rates;
+	int bg_ranking_bonus;
+ 
+	int bg_ranked_mode;
+	int bg_ranked_max_games;
+	int bg_reportafk_leaderonly;
+	int bg_queue2team_balanced;
+	int bg_logincount_check;
+	int bg_queue_onlytowns;
 
+	int bg_eAmod_mode;
+
+	// Faction System
+	int faction_allow_party;
+	int faction_allow_guild;
+	int faction_allow_chat;
+	int faction_allow_vending;
+	int faction_allow_trade;
+
+	int faction_short_damage_rate;
+	int faction_long_damage_rate;
+	int faction_weapon_damage_rate;
+	int faction_magic_damage_rate;
+	int faction_misc_damage_rate;
+
+	// [Reserved Chars ID]
+	int ancient_reserved_char_id;
+	int costume_reserved_char_id;
+	int woe_reserved_char_id;
+
+	// [PVP Event Settings]
+	int pvpevent_short_damage_rate;
+	int pvpevent_long_damage_rate;
+	int pvpevent_weapon_damage_rate;
+	int pvpevent_magic_damage_rate;
+	int pvpevent_misc_damage_rate;
+	int pvpevent_flee_penalty;
+	int pvpevent_cashperkill;
+	// [Custom Settings Terra RO]
+	int channel_system_enable;
+	int channel_announces;
+	int channel_announce_join;
+	int skill_zeny2item;
+
+	int myinfo_event_vote_points;
+	int vending_cash_id;
+	int vending_zeny_id;
+
+	int guild_wars;
+	int region_display; // Region Notifications
+	int super_woe_enable;
+	int at_changegm_cost;
+
+	int mob_slave_adddrop;
+	int reflect_damage_fix;
+	int anti_mayapurple_hack;
+
 	// [brAthena]
 	int devotion_rdamage, warp_no_ress, mob_drop_identified, bRO_Renewal, alliance_in_woe, use_item_in_status, supports_castle_gvg, max_atk,hanbok_ignorepalette, edp_rate, walk_speed_default;
 
@@ -500,6 +595,11 @@
 	int item_restricted_consumption_type;
 	int max_walk_path;
 	int item_enabled_npc;
+	
+	// Premium Account System
+	int premium_group_id;
+	int premium_bonusexp;
+	int premium_dropboost;
 
 } battle_config;
 
Index: src/map/battleground.c
===================================================================
--- src/map/battleground.c	(revision 1953)
+++ src/map/battleground.c	(working copy)
@@ -18,12 +18,13 @@
 #include "../common/timer.h"
 #include "../common/malloc.h"
 #include "../common/nullpo.h"
-#include "../common/showmsg.h"
-#include "../common/socket.h"
-#include "../common/strlib.h"
-
-#include "battleground.h"
-#include "battle.h"
+#include "../common/showmsg.h"
+#include "../common/socket.h"
+#include "../common/strlib.h"
+#include "../common/utils.h"
+
+#include "battleground.h"
+#include "battle.h"
 #include "clif.h"
 #include "map.h"
 #include "npc.h"
@@ -31,6 +32,12 @@
 #include "pet.h"
 #include "homunculus.h"
 #include "mercenary.h"
+#include "elemental.h"
+#include "party.h"
+#include "log.h"
+#include "quest.h"
+#include "skill.h"
+#include "achievement.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -38,6 +45,115 @@
 static DBMap *bg_team_db; // int bg_id -> struct battleground_data*
 static unsigned int bg_team_counter = 0; // Next bg_id
 
+struct guild bg_guild[13]; // Temporal fake guild information
+const unsigned int bg_colors[13] = { 0x0000FF, 0xFF0000, 0x00FF00, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
+
+static unsigned int queue_counter = 0; // Next q_id
+static DBMap* queue_db;
+
+#define BLUE_SKULL 8965
+#define RED_SKULL 8966
+#define GREEN_SKULL 8967
+
+int bg_member_removeskulls(struct map_session_data *sd)
+{
+	int n;
+	nullpo_ret(sd);
+	if( (n = pc_search_inventory(sd,BLUE_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->status.inventory[n].amount,0,2,LOG_TYPE_CONSUME);
+	if( (n = pc_search_inventory(sd,RED_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->status.inventory[n].amount,0,2,LOG_TYPE_CONSUME);
+	if( (n = pc_search_inventory(sd,GREEN_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->status.inventory[n].amount,0,2,LOG_TYPE_CONSUME);
+
+	return 1;
+}
+
+int battleground_countlogin(struct map_session_data *sd, bool check_bat_room)
+{
+	int c = 0, m = map_mapname2mapid("bat_room");
+	struct map_session_data* pl_sd;
+	struct s_mapiterator* iter;
+	nullpo_ret(sd);
+
+	iter = mapit_getallusers();
+	for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+	{
+		if( !(pl_sd->qd || map[pl_sd->bl.m].flag.battleground || (check_bat_room && pl_sd->bl.m == m)) )
+			continue;
+		if( session[sd->fd]->client_addr == session[pl_sd->fd]->client_addr )
+			c++;
+	}
+	mapit_free(iter);
+	return c;
+}
+
+int bg_checkskill(struct battleground_data *bg, int id)
+{
+	int idx = id - GD_SKILLBASE;
+	if( idx < 0 || idx >= MAX_GUILDSKILL || !bg->g )
+		return 0;
+	return bg->g->skill[idx].lv;
+}
+
+int bg_block_skill_end(int tid, unsigned int tick, int id, intptr_t data)
+{
+	struct battleground_data *bg;
+	char output[128];
+	int idx = battle_config.guild_skills_separed_delay ? (int)data - GD_SKILLBASE : 0;
+
+	if( (bg = bg_team_search(id)) == NULL )
+		return 1;
+
+	if( idx < 0 || idx >= MAX_GUILDSKILL )
+	{
+		ShowError("bg_block_skill_end invalid skillnum %d.\n", (int)data);
+		return 0;
+	}
+
+	if( tid != bg->skill_block_timer[idx] )
+	{
+		ShowError("bg_block_skill_end %d != %d.\n", bg->skill_block_timer[idx], tid);
+		return 0;
+	}
+
+	sprintf(output, "%s : Guild Skill %s Ready!!", bg->g->name, skill_get_desc((int)data));
+	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+	bg->skill_block_timer[idx] = INVALID_TIMER;
+
+	return 1;
+}
+
+void bg_block_skill_status(struct battleground_data *bg, int skillnum)
+{
+	const struct TimerData * td;
+	char output[128];
+	int seconds, idx;
+
+	idx = battle_config.guild_skills_separed_delay ? skillnum - GD_SKILLBASE : 0;
+	if( bg == NULL || bg->g == NULL || idx < 0 || idx >= MAX_GUILDSKILL || bg->skill_block_timer[idx] == INVALID_TIMER )
+		return;
+
+	if( (td = get_timer(bg->skill_block_timer[idx])) == NULL )
+		return;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "%s : Cannot use team skill %s. %d seconds remaining...", bg->g->name, skill_get_desc(skillnum), seconds);
+	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+}
+
+void bg_block_skill_start(struct battleground_data *bg, int skillnum, int time)
+{
+	int idx = battle_config.guild_skills_separed_delay ? skillnum - GD_SKILLBASE : 0;
+	if( bg == NULL || idx < 0 || idx >= MAX_GUILDSKILL )
+		return;
+
+	if( bg->skill_block_timer[idx] != INVALID_TIMER )
+		delete_timer(bg->skill_block_timer[idx], bg_block_skill_end);
+
+	bg->skill_block_timer[idx] = add_timer(gettick() + time, bg_block_skill_end, bg->bg_id, skillnum);
+}
+
 struct battleground_data *bg_team_search(int bg_id) {
 	// Search a BG Team using bg_id
 	if(!bg_id) return NULL;
@@ -51,43 +167,118 @@
 	return(i < MAX_BG_MEMBERS) ? bg->members[i].sd : NULL;
 }
 
-int bg_team_delete(int bg_id)
+int bg_team_clean(int bg_id, bool remove)
 {
 	// Deletes BG Team from db
 	int i;
 	struct map_session_data *sd;
 	struct battleground_data *bg = bg_team_search(bg_id);
+	struct guild *g;
 
 	if(bg == NULL) return 0;
 	for(i = 0; i < MAX_BG_MEMBERS; i++) {
 		if((sd = bg->members[i].sd) == NULL)
 			continue;
-
-		bg_send_dot_remove(sd);
-		sd->bg_id = 0;
-	}
-	idb_remove(bg_team_db, bg_id);
-	return 1;
-}
-
+
+		bg_send_dot_remove(sd);
+		sd->bg_id = 0;
+		sd->state.bg_afk = 0;
+		sd->bmaster_flag = NULL;
+		bg_member_removeskulls(sd);
+
+		// Remove Guild Skill Buffs
+		status_change_end(&sd->bl,SC_GUILDAURA,INVALID_TIMER);
+		status_change_end(&sd->bl,SC_BATTLEORDERS,INVALID_TIMER);
+		status_change_end(&sd->bl,SC_REGENERATION,INVALID_TIMER);
+
+		if( !battle_config.bg_eAmod_mode )
+			continue; // No need to touch Guild stuff
+
+		if( sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL )
+		{
+			clif_guild_belonginfo(sd,g);
+			clif_guild_basicinfo(sd);
+			clif_guild_allianceinfo(sd);
+			clif_guild_memberlist(sd);
+			clif_guild_skillinfo(sd);
+		}
+		else
+			clif_bg_leave_single(sd, sd->status.name, "Leaving Battleground...");
+
+		clif_charnameupdate(sd);
+		clif_guild_emblem_area(&sd->bl);
+	}
+
+	for( i = 0; i < MAX_GUILDSKILL; i++ )
+	{
+		if( bg->skill_block_timer[i] == INVALID_TIMER )
+			continue;
+		delete_timer(bg->skill_block_timer[i], bg_block_skill_end);
+	}
+
+	if( remove )
+		idb_remove(bg_team_db, bg_id);
+	else
+	{
+		bg->count = 0;
+		bg->leader_char_id = 0;
+		bg->team_score = 0;
+		bg->creation_tick = 0;
+		memset(&bg->members, 0, sizeof(bg->members));
+	}
+
+	return 1;
+}
+
 int bg_team_warp(int bg_id, unsigned short mapindex, short x, short y)
 {
 	// Warps a Team
-	int i;
-	struct battleground_data *bg = bg_team_search(bg_id);
-	if(bg == NULL) return 0;
-	for(i = 0; i < MAX_BG_MEMBERS; i++)
-		if(bg->members[i].sd != NULL) pc_setpos(bg->members[i].sd, mapindex, x, y, CLR_TELEPORT);
-	return 1;
-}
-
-int bg_send_dot_remove(struct map_session_data *sd)
-{
-	if(sd && sd->bg_id)
-		clif_bg_xy_remove(sd);
-	return 0;
-}
-
+	int i;
+	struct battleground_data *bg = bg_team_search(bg_id);
+	if( bg == NULL ) return 0;
+	if( mapindex == 0 )
+	{
+		mapindex = bg->mapindex;
+		x = bg->x;
+		y = bg->y;
+	}
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+		if( bg->members[i].sd != NULL ) pc_setpos(bg->members[i].sd, mapindex, x, y, CLR_TELEPORT);
+	return 1;
+}
+
+int bg_reveal_pos(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *pl_sd, *sd = NULL;
+	int flag, color;
+
+	pl_sd = (struct map_session_data *)bl;
+	sd = va_arg(ap,struct map_session_data *); // Source
+	flag = va_arg(ap,int);
+	color = va_arg(ap,int);
+
+	if( pl_sd->bg_id == sd->bg_id )
+		return 0; // Same Team
+
+	clif_viewpoint(pl_sd,sd->bl.id,flag,sd->bl.x,sd->bl.y,sd->bl.id,color);
+	return 0;
+}
+
+int bg_send_dot_remove(struct map_session_data *sd)
+{
+	struct battleground_data *bg;
+	int m;
+
+	if( sd && sd->bg_id && (bg = bg_team_search(sd->bg_id)) != NULL )
+	{
+		clif_bg_xy_remove(sd);
+		if( bg->reveal_pos && (m = map_mapindex2mapid(bg->mapindex)) == sd->bl.m )
+			map_foreachinmap(bg_reveal_pos,m,BL_PC,sd,2,0xFFFFFF);
+	}
+	return 0;
+}
+
 int bg_team_join(int bg_id, struct map_session_data *sd)
 {
 	// Player joins team
@@ -100,19 +291,57 @@
 	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd == NULL);
 	if(i == MAX_BG_MEMBERS) return 0;   // No free slots
 
+	pc_update_last_action(sd,0); // Start count from here...
 	sd->bg_id = bg_id;
+	sd->bg_kills = 0;
+	sd->state.bg_afk = 0;
 	bg->members[i].sd = sd;
 	bg->members[i].x = sd->bl.x;
 	bg->members[i].y = sd->bl.y;
 	bg->count++;
+	
+	if( bg->creation_tick == 0 ) bg->creation_tick = last_tick; // Creation Tick = First member joined.
 
+	if( bg->leader_char_id == 0 )
+	{ // First Join = Team Leader
+		bg->leader_char_id = sd->status.char_id;
+		sd->bmaster_flag = bg;
+	}
+
+	if( battle_config.bg_ranked_mode && sd->status.bgstats.rank_games < battle_config.bg_ranked_max_games && DIFF_TICK(last_tick,bg->creation_tick) < 60 )
+	{
+		char output[128];
+		bg->members[i].ranked = true;
+		sd->status.bgstats.rank_games++;
+		sprintf(output,"-- RANKED BATTLEGROUND MATCH %d OF %d --", sd->status.bgstats.rank_games, battle_config.bg_ranked_max_games);
+		clif_displaymessage(sd->fd,output);
+	}
+
+ 	guild_send_dot_remove(sd);
+	if( battle_config.bg_eAmod_mode )
+	{
+		clif_bg_belonginfo(sd);
+		clif_charnameupdate(sd);
+	}
+
 	guild_send_dot_remove(sd);
 
 	for(i = 0; i < MAX_BG_MEMBERS; i++) {
-		if((pl_sd = bg->members[i].sd) != NULL && pl_sd != sd)
-			clif_hpmeter_single(sd->fd, pl_sd->bl.id, pl_sd->battle_status.hp, pl_sd->battle_status.max_hp);
+		if( (pl_sd = bg->members[i].sd) == NULL )
+			continue;
+
+		if( battle_config.bg_eAmod_mode )
+		{ // Simulate Guild Information
+			clif_guild_basicinfo(pl_sd);
+			clif_bg_emblem(pl_sd, bg->g);
+			clif_bg_memberlist(pl_sd);
+		}
+
+		if( pl_sd != sd )
+			clif_bg_hp_single(sd->fd,pl_sd);
 	}
 
+	if( battle_config.bg_eAmod_mode ) clif_guild_emblem_area(&sd->bl);
 	clif_bg_hp(sd);
 	clif_bg_xy(sd);
 	return 1;
@@ -121,33 +350,95 @@
 int bg_team_leave(struct map_session_data *sd, int flag)
 {
 	// Single Player leaves team
-	int i, bg_id;
+	int i;
 	struct battleground_data *bg;
-	char output[128];
+	struct map_session_data *pl_sd;
+	struct guild *g;
 
 	if(sd == NULL || !sd->bg_id)
 		return 0;
+		
+	bg = bg_team_search(sd->bg_id);
 
+	if( bg && bg->logout_event[0] && flag )
+		npc_event(sd, bg->logout_event, 0);
+
+	// Packets
+	if( battle_config.bg_eAmod_mode ) clif_bg_leave_single(sd, sd->status.name, "Leaving Battle...");
+
 	bg_send_dot_remove(sd);
-	bg_id = sd->bg_id;
 	sd->bg_id = 0;
+	
+	sd->bg_kills = 0;
+	sd->state.bg_afk = 0;
+	sd->bmaster_flag = NULL;
+	bg_member_removeskulls(sd);
 
-	if((bg = bg_team_search(bg_id)) == NULL)
-		return 0;
+	// Remove Guild Skill Buffs
+	status_change_end(&sd->bl,SC_GUILDAURA,INVALID_TIMER);
+	status_change_end(&sd->bl,SC_BATTLEORDERS,INVALID_TIMER);
+	status_change_end(&sd->bl,SC_REGENERATION,INVALID_TIMER);
+ 
+	if( battle_config.bg_eAmod_mode )
+	{ // Refresh Guild Information
+		if( sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL )
+		{
+			clif_guild_belonginfo(sd, g);
+			clif_guild_basicinfo(sd);
+			clif_guild_allianceinfo(sd);
+			clif_guild_memberlist(sd);
+			clif_guild_skillinfo(sd);
+			clif_guild_emblem(sd, g);
+		}
 
+		clif_charnameupdate(sd);
+		clif_guild_emblem_area(&sd->bl);
+	}
+
+	if( !bg ) return 0;
+
 	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd == sd);
 	if(i < MAX_BG_MEMBERS)   // Removes member from BG
 		memset(&bg->members[i], 0, sizeof(bg->members[0]));
 	bg->count--;
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{ // Update other BG members
+		if( (pl_sd = bg->members[i].sd) == NULL )
+			continue;
+		if( !bg->leader_char_id )
+		{ // Set new Leader first on the list
+			bg->leader_char_id = pl_sd->status.char_id;
+			pl_sd->bmaster_flag = bg;
+		}
 
-	if(flag)
-		sprintf(output, "Server : %s has quit the game...", sd->status.name);
-	else
-		sprintf(output, "Server : %s is leaving the battlefield...", sd->status.name);
-	clif_bg_message(bg, 0, "Server", output, strlen(output) + 1);
+		if( battle_config.bg_eAmod_mode )
+		{
+			switch( flag )
+			{
+			case 3: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Status..."); break;
+			case 2: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Report..."); break;
+			case 1: clif_bg_expulsion_single(pl_sd, sd->status.name, "User has quit the game..."); break;
+			case 0: clif_bg_leave_single(pl_sd, sd->status.name, "Leaving Battle..."); break;
+			}
 
-	if(bg->logout_event[0] && flag)
-		npc_event(sd, bg->logout_event, 0);
+			clif_guild_basicinfo(pl_sd);
+			clif_bg_emblem(pl_sd, bg->g);
+			clif_bg_memberlist(pl_sd);
+		}
+	}
+ 
+	if( !battle_config.bg_eAmod_mode )
+	{
+		char output[128];
+		switch( flag )
+		{
+		case 3: sprintf(output, "Server : %s kicked by AFK Status...", sd->status.name); break;
+		case 2: sprintf(output, "Server : %s kicked by AFK Report...", sd->status.name); break;
+		case 1: sprintf(output, "Server : %s has quit the game...", sd->status.name); break;
+		case 0: sprintf(output, "Server : %s is leaving the battlefield...", sd->status.name); break;
+		}
+		clif_bg_message(bg, 0, "Server", output, strlen(output) + 1);
+	}
 
 	return bg->count;
 }
@@ -163,32 +454,47 @@
 	pc_setpos(sd, bg->mapindex, bg->x, bg->y, CLR_OUTSIGHT);
 	status_revive(&sd->bl, 1, 100);
 
-	return 1; // Warped
+	return 1; // Warped
+}
+
+struct guild* bg_guild_get(int bg_id)
+{ // Return Fake Guild for BG Members
+	struct battleground_data *bg = bg_team_search(bg_id);
+	if( bg == NULL ) return NULL;
+	return bg->g;
+}
+
+int bg_create(unsigned short mapindex, short rx, short ry, int guild_index, const char *ev, const char *dev)
+{
+	struct battleground_data *bg;
+	int i;
+	if( ++bg_team_counter <= 0 ) bg_team_counter = 1;
+
+	CREATE(bg, struct battleground_data, 1);
+	bg->bg_id = bg_team_counter;
+	bg->creation_tick = 0;
+	bg->count = 0;
+	bg->g = &bg_guild[guild_index];
+	bg->mapindex = mapindex;
+	bg->x = rx;
+	bg->y = ry;
+	safestrncpy(bg->logout_event, ev, sizeof(bg->logout_event));
+	safestrncpy(bg->die_event, dev, sizeof(bg->die_event));
+	for( i = 0; i < MAX_GUILDSKILL; i++ )
+		bg->skill_block_timer[i] = INVALID_TIMER;
+
+	memset(&bg->members, 0, sizeof(bg->members));
+	bg->color = bg_colors[guild_index];
+	bg->pf_id = 0;
+
+	idb_put(bg_team_db, bg_team_counter, bg);
+
+	return bg->bg_id;
 }
 
-int bg_create(unsigned short mapindex, short rx, short ry, const char *ev, const char *dev)
-{
-	struct battleground_data *bg;
-	bg_team_counter++;
-
-	CREATE(bg, struct battleground_data, 1);
-	bg->bg_id = bg_team_counter;
-	bg->count = 0;
-	bg->mapindex = mapindex;
-	bg->x = rx;
-	bg->y = ry;
-	safestrncpy(bg->logout_event, ev, sizeof(bg->logout_event));
-	safestrncpy(bg->die_event, dev, sizeof(bg->die_event));
-
-	memset(&bg->members, 0, sizeof(bg->members));
-	idb_put(bg_team_db, bg_team_counter, bg);
-
-	return bg->bg_id;
-}
-
 int bg_team_get_id(struct block_list *bl)
 {
-	nullpo_ret(bl);
+	if( bl )
 	switch(bl->type) {
 		case BL_PC:
 			return ((TBL_PC *)bl)->bg_id;
@@ -208,14 +514,20 @@
 				return ((TBL_HOM *)bl)->master->bg_id;
 			break;
 		case BL_MER:
-			if(((TBL_MER *)bl)->master)
-				return ((TBL_MER *)bl)->master->bg_id;
-			break;
-		case BL_SKILL:
-			return ((TBL_SKILL *)bl)->group->bg_id;
-	}
-
-	return 0;
+			if( ((TBL_MER*)bl)->master )
+				return ((TBL_MER*)bl)->master->bg_id;
+			break;
+		case BL_ELEM:
+			if( ((TBL_ELEM*)bl)->master )
+				return ((TBL_ELEM*)bl)->master->bg_id;
+			break;
+		case BL_SKILL:
+			return ((TBL_SKILL*)bl)->group->bg_id;
+		case BL_NPC:
+			return ((TBL_NPC*)bl)->u.scr.bg_id;
+	}
+
+	return 0;
 }
 
 int bg_send_message(struct map_session_data *sd, const char *mes, int len)
@@ -229,24 +541,43 @@
 	return 0;
 }
 
-/**
- * @see DBApply
- */
+
 int bg_send_xy_timer_sub(DBKey key, DBData *data, va_list ap)
 {
-	struct battleground_data *bg = db_data2ptr(data);
+	struct battleground_data *bg = (struct battleground_data *)db_data2ptr(data);
 	struct map_session_data *sd;
-	int i;
+	char output[128];
+	int i, m;
 	nullpo_ret(bg);
+	m = map_mapindex2mapid(bg->mapindex);
+	bg->reveal_flag = !bg->reveal_flag; // Switch
 	for(i = 0; i < MAX_BG_MEMBERS; i++) {
 		if((sd = bg->members[i].sd) == NULL)
 			continue;
+		if( battle_config.bg_idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_autokick && bg->g )
+		{
+			sprintf(output, "- AFK [%s] Kicked -", sd->status.name);
+			clif_broadcast2(&sd->bl, output, (int)strlen(output)+1, bg->color, 0x190, 20, 0, 0, BG);
+
+			bg_team_leave(sd,3);
+			clif_displaymessage(sd->fd, "You have been kicked from Battleground because of your AFK status.");
+			pc_setpos(sd,sd->status.save_point.map,sd->status.save_point.x,sd->status.save_point.y,3);
+			continue;
+		}
 		if(sd->bl.x != bg->members[i].x || sd->bl.y != bg->members[i].y) {
 			// xy update
 			bg->members[i].x = sd->bl.x;
 			bg->members[i].y = sd->bl.y;
 			clif_bg_xy(sd);
 		}
+		if( bg->reveal_pos && bg->reveal_flag && sd->bl.m == m ) // Reveal each 4 seconds
+			map_foreachinmap(bg_reveal_pos,m,BL_PC,sd,1,bg->color);
+		if( battle_config.bg_idle_announce && !sd->state.bg_afk && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_announce && bg->g )
+		{ // Idle announces
+			sd->state.bg_afk = 1;
+			sprintf(output, "%s : %s seens to be away. AFK Warning - Can be kicked out with @reportafk", bg->g->name, sd->status.name);
+			clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+		}
 	}
 	return 0;
 }
@@ -254,17 +585,640 @@
 int bg_send_xy_timer(int tid, unsigned int tick, int id, intptr_t data)
 {
 	bg_team_db->foreach(bg_team_db, bg_send_xy_timer_sub, tick);
-	return 0;
-}
-
-void do_init_battleground(void)
-{
-	bg_team_db = idb_alloc(DB_OPT_RELEASE_DATA);
-	add_timer_func_list(bg_send_xy_timer, "bg_send_xy_timer");
-	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
-}
-
-void do_final_battleground(void)
-{
-	bg_team_db->destroy(bg_team_db, NULL);
-}
+	return 0;
+}
+
+void bg_guild_build_data(void)
+{
+	int i, j, k, skill;
+	memset(&bg_guild, 0, sizeof(bg_guild));
+	for( i = 1; i <= 13; i++ )
+	{ // Emblem Data - Guild ID's
+		FILE* fp = NULL;
+		char path[256];
+
+		j = i - 1;
+		bg_guild[j].emblem_id = 1; // Emblem Index
+		bg_guild[j].guild_id = SHRT_MAX - j;
+		bg_guild[j].guild_lv = 1;
+		bg_guild[j].max_member = MAX_BG_MEMBERS;
+
+		// Skills
+		if( j < 3 )
+		{ // Clan Skills
+			for( k = 0; k < MAX_GUILDSKILL; k++ )
+			{
+				skill = k + GD_SKILLBASE;
+				bg_guild[j].skill[k].id = skill;
+				switch( skill )
+				{
+				case GD_GLORYGUILD:
+					bg_guild[j].skill[k].lv = 0;
+					break;
+				case GD_APPROVAL:
+				case GD_KAFRACONTRACT:
+				case GD_GUARDRESEARCH:
+				case GD_BATTLEORDER:
+				case GD_RESTORE:
+				case GD_EMERGENCYCALL:
+				case GD_DEVELOPMENT:
+					bg_guild[j].skill[k].lv = 1;
+					break;
+				case GD_GUARDUP:
+				case GD_REGENERATION:
+					bg_guild[j].skill[k].lv = 3;
+					break;
+				case GD_LEADERSHIP:
+				case GD_GLORYWOUNDS:
+				case GD_SOULCOLD:
+				case GD_HAWKEYES:
+					bg_guild[j].skill[k].lv = 5;
+					break;
+				case GD_EXTENSION:
+					bg_guild[j].skill[k].lv = 10;
+					break;
+				}
+			}
+		}
+		else
+		{ // Other Data
+			snprintf(bg_guild[j].name, NAME_LENGTH, "Team %d", i - 3); // Team 1, Team 2 ... Team 10
+			strncpy(bg_guild[j].master, bg_guild[j].name, NAME_LENGTH);
+			snprintf(bg_guild[j].position[0].name, NAME_LENGTH, "%s Leader", bg_guild[j].name);
+			strncpy(bg_guild[j].position[1].name, bg_guild[j].name, NAME_LENGTH);
+		}
+
+		sprintf(path, "%s/emblems/bg_%d.ebm", db_path, i);
+		if( (fp = fopen(path, "rb")) != NULL )
+		{
+			fseek(fp, 0, SEEK_END);
+			bg_guild[j].emblem_len = ftell(fp);
+			fseek(fp, 0, SEEK_SET);
+			fread(&bg_guild[j].emblem_data, 1, bg_guild[j].emblem_len, fp);
+			fclose(fp);
+			ShowStatus("Done reading '"CL_WHITE"%s"CL_RESET"' emblem data file.\n", path);
+		}
+	}
+
+	// Guild Data - Guillaume
+	strncpy(bg_guild[0].name, "Blue Team", NAME_LENGTH);
+	strncpy(bg_guild[0].master, "General Guillaume", NAME_LENGTH);
+	strncpy(bg_guild[0].position[0].name, "Blue Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[0].position[1].name, "Blue Team", NAME_LENGTH);
+
+	// Guild Data - Croix
+	strncpy(bg_guild[1].name, "Red Team", NAME_LENGTH);
+	strncpy(bg_guild[1].master, "Prince Croix", NAME_LENGTH);
+	strncpy(bg_guild[1].position[0].name, "Red Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[1].position[1].name, "Red Team", NAME_LENGTH);
+
+	// Guild Data - Traitors
+	strncpy(bg_guild[2].name, "Green Team", NAME_LENGTH);
+	strncpy(bg_guild[2].master, "Mercenary", NAME_LENGTH);
+	strncpy(bg_guild[2].position[0].name, "Green Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[2].position[1].name, "Green Team", NAME_LENGTH);
+}
+
+void bg_team_getitem(int bg_id, int nameid, int amount)
+{
+	struct battleground_data *bg;
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int get_amount, i, j, flag, rank = 0;
+
+	if( amount < 1 || (bg = bg_team_search(bg_id)) == NULL || (id = itemdb_exists(nameid)) == NULL )
+		return;
+	if( nameid != 7828 && nameid != 7829 && nameid != 7773 )
+		return;
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for( j = 0; j < MAX_BG_MEMBERS; j++ )
+	{
+		if( (sd = bg->members[j].sd) == NULL )
+			continue;
+		if( battle_config.bg_ranking_bonus )
+		{
+			rank = 0;
+			ARR_FIND(0,MAX_FAME_LIST,i,bgrank_fame_list[i].id == sd->status.char_id);
+			if( i < MAX_FAME_LIST )
+				rank = 1;
+			else
+			{
+				ARR_FIND(0,MAX_FAME_LIST,i,bg_fame_list[i].id == sd->status.char_id);
+				if( i < MAX_FAME_LIST )
+					rank = 1;
+			}
+		}
+
+		get_amount = amount;
+		if( rank ) get_amount += battle_config.bg_ranking_bonus * get_amount / 100;
+
+		if( (flag = pc_additem(sd,&it,get_amount,LOG_TYPE_SCRIPT)) )
+			clif_additem(sd,0,0,flag);
+	}
+}
+
+void bg_team_get_kafrapoints(int bg_id, int amount)
+{
+	struct battleground_data *bg;
+	struct map_session_data *sd;
+	int i, j, get_amount, rank = 0;
+
+	if( (bg = bg_team_search(bg_id)) == NULL )
+		return;
+
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
+		if( battle_config.bg_ranking_bonus )
+		{
+			rank = 0;
+			ARR_FIND(0,MAX_FAME_LIST,j,bgrank_fame_list[j].id == sd->status.char_id);
+			if( j < MAX_FAME_LIST )
+				rank = 1;
+			else
+			{
+				ARR_FIND(0,MAX_FAME_LIST,j,bg_fame_list[j].id == sd->status.char_id);
+				if( j < MAX_FAME_LIST )
+					rank = 1;
+			}
+		}
+
+		get_amount = amount;
+		if( rank ) get_amount += battle_config.bg_ranking_bonus * get_amount / 100;
+		pc_getcash(sd,0,get_amount);
+	}
+}
+
+/* ==============================================================
+   bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON | 7 RUSH | 8 DOM)
+   bg_result (0 Won | 1 Tie | 2 Lost)
+   ============================================================== */
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result)
+{
+	struct battleground_data *bg;
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int i, j, flag, fame, get_amount, rank = 0, type;
+
+	if( amount < 1 || (bg = bg_team_search(bg_id)) == NULL || (id = itemdb_exists(nameid)) == NULL )
+		return;
+
+	if( battle_config.bg_reward_rates != 100 )
+	{ // BG Reward Rates
+		amount = amount * battle_config.bg_reward_rates / 100;
+		kafrapoints = kafrapoints * battle_config.bg_reward_rates / 100;
+	}
+
+	bg_result = cap_value(bg_result,0,2);
+	memset(&it,0,sizeof(it));
+	if( nameid == 7828 || nameid == 7829 || nameid == 7773 )
+	{
+		it.nameid = nameid;
+		it.identify = 1;
+	}
+	else nameid = 0;
+
+	for( j = 0; j < MAX_BG_MEMBERS; j++ )
+	{
+		if( (sd = bg->members[j].sd) == NULL )
+			continue;
+
+		if( battle_config.bg_ranking_bonus )
+		{
+			rank = 0;
+			ARR_FIND(0,MAX_FAME_LIST,i,bgrank_fame_list[i].id == sd->status.char_id);
+			if( i < MAX_FAME_LIST )
+				rank = 1;
+			else
+			{
+				ARR_FIND(0,MAX_FAME_LIST,i,bg_fame_list[i].id == sd->status.char_id);
+				if( i < MAX_FAME_LIST )
+					rank = 1;
+			}
+		}
+
+		if( quest_id ) quest_add(sd,quest_id);
+		pc_setglobalreg(sd,var,pc_readglobalreg(sd,var) + add_value);
+
+		if( kafrapoints > 0 )
+		{
+			get_amount = kafrapoints;
+			if( rank ) get_amount += battle_config.bg_ranking_bonus * get_amount / 100;
+			pc_getcash(sd,0,get_amount);
+		}
+
+		if( nameid && amount > 0 )
+		{
+			get_amount = amount;
+			if( rank ) get_amount += battle_config.bg_ranking_bonus * get_amount / 100;
+
+			if( (flag = pc_additem(sd,&it,get_amount,LOG_TYPE_SCRIPT)) )
+				clif_additem(sd,0,0,flag);
+		}
+
+		type = bg->members[j].ranked ? 2 : 3; // Where to Add Fame
+
+		switch( bg_result )
+		{
+		case 0: // Won
+			add2limit(sd->status.bgstats.win,1,USHRT_MAX);
+			achievement_validate_bg(sd,ATB_VICTORY,1);
+			fame = 100;
+			if( sd->bmaster_flag )
+			{
+				add2limit(sd->status.bgstats.leader_win,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_LEADER_VICTORY,1);
+				fame += 25;
+			}
+			pc_addfame(sd,fame,type);
+			switch( bg_arena )
+			{
+			case 0:
+				add2limit(sd->status.bgstats.eos_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_EOS_VICTORY,1);
+				break;
+			case 1:
+				add2limit(sd->status.bgstats.boss_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_BOSS_VICTORY,1);
+				break;
+			case 2:
+				add2limit(sd->status.bgstats.ti_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_TI_VICTORY,1);
+				break;
+			case 3:
+				add2limit(sd->status.bgstats.ctf_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_CTF_VICTORY,1);
+				break;
+			case 4:
+				add2limit(sd->status.bgstats.td_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_TDM_VICTORY,1);
+				break;
+			case 5:
+				add2limit(sd->status.bgstats.sc_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_SC_VICTORY,1);
+				break;
+			case 6:
+				add2limit(sd->status.bgstats.cq_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_CON_VICTORY,1);
+				break;
+			case 7:
+				add2limit(sd->status.bgstats.ru_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_RU_VICTORY,1);
+				break;
+			case 8:
+				add2limit(sd->status.bgstats.dom_wins,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_DOM_VICTORY,1);
+				break;
+			}
+			break;
+		case 1: // Tie
+			add2limit(sd->status.bgstats.tie,1,USHRT_MAX);
+			fame = 75;
+			if( sd->bmaster_flag )
+			{
+				add2limit(sd->status.bgstats.leader_tie,1,USHRT_MAX);
+				fame += 10;
+			}
+			pc_addfame(sd,fame,type);
+			switch( bg_arena )
+			{
+			case 0: add2limit(sd->status.bgstats.eos_tie,1,USHRT_MAX); break;
+			case 1: add2limit(sd->status.bgstats.boss_tie,1,USHRT_MAX); break;
+			case 2: add2limit(sd->status.bgstats.ti_tie,1,USHRT_MAX); break;
+			case 3: add2limit(sd->status.bgstats.ctf_tie,1,USHRT_MAX); break;
+			case 4: add2limit(sd->status.bgstats.td_tie,1,USHRT_MAX); break;
+			case 5: add2limit(sd->status.bgstats.sc_tie,1,USHRT_MAX); break;
+			// No Tie for Conquest or Rush
+			case 8: add2limit(sd->status.bgstats.dom_tie,1,USHRT_MAX); break;
+			}
+			break;
+		case 2: // Lost
+			add2limit(sd->status.bgstats.lost,1,USHRT_MAX);
+			achievement_validate_bg(sd,ATB_DEFEAT,1);
+			fame = 50;
+			if( sd->bmaster_flag )
+			{
+				add2limit(sd->status.bgstats.leader_lost,1,USHRT_MAX);
+				achievement_validate_bg(sd,ATB_LEADER_DEFEAT,1);
+			}
+			pc_addfame(sd,fame,type);
+			switch( bg_arena )
+			{
+			case 0: add2limit(sd->status.bgstats.eos_lost,1,USHRT_MAX); break;
+			case 1: add2limit(sd->status.bgstats.boss_lost,1,USHRT_MAX); break;
+			case 2: add2limit(sd->status.bgstats.ti_lost,1,USHRT_MAX); break;
+			case 3: add2limit(sd->status.bgstats.ctf_lost,1,USHRT_MAX); break;
+			case 4: add2limit(sd->status.bgstats.td_lost,1,USHRT_MAX); break;
+			case 5: add2limit(sd->status.bgstats.sc_lost,1,USHRT_MAX); break;
+			case 6: add2limit(sd->status.bgstats.cq_lost,1,USHRT_MAX); break;
+			case 7: add2limit(sd->status.bgstats.ru_lost,1,USHRT_MAX); break;
+			case 8: add2limit(sd->status.bgstats.dom_lost,1,USHRT_MAX); break;
+			}
+			break;
+		}
+	}
+}
+
+// ====================================================================
+// Battleground Queue System
+// ====================================================================
+
+struct queue_data* queue_search(int q_id)
+{ // Search a Queue using q_id
+	if( !q_id ) return NULL;
+	return (struct queue_data *)idb_get(queue_db, q_id);
+}
+
+int queue_create(const char* queue_name, const char* join_event, int min_level)
+{
+	struct queue_data *qd;
+	if( ++queue_counter <= 0 ) queue_counter = 1;
+
+	CREATE(qd, struct queue_data, 1);
+	qd->q_id = queue_counter;
+	safestrncpy(qd->queue_name, queue_name, sizeof(qd->queue_name));
+	safestrncpy(qd->join_event, join_event, sizeof(qd->join_event));
+	qd->first = qd->last = NULL; // First and Last Queue Members
+	qd->users = 0;
+	qd->min_level = min_level;
+
+	idb_put(queue_db, queue_counter, qd);
+
+	return qd->q_id;
+}
+
+void queue_members_clean(struct queue_data *qd)
+{
+	struct queue_member *head, *next;
+	nullpo_retv(qd);
+
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd ) head->sd->qd = NULL;
+		next = head->next;
+		aFree(head);
+		head = next;
+	}
+
+	qd->first = qd->last = NULL;
+	qd->users = 0;
+}
+
+int queue_member_add(struct queue_data *qd, struct map_session_data *sd)
+{
+	struct queue_member *qm;
+	nullpo_retr(0,qd);
+	nullpo_retr(0,sd);
+
+	CREATE(qm, struct queue_member, 1);
+	qd->users++;
+	qm->sd = sd;
+	qm->position = qd->users;
+	qm->next = NULL;
+	sd->qd = qd; // Attach user to the Queue too
+
+	if( qd->last == NULL )
+		qd->first = qd->last = qm; // Attach to first position
+	else
+	{ // Attach at the end of the queue
+		qd->last->next = qm;
+		qd->last = qm;
+	}
+
+	return qm->position;
+}
+
+struct queue_member* queue_member_get(struct queue_data *qd, int position)
+{
+	struct queue_member *head;
+	if( !qd ) return NULL;
+
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd && head->position == position )
+			return head;
+
+		head = head->next;
+	}
+
+	return NULL;
+}
+
+int queue_member_remove(struct queue_data *qd, int id)
+{
+	struct queue_member *head, *previous;
+	int i;
+	nullpo_retr(0,qd);
+
+	head = qd->first;
+	previous = NULL;
+
+	while( head != NULL )
+	{
+		if( head->sd && head->sd->bl.id == id )
+		{
+			struct queue_member *next;
+
+			next = head->next;
+			i = head->position;
+			head->sd->qd = NULL;
+			qd->users--;
+
+			// De-attach target from the main queue
+			if( previous )
+				previous->next = head->next;
+			else
+				qd->first = head->next; // Deleted is on first position
+
+			if( head->next == NULL ) qd->last = previous; // Deleted is on last position
+
+			while( next != NULL )
+			{ // Reduces positions of the next of the queue in -1
+				next->position--;
+				next = next->next;
+			}
+
+			aFree(head);
+			return i;
+		}
+
+		previous = head;
+		head = head->next;
+	}
+
+	return 0;
+}
+
+int queue_member_search(struct queue_data *qd, int id)
+{
+	struct queue_member *head;
+	nullpo_retr(0,qd);
+
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd && head->sd->bl.id == id )
+			return head->position;
+
+		head = head->next;
+	}
+
+	return 0; // Not Found
+}
+
+int queue_destroy(int q_id)
+{
+	struct queue_data *qd;
+
+	if( (qd = queue_search(q_id)) == NULL )
+		return 0;
+
+	queue_members_clean(qd);
+	idb_remove(queue_db, q_id);
+	return 1;
+}
+
+int queue_join(struct map_session_data *sd, int q_id)
+{
+	char output[128];
+	struct queue_data *qd;
+	int i;
+
+	if( battle_config.bg_queue_onlytowns && !map[sd->bl.m].flag.town )
+	{
+		clif_displaymessage(sd->fd,"You only can join BG queues from Towns or BG Waiting Room.");
+		return 0;
+	}
+
+	if( sd->bg_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot join queues when already playing Battlegrounds.");
+		return 0;
+	}
+
+	if( sd->sc.data[SC_JAILED] )
+	{
+		clif_displaymessage(sd->fd,"You cannot join queues when jailed.");
+		return 0;
+	}
+
+	if( (qd = sd->qd) != NULL )
+	{ // You cannot join a Queue if you are already on one.
+		i = queue_member_search(qd,sd->bl.id);
+		sprintf(output,"You are already on %s queue at position %d.", qd->queue_name, i);
+		clif_displaymessage(sd->fd,output);
+		return 0;
+	}
+
+	if( (qd = queue_search(q_id)) == NULL )
+		return 0; // Current Queue don't exists
+
+	if( qd->min_level && sd->status.base_level < qd->min_level )
+	{
+		sprintf(output,"You cannot join %s queue. Required min level is %d.", qd->queue_name, qd->min_level);
+		clif_displaymessage(sd->fd,output);
+		return 0;
+	}
+
+	if( battle_config.bg_logincount_check && battleground_countlogin(sd,false) > 0 )
+	{
+		sprintf(output,"You cannot join %s queue. Double Login detected.", qd->queue_name);
+		clif_displaymessage(sd->fd,output);
+		return 0;
+	}
+
+	i = queue_member_add(qd,sd);
+	sprintf(output,"You have joined %s queue at position %d.", qd->queue_name, i);
+	clif_displaymessage(sd->fd,output);
+
+	if( qd->join_event[0] ) npc_event_do(qd->join_event);
+	return 1;
+}
+
+int queue_leave(struct map_session_data *sd, int q_id)
+{
+	char output[128];
+	struct queue_data *qd;
+
+	if( (qd = queue_search(q_id)) == NULL )
+		return 0;
+
+	if( !queue_member_remove(qd,sd->bl.id) )
+	{
+		sprintf(output,"You are not at %s queue.", qd->queue_name);
+		clif_displaymessage(sd->fd,output);
+		return 0;
+	}
+
+	return 1;
+}
+
+void queue_leaveall(struct map_session_data *sd)
+{
+	struct queue_data *qd;
+	if( sd && (qd = sd->qd) != NULL )
+	{
+		char output[128];
+		queue_member_remove(qd,sd->bl.id);
+		sprintf(output,"You have been removed from %s BG Queue.",qd->queue_name);
+		clif_displaymessage(sd->fd,output);
+	}
+}
+
+// ====================================================================
+
+void do_init_battleground(void)
+{
+	bg_team_db = idb_alloc(DB_OPT_RELEASE_DATA);
+	queue_db = idb_alloc(DB_OPT_RELEASE_DATA);
+
+	add_timer_func_list(bg_send_xy_timer, "bg_send_xy_timer");
+	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
+	bg_guild_build_data();
+}
+
+static int bg_team_db_reset(DBKey key, DBData *data, va_list ap)
+{
+	struct battleground_data *bg = (struct battleground_data *)db_data2ptr(data);
+	bg_team_clean(bg->bg_id,false);
+	return 0;
+}
+
+static int queue_db_final(DBKey key, DBData *data, va_list ap)
+{
+	struct queue_data *qd = (struct queue_data *)db_data2ptr(data);
+	queue_members_clean(qd); // Unlink all queue members
+	return 0;
+}
+
+void bg_reload(void)
+{ // @reloadscript
+	bg_team_db->destroy(bg_team_db,bg_team_db_reset);
+	queue_db->destroy(queue_db, queue_db_final);
+
+	bg_team_db = idb_alloc(DB_OPT_RELEASE_DATA);
+	queue_db = idb_alloc(DB_OPT_RELEASE_DATA);
+
+	bg_team_counter = 0;
+	queue_counter = 0;
+}
+
+void do_final_battleground(void)
+{
+	bg_team_db->destroy(bg_team_db, NULL);
+	queue_db->destroy(queue_db, queue_db_final);
+}
Index: src/map/battleground.h
===================================================================
--- src/map/battleground.h	(revision 1953)
+++ src/map/battleground.h	(working copy)
@@ -17,42 +17,90 @@
 #ifndef _BATTLEGROUND_H_
 #define _BATTLEGROUND_H_
 
-#include "../common/mmo.h" // struct party
-#include "guild.h"
-
-#define MAX_BG_MEMBERS 30
-
-struct battleground_member_data {
-	unsigned short x, y;
-	struct map_session_data *sd;
-	unsigned afk : 1;
-};
-
-struct battleground_data {
-	unsigned int bg_id;
-	unsigned char count;
-	struct battleground_member_data members[MAX_BG_MEMBERS];
-	// BG Cementery
-	unsigned short mapindex, x, y;
-	// Logout Event
-	char logout_event[EVENT_NAME_LENGTH];
-	char die_event[EVENT_NAME_LENGTH];
-};
-
-void do_init_battleground(void);
-void do_final_battleground(void);
-
-struct battleground_data *bg_team_search(int bg_id);
-int bg_send_dot_remove(struct map_session_data *sd);
-int bg_team_get_id(struct block_list *bl);
-struct map_session_data *bg_getavailablesd(struct battleground_data *bg);
-
-int bg_create(unsigned short mapindex, short rx, short ry, const char *ev, const char *dev);
-int bg_team_join(int bg_id, struct map_session_data *sd);
-int bg_team_delete(int bg_id);
-int bg_team_leave(struct map_session_data *sd, int flag);
-int bg_team_warp(int bg_id, unsigned short mapindex, short x, short y);
-int bg_member_respawn(struct map_session_data *sd);
-int bg_send_message(struct map_session_data *sd, const char *mes, int len);
-
-#endif /* _BATTLEGROUND_H_ */
+#include "../common/mmo.h" // struct party
+#include "guild.h"
+
+#define MAX_BG_MEMBERS 50
+
+struct battleground_member_data {
+	unsigned short x, y;
+	struct map_session_data *sd;
+	bool ranked;
+};
+
+struct battleground_data {
+	unsigned int bg_id;
+	time_t creation_tick; // Creation of this Team
+	int count;
+	struct battleground_member_data members[MAX_BG_MEMBERS];
+	// Team Leader and BG Skills features
+	int leader_char_id;
+	int skill_block_timer[MAX_GUILDSKILL];
+	unsigned int color;
+	// Party - Faction ID
+	int pf_id;
+	// Fake Guild Link
+	struct guild *g;
+	// BG Cementery
+	unsigned short mapindex, x, y;
+	bool reveal_pos, reveal_flag;
+	// Script Events
+	char logout_event[EVENT_NAME_LENGTH];
+	char die_event[EVENT_NAME_LENGTH];
+	// Score Board
+	int team_score;
+};
+
+struct queue_member {
+	int position;
+	struct map_session_data *sd;
+	struct queue_member *next;
+};
+
+struct queue_data {
+	unsigned int q_id;
+	int min_level, users;
+	struct queue_member *first, *last;
+	char queue_name[50], join_event[EVENT_NAME_LENGTH];
+};
+
+extern struct guild bg_guild[];
+extern const unsigned int bg_colors[];
+
+void do_init_battleground(void);
+void do_final_battleground(void);
+
+struct battleground_data* bg_team_search(int bg_id);
+struct guild* bg_guild_get(int bg_id);
+int bg_send_dot_remove(struct map_session_data *sd);
+int bg_team_get_id(struct block_list *bl);
+struct map_session_data* bg_getavailablesd(struct battleground_data *bg);
+
+int bg_create(unsigned short mapindex, short rx, short ry, int guild_index, const char *ev, const char *dev);
+int bg_team_join(int bg_id, struct map_session_data *sd);
+int bg_team_clean(int bg_id, bool remove);
+int bg_team_leave(struct map_session_data *sd, int flag);
+int bg_team_warp(int bg_id, unsigned short mapindex, short x, short y);
+int bg_member_respawn(struct map_session_data *sd);
+int bg_send_message(struct map_session_data *sd, const char *mes, int len);
+int battleground_countlogin(struct map_session_data *sd, bool check_bat_room);
+void bg_team_getitem(int bg_id, int nameid, int amount);
+void bg_team_get_kafrapoints(int bg_id, int amount);
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result);
+int bg_checkskill(struct battleground_data *bg, int id);
+void bg_block_skill_status(struct battleground_data *bg, int skillnum);
+void bg_block_skill_start(struct battleground_data *bg, int skillnum, int time);
+
+struct queue_data* queue_search(int q_id);
+int queue_create(const char* queue_name, const char* join_event, int min_level);
+int queue_destroy(int q_id);
+int queue_leave(struct map_session_data *sd, int q_id);
+void queue_leaveall(struct map_session_data *sd);
+int queue_join(struct map_session_data *sd, int q_id);
+
+struct queue_member* queue_member_get(struct queue_data *qd, int position);
+int queue_member_remove(struct queue_data *qd, int id);
+
+void bg_reload(void);
+
+#endif /* _BATTLEGROUND_H_ */
Index: src/map/buyingstore.c
===================================================================
--- src/map/buyingstore.c	(revision 1953)
+++ src/map/buyingstore.c	(working copy)
@@ -16,12 +16,13 @@
 
 #include "../common/cbasetypes.h"
 #include "../common/db.h"  // ARR_FIND
-#include "../common/showmsg.h"  // ShowWarning
-#include "../common/socket.h"  // RBUF*
-#include "../common/strlib.h"  // safestrncpy
-#include "atcommand.h"  // msg_txt
-#include "battle.h"  // battle_config.*
-#include "buyingstore.h"  // struct s_buyingstore
+#include "../common/showmsg.h"  // ShowWarning
+#include "../common/socket.h"  // RBUF*
+#include "../common/strlib.h"  // safestrncpy
+#include "../common/utils.h"  // MakeDWord - eAmod Required
+#include "atcommand.h"  // msg_txt
+#include "battle.h"  // battle_config.*
+#include "buyingstore.h"  // struct s_buyingstore
 #include "clif.h"  // clif_buyingstore_*
 #include "log.h"  // log_pick_pc, log_zeny
 #include "pc.h"  // struct map_session_data
@@ -58,7 +59,7 @@
 
 bool buyingstore_setup(struct map_session_data *sd, unsigned char slots)
 {
-	if(!battle_config.feature_buying_store || sd->state.vending || sd->state.buyingstore || sd->state.trading || slots == 0) {
+	if( !battle_config.feature_buying_store || battle_config.super_woe_enable || sd->state.vending || sd->state.buyingstore || sd->state.trading || slots == 0 ) {
 		return false;
 	}
 
@@ -72,8 +73,14 @@
 		clif_displaymessage(sd->fd, msg_txt(276)); // "You can't open a shop on this map"
 		return false;
 	}
+	
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't open Buying. Blocked with @security");
+		return false;
+	}
 
-	if(map_getcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_CHKNOVENDING)) {
+	if( map[sd->bl.m].flag.vending_cell != map_getcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_CHKNOVENDING) ) {
 		// custom: no vending cells
 		clif_displaymessage(sd->fd, msg_txt(204)); // "You can't open a shop on this cell."
 		return false;
@@ -127,7 +134,7 @@
 		return;
 	}
 
-	if(map_getcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_CHKNOVENDING)) {
+	if( map[sd->bl.m].flag.vending_cell != map_getcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_CHKNOVENDING) ) {
 		// custom: no vending cells
 		clif_displaymessage(sd->fd, msg_txt(204)); // "You can't open a shop on this cell."
 		return;
@@ -200,25 +207,31 @@
 	sd->buyer_id = buyingstore_getuid();
 	sd->buyingstore.zenylimit = zenylimit;
 	sd->buyingstore.slots = i;  // store actual amount of items
-	safestrncpy(sd->message, storename, sizeof(sd->message));
-	clif_buyingstore_myitemlist(sd);
-	clif_buyingstore_entry(sd);
-}
-
-
+	safestrncpy(sd->message, storename, sizeof(sd->message));
+	clif_buyingstore_myitemlist(sd);
+	clif_buyingstore_entry(sd);
+
+	if( map[sd->bl.m].flag.vending_cell )
+		map_setcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_NOVENDING, false);
+}
+
+
 void buyingstore_close(struct map_session_data *sd)
 {
 	if(sd->state.buyingstore) {
 		// invalidate data
 		sd->state.buyingstore = false;
 		memset(&sd->buyingstore, 0, sizeof(sd->buyingstore));
+
+		// notify other players
+		clif_buyingstore_disappear_entry(sd);
+
+		if( map[sd->bl.m].flag.vending_cell ) // Cell becomes available again.
+			map_setcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_NOVENDING, true);
+	}
+}
+
 
-		// notify other players
-		clif_buyingstore_disappear_entry(sd);
-	}
-}
-
-
 void buyingstore_open(struct map_session_data *sd, int account_id)
 {
 	struct map_session_data *pl_sd;
@@ -238,6 +251,12 @@
 		// not online or not buying
 		return;
 	}
+	
+	if( !battle_config.faction_allow_vending && pl_sd->status.faction_id != sd->status.faction_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot sell to other faction members.");
+		return;
+	}
 
 	if(!searchstore_queryremote(sd, account_id) && (sd->bl.m != pl_sd->bl.m || !check_distance_bl(&sd->bl, &pl_sd->bl, AREA_SIZE))) {
 		// out of view range
@@ -248,13 +267,13 @@
 	clif_buyingstore_itemlist(sd, pl_sd);
 }
 
-
-void buyingstore_trade(struct map_session_data *sd, int account_id, unsigned int buyer_id, const uint8 *itemlist, unsigned int count)
-{
-	int zeny = 0;
-	unsigned int i, weight, listidx, k;
-	struct map_session_data *pl_sd;
-
+
+void buyingstore_trade(struct map_session_data* sd, int account_id, unsigned int buyer_id, const uint8* itemlist, unsigned int count)
+{
+	int zeny = 0, char_id;
+	unsigned int i, weight, listidx, k;
+	struct map_session_data* pl_sd;
+
 	if(count == 0) {
 		// nothing to do
 		return;
@@ -321,11 +340,18 @@
 			return;
 		}
 
-		if(sd->status.inventory[index].expire_time || !itemdb_cantrade(&sd->status.inventory[index], pc_get_group_level(sd), pc_get_group_level(pl_sd)) || memcmp(sd->status.inventory[index].card, buyingstore_blankslots, sizeof(buyingstore_blankslots))) {
+		if( sd->status.inventory[index].expire_time || sd->status.inventory[index].bound || !itemdb_cantrade(&sd->status.inventory[index], pc_get_group_level(sd), pc_get_group_level(pl_sd)) || memcmp(sd->status.inventory[index].card, buyingstore_blankslots, sizeof(buyingstore_blankslots)) ) {
 			// non-tradable item
 			clif_buyingstore_trade_failed_seller(sd, BUYINGSTORE_TRADE_SELLER_FAILED, nameid);
 			return;
 		}
+		
+		if( sd->status.inventory[index].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->status.inventory[index].card[2],sd->status.inventory[index].card[3])) > 0 && (char_id == battle_config.bg_reserved_char_id || char_id == battle_config.ancient_reserved_char_id || char_id == battle_config.woe_reserved_char_id) )
+		{ // Items where creator's ID is important
+			clif_buyingstore_trade_failed_seller(sd, BUYINGSTORE_TRADE_SELLER_FAILED, nameid);
+			clif_displaymessage(sd->fd,"Cannot Trade event reserved Items (Battleground, WoE).");
+			return;
+		}
 
 		ARR_FIND(0, pl_sd->buyingstore.slots, listidx, pl_sd->buyingstore.items[listidx].nameid == nameid);
 		if(listidx == pl_sd->buyingstore.slots || pl_sd->buyingstore.items[listidx].amount == 0) {
Index: src/map/chrif.c
===================================================================
--- src/map/chrif.c	(revision 1953)
+++ src/map/chrif.c	(working copy)
@@ -51,16 +51,17 @@
 static struct eri *auth_db_ers; //For reutilizing player login structures.
 static DBMap *auth_db; // int id -> struct auth_node*
 
-static const int packet_len_table[0x3d] = { // U - used, F - free
-	60, 3,-1,27,10,-1, 6,-1,    // 2af8-2aff: U->2af8, U->2af9, U->2afa, U->2afb, U->2afc, U->2afd, U->2afe, U->2aff
-	6,-1,18, 7,-1,39,30, 10,   // 2b00-2b07: U->2b00, U->2b01, U->2b02, U->2b03, U->2b04, U->2b05, U->2b06, U->2b07
-	6,30, 0, 0,86, 7,44,34,    // 2b08-2b0f: U->2b08, U->2b09, F->2b0a, F->2b0b, U->2b0c, U->2b0d, U->2b0e, U->2b0f
-	11,10,10, 0,11, 0,266,10,   // 2b10-2b17: U->2b10, U->2b11, U->2b12, F->2b13, U->2b14, F->2b15, U->2b16, U->2b17
-	2,10, 2,-1,-1,-1, 2, 7,    // 2b18-2b1f: U->2b18, U->2b19, U->2b1a, U->2b1b, U->2b1c, U->2b1d, U->2b1e, U->2b1f
-	-1,10, 8, 2, 2,14,19,19,    // 2b20-2b27: U->2b20, U->2b21, U->2b22, U->2b23, U->2b24, U->2b25, U->2b26, U->2b27
-};
-
-//Used Packets:
+static const int packet_len_table[0x3d] = { // U - used, F - free
+	60, 3,-1,27,10,-1, 6,-1,	// 2af8-2aff: U->2af8, U->2af9, U->2afa, U->2afb, U->2afc, U->2afd, U->2afe, U->2aff
+	 6,-1,18, 7,-1,39,30, 10,	// 2b00-2b07: U->2b00, U->2b01, U->2b02, U->2b03, U->2b04, U->2b05, U->2b06, U->2b07
+	 6,30,10,-1,86, 7,44,34,	// 2b08-2b0f: U->2b08, U->2b09, U->2b0a, U->2b0b, U->2b0c, U->2b0d, U->2b0e, U->2b0f
+	11,10,10, 6,11,-1,14,10,	// 2b10-2b17: U->2b10, U->2b11, U->2b12, U->2b13, U->2b14, U->2b15, U->2b16, U->2b17
+	 2,10, 2,-1,-1,-1, 2, 7,	// 2b18-2b1f: U->2b18, U->2b19, U->2b1a, U->2b1b, U->2b1c, U->2b1d, U->2b1e, U->2b1f
+	-1,10, 8, 2, 2,14,19,19,	// 2b20-2b27: U->2b20, U->2b21, U->2b22, U->2b23, U->2b24, U->2b25, U->2b26, U->2b27
+	 4, 4, 4, 4,-1, 6, 0, 0,	// 2b28-2b2f: U->2b28, U->2b29, U->2b2a, U->2b2b, U->2b2c, F->2b2d, F->2b2e, F->2b2f
+};
+
+//Used Packets:
 //2af8: Outgoing, chrif_connect -> 'connect to charserver / auth @ charserver'
 //2af9: Incoming, chrif_connectack -> 'answer of the 2af8 login(ok / fail)'
 //2afa: Outgoing, chrif_sendmap -> 'sending our maps'
@@ -76,24 +77,24 @@
 //2b04: Incoming, chrif_recvmap -> 'getting maps from charserver of other mapserver's'
 //2b05: Outgoing, chrif_changemapserver -> 'Tell the charserver the mapchange / quest for ok...'
 //2b06: Incoming, chrif_changemapserverack -> 'awnser of 2b05, ok/fail, data: dunno^^'
-//2b07: Outgoing, chrif_removefriend -> 'Tell charserver to remove friend_id from char_id friend list'
-//2b08: Outgoing, chrif_searchcharid -> '...'
-//2b09: Incoming, map_addchariddb -> 'Adds a name to the nick db'
-//2b0a: FREE
-//2b0b: FREE
-//2b0c: Outgoing, chrif_changeemail -> 'change mail address ...'
-//2b0d: Incoming, chrif_changedsex -> 'Change sex of acc XY'
-//2b0e: Outgoing, chrif_char_ask_name -> 'Do some operations (change sex, ban / unban etc)'
+//2b07: Outgoing, chrif_removefriend -> 'Tell charserver to remove friend_id from char_id friend list'
+//2b08: Outgoing, chrif_searchcharid -> '...'
+//2b09: Incoming, map_addchariddb -> 'Adds a name to the nick db'
+//2b0a: Outgoing, chrif_skillcooldown_request -> request skill cooldown data
+//2b0b: Incoming, chrif_skillcooldown_load -> receives skill cooldown data
+//2b0c: Outgoing, chrif_changeemail -> 'change mail address ...'
+//2b0d: Incoming, chrif_changedsex -> 'Change sex of acc XY'
+//2b0e: Outgoing, chrif_char_ask_name -> 'Do some operations (change sex, ban / unban etc)'
 //2b0f: Incoming, chrif_char_ask_name_answer -> 'answer of the 2b0e'
 //2b10: Outgoing, chrif_updatefamelist -> 'Update the fame ranking lists and send them'
 //2b11: Outgoing, chrif_divorce -> 'tell the charserver to do divorce'
-//2b12: Incoming, chrif_divorceack -> 'divorce chars
-//2b13: FREE
-//2b14: Incoming, chrif_accountban -> 'not sure: kick the player with message XY'
-//2b15: FREE
-//2b16: Outgoing, chrif_ragsrvinfo -> 'sends base / job / drop rates ....'
-//2b17: Outgoing, chrif_char_offline -> 'tell the charserver that the char is now offline'
-//2b18: Outgoing, chrif_char_reset_offline -> 'set all players OFF!'
+//2b12: Incoming, chrif_divorceack -> 'divorce chars
+//2b13: FREE
+//2b14: Incoming, chrif_accountban -> 'not sure: kick the player with message XY'
+//2b15: Outgoing, chrif_skillcooldown_save -> Send skill cooldown data for saving
+//2b16: Outgoing, chrif_ragsrvinfo -> 'sends base / job / drop rates ....'
+//2b17: Outgoing, chrif_char_offline -> 'tell the charserver that the char is now offline'
+//2b18: Outgoing, chrif_char_reset_offline -> 'set all players OFF!'
 //2b19: Outgoing, chrif_char_online -> 'tell the charserver that the char .. is online'
 //2b1a: Outgoing, chrif_buildfamelist -> 'Build the fame ranking lists and send them'
 //2b1b: Incoming, chrif_recvfamelist -> 'Receive fame ranking lists'
@@ -106,12 +107,17 @@
 //2b22: Incoming, chrif_updatefamelist_ack. Updated one position in the fame list.
 //2b23: Outgoing, chrif_keepalive. charserver ping.
 //2b24: Incoming, chrif_keepalive_ack. charserver ping reply.
-//2b25: Incoming, chrif_deadopt -> 'Removes baby from Father ID and Mother ID'
-//2b26: Outgoing, chrif_authreq -> 'client authentication request'
-//2b27: Incoming, chrif_authfail -> 'client authentication failed'
-
-int chrif_connected = 0;
-int char_fd = -1;
+//2b25: Incoming, chrif_deadopt -> 'Removes baby from Father ID and Mother ID'
+//2b26: Outgoing, chrif_authreq -> 'client authentication request'
+//2b27: Incoming, chrif_authfail -> 'client authentication failed'
+//2b28: Outgoing, chrif_ranking_reset -> '...'
+//2b29: Incoming, chrif_ranking_reset_ack -> '...'
+//2b2a: Outgoing, chrif_item_remove4all -> '...'
+//2b2b: Incoming, chrif_item_remove4all_ack -> '...'
+//2b2d: Outgoing, chrif_char2dumpfile -> '...'
+
+int chrif_connected = 0;
+int char_fd = -1;
 int srvinfo;
 static char char_ip_str[128];
 static uint32 char_ip = 0;
@@ -298,15 +304,18 @@
 	nullpo_retr(-1, sd);
 
 	pc_makesavestatus(sd);
-
-	if(flag && sd->state.active) {  //Store player data which is quitting
-		//FIXME: SC are lost if there's no connection at save-time because of the way its related data is cleared immediately after this function. [Skotlex]
-		if(chrif_isconnected())
-			chrif_save_scdata(sd);
-		if(!chrif_auth_logout(sd,flag == 1 ? ST_LOGOUT : ST_MAPCHANGE))
-			ShowError("chrif_save: Failed to set up player %d:%d for proper quitting!\n", sd->status.account_id, sd->status.char_id);
-	}
-
+
+	if (flag && sd->state.active) { //Store player data which is quitting
+		//FIXME: SC are lost if there's no connection at save-time because of the way its related data is cleared immediately after this function. [Skotlex]
+		if( chrif_isconnected() )
+		{
+			chrif_save_scdata(sd);
+			chrif_skillcooldown_save(sd);
+		}
+		if (!chrif_auth_logout(sd, flag==1?ST_LOGOUT:ST_MAPCHANGE))
+			ShowError("chrif_save: Failed to set up player %d:%d for proper quitting!\n", sd->status.account_id, sd->status.char_id);
+	}
+
 	chrif_check(-1); //Character is saved on reconnect.
 
 	//For data sync
@@ -321,12 +330,14 @@
 		intif_saveregistry(sd, 3); //Save char regs
 	if(sd->state.reg_dirty&2)
 		intif_saveregistry(sd, 2); //Save account regs
-	if(sd->state.reg_dirty&1)
-		intif_saveregistry(sd, 1); //Save account2 regs
-
-	WFIFOHEAD(char_fd, sizeof(sd->status) + 13);
-	WFIFOW(char_fd,0) = 0x2b01;
-	WFIFOW(char_fd,2) = sizeof(sd->status) + 13;
+	if (sd->state.reg_dirty&1)
+		intif_saveregistry(sd, 1); //Save account2 regs
+
+	pc_calc_playtime(sd); // Play Time Calculation
+
+	WFIFOHEAD(char_fd, sizeof(sd->status) + 13);
+	WFIFOW(char_fd,0) = 0x2b01;
+	WFIFOW(char_fd,2) = sizeof(sd->status) + 13;
 	WFIFOL(char_fd,4) = sd->status.account_id;
 	WFIFOL(char_fd,8) = sd->status.char_id;
 	WFIFOB(char_fd,12) = (flag==1)?1:0; //Flag to tell char-server this character is quitting.
@@ -340,13 +351,15 @@
 	if(sd->md && mercenary_get_lifetime(sd->md) > 0)
 		mercenary_save(sd->md);
 	if(sd->ed && elemental_get_lifetime(sd->ed) > 0)
-		elemental_save(sd->ed);
-	if(sd->save_quest)
-		intif_quest_save(sd);
+		elemental_save(sd->ed);	
+	if( sd->save_quest )
+		intif_quest_save(sd);
+	if( sd->save_achievement )
+		intif_achievement_save(sd);
+
+	return 0;
+}
 
-	return 0;
-}
-
 // connects to char-server (plaintext)
 int chrif_connect(int fd)
 {
@@ -598,13 +611,26 @@
 	WFIFOL(char_fd,6) = char_id;
 	WFIFOSET(char_fd,10);
 #endif
-
-	return 0;
-}
-
-/*==========================================
- * Request auth confirmation
- *------------------------------------------*/
+	
+	return 0;
+}
+/*==========================================
+ * Request skillcooldown from charserver [Zephyrus]
+ *------------------------------------------*/
+int chrif_skillcooldown_request(int account_id, int char_id)
+{
+	chrif_check(-1);
+
+	WFIFOHEAD(char_fd,10);
+	WFIFOW(char_fd,0) = 0x2b0a;
+	WFIFOL(char_fd,2) = account_id;
+	WFIFOL(char_fd,6) = char_id;
+	WFIFOSET(char_fd,10);
+	return 0;
+}
+/*==========================================
+ * Request auth confirmation
+ *------------------------------------------*/
 void chrif_authreq(struct map_session_data *sd)
 {
 	struct auth_node *node= chrif_search(sd->bl.id);
@@ -1030,12 +1056,52 @@
 		clif_deleteskill(sd,WE_CALLBABY);
 	}
 
-	return 0;
-}
-
-/*==========================================
- * Disconnection of a player (account has been banned of has a status, from login-server) by [Yor]
- *------------------------------------------*/
+	return 0;
+}
+/*==========================================
+ * Ranking Reset
+ *------------------------------------------*/
+int chrif_ranking_reset(int type)
+{
+	chrif_check(-1);
+
+	WFIFOHEAD(char_fd,4);
+	WFIFOW(char_fd,0) = 0x2b28;
+	WFIFOW(char_fd,2) = type;
+	WFIFOSET(char_fd,4);
+
+	return 0;
+}
+
+int chrif_ranking_reset_ack(int type)
+{
+	pc_ranking_reset(type, false);
+	return 0;
+}
+/*==========================================
+ * Ranking Reset
+ *------------------------------------------*/
+int chrif_item_remove4all(int nameid)
+{
+	chrif_check(-1);
+
+	WFIFOHEAD(char_fd,4);
+	WFIFOW(char_fd,0) = 0x2b2a;
+	WFIFOW(char_fd,2) = nameid;
+	WFIFOSET(char_fd,4);
+
+	return 0;
+}
+
+int chrif_item_remove4all_ack(int nameid)
+{
+	pc_item_remove4all(nameid, false);
+	return 0;
+}
+
+/*==========================================
+ * Disconnection of a player (account has been banned of has a status, from login-server) by [Yor]
+ *------------------------------------------*/
 int chrif_accountban(int fd)
 {
 	int acc;
@@ -1114,30 +1180,67 @@
 /*==========================================
  * Request/Receive top 10 Fame character list
  *------------------------------------------*/
-int chrif_updatefamelist(struct map_session_data *sd)
+int chrif_updatefamelist(struct map_session_data* sd, short flag)
 {
 	char type;
 
 	chrif_check(-1);
 
-	switch(sd->class_ & MAPID_UPPERMASK) {
+	if( !flag )
+	{
+		switch(sd->class_ & MAPID_UPPERMASK)
+		{
 		case MAPID_BLACKSMITH: type = 1; break;
 		case MAPID_ALCHEMIST:  type = 2; break;
 		case MAPID_TAEKWON:    type = 3; break;
 		default:
 			return 0;
+		}
 	}
+	else type = 3 + flag; // 4 = PK | 5 = BG Ranked | 6 = BG Normal
 
 	WFIFOHEAD(char_fd, 11);
 	WFIFOW(char_fd,0) = 0x2b10;
 	WFIFOL(char_fd,2) = sd->status.char_id;
-	WFIFOL(char_fd,6) = sd->status.fame;
+	switch( flag )
+	{
+	case 1:  WFIFOL(char_fd,6) = sd->status.pk.score; break;
+	case 2:  WFIFOL(char_fd,6) = sd->status.bgstats.rank_points; break;
+	case 3:  WFIFOL(char_fd,6) = sd->status.bgstats.points; break;
+	default: WFIFOL(char_fd,6) = sd->status.fame; break;
+	}
 	WFIFOB(char_fd,10) = type;
 	WFIFOSET(char_fd,11);
 
 	return 0;
 }
 
+int chrif_recvfamelist_single(int fd, int type)
+{
+	struct fame_list* list;
+	int i, len = 6, size;
+
+	switch( type )
+	{
+		case 1: memset(smith_fame_list, 0, sizeof(smith_fame_list)); list = smith_fame_list;   break;
+		case 2: memset(chemist_fame_list, 0, sizeof(chemist_fame_list)); list = chemist_fame_list; break;
+		case 3: memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list)); list = taekwon_fame_list; break;
+		case 4: memset(pvprank_fame_list, 0, sizeof(pvprank_fame_list)); list = pvprank_fame_list; break;
+		case 5: memset(bgrank_fame_list, 0, sizeof(bgrank_fame_list)); list = bgrank_fame_list;  break;
+		case 6: memset(bg_fame_list, 0, sizeof(bg_fame_list)); list = bg_fame_list;  break;
+		default: return 0;
+	}
+
+	size = RFIFOW(fd,2);
+	for( i = 0; len < size && i < MAX_FAME_LIST; i++ )
+	{
+		memcpy(&list[i],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+
+	return 0;
+}
+
 int chrif_buildfamelist(void)
 {
 	chrif_check(-1);
@@ -1152,34 +1255,61 @@
 int chrif_recvfamelist(int fd)
 {
 	int num, size;
-	int total = 0, len = 8;
+	int total = 0, len = 14;
 
 	memset(smith_fame_list, 0, sizeof(smith_fame_list));
 	memset(chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset(pvprank_fame_list, 0, sizeof(pvprank_fame_list));
+	memset(bgrank_fame_list, 0, sizeof(bgrank_fame_list));
+	memset(bg_fame_list, 0, sizeof(bg_fame_list));
 
-	size = RFIFOW(fd, 6); //Blacksmith block size
+	size = RFIFOW(fd,12); //BGRank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&bg_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	total += num;
 
-	for(num = 0; len < size && num < MAX_FAME_LIST; num++) {
-		memcpy(&smith_fame_list[num], RFIFOP(fd,len), sizeof(struct fame_list));
+	size = RFIFOW(fd,10); //BGRank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&bgrank_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
+	total += num;
 
+	size = RFIFOW(fd,8); //PvPRank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&pvprank_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
 	total += num;
 
-	size = RFIFOW(fd, 4); //Alchemist block size
+	size = RFIFOW(fd,6); //Blacksmith block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&smith_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
 
-	for(num = 0; len < size && num < MAX_FAME_LIST; num++) {
-		memcpy(&chemist_fame_list[num], RFIFOP(fd,len), sizeof(struct fame_list));
+	total += num;
+
+	size = RFIFOW(fd,4); //Alchemist block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&chemist_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
 
 	total += num;
 
-	size = RFIFOW(fd, 2); //Total packet length
-
-	for(num = 0; len < size && num < MAX_FAME_LIST; num++) {
-		memcpy(&taekwon_fame_list[num], RFIFOP(fd,len), sizeof(struct fame_list));
+	size = RFIFOW(fd,2); //Total packet length
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&taekwon_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
 	}
 
@@ -1198,12 +1328,15 @@
 	uint8 index;
 
 	switch(RFIFOB(fd,2)) {
-		case 1: list = smith_fame_list;   break;
-		case 2: list = chemist_fame_list; break;
-		case 3: list = taekwon_fame_list; break;
-		default: return 0;
-	}
-
+		case 1: list = smith_fame_list;   break;
+		case 2: list = chemist_fame_list; break;
+		case 3: list = taekwon_fame_list; break;
+		case 4: list = pvprank_fame_list; break;
+		case 5: list = bgrank_fame_list;  break;
+		case 6: list = bg_fame_list;  break;
+		default: return 0;
+	}
+	
 	index = RFIFOB(fd, 3);
 
 	if(index >= MAX_FAME_LIST)
@@ -1262,8 +1395,49 @@
 
 	return 0;
 }
-
-//Retrieve and load sc_data for a player. [Skotlex]
+
+int chrif_skillcooldown_save(struct map_session_data *sd)
+{
+	int i, count = 0;
+	struct skill_cooldown_data data;
+	unsigned int tick;
+	const struct TimerData *timer;
+
+	chrif_check(-1);
+	tick = gettick();
+
+	WFIFOHEAD(char_fd,14 + MAX_SKILLCOOLDOWN * sizeof(struct skill_cooldown_data));
+	WFIFOW(char_fd,0) = 0x2b15;
+	WFIFOL(char_fd,4) = sd->status.account_id;
+	WFIFOL(char_fd,8) = sd->status.char_id;
+	for( i = 0; i < MAX_SKILLCOOLDOWN; i++ )
+	{
+		if( !sd->scd[i] )
+			continue;
+
+		if( !battle_config.guild_skill_relog_delay && (sd->scd[i]->skill_id >= GD_BATTLEORDER && sd->scd[i]->skill_id <= GD_EMERGENCYCALL ) )
+			continue;
+
+		timer = get_timer(sd->scd[i]->timer);
+		if( timer == NULL || timer->func != skill_blockpc_end || DIFF_TICK(timer->tick,tick) < 0 )
+			continue;
+		
+		data.tick = DIFF_TICK(timer->tick,tick);
+		data.skill_id = sd->scd[i]->skill_id;
+		memcpy(WFIFOP(char_fd,14+count*sizeof(struct skill_cooldown_data)),	&data, sizeof(struct skill_cooldown_data));
+		count++;
+	}
+	if( count == 0 )
+		return 0;
+
+	WFIFOW(char_fd,12) = count;
+	WFIFOW(char_fd,2) = 14 + count * sizeof(struct skill_cooldown_data);
+	WFIFOSET(char_fd,WFIFOW(char_fd,2));
+
+	return 0;
+}
+
+//Retrieve and load sc_data for a player. [Skotlex]
 int chrif_load_scdata(int fd)
 {
 
@@ -1295,12 +1469,42 @@
 	}
 #endif
 
-	return 0;
-}
-
-/*==========================================
- * Send rates and motd to char server [Wizputer]
- * S 2b16 <base rate>.L <job rate>.L <drop rate>.L
+	return 0;
+}
+
+//Retrieve and load skillcooldown for a player
+int chrif_skillcooldown_load(int fd)
+{
+	struct map_session_data *sd;
+	struct skill_cooldown_data *data;
+	int aid, cid, i, count;
+
+	aid = RFIFOL(fd,4);
+	cid = RFIFOL(fd,8);
+
+	sd = map_id2sd(aid);
+	if( !sd )
+	{
+		ShowError("chrif_skillcooldown_load: Player of AID %d not found!\n", aid);
+		return -1;	
+	}
+	if( sd->status.char_id != cid )
+	{
+		ShowError("chrif_skillcooldown_load: Receiving data for account %d, char id does not matches (%d != %d)!\n", aid, sd->status.char_id, cid);
+		return -1;
+	}
+	count = RFIFOW(fd,12); //sc_count
+	for( i = 0; i < count; i++ )
+	{
+		data = (struct skill_cooldown_data*)RFIFOP(fd,14 + i*sizeof(struct skill_cooldown_data));
+		skill_blockpc_start(sd, data->skill_id, data->tick);
+	}
+	return 0;
+}
+
+/*==========================================
+ * Send rates and motd to char server [Wizputer]
+ * S 2b16 <base rate>.L <job rate>.L <drop rate>.L
  *------------------------------------------*/
 int chrif_ragsrvinfo(int base_rate, int job_rate, int drop_rate)
 {
@@ -1371,12 +1575,27 @@
 	WFIFOSET(char_fd,2);
 
 	return 0;
-}
-
-/*=========================================
- * Tell char-server charcter is online [Wizputer]
- *-----------------------------------------*/
-
+}
+
+/*=========================================
+ * Request to create a Backup file of a char_id
+ *-----------------------------------------*/
+int chrif_char2dumpfile(int char_id)
+{
+	chrif_check(-1);
+
+	WFIFOHEAD(char_fd,6);
+	WFIFOW(char_fd,0) = 0x2b2d;
+	WFIFOL(char_fd,2) = char_id;
+	WFIFOSET(char_fd,6);
+
+	return 0;
+}
+
+/*=========================================
+ * Tell char-server charcter is online [Wizputer]
+ *-----------------------------------------*/
+
 int chrif_char_online(struct map_session_data *sd)
 {
 	chrif_check(-1);
@@ -1498,12 +1717,13 @@
 			case 0x2afd: chrif_authok(fd); break;
 			case 0x2b00: map_setusers(RFIFOL(fd,2)); chrif_keepalive(fd); break;
 			case 0x2b03: clif_charselectok(RFIFOL(fd,2), RFIFOB(fd,6)); break;
-			case 0x2b04: chrif_recvmap(fd); break;
-			case 0x2b06: chrif_changemapserverack(RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10), RFIFOL(fd,14), RFIFOW(fd,18), RFIFOW(fd,20), RFIFOW(fd,22), RFIFOL(fd,24), RFIFOW(fd,28)); break;
-			case 0x2b09: map_addnickdb(RFIFOL(fd,2), (char *)RFIFOP(fd,6)); break;
-			case 0x2b0d: chrif_changedsex(fd); break;
-			case 0x2b0f: chrif_char_ask_name_answer(RFIFOL(fd,2), (char *)RFIFOP(fd,6), RFIFOW(fd,30), RFIFOW(fd,32)); break;
-			case 0x2b12: chrif_divorceack(RFIFOL(fd,2), RFIFOL(fd,6)); break;
+			case 0x2b04: chrif_recvmap(fd); break;
+			case 0x2b06: chrif_changemapserverack(RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10), RFIFOL(fd,14), RFIFOW(fd,18), RFIFOW(fd,20), RFIFOW(fd,22), RFIFOL(fd,24), RFIFOW(fd,28)); break;
+			case 0x2b09: map_addnickdb(RFIFOL(fd,2), (char*)RFIFOP(fd,6)); break;
+			case 0x2b0b: chrif_skillcooldown_load(fd); break;
+			case 0x2b0d: chrif_changedsex(fd); break;
+			case 0x2b0f: chrif_char_ask_name_answer(RFIFOL(fd,2), (char*)RFIFOP(fd,6), RFIFOW(fd,30), RFIFOW(fd,32)); break;
+			case 0x2b12: chrif_divorceack(RFIFOL(fd,2), RFIFOL(fd,6)); break;
 			case 0x2b14: chrif_accountban(fd); break;
 			case 0x2b1b: chrif_recvfamelist(fd); break;
 			case 0x2b1d: chrif_load_scdata(fd); break;
@@ -1512,12 +1732,15 @@
 			case 0x2b20: chrif_removemap(fd); break;
 			case 0x2b21: chrif_save_ack(fd); break;
 			case 0x2b22: chrif_updatefamelist_ack(fd); break;
-			case 0x2b24: chrif_keepalive_ack(fd); break;
-			case 0x2b25: chrif_deadopt(RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10)); break;
-			case 0x2b27: chrif_authfail(fd); break;
-			default:
-				ShowError("chrif_parse : unknown packet (session #%d): 0x%x. Disconnecting.\n", fd, cmd);
-				set_eof(fd);
+			case 0x2b24: chrif_keepalive_ack(fd); break;
+			case 0x2b25: chrif_deadopt(RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10)); break;
+			case 0x2b27: chrif_authfail(fd); break;
+			case 0x2b29: chrif_ranking_reset_ack(RFIFOW(fd,2)); break;
+			case 0x2b2b: chrif_item_remove4all_ack(RFIFOW(fd,2)); break;
+			case 0x2b2c: chrif_recvfamelist_single(fd,RFIFOW(fd,4)); break;
+			default:
+				ShowError("chrif_parse : unknown packet (session #%d): 0x%x. Disconnecting.\n", fd, cmd);
+				set_eof(fd);
 				return 0;
 		}
 		if(fd == char_fd)    //There's the slight chance we lost the connection during parse, in which case this would segfault if not checked [Skotlex]
Index: src/map/chrif.h
===================================================================
--- src/map/chrif.h	(revision 1953)
+++ src/map/chrif.h	(working copy)
@@ -48,32 +48,36 @@
 bool chrif_auth_delete(int account_id, int char_id, enum sd_state state);
 bool chrif_auth_finished(struct map_session_data *sd);
 
-void chrif_authreq(struct map_session_data *sd);
-void chrif_authok(int fd);
-int chrif_scdata_request(int account_id, int char_id);
-int chrif_save(struct map_session_data *sd, int flag);
-int chrif_charselectreq(struct map_session_data *sd, uint32 s_ip);
-int chrif_changemapserver(struct map_session_data *sd, uint32 ip, uint16 port);
+void chrif_authreq(struct map_session_data* sd);
+void chrif_authok(int fd);
+int chrif_scdata_request(int account_id, int char_id);
+int chrif_skillcooldown_request(int account_id, int char_id);
+int chrif_save(struct map_session_data* sd, int flag);
+int chrif_charselectreq(struct map_session_data* sd, uint32 s_ip);
+int chrif_changemapserver(struct map_session_data* sd, uint32 ip, uint16 port);
 
-int chrif_searchcharid(int char_id);
-int chrif_changeemail(int id, const char *actual_email, const char *new_email);
-int chrif_char_ask_name(int acc, const char *character_name, unsigned short operation_type, int year, int month, int day, int hour, int minute, int second);
-int chrif_updatefamelist(struct map_session_data *sd);
-int chrif_buildfamelist(void);
-int chrif_save_scdata(struct map_session_data *sd);
-int chrif_ragsrvinfo(int base_rate,int job_rate, int drop_rate);
-int chrif_char_offline(struct map_session_data *sd);
-int chrif_char_offline_nsd(int account_id, int char_id);
+int chrif_searchcharid(int char_id);
+int chrif_changeemail(int id, const char *actual_email, const char *new_email);
+int chrif_char_ask_name(int acc, const char* character_name, unsigned short operation_type, int year, int month, int day, int hour, int minute, int second);
+int chrif_updatefamelist(struct map_session_data *sd, short flag);
+int chrif_buildfamelist(void);
+int chrif_save_scdata(struct map_session_data *sd);
+int chrif_skillcooldown_save(struct map_session_data *sd);
+int chrif_ragsrvinfo(int base_rate,int job_rate, int drop_rate);
+int chrif_char_offline(struct map_session_data *sd);
+int chrif_char_offline_nsd(int account_id, int char_id);
 int chrif_char_reset_offline(void);
 int send_users_tochar(void);
 int chrif_char_online(struct map_session_data *sd);
-int chrif_changesex(struct map_session_data *sd);
-int chrif_chardisconnect(struct map_session_data *sd);
-int chrif_divorce(int partner_id1, int partner_id2);
-
-int chrif_removefriend(int char_id, int friend_id);
-void chrif_send_report(char *buf, int len);
-
+int chrif_changesex(struct map_session_data *sd);
+int chrif_chardisconnect(struct map_session_data *sd);
+int chrif_divorce(int partner_id1, int partner_id2);
+int chrif_char2dumpfile(int char_id); // Zephyrus
+int chrif_ranking_reset(int type);
+int chrif_item_remove4all(int nameid);
+int chrif_removefriend(int char_id, int friend_id);
+void chrif_send_report(char* buf, int len);
+
 int do_final_chrif(void);
 int do_init_chrif(void);
 
Index: src/map/clif.c
===================================================================
--- src/map/clif.c	(revision 1953)
+++ src/map/clif.c	(working copy)
@@ -22,19 +22,21 @@
 #include "../common/nullpo.h"
 #include "../common/random.h"
 #include "../common/showmsg.h"
-#include "../common/strlib.h"
-#include "../common/utils.h"
-#include "../common/ers.h"
-
-#include "map.h"
-#include "chrif.h"
+#include "../common/strlib.h"
+#include "../common/utils.h"
+#include "../common/ers.h"
+#include "../common/db.h"
+
+#include "map.h"
+#include "chrif.h"
 #include "pc.h"
-#include "status.h"
-#include "npc.h"
-#include "itemdb.h"
-#include "chat.h"
-#include "trade.h"
-#include "storage.h"
+#include "status.h"
+#include "npc.h"
+#include "itemdb.h"
+#include "channel.h"
+#include "chat.h"
+#include "trade.h"
+#include "storage.h"
 #include "script.h"
 #include "skill.h"
 #include "atcommand.h"
@@ -52,12 +54,15 @@
 #include "mercenary.h"
 #include "elemental.h"
 #include "log.h"
-#include "clif.h"
-#include "mail.h"
-#include "quest.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "clif.h"
+#include "mail.h"
+#include "quest.h"
+#include "achievement.h"
+#include "region.h"
+#include "faction.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <time.h>
@@ -201,12 +206,180 @@
 static uint16 map_port = 5121;
 int map_fd;
 
-static int clif_parse(int fd);
-
-/*==========================================
- * Ip setting of map-server
- *------------------------------------------*/
-int clif_setip(const char *ip)
+static int clif_parse (int fd);
+
+/*==========================================
+ * GM Level - Chat Color
+ *------------------------------------------*/
+static int gm_color[100];
+
+static bool clif_parse_row_gmcolor(char* split[], int columns, int current)
+{
+	int from, to;
+	unsigned long color;
+	int i;
+
+	// Get values from Row
+	from = atoi(split[0]);
+	to = atoi(split[1]);
+	color = strtoul(split[2],NULL,0);
+
+	// RGB to BGR
+	color = (color & 0x0000FF) << 16 | (color & 0x00FF00) | (color & 0xFF0000) >> 16;
+
+	// Limit received values to avoid crash
+	from = cap_value(from,0,99);
+	to = cap_value(to,0,99);
+
+	for( i = from; i <= to; i++ )
+		gm_color[i] = color;
+
+	return true;
+}
+
+void clif_load_gm_color(void)
+{
+	int i;
+	for( i = 0; i < 100; i++ ) gm_color[i] = -1;
+	sv_readdb(db_path, "gm_color_db.txt", ',', 3, 3, -1, clif_parse_row_gmcolor);
+}
+
+/*==========================================
+ * @aura
+ *------------------------------------------*/
+static int auraTable[][3] = {
+	{  -1,  -1,  -1 },
+	// Reserved for PK Mode
+	{ 586,  -1,  -1 }, // LH
+	{ 586, 362,  -1 }, // LH Mvp
+	{ 586, 362, 240 }, // 1º PK Place
+	// Basic Auras
+	{ 418,  -1,  -1 }, // Red Fury
+	{ 486,  -1,  -1 }, // Blue Fury
+	{ 485,  -1,  -1 }, // White Fury
+	{ 239,  -1,  -1 }, // Aura Red
+	{ 240,  -1,  -1 }, // Aura White
+	{ 241,  -1,  -1 }, // Aura Yellow
+	{ 620,  -1,  -1 }, // Aura Blue
+	{ 202,  -1,  -1 }, // Lvl 99 Bubbles
+	{ 362,  -1,  -1 }, // Advanced Lvl 99 Bubbles
+	{ 678,  -1,  -1 }, // Brazil Aura Bubbles
+	{ 679,  -1,  -1 }, // Brazil Aura
+	{ 680,  -1,  -1 }, // Brazil Aura Floor
+	// 2 Sets
+	{ 239, 418,  -1 },
+	{ 239, 486,  -1 },
+	{ 239, 485,  -1 },
+	{ 240, 418,  -1 },
+	{ 240, 486,  -1 },
+	{ 240, 485,  -1 },
+	{ 241, 418,  -1 },
+	{ 241, 486,  -1 },
+	{ 241, 485,  -1 },
+	{ 620, 418,  -1 },
+	{ 620, 486,  -1 },
+	{ 620, 485,  -1 },
+	// Full Sets
+	{ 239, 418, 202 },
+	{ 239, 486, 202 },
+	{ 239, 485, 202 },
+	{ 240, 418, 202 },
+	{ 240, 486, 202 },
+	{ 240, 485, 202 },
+	{ 241, 418, 202 },
+	{ 241, 486, 202 },
+	{ 241, 485, 202 },
+	{ 620, 418, 202 },
+	{ 620, 486, 202 },
+	{ 620, 485, 202 },
+	{ 239, 418, 362 },
+	{ 239, 486, 362 },
+	{ 239, 485, 362 },
+	{ 240, 418, 362 },
+	{ 240, 486, 362 },
+	{ 240, 485, 362 },
+	{ 241, 418, 362 },
+	{ 241, 486, 362 },
+	{ 241, 485, 362 },
+	{ 620, 418, 362 },
+	{ 620, 486, 362 },
+	{ 620, 485, 362 },
+	{ 239, 418, 678 },
+	{ 239, 486, 678 },
+	{ 239, 485, 678 },
+	{ 240, 418, 678 },
+	{ 240, 486, 678 },
+	{ 240, 485, 678 },
+	{ 241, 418, 678 },
+	{ 241, 486, 678 },
+	{ 241, 485, 678 },
+	{ 620, 418, 678 },
+	{ 620, 486, 678 },
+	{ 620, 485, 678 },
+	// Oficial Set
+	{ 680, 679, 678 },
+	{  -1,  -1,  -1 }
+};
+
+int aura_getSize()
+{
+	return sizeof(auraTable)/(sizeof(int) * 3) - 1;
+}
+
+int aura_getAuraEffect(struct map_session_data *sd, short pos)
+{
+	int aura = sd->view_aura;
+	if( pos < 0 || pos > 2 )
+		return -1;
+	if( aura > aura_getSize() || aura < 0 )
+		return -1;
+
+	return auraTable[aura][pos];
+}
+
+void clif_sendaurastoone(struct map_session_data *sd, struct map_session_data *dsd)
+{
+	int effect1, effect2, effect3;
+
+	if( pc_ishiding(sd) || map_flag_vs(sd->bl.m) )
+		return;
+
+	effect1 = aura_getAuraEffect(sd,0);
+	effect2 = aura_getAuraEffect(sd,1);
+	effect3 = aura_getAuraEffect(sd,2);
+
+	if( effect1 >= 0 )
+		clif_specialeffect_single(&sd->bl,effect1,dsd->fd);
+	if( effect2 >= 0 )
+		clif_specialeffect_single(&sd->bl,effect2,dsd->fd);
+	if( effect3 >= 0 )
+		clif_specialeffect_single(&sd->bl,effect3,dsd->fd);
+}
+
+void clif_sendauras(struct map_session_data *sd,  enum send_target type)
+{
+	int effect1, effect2, effect3;
+
+	if( pc_ishiding(sd) || map_flag_vs(sd->bl.m) )
+		return;
+
+	effect1 = aura_getAuraEffect(sd,0);
+	effect2 = aura_getAuraEffect(sd,1);
+	effect3 = aura_getAuraEffect(sd,2);
+
+	if( effect1 >= 0 )
+		clif_specialeffect(&sd->bl,effect1,type);
+	if( effect2 >= 0 )
+		clif_specialeffect(&sd->bl,effect2,type);
+	if( effect3 >= 0 )
+		clif_specialeffect(&sd->bl,effect3,type);
+}
+
+
+/*==========================================
+ * Ip setting of map-server
+ *------------------------------------------*/
+int clif_setip(const char* ip)
 {
 	char ip_str[16];
 	map_ip = host2ip(ip);
@@ -319,6 +492,10 @@
 	type = va_arg(ap,int);
 
 	switch(type) {
+		case AREA:
+			if( RBUFW(buf,0) == 0x01c8 && (map[sd->bl.m].flag.gvg || map[sd->bl.m].flag.battleground) && bl != src_bl && sd->state.packet_filter&2 )
+				return 0; // Ignore other player's item usage
+		break;
 		case AREA_WOS:
 			if(bl == src_bl)
 				return 0;
@@ -326,7 +503,50 @@
 		case AREA_WOC:
 			if(sd->chatID || bl == src_bl)
 				return 0;
+			if( RBUFW(buf,0) == 0x8d && (map[sd->bl.m].flag.gvg || map[sd->bl.m].flag.battleground) && sd->state.packet_filter&1 )
+				return 0;
 			break;
+		case LANG_AREA_CHAT_WOC:
+		case OTHER_LANG_AREA_CHAT_WOC:
+		case FACTION_AREA_CHAT_WOC:
+		case OTHER_FACTION_AREA_CHAT_WOC:
+		case FACTION_LANG_AREA_CHAT_WOC:
+		case FACTION_OTHER_LANG_AREA_CHAT_WOC:
+		case OTHER_FACTION_LANG_AREA_CHAT_WOC:
+		case OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC:
+		{
+			int faction_id, lang_id;
+			struct faction_data* fd = NULL;
+			bool known;
+
+			if( sd->chatID || bl == src_bl )
+				return 0;
+
+			faction_id = va_arg(ap,int);
+			if( faction_id == sd->status.faction_id && (type == OTHER_FACTION_AREA_CHAT_WOC || type == OTHER_FACTION_LANG_AREA_CHAT_WOC || type == OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC) )
+				return 0;
+			if( faction_id != sd->status.faction_id && (type == FACTION_AREA_CHAT_WOC || type == FACTION_LANG_AREA_CHAT_WOC || type == FACTION_OTHER_LANG_AREA_CHAT_WOC) )
+				return 0;
+
+			if( type != OTHER_FACTION_AREA_CHAT_WOC && type != FACTION_AREA_CHAT_WOC )
+			{
+				lang_id = va_arg(ap,int);
+				if( sd->status.faction_id ) fd = faction_search(sd->status.faction_id);
+					known = (sd->lang_id == lang_id || (sd->lang_mastery&lang_pow[lang_id-1]) || (fd && fd->lang_id == lang_id));
+
+				if( (type == LANG_AREA_CHAT_WOC || type == OTHER_FACTION_LANG_AREA_CHAT_WOC || type == FACTION_LANG_AREA_CHAT_WOC) && !known )
+					return 0;
+				if( (type == OTHER_LANG_AREA_CHAT_WOC || type == OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC || type == FACTION_OTHER_LANG_AREA_CHAT_WOC) && known )
+					return 0;
+			}
+		}
+		break;
+		case FACTION_AREA_WOS:
+			if( bl == src_bl )
+				return 0;
+			if( sd->status.faction_id != status_get_faction_id(src_bl) )
+				return 0;
+		break;
 		case AREA_WOSC: {
 				if(src_bl->type == BL_PC) {
 					struct map_session_data *ssd = (struct map_session_data *)src_bl;
@@ -336,12 +556,23 @@
 					struct npc_data *nd = (struct npc_data *)src_bl;
 					if(nd && sd->chatID && (sd->chatID == nd->chat_id))
 						return 0;
-				}
-			}
-			break;
-	}
-
-	if(session[fd] == NULL)
+		}
+	}
+	break;
+	case AREA_IWOS:
+		if( bl == src_bl )
+			return 0;
+	case AREA_IWS:
+		if( bl != src_bl && !sd->special_state.intravision && !sd->sc.data[SC_INTRAVISION] )
+			return 0;
+	break;
+	case AREA_WOI:
+		if( bl == src_bl || sd->special_state.intravision || sd->sc.data[SC_INTRAVISION] )
+			return 0;
+	break;
+	}
+
+	if (session[fd] == NULL)
 		return 0;
 
 	WFIFOHEAD(fd, len);
@@ -377,16 +608,22 @@
 	int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
 	struct s_mapiterator *iter;
 
-	if(type != ALL_CLIENT && type != CHAT_MAINCHAT)
+	if( type != ALL_CLIENT && type != BG_LISTEN )
 		nullpo_ret(bl);
+		
+	if( type == ALL_REGION && map[bl->m].region_id < 1 )
+		return 0; // Not on a Region
 
 	sd = BL_CAST(BL_PC, bl);
 
 	switch(type) {
 
 		case ALL_CLIENT: //All player clients.
+		case BG_LISTEN:
 			iter = mapit_getallusers();
 			while((tsd = (TBL_PC *)mapit_next(iter)) != NULL) {
+				if( type == BG_LISTEN && !(tsd->state.bg_listen || tsd->qd) )
+					continue;
 				if(packet_db[tsd->packet_ver][RBUFW(buf,0)].len) {
 					// packet must exist for the client version
 					WFIFOHEAD(tsd->fd, len);
@@ -398,9 +635,10 @@
 			break;
 
 		case ALL_SAMEMAP: //All players on the same map
+		case ALL_REGION: // All players on the same region
 			iter = mapit_getallusers();
 			while((tsd = (TBL_PC *)mapit_next(iter)) != NULL) {
-				if(bl->m == tsd->bl.m && packet_db[tsd->packet_ver][RBUFW(buf,0)].len) {
+				if( ((type == ALL_SAMEMAP && tsd->bl.m == bl->m) || (type == ALL_REGION && map[tsd->bl.m].region_id == map[bl->m].region_id)) && packet_db[tsd->packet_ver][RBUFW(buf,0)].len ) {
 					// packet must exist for the client version
 					WFIFOHEAD(tsd->fd, len);
 					memcpy(WFIFOP(tsd->fd,0), buf, len);
@@ -423,9 +661,35 @@
 			map_foreachinarea(clif_send_sub, bl->m, bl->x-(AREA_SIZE-5), bl->y-(AREA_SIZE-5),
 			                  bl->x+(AREA_SIZE-5), bl->y+(AREA_SIZE-5), BL_PC, buf, len, bl, AREA_WOC);
 			break;
+			
+		case LANG_AREA_CHAT_WOC:
+		case OTHER_LANG_AREA_CHAT_WOC:
+		case FACTION_AREA_CHAT_WOC:
+		case OTHER_FACTION_AREA_CHAT_WOC:
+		case FACTION_LANG_AREA_CHAT_WOC:
+		case FACTION_OTHER_LANG_AREA_CHAT_WOC:
+		case OTHER_FACTION_LANG_AREA_CHAT_WOC:
+		case OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC:
+			if( !sd ) break;
+			map_foreachinarea(clif_send_sub, bl->m, bl->x-(AREA_SIZE-5), bl->y-(AREA_SIZE-5),
+				bl->x+(AREA_SIZE-5), bl->y+(AREA_SIZE-5), BL_PC, buf, len, bl, type, sd->status.faction_id, sd->lang_id);
+			break;
+		case FACTION_AREA_WOS:
+			map_foreachinarea(clif_send_sub, bl->m, bl->x-AREA_SIZE, bl->y-AREA_SIZE, bl->x+AREA_SIZE, bl->y+AREA_SIZE,
+				BL_PC, buf, len, bl, type);
+			break;
+ 
+		case AREA_IWS:
+		case AREA_IWOS:
+		case AREA_WOI:
+			map_foreachinarea(clif_send_sub, bl->m, bl->x-AREA_SIZE, bl->y-AREA_SIZE, bl->x+AREA_SIZE, bl->y+AREA_SIZE,
+				BL_PC, buf, len, bl, type);
+		break;
 
 		case CHAT:
-		case CHAT_WOS: {
+		case CHAT_WOS:
+		case LANG_CHAT_WOS:
+		case OTHER_LANG_CHAT_WOS: {
 				struct chat_data *cd;
 				if(sd) {
 					cd = (struct chat_data *)map_id2bl(sd->chatID);
@@ -434,10 +698,23 @@
 				} else break;
 				if(cd == NULL)
 					break;
-				for(i = 0; i < cd->users; i++) {
-					if(type == CHAT_WOS && cd->usersd[i] == sd)
-						continue;
-					if(packet_db[cd->usersd[i]->packet_ver][RBUFW(buf,0)].len) {  // packet must exist for the client version
+			for(i = 0; i < cd->users; i++) {
+				if( cd->usersd[i] == sd && (type == CHAT_WOS || type == LANG_CHAT_WOS || type == OTHER_LANG_CHAT_WOS) )
+					continue;
+				if( sd && (type == LANG_CHAT_WOS || type == OTHER_LANG_CHAT_WOS) )
+				{
+					struct faction_data* fd = NULL;
+					bool known;
+
+					if( cd->usersd[i]->status.faction_id ) fd = faction_search(cd->usersd[i]->status.faction_id);
+					known = (cd->usersd[i]->lang_id == sd->lang_id || (cd->usersd[i]->lang_mastery&lang_pow[sd->lang_id-1]) || (fd && fd->lang_id == sd->lang_id));
+
+					if( type == LANG_CHAT_WOS && !known )
+						continue;
+					if( type == OTHER_LANG_CHAT_WOS && known )
+						continue;
+				}
+				if (packet_db[cd->usersd[i]->packet_ver][RBUFW(buf,0)].len) { // packet must exist for the client version
 						if((fd=cd->usersd[i]->fd) >0 && session[fd]) { // Added check to see if session exists [PoW]
 							WFIFOHEAD(fd,len);
 							memcpy(WFIFOP(fd,0), buf, len);
@@ -448,19 +725,6 @@
 			}
 			break;
 
-		case CHAT_MAINCHAT: //[LuzZza]
-			iter = mapit_getallusers();
-			while((tsd = (TBL_PC *)mapit_next(iter)) != NULL) {
-				if(tsd->state.mainchat && tsd->chatID == 0 && packet_db[tsd->packet_ver][RBUFW(buf,0)].len) {
-					// packet must exist for the client version
-					WFIFOHEAD(tsd->fd, len);
-					memcpy(WFIFOP(tsd->fd,0), buf, len);
-					WFIFOSET(tsd->fd,len);
-				}
-			}
-			mapit_free(iter);
-			break;
-
 		case PARTY_AREA:
 		case PARTY_AREA_WOS:
 			x0 = bl->x - AREA_SIZE;
@@ -832,12 +1096,21 @@
 	if(disguised(bl)) {
 		WBUFL(buf,2) = -bl->id;
 		clif_send(buf, packet_len(0x80), bl, SELF);
-	}
-}
-
-
-/// Used to make monsters with player-sprites disappear after dying
-/// like normal monsters, because the client does not remove those
+	}
+}
+
+void clif_clearunit_invisible(struct block_list *bl)
+{
+	unsigned char buf[8];
+	nullpo_retv(bl);
+	WBUFW(buf,0) = 0x80;
+	WBUFL(buf,2) = bl->id;
+	WBUFB(buf,6) = CLR_OUTSIGHT;
+	clif_send(buf, packet_len(0x80), bl, AREA_WOI);
+}
+
+/// Used to make monsters with player-sprites disappear after dying
+/// like normal monsters, because the client does not remove those
 /// automatically.
 static int clif_clearunit_delayed_sub(int tid, unsigned int tick, int id, intptr_t data)
 {
@@ -1015,9 +1288,9 @@
 
 	if(bl->type == BL_NPC && vd->class_ == FLAG_CLASS) {
 		//The hell, why flags work like this?
-		WBUFW(buf,22) = status_get_emblem_id(bl);
-		WBUFW(buf,24) = GetWord(status_get_guild_id(bl), 1);
-		WBUFW(buf,26) = GetWord(status_get_guild_id(bl), 0);
+		WBUFW(buf,22) = clif_visual_emblem_id(bl);
+		WBUFW(buf,24) = GetWord(clif_visual_guild_id(bl), 1);
+		WBUFW(buf,26) = GetWord(clif_visual_guild_id(bl), 0);
 	}
 
 	WBUFW(buf,28) = vd->hair_color;
@@ -1035,14 +1308,14 @@
 #endif
 #if PACKETVER >= 20110111
 	WBUFW(buf,34) = vd->robe;
-	offset+= 2;
-	buf = WBUFP(buffer,offset);
-#endif
-	WBUFL(buf,34) = status_get_guild_id(bl);
-	WBUFW(buf,38) = status_get_emblem_id(bl);
-	WBUFW(buf,40) = (sd)? sd->status.manner : 0;
-#if PACKETVER >= 20091103
-	WBUFL(buf,42) = (sc)? sc->opt3 : 0;
+	offset+= 2;
+	buf = WBUFP(buffer,offset);
+#endif
+	WBUFL(buf,34) = clif_visual_guild_id(bl);
+	WBUFW(buf,38) = clif_visual_emblem_id(bl);
+	WBUFW(buf,40) = (sd)? sd->status.manner : 0;
+#if PACKETVER >= 20091103
+	WBUFL(buf,42) = (sc)? sc->opt3 : 0;
 	offset+=2;
 	buf = WBUFP(buffer,offset);
 #elif PACKETVER >= 7
@@ -1158,14 +1431,14 @@
 	WBUFW(buf,36) = (sd)? sd->head_dir : 0;
 #if PACKETVER >= 20110111
 	WBUFW(buf,38) = vd->robe;
-	offset+= 2;
-	buf = WBUFP(buffer,offset);
-#endif
-	WBUFL(buf,38) = status_get_guild_id(bl);
-	WBUFW(buf,42) = status_get_emblem_id(bl);
-	WBUFW(buf,44) = (sd)? sd->status.manner : 0;
-#if PACKETVER < 7
-	WBUFW(buf,46) = (sc)? sc->opt3 : 0;
+	offset+= 2;
+	buf = WBUFP(buffer,offset);
+#endif
+	WBUFL(buf,38) = clif_visual_guild_id(bl);
+	WBUFW(buf,42) = clif_visual_emblem_id(bl);
+	WBUFW(buf,44) = (sd)? sd->status.manner : 0;
+#if PACKETVER < 7
+	WBUFW(buf,46) = (sc)? sc->opt3 : 0;
 #else
 	WBUFL(buf,46) = (sc)? sc->opt3 : 0;
 	offset+=2; //Shift the rest of elements by 2 bytes.
@@ -1324,13 +1597,19 @@
 
 	/**
 	* Hide NPC from maya purple card.
-	**/
-	if(bl->type == BL_NPC && !((TBL_NPC *)bl)->chat_id && (((TBL_NPC *)bl)->sc.option&OPTION_INVISIBLE))
-		return 0;
-
-	len = clif_set_unit_idle(bl, buf,true);
-	clif_send(buf, len, bl, AREA_WOS);
-	if(disguised(bl))
+	**/
+	if(bl->type == BL_NPC && !((TBL_NPC*)bl)->chat_id && (((TBL_NPC*)bl)->sc.option&OPTION_INVISIBLE))
+		return 0;
+	if( battle_config.anti_mayapurple_hack && bl->type == BL_PC )
+	{
+		TBL_PC *tsd = ((TBL_PC*)bl);
+		TBL_PC *sd  = BL_CAST(BL_PC, bl);
+		if( tsd->sc.option&(OPTION_HIDE|OPTION_CLOAK) && !tsd->state.evade_antiwpefilter && !sd->special_state.intravision && !sd->sc.data[SC_INTRAVISION] )
+			return 0;
+	}
+	len = clif_set_unit_idle(bl, buf,true);
+	clif_send(buf, len, bl, AREA_WOS);
+	if (disguised(bl))
 		clif_setdisguise(bl, buf, len);
 
 	if(vd->cloth_color)
@@ -1343,14 +1622,16 @@
 				if(sd->spiritball > 0)
 					clif_spiritball(&sd->bl);
 				if(sd->state.size==SZ_BIG) // tiny/big players [Valaris]
-					clif_specialeffect(bl,423,AREA);
-				else if(sd->state.size==SZ_MEDIUM)
-					clif_specialeffect(bl,421,AREA);
-				if(sd->bg_id && map[sd->bl.m].flag.battleground)
-					clif_sendbgemblem_area(sd);
-				if(sd->sc.option&OPTION_MOUNTING) {
-					//New Mounts are not complaint to the original method, so we gotta tell this guy that he is mounting.
-					clif_status_load_notick(&sd->bl,SI_ALL_RIDING,2,1,0,0);
+				clif_specialeffect(bl,423,AREA);
+			else if(sd->state.size==SZ_MEDIUM)
+				clif_specialeffect(bl,421,AREA);
+			if( !battle_config.bg_eAmod_mode && sd->bg_id && map[sd->bl.m].flag.battleground )
+				clif_sendbgemblem_area(sd);
+			if( map[sd->bl.m].flag.fvf ) clif_faction_area(sd);
+			clif_sendauras((TBL_PC*)bl, AREA);
+			if( sd->sc.option&OPTION_MOUNTING ) {
+				//New Mounts are not complaint to the original method, so we gotta tell this guy that he is mounting.
+				clif_status_load_notick(&sd->bl,SI_ALL_RIDING,2,1,0,0);
 				}
 				for(i = 1; i < 5; i++) {
 					if(sd->talisman[i] > 0)
@@ -1368,10 +1649,12 @@
 				TBL_MOB *md = ((TBL_MOB *)bl);
 				if(md->special_state.size==SZ_BIG) // tiny/big mobs [Valaris]
 					clif_specialeffect(&md->bl,423,AREA);
-				else if(md->special_state.size==SZ_MEDIUM)
-					clif_specialeffect(&md->bl,421,AREA);
-			}
-			break;
+			else if(md->special_state.size==SZ_MEDIUM)
+				clif_specialeffect(&md->bl,421,AREA);
+			if (md->option.hp_show == 1)
+				clif_mobhpmeter(md);
+		}
+		break;
 		case BL_NPC: {
 				TBL_NPC *nd = ((TBL_NPC *)bl);
 				if(nd->size == SZ_BIG)
@@ -1557,27 +1840,30 @@
 
 static void clif_move2(struct block_list *bl, struct view_data *vd, struct unit_data *ud)
 {
-	uint8 buf[128];
-	int len;
-
-	len = clif_set_unit_walking(bl,ud,buf);
-	clif_send(buf,len,bl,AREA_WOS);
-	if(disguised(bl))
-		clif_setdisguise(bl, buf, len);
-
-	if(vd->cloth_color)
-		clif_refreshlook(bl,bl->id,LOOK_CLOTHES_COLOR,vd->cloth_color,AREA_WOS);
-
+	uint8 buf[128];
+	struct map_session_data *sd = BL_CAST(BL_PC,bl);
+	int len, flag = 0;
+
+	len = clif_set_unit_walking(bl,ud,buf);
+	if( battle_config.anti_mayapurple_hack && sd && sd->sc.option&(OPTION_HIDE|OPTION_CLOAK) && !sd->state.evade_antiwpefilter )
+		flag = 1;
+	clif_send(buf,len,bl,(flag ? AREA_IWOS : AREA_WOS));
+	if (disguised(bl))
+		clif_setdisguise(bl, buf, len);
+
+	if(vd->cloth_color)
+		clif_refreshlook(bl,bl->id,LOOK_CLOTHES_COLOR,vd->cloth_color,(flag ? AREA_IWOS : AREA_WOS));
+
 	switch(bl->type) {
 		case BL_PC: {
 				TBL_PC *sd = ((TBL_PC *)bl);
-//			clif_movepc(sd);
-				if(sd->state.size==SZ_BIG) // tiny/big players [Valaris]
-					clif_specialeffect(&sd->bl,423,AREA);
-				else if(sd->state.size==SZ_MEDIUM)
-					clif_specialeffect(&sd->bl,421,AREA);
-			}
-			break;
+//			clif_movepc(sd);
+			if(sd->state.size==SZ_BIG) // tiny/big players [Valaris]
+				clif_specialeffect(&sd->bl,423,(flag ? AREA_IWS : AREA));
+			else if(sd->state.size==SZ_MEDIUM)
+				clif_specialeffect(&sd->bl,421,(flag ? AREA_IWS : AREA));
+		}
+		break;
 		case BL_MOB: {
 				TBL_MOB *md = ((TBL_MOB *)bl);
 				if(md->special_state.size==SZ_BIG) // tiny/big mobs [Valaris]
@@ -1601,12 +1887,14 @@
 /// Note: unit must not be self
 void clif_move(struct unit_data *ud)
 {
-	unsigned char buf[16];
-	struct view_data *vd;
-	struct block_list *bl = ud->bl;
-
-	vd = status_get_viewdata(bl);
-	if(!vd || vd->class_ == INVISIBLE_CLASS)
+	unsigned char buf[16];
+	struct view_data* vd;
+	struct block_list* bl = ud->bl;
+	struct map_session_data *tsd = BL_CAST(BL_PC,bl);
+	int target = AREA_WOS;
+
+	vd = status_get_viewdata(bl);
+	if (!vd || vd->class_ == INVISIBLE_CLASS)
 		return; //This performance check is needed to keep GM-hidden objects from being notified to bots.
 
 	/**
@@ -1622,12 +1910,15 @@
 		clif_move2(bl, vd, ud);
 		return;
 	}
+	
+	if( battle_config.anti_mayapurple_hack && tsd && tsd->sc.option&(OPTION_HIDE|OPTION_CLOAK) && !tsd->state.evade_antiwpefilter )
+		target = AREA_IWOS;
 
 	WBUFW(buf,0)=0x86;
 	WBUFL(buf,2)=bl->id;
 	WBUFPOS2(buf,6,bl->x,bl->y,ud->to_x,ud->to_y,8,8);
 	WBUFL(buf,12)=gettick();
-	clif_send(buf, packet_len(0x86), bl, AREA_WOS);
+	clif_send(buf, packet_len(0x86), bl, target);
 	if(disguised(bl)) {
 		WBUFL(buf,2)=-bl->id;
 		clif_send(buf, packet_len(0x86), bl, SELF);
@@ -1676,12 +1967,15 @@
 	WFIFOHEAD(fd,packet_len(0x91));
 	WFIFOW(fd,0) = 0x91;
 	mapindex_getmapname_ext(mapindex_id2name(map), (char *)WFIFOP(fd,2));
-	WFIFOW(fd,18) = x;
-	WFIFOW(fd,20) = y;
-	WFIFOSET(fd,packet_len(0x91));
-}
-
-
+	WFIFOW(fd,18) = x;
+	WFIFOW(fd,20) = y;
+	WFIFOSET(fd,packet_len(0x91));
+	// AutoRefresh - Restart
+	if( sd->sc.data[SC_AUTOREFRESH] && sd->sc.data[SC_AUTOREFRESH]->val2 == 0 )
+		sc_start2(NULL,&sd->bl,SC_AUTOREFRESH,100,sd->sc.data[SC_AUTOREFRESH]->val1,0,-1);
+}
+
+
 /// Notifies the client of a position change to coordinates on given map, which is on another map-server (ZC_NPCACK_SERVERMOVE).
 /// 0092 <map name>.16B <x>.W <y>.W <ip>.L <port>.W
 void clif_changemapserver(struct map_session_data *sd, unsigned short map_index, int x, int y, uint32 ip, uint16 port)
@@ -1700,18 +1994,20 @@
 	WFIFOSET(fd,packet_len(0x92));
 }
 
-
-void clif_blown(struct block_list *bl)
-{
-//Aegis packets says fixpos, but it's unsure whether slide works better or not.
-//	clif_fixpos(bl);
-	clif_slide(bl, bl->x, bl->y);
-}
-
-
-/// Visually moves(slides) a character to x,y. If the target cell
-/// isn't walkable, the char doesn't move at all. If the char is
-/// sitting it will stand up (ZC_STOPMOVE).
+
+void clif_blown(struct block_list *bl)
+{
+	clif_fixpos(bl);
+}
+
+void clif_blown_slide(struct block_list *bl)
+{
+	clif_slide(bl, bl->x, bl->y);
+}
+
+/// Visually moves(slides) a character to x,y. If the target cell
+/// isn't walkable, the char doesn't move at all. If the char is
+/// sitting it will stand up (ZC_STOPMOVE).
 /// 0088 <id>.L <x>.W <y>.W
 void clif_fixpos(struct block_list *bl)
 {
@@ -1779,27 +2075,38 @@
 
 
 /// Presents list of items, that can be sold to an NPC shop (ZC_PC_SELL_ITEMLIST).
-/// 00c7 <packet len>.W { <index>.W <price>.L <overcharge price>.L }*
-void clif_selllist(struct map_session_data *sd)
-{
-	int fd,i,c=0,val;
-
-	nullpo_retv(sd);
-
+/// 00c7 <packet len>.W { <index>.W <price>.L <overcharge price>.L }*
+void clif_selllist(struct map_session_data *sd)
+{
+	int fd,i,c=0,val,char_id;
+
+	nullpo_retv(sd);
+
 	fd=sd->fd;
 	WFIFOHEAD(fd, MAX_INVENTORY * 10 + 4);
 	WFIFOW(fd,0)=0xc7;
 	for(i = 0; i < MAX_INVENTORY; i++) {
 		if(sd->status.inventory[i].nameid > 0 && sd->inventory_data[i]) {
-			if(!itemdb_cansell(&sd->status.inventory[i], pc_get_group_level(sd)))
-				continue;
-
-			if(sd->status.inventory[i].expire_time)
-				continue; // Cannot Sell Rental Items
-
-			val=sd->inventory_data[i]->value_sell;
-			if(val < 0)
-				continue;
+			if( !itemdb_cansell(&sd->status.inventory[i], pc_get_group_level(sd)) )
+				continue;
+
+			if( sd->status.inventory[i].expire_time || sd->status.inventory[i].bound )
+				continue; // Cannot Sell Rental Items - Account Bound
+
+			if( sd->status.inventory[i].card[0] == CARD0_CREATE )
+			{ // Do not allow sell BG - Ancient Items
+				char_id = MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3]);
+				if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id )
+					continue;
+				if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id )
+					continue;
+				if( battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id )
+					continue;
+			}
+
+			val=sd->inventory_data[i]->value_sell;
+			if( val < 0 )
+				continue;
 			WFIFOW(fd,4+c*10)=i+2;
 			WFIFOL(fd,6+c*10)=val;
 			WFIFOL(fd,10+c*10)=pc_modifysellvalue(sd,val);
@@ -2181,17 +2488,21 @@
 		WFIFOB(fd,21)=itemtype(sd->inventory_data[n]->type);
 		WFIFOB(fd,22)=fail;
 #if PACKETVER >= 20061218
-		WFIFOL(fd,23)=sd->status.inventory[n].expire_time;
-#endif
-#if PACKETVER >= 20071002
-		WFIFOW(fd,27)=0;  // unknown
-#endif
-	}
-
-	WFIFOSET(fd,packet_len(cmd));
-}
-
-
+		WFIFOL(fd,23)=sd->status.inventory[n].expire_time;
+#endif
+#if PACKETVER >= 20071002
+		WFIFOW(fd,27)=sd->status.inventory[n].bound ? 2 : 0;
+#endif
+	}
+
+	WFIFOSET(fd,packet_len(cmd));
+#if PACKETVER >= 20111122
+	if( sd->status.inventory[n].favorite )
+		clif_favorite_item(sd,n);
+#endif
+}
+
+
 /// Notifies the client, that an inventory item was deleted or dropped (ZC_ITEM_THROW_ACK).
 /// 00af <index>.W <amount>.W
 void clif_dropitem(struct map_session_data *sd,int n,int amount)
@@ -2300,13 +2611,13 @@
 			//Non-stackable (Equippable)
 			WBUFW(bufe,ne*se+4)=i+2;
 			clif_item_sub(bufe, ne*se+6, &sd->status.inventory[i], sd->inventory_data[i], pc_equippoint(sd,i));
-			clif_addcards(WBUFP(bufe, ne*se+16), &sd->status.inventory[i]);
-#if PACKETVER >= 20071002
-			WBUFL(bufe,ne*se+24)=sd->status.inventory[i].expire_time;
-			WBUFW(bufe,ne*se+28)=0; //Unknown
-#endif
-#if PACKETVER >= 20100629
-			if(sd->inventory_data[i]->equip&EQP_VISIBLE)
+			clif_addcards(WBUFP(bufe, ne*se+16), &sd->status.inventory[i]);
+#if PACKETVER >= 20071002
+			WBUFL(bufe,ne*se+24)=sd->status.inventory[i].expire_time;
+			WBUFW(bufe,ne*se+28)=sd->status.inventory[i].bound ? 2 : 0;
+#endif
+#if PACKETVER >= 20100629
+			if (sd->inventory_data[i]->equip&EQP_VISIBLE)
 				WBUFW(bufe,ne*se+30)= sd->inventory_data[i]->look;
 			else
 				WBUFW(bufe,ne*se+30)=0;
@@ -2359,59 +2670,69 @@
 			clif_favorite_item(sd, i);
 	}
 #endif
-
-	if(buf) aFree(buf);
-	if(bufe) aFree(bufe);
-}
-
-//Required when items break/get-repaired. Only sends equippable item list.
+
+	if( buf ) aFree(buf);
+	if( bufe ) aFree(bufe);
+
+#if PACKETVER >= 20111122
+	for( i = 0; i < MAX_INVENTORY; i++ )
+	{
+		if( sd->status.inventory[i].nameid <= 0 || sd->inventory_data[i] == NULL )
+			continue;
+		if( sd->status.inventory[i].favorite )
+			clif_favorite_item(sd,i);
+	}
+#endif
+}
+
+//Required when items break/get-repaired. Only sends equippable item list.
 void clif_equiplist(struct map_session_data *sd)
 {
-	int i,n,fd = sd->fd;
-	unsigned char *buf;
-#if PACKETVER < 20071002
-	const int cmd = 20;
-#elif PACKETVER < 20100629
-	const int cmd = 26;
-#else
-	const int cmd = 28;
-#endif
-
-	WFIFOHEAD(fd, MAX_INVENTORY * cmd + 4);
-	buf = WFIFOP(fd,0);
-
-	for(i=0,n=0; i<MAX_INVENTORY; i++) {
+	int i,n,fd = sd->fd;
+	unsigned char *buf;
+#if PACKETVER < 20071002
+	const int se = 20;
+#elif PACKETVER < 20100629
+	const int se = 26;
+#else
+	const int se = 28;
+#endif
+
+	WFIFOHEAD(fd, MAX_INVENTORY * se + 4);
+	buf = WFIFOP(fd,0);
+
+	for(i=0,n=0;i<MAX_INVENTORY;i++){
 		if(sd->status.inventory[i].nameid <=0 || sd->inventory_data[i] == NULL)
 			continue;
 
-		if(itemdb_isstackable2(sd->inventory_data[i]))
-			continue;
-		//Equippable
-		WBUFW(buf,n*cmd+4)=i+2;
-		clif_item_sub(buf, n*cmd+6, &sd->status.inventory[i], sd->inventory_data[i], pc_equippoint(sd,i));
-		clif_addcards(WBUFP(buf, n*cmd+16), &sd->status.inventory[i]);
-#if PACKETVER >= 20071002
-		WBUFL(buf,n*cmd+24)=sd->status.inventory[i].expire_time;
-		WBUFW(buf,n*cmd+28)=0; //Unknown
-#endif
-#if PACKETVER >= 20100629
-		if(sd->inventory_data[i]->equip&EQP_VISIBLE)
-			WBUFW(buf,n*cmd+30)= sd->inventory_data[i]->look;
-		else
-			WBUFW(buf,n*cmd+30)=0;
-#endif
-		n++;
-	}
+		if(itemdb_isstackable2(sd->inventory_data[i]))
+			continue;
+		//Equippable
+		WBUFW(buf,n*se+4)=i+2;
+		clif_item_sub(buf, n*se+6, &sd->status.inventory[i], sd->inventory_data[i], pc_equippoint(sd,i));
+		clif_addcards(WBUFP(buf, n*se+16), &sd->status.inventory[i]);
+#if PACKETVER >= 20071002
+		WBUFL(buf,n*se+24)=sd->status.inventory[i].expire_time;
+		WBUFW(buf,n*se+28)=sd->status.inventory[i].bound ? 2 : 0;
+#endif
+#if PACKETVER >= 20100629
+		if (sd->inventory_data[i]->equip&EQP_VISIBLE)
+			WBUFW(buf,n*se+30)= sd->inventory_data[i]->look;
+		else
+			WBUFW(buf,n*se+30)=0;
+#endif
+		n++;
+	}
 	if(n) {
 #if PACKETVER < 20071002
 		WBUFW(buf,0)=0xa4;
-#else
-		WBUFW(buf,0)=0x2d0;
-#endif
-		WBUFW(buf,2)=4+n*cmd;
-		WFIFOSET(fd,WFIFOW(fd,2));
-	}
-}
+#else
+		WBUFW(buf,0)=0x2d0;
+#endif
+		WBUFW(buf,2)=4+n*se;
+		WFIFOSET(fd,WFIFOW(fd,2));
+	}
+}
 
 void clif_storagelist(struct map_session_data *sd, struct item *items, int items_length)
 {
@@ -2426,30 +2747,36 @@
 #else
 	const int s = 22;
 #endif
-#if PACKETVER < 20071002
-	const int cmd = 20;
-#elif PACKETVER < 20100629
-	const int cmd = 26;
-#else
-	const int cmd = 28;
-#endif
-
-	buf = (unsigned char *)aMalloc(items_length * s + 4);
-	bufe = (unsigned char *)aMalloc(items_length * cmd + 4);
-
+#if PACKETVER < 20071002
+	const int se = 20;
+#elif PACKETVER < 20100629
+	const int se = 26;
+#else
+	const int se = 28;
+#endif
+
+	buf = (unsigned char*)aMalloc(items_length * s + 4);
+	bufe = (unsigned char*)aMalloc(items_length * se + 4);
+
 	for(i = 0, n = 0, ne = 0; i < items_length; i++) {
 		if(items[i].nameid <= 0)
 			continue;
 		id = itemdb_search(items[i].nameid);
 		if(!itemdb_isstackable2(id)) {
 			//Equippable
-			WBUFW(bufe,ne*cmd+4)=i+1;
-			clif_item_sub(bufe, ne*cmd+6, &items[i], id, id->equip);
-			clif_addcards(WBUFP(bufe, ne*cmd+16), &items[i]);
+			WBUFW(bufe,ne*se+4)=i+1;
+			clif_item_sub(bufe, ne*se+6, &items[i], id, id->equip);
+			clif_addcards(WBUFP(bufe, ne*se+16), &items[i]);
 #if PACKETVER >= 20071002
-			WBUFL(bufe,ne*cmd+24)=items[i].expire_time;
-			WBUFW(bufe,ne*cmd+28)=0; //Unknown
+			WBUFL(bufe,ne*se+24)=items[i].expire_time;
+			WBUFW(bufe,ne*se+28)=items[i].bound ? 2 : 0;
 #endif
+#if PACKETVER >= 20100629
+			if (id->equip&EQP_VISIBLE)
+				WBUFW(bufe,ne*se+30)= id->look;
+			else
+				WBUFW(bufe,ne*se+30)=0;
+#endif
 			ne++;
 		} else {
 			//Stackable
@@ -2478,13 +2805,13 @@
 	if(ne) {
 #if PACKETVER < 20071002
 		WBUFW(bufe,0)=0xa6;
-#else
-		WBUFW(bufe,0)=0x2d1;
-#endif
-		WBUFW(bufe,2)=4+ne*cmd;
-		clif_send(bufe, WBUFW(bufe,2), &sd->bl, SELF);
-	}
-
+#else
+		WBUFW(bufe,0)=0x2d1;
+#endif
+		WBUFW(bufe,2)=4+ne*se;
+		clif_send(bufe, WBUFW(bufe,2), &sd->bl, SELF);
+	}
+
 	if(buf) aFree(buf);
 	if(bufe) aFree(bufe);
 }
@@ -2502,30 +2829,36 @@
 #else
 	const int s = 22;
 #endif
-#if PACKETVER < 20071002
-	const int cmd = 20;
-#elif PACKETVER < 20100629
-	const int cmd = 26;
-#else
-	const int cmd = 28;
-#endif
-
-	buf = (unsigned char *)aMalloc(MAX_CART * s + 4);
-	bufe = (unsigned char *)aMalloc(MAX_CART * cmd + 4);
-
+#if PACKETVER < 20071002
+	const int se = 20;
+#elif PACKETVER < 20100629
+	const int se = 26;
+#else
+	const int se = 28;
+#endif
+
+	buf = (unsigned char*)aMalloc(MAX_CART * s + 4);
+	bufe = (unsigned char*)aMalloc(MAX_CART * se + 4);
+
 	for(i = 0, n = 0, ne = 0; i < MAX_CART; i++) {
 		if(sd->status.cart[i].nameid <= 0)
 			continue;
 		id = itemdb_search(sd->status.cart[i].nameid);
 		if(!itemdb_isstackable2(id)) {
 			//Equippable
-			WBUFW(bufe,ne*cmd+4)=i+2;
-			clif_item_sub(bufe, ne*cmd+6, &sd->status.cart[i], id, id->equip);
-			clif_addcards(WBUFP(bufe, ne*cmd+16), &sd->status.cart[i]);
+			WBUFW(bufe,ne*se+4)=i+2;
+			clif_item_sub(bufe, ne*se+6, &sd->status.cart[i], id, id->equip);
+			clif_addcards(WBUFP(bufe, ne*se+16), &sd->status.cart[i]);
 #if PACKETVER >= 20071002
-			WBUFL(bufe,ne*cmd+24)=sd->status.cart[i].expire_time;
-			WBUFW(bufe,ne*cmd+28)=0; //Unknown
+			WBUFL(bufe,ne*se+24)=sd->status.cart[i].expire_time;
+			WBUFW(bufe,ne*se+28)=sd->status.cart[i].bound ? 2 : 0; //Unknown
 #endif
+#if PACKETVER >= 20100629
+			if (id->equip&EQP_VISIBLE)
+				WBUFW(bufe,ne*se+30)= id->look;
+			else
+				WBUFW(bufe,ne*se+30)=0;
+#endif
 			ne++;
 		} else {
 			//Stackable
@@ -2552,23 +2885,22 @@
 		clif_send(buf, WBUFW(buf,2), &sd->bl, SELF);
 	}
 	if(ne) {
-#if PACKETVER < 20071002
-		WBUFW(bufe,0)=0x122;
-#else
-		WBUFW(bufe,0)=0x2d2;
-#endif
-		WBUFW(bufe,2)=4+ne*cmd;
-		clif_send(bufe, WBUFW(bufe,2), &sd->bl, SELF);
+#if PACKETVER < 20071002
+		WBUFW(bufe,0)=0x122;
+#else
+		WBUFW(bufe,0)=0x2d2;
+#endif
+		WBUFW(bufe,2)=4+ne*se;
+		clif_send(bufe, WBUFW(bufe,2), &sd->bl, SELF);
 	}
 
 	if(buf) aFree(buf);
-	if(bufe) aFree(bufe);
-}
-
-
-/// Removes cart (ZC_CARTOFF).
-/// 012b
-/// Client behaviour:
+	if( bufe ) aFree(bufe);
+}
+
+/// Removes cart (ZC_CARTOFF).
+/// 012b
+/// Client behaviour:
 /// Closes the cart storage and removes all it's items from memory.
 /// The Num & Weight values of the cart are left untouched and the cart is NOT removed.
 void clif_clearcart(int fd)
@@ -2625,12 +2957,40 @@
 	clif_send(buf,packet_len(0x1eb),&sd->bl,GUILD_SAMEMAP_WOS);
 }
 
-/*==========================================
- *
- *------------------------------------------*/
-static int clif_hpmeter_sub(struct block_list *bl, va_list ap)
-{
-	struct map_session_data *sd, *tsd;
+/*==========================================
+ *
+ *------------------------------------------*/
+void clif_mobhpmeter(struct mob_data *md)
+{
+	unsigned char buf[16];
+#if PACKETVER < 20100414
+	const int cmd = 0x106;
+#else
+	const int cmd = 0x80e;
+#endif
+	nullpo_retv(md);
+
+	WBUFW(buf,0)=cmd;
+	WBUFL(buf,2) = md->bl.id;
+#if PACKETVER < 20100414
+	if (md->status.max_hp > INT16_MAX) {
+		WBUFW(buf,6) = md->status.hp/(md->status.max_hp/100);
+		WBUFW(buf,8) = 100;
+	} else {
+		WBUFW(buf,6) = md->status.hp;
+		WBUFW(buf,8) = md->status.max_hp;
+	}
+#else
+	WBUFL(buf,6) = md->status.hp;
+	WBUFL(buf,10) = md->status.max_hp;
+#endif
+
+	clif_send(buf, packet_len(cmd), &md->bl, AREA);
+}
+
+static int clif_hpmeter_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd, *tsd;
 #if PACKETVER < 20100126
 	const int cmd = 0x106;
 #else
@@ -2755,13 +3115,15 @@
 			// TODO: Won't these overwrite the current packet?
 			clif_hpmeter(sd);
 			if(!battle_config.party_hp_mode && sd->status.party_id)
-				clif_party_hp(sd);
-			if(sd->bg_id)
-				clif_bg_hp(sd);
+			clif_party_hp(sd);
+		if( sd->bg_id )
+			clif_bg_hp(sd);
+		if( map[sd->bl.m].flag.fvf )
+			clif_faction_hp(sd);
+		break;
+	case SP_SP:
+		WFIFOL(fd,4)=sd->battle_status.sp;
 			break;
-		case SP_SP:
-			WFIFOL(fd,4)=sd->battle_status.sp;
-			break;
 		case SP_ASPD:
 			WFIFOL(fd,4)=sd->battle_status.amotion;
 			break;
@@ -4006,17 +4368,19 @@
 	}
 #ifdef NEW_CARTS
 	if(dstsd->sc.data[SC_PUSH_CART])
-		clif_status_load_single(sd->fd, dstsd->bl.id, SI_ON_PUSH_CART, 2, dstsd->sc.data[SC_PUSH_CART]->val1, 0, 0);
-#endif
-	if((sd->status.party_id && dstsd->status.party_id == sd->status.party_id) ||  //Party-mate, or hpdisp setting.
-	   (sd->bg_id && sd->bg_id == dstsd->bg_id) || //BattleGround
-	   pc_has_permission(sd, PC_PERM_VIEW_HPMETER)
-	  )
-		clif_hpmeter_single(sd->fd, dstsd->bl.id, dstsd->battle_status.hp, dstsd->battle_status.max_hp);
-
-	// display link (sd - dstsd) to sd
-	ARR_FIND(0, 5, i, sd->devotion[i] == dstsd->bl.id);
-	if(i < 5) clif_devotion(&sd->bl, sd);
+		clif_status_load_single(sd->fd, dstsd->bl.id, SI_ON_PUSH_CART, 2, dstsd->sc.data[SC_PUSH_CART]->val1, 0, 0);
+#endif
+	if( (sd->status.party_id && dstsd->status.party_id == sd->status.party_id) || //Party-mate, or hpdisp setting.
+		pc_has_permission(sd, PC_PERM_VIEW_HPMETER)
+	)
+		clif_hpmeter_single(sd->fd, dstsd->bl.id, dstsd->battle_status.hp, dstsd->battle_status.max_hp);
+
+	if( (sd->bg_id && sd->bg_id == dstsd->bg_id) || (map[sd->bl.m].flag.fvf && sd->status.faction_id == dstsd->status.faction_id) )
+		clif_bg_hp_single(sd->fd,dstsd);
+
+	// display link (sd - dstsd) to sd
+	ARR_FIND( 0, 5, i, sd->devotion[i] == dstsd->bl.id );
+	if( i < 5 ) clif_devotion(&sd->bl, sd);
 	// display links (dstsd - devotees) to sd
 	ARR_FIND(0, 5, i, dstsd->devotion[i] > 0);
 	if(i < 5) clif_devotion(&dstsd->bl, sd);
@@ -4027,23 +4391,27 @@
 
 void clif_getareachar_unit(struct map_session_data *sd,struct block_list *bl)
 {
-	uint8 buf[128];
-	struct unit_data *ud;
-	struct view_data *vd;
-	int len;
-
-	vd = status_get_viewdata(bl);
+	uint8 buf[128];
+	struct unit_data *ud;
+	struct view_data *vd;
+	struct map_session_data *tsd;
+	int len;
+
+	vd = status_get_viewdata(bl);
 	if(!vd || vd->class_ == INVISIBLE_CLASS)
 		return;
 
 	/**
 	* Hide NPC from maya purple card.
-	**/
-	if(bl->type == BL_NPC && !((TBL_NPC *)bl)->chat_id && (((TBL_NPC *)bl)->sc.option&OPTION_INVISIBLE))
-		return;
-
-	ud = unit_bl2ud(bl);
-	len = (ud && ud->walktimer != INVALID_TIMER) ? clif_set_unit_walking(bl,ud,buf) : clif_set_unit_idle(bl,buf,false);
+	**/
+	if(bl->type == BL_NPC && !((TBL_NPC*)bl)->chat_id && (((TBL_NPC*)bl)->sc.option&OPTION_INVISIBLE))
+		return;
+	tsd = BL_CAST(BL_PC,bl);
+	if( battle_config.anti_mayapurple_hack && tsd && tsd->sc.option&(OPTION_HIDE|OPTION_CLOAK) && !tsd->state.evade_antiwpefilter && !sd->special_state.intravision && !sd->sc.data[SC_INTRAVISION] )
+		return;
+
+	ud = unit_bl2ud(bl);
+	len = ( ud && ud->walktimer != INVALID_TIMER ) ? clif_set_unit_walking(bl,ud,buf) : clif_set_unit_idle(bl,buf,false);
 	clif_send(buf,len,&sd->bl,SELF);
 
 	if(vd->cloth_color)
@@ -4051,18 +4419,21 @@
 
 	switch(bl->type) {
 		case BL_PC: {
-				TBL_PC *tsd = (TBL_PC *)bl;
+				tsd = (TBL_PC*)bl;
 				clif_getareachar_pc(sd, tsd);
 				if(tsd->state.size==SZ_BIG) // tiny/big players [Valaris]
 					clif_specialeffect_single(bl,423,sd->fd);
 				else if(tsd->state.size==SZ_MEDIUM)
 					clif_specialeffect_single(bl,421,sd->fd);
-				if(tsd->bg_id && map[tsd->bl.m].flag.battleground)
+				clif_sendaurastoone(tsd, sd);
+				if( !battle_config.bg_eAmod_mode && tsd->bg_id && map[tsd->bl.m].flag.battleground )
 					clif_sendbgemblem_single(sd->fd,tsd);
 				if(tsd->sc.data[SC_CAMOUFLAGE])
 					clif_status_load(bl,SI_CAMOUFLAGE,1);
 				if (tsd->status.robe)
 					clif_refreshlook(&sd->bl,bl->id,LOOK_ROBE,tsd->status.robe,SELF);
+				if( map[tsd->bl.m].flag.fvf )
+					clif_faction_single(sd->fd,tsd);
 			}
 			break;
 		case BL_MER: // Devotion Effects
@@ -4082,12 +4453,14 @@
 		case BL_MOB: {
 				TBL_MOB *md = (TBL_MOB *)bl;
 				if(md->special_state.size==SZ_BIG) // tiny/big mobs [Valaris]
-					clif_specialeffect_single(bl,423,sd->fd);
-				else if(md->special_state.size==SZ_MEDIUM)
-					clif_specialeffect_single(bl,421,sd->fd);
-#if PACKETVER >= 20120404
-				if(!(md->status.mode&MD_BOSS)) {
-					int i;
+				clif_specialeffect_single(bl,423,sd->fd);
+			else if(md->special_state.size==SZ_MEDIUM)
+				clif_specialeffect_single(bl,421,sd->fd);
+			if (md->option.hp_show == 1)
+				clif_hpmeter_single(sd->fd, md->bl.id, md->status.hp, md->status.max_hp);
+#if PACKETVER >= 20120404
+			if( !(md->status.mode&MD_BOSS) ){
+				int i;
 					for(i = 0; i < DAMAGELOG_SIZE; i++)// must show hp bar to all char who already hit the mob.
 						if(md->dmglog[i].id == sd->status.char_id)
 							clif_monster_hp_bar(md, sd->fd);
@@ -4117,11 +4490,18 @@
 	if(type == 4 || type == 9 || damage <=0)
 		return 0;
 
-	if(bl->type == BL_PC) {
-		if(battle_config.pc_walk_delay_rate != 100)
-			delay = delay*battle_config.pc_walk_delay_rate/100;
-	} else if(battle_config.walk_delay_rate != 100)
-		delay = delay*battle_config.walk_delay_rate/100;
+	if( bl->type == BL_PC )
+	{
+		if( battle_config.pc_walk_delay_rate != 100 )
+			delay = delay * battle_config.pc_walk_delay_rate / 100;
+	}
+	else if( bl->type == BL_MOB && status_get_mode(bl)&MD_BOSS )
+	{
+		if( battle_config.walk_delay_rate_boss != 100 )
+			delay = delay * battle_config.walk_delay_rate_boss / 100;
+	}
+	else if( battle_config.walk_delay_rate != 100 )
+		delay = delay * battle_config.walk_delay_rate / 100;
 
 	if(div_ > 1)  //Multi-hit skills mean higher delays.
 		delay += battle_config.multihit_delay*(div_-1);
@@ -4157,12 +4537,14 @@
 	const int cmd = 0x2e1;
 #endif
 
-	nullpo_ret(src);
-	nullpo_ret(dst);
-
-	type = clif_calc_delay(type,div,damage+damage2,ddelay);
-	sc = status_get_sc(dst);
-	if(sc && sc->count) {
+	nullpo_ret(src);
+	nullpo_ret(dst);
+
+	pc_record_maxdamage(src, dst, damage + damage2);
+
+	type = clif_calc_delay(type,div,damage+damage2,ddelay);
+	sc = status_get_sc(dst);
+	if(sc && sc->count) {
 		if(sc->data[SC_HALLUCINATION]) {
 			if(damage) damage = damage*(sc->data[SC_HALLUCINATION]->val2) + rnd()%100;
 			if(damage2) damage2 = damage2*(sc->data[SC_HALLUCINATION]->val2) + rnd()%100;
@@ -4243,40 +4625,46 @@
 
 }
 
-/*==========================================
- * inform clients in area that `bl` is sitting
- *------------------------------------------*/
-void clif_sitting(struct block_list *bl)
-{
-	unsigned char buf[32];
-	nullpo_retv(bl);
+/*==========================================
+ * inform clients in area that `bl` is sitting
+ *------------------------------------------*/
+void clif_sitting(struct block_list* bl, bool area)
+{
+	unsigned char buf[32];
+	nullpo_retv(bl);
 
-	WBUFW(buf, 0) = 0x8a;
-	WBUFL(buf, 2) = bl->id;
-	WBUFB(buf,26) = 2;
-	clif_send(buf, packet_len(0x8a), bl, AREA);
-
-	if(disguised(bl)) {
-		WBUFL(buf, 2) = - bl->id;
+	WBUFW(buf, 0) = 0x8a;
+	WBUFL(buf, 2) = bl->id;
+	WBUFB(buf,26) = 2;
+	if( area )
+		clif_send(buf, packet_len(0x8a), bl, AREA);
+	else
+		clif_send(buf, packet_len(0x8a), bl, SELF);
+
+	if(disguised(bl)) {
+		WBUFL(buf, 2) = - bl->id;
 		clif_send(buf, packet_len(0x8a), bl, SELF);
 	}
 }
 
-/*==========================================
- * inform clients in area that `bl` is standing
- *------------------------------------------*/
-void clif_standing(struct block_list *bl)
-{
-	unsigned char buf[32];
-	nullpo_retv(bl);
+/*==========================================
+ * inform clients in area that `bl` is standing
+ *------------------------------------------*/
+void clif_standing(struct block_list* bl, bool area)
+{
+	unsigned char buf[32];
+	nullpo_retv(bl);
 
-	WBUFW(buf, 0) = 0x8a;
-	WBUFL(buf, 2) = bl->id;
-	WBUFB(buf,26) = 3;
-	clif_send(buf, packet_len(0x8a), bl, AREA);
-
-	if(disguised(bl)) {
-		WBUFL(buf, 2) = - bl->id;
+	WBUFW(buf, 0) = 0x8a;
+	WBUFL(buf, 2) = bl->id;
+	WBUFB(buf,26) = 3;
+	if( area )
+		clif_send(buf, packet_len(0x8a), bl, AREA);
+	else
+		clif_send(buf, packet_len(0x8a), bl, SELF);
+
+	if(disguised(bl)) {
+		WBUFL(buf, 2) = - bl->id;
 		clif_send(buf, packet_len(0x8a), bl, SELF);
 	}
 }
@@ -4542,13 +4930,50 @@
 		//Tell sd that tbl walked into his view
 		clif_getareachar_unit(sd,tbl);
 	}
-	return 0;
-}
-
-
-/// Updates whole skill tree (ZC_SKILLINFO_LIST).
-/// 010f <packet len>.W { <skill id>.W <type>.L <level>.W <sp cost>.W <attack range>.W <skill name>.24B <upgradable>.B }*
-void clif_skillinfoblock(struct map_session_data *sd)
+	return 0;
+}
+
+/*==========================================
+ * Refresh on tbl all bl's around (Currently only used for Intravision + Anti MayaPurple Hack
+ *------------------------------------------*/
+int clif_insight_bl2tbl(struct block_list *bl,va_list ap)
+{
+	struct block_list *tbl;
+	struct map_session_data *sd, *tsd;
+
+	tbl = va_arg(ap,struct block_list*);
+	tsd = BL_CAST(BL_PC,tbl);
+	sd = BL_CAST(BL_PC,bl);
+
+	if( bl == tbl || !tsd || !tsd->fd || !sd || !pc_ishiding(sd) )
+		return 0;
+
+	clif_getareachar_unit(tsd,bl);
+	return 0;
+}
+
+/*==========================================
+ * Refresh tbl on all bl's around
+ *------------------------------------------*/
+int clif_insight_tbl2bl(struct block_list *bl,va_list ap)
+{
+	struct block_list *tbl;
+	struct map_session_data *sd;
+
+	tbl = va_arg(ap,struct block_list*);
+	sd = BL_CAST(BL_PC,bl);
+
+	if( bl == tbl || tbl->type != BL_PC || !sd || !sd->fd )
+		return 0;
+
+	clif_getareachar_unit(sd,tbl);
+	return 0;
+}
+
+
+/// Updates whole skill tree (ZC_SKILLINFO_LIST).
+/// 010f <packet len>.W { <skill id>.W <type>.L <level>.W <sp cost>.W <attack range>.W <skill name>.24B <upgradable>.B }*
+void clif_skillinfoblock(struct map_session_data *sd)
 {
 	int fd;
 	int i,len,id;
@@ -4824,16 +5249,38 @@
 /// 0114 <skill id>.W <src id>.L <dst id>.L <tick>.L <src delay>.L <dst delay>.L <damage>.W <level>.W <div>.W <type>.B (ZC_NOTIFY_SKILL)
 /// 01de <skill id>.W <src id>.L <dst id>.L <tick>.L <src delay>.L <dst delay>.L <damage>.L <level>.W <div>.W <type>.B (ZC_NOTIFY_SKILL2)
 int clif_skill_damage(struct block_list *src,struct block_list *dst,unsigned int tick,int sdelay,int ddelay,int damage,int div,uint16 skill_id,uint16 skill_lv,int type)
-{
-	unsigned char buf[64];
-	struct status_change *sc;
-
-	nullpo_ret(src);
-	nullpo_ret(dst);
-
-	type = clif_calc_delay(type,div,damage,ddelay);
-	sc = status_get_sc(dst);
-	if(sc && sc->count) {
+{
+	unsigned char buf[64];
+	struct status_change *sc;
+	struct map_session_data *sd;
+
+	nullpo_ret(src);
+	nullpo_ret(dst);
+
+	/* WoE Stats */
+	pc_record_maxdamage(src, dst, damage);
+	sd = BL_CAST(BL_PC, src);
+	if( sd && skill_id == CR_ACIDDEMONSTRATION )
+	{
+		if( damage > 0 )
+		{
+			if( sd->status.guild_id && map_allowed_woe(src->m) )
+				add2limit(sd->status.wstats.acid_demostration, 1, UINT32_MAX);
+			else if( map[src->m].flag.battleground && sd->bg_id )
+				add2limit(sd->status.bgstats.acid_demostration, 1, UINT32_MAX);
+		}
+		else
+		{
+			if( sd->status.guild_id && map_allowed_woe(src->m) )
+				add2limit(sd->status.wstats.acid_demostration_fail, 1, UINT32_MAX);
+			else if( map[src->m].flag.battleground && sd->bg_id )
+				add2limit(sd->status.bgstats.acid_demostration_fail, 1, UINT32_MAX);
+		}
+	}
+
+	type = clif_calc_delay(type,div,damage,ddelay);
+	sc = status_get_sc(dst);
+	if(sc && sc->count) {
 		if(sc->data[SC_HALLUCINATION] && damage)
 			damage = damage*(sc->data[SC_HALLUCINATION]->val2) + rnd()%100;
 	}
@@ -5406,26 +5853,46 @@
 }
 
 /*==========================================
- * Send main chat message [LuzZza]
+ * Chat Room System [Zephyrus]
  *------------------------------------------*/
-void clif_MainChatMessage(const char *message)
+void clif_channel_message(struct channel_data *cd, const char *message, int color)
 {
-	uint8 buf[200];
-	int len;
+	struct map_session_data *pl_sd;
+	char mes[CHAT_SIZE_MAX], buf[1024];
+	int len, fd;
+	unsigned long mcolor; // Message Color
+	DBIterator* iter;
 
-	if(!message)
+	if( !message || !*message || cd == NULL )
 		return;
 
-	len = strlen(message)+1;
-	if(len+8 > sizeof(buf)) {
-		ShowDebug("clif_MainChatMessage: Received message too long (len %d): %s\n", len, message);
-		len = sizeof(buf)-8;
+	strncpy(mes, message, CHAT_SIZE_MAX);
+	len = (int)strlen(message) + 1;
+	mes_len_check(mes, len, CHAT_SIZE_MAX);
+	mcolor = (color < 0) ? cd->color : channel_color[cap_value(color,0,38)];
+
+	// Convert Color to BGR
+	mcolor = (mcolor & 0x0000FF) << 16 | (mcolor & 0x00FF00) | (mcolor & 0xFF0000) >> 16;
+	WBUFW(buf,0) = 0x2C1;
+	WBUFW(buf,2) = len + 12;
+	WBUFL(buf,4) = 0;
+	WBUFL(buf,8) = mcolor;
+	memcpy(WBUFP(buf,12),mes,len);
+
+	iter = db_iterator(cd->users_db);
+	for( pl_sd = (struct map_session_data *)dbi_first(iter); dbi_exists(iter); pl_sd = (struct map_session_data *)dbi_next(iter) )
+	{
+		if( pl_sd->chatID )
+			continue;
+
+		fd = pl_sd->fd;
+		WFIFOHEAD(fd, WBUFW(buf,2));
+		memcpy(WFIFOP(fd,0), (unsigned char *)buf, WBUFW(buf,2));
+		WFIFOSET(fd, WBUFW(buf,2));
 	}
-	WBUFW(buf,0)=0x8d;
-	WBUFW(buf,2)=len+8;
-	WBUFL(buf,4)=0;
-	safestrncpy((char *) WBUFP(buf,8),message,len);
-	clif_send(buf,WBUFW(buf,2),NULL,CHAT_MAINCHAT);
+	dbi_destroy(iter);
+
+	return;
 }
 
 /// Send broadcast message with font formatting (ZC_BROADCAST2).
@@ -5530,19 +5997,19 @@
 		WFIFOL(fd,10) = pvpnum;
 		WFIFOSET(fd,packet_len(0x19a));
 	} else {
-		unsigned char buf[32];
-		WBUFW(buf,0) = 0x19a;
-		WBUFL(buf,2) = sd->bl.id;
-		if(sd->sc.option&(OPTION_HIDE|OPTION_CLOAK))
-			WBUFL(buf,6) = UINT32_MAX; //On client displays as --
-		else
-			WBUFL(buf,6) = pvprank;
-		WBUFL(buf,10) = pvpnum;
-		if(sd->sc.option&OPTION_INVISIBLE || sd->disguise) //Causes crashes when a 'mob' with pvp info dies.
-			clif_send(buf,packet_len(0x19a),&sd->bl,SELF);
-		else if(!type)
-			clif_send(buf,packet_len(0x19a),&sd->bl,AREA);
-		else
+		unsigned char buf[32];
+		WBUFW(buf,0) = 0x19a;
+		WBUFL(buf,2) = sd->bl.id;
+		if( !battle_config.anti_mayapurple_hack && sd->sc.option&(OPTION_HIDE|OPTION_CLOAK) )
+			WBUFL(buf,6) = UINT32_MAX; //On client displays as --
+		else
+			WBUFL(buf,6) = pvprank;
+		WBUFL(buf,10) = pvpnum;
+		if( sd->sc.option&OPTION_INVISIBLE || sd->disguise || (battle_config.anti_mayapurple_hack && sd->sc.option&(OPTION_HIDE|OPTION_CLOAK)) )
+			clif_send(buf,packet_len(0x19a),&sd->bl,SELF); //Causes crashes when a 'mob' with pvp info dies.
+		else if(!type)
+			clif_send(buf,packet_len(0x19a),&sd->bl,AREA);
+		else
 			clif_send(buf,packet_len(0x19a),&sd->bl,ALL_SAMEMAP);
 	}
 }
@@ -5685,17 +6152,30 @@
 
 		if((sd->inventory_data[i]->equip&ep)==0)    //Not equippable on this part.
 			continue;
-
-		if(sd->inventory_data[i]->type==IT_WEAPON && ep==EQP_SHIELD) //Shield card won't go on left weapon.
-			continue;
-
-		ARR_FIND(0, sd->inventory_data[i]->slot, j, sd->status.inventory[i].card[j] == 0);
-		if(j == sd->inventory_data[i]->slot)     // No room
-			continue;
-
-		WFIFOW(fd,4+c*2)=i+2;
-		c++;
-	}
+
+		if(sd->inventory_data[i]->type==IT_WEAPON && ep==EQP_SHIELD) //Shield card won't go on left weapon.
+			continue;
+	
+		if( itemdb_isenchant(sd->inventory_data[idx]->nameid) )
+		{
+			if( sd->inventory_data[i]->slot > 3 )
+				continue; // More than 3 slots
+			switch( sd->inventory_data[i]->nameid )
+			{ // Non Enchantable Stuff
+			case 2357:
+				continue;
+			}
+		}
+		else
+		{
+			ARR_FIND( 0, sd->inventory_data[i]->slot, j, sd->status.inventory[i].card[j] == 0 );
+			if( j == sd->inventory_data[i]->slot )	// No room
+				continue;
+		}
+
+		WFIFOW(fd,4+c*2)=i+2;
+		c++;
+	}
 	WFIFOW(fd,2)=4+c*2;
 	WFIFOSET(fd,WFIFOW(fd,2));
 }
@@ -6487,12 +6967,13 @@
 	const int cmd = 0x106;
 #else
 	const int cmd = 0x80e;
-#endif
-
-	nullpo_retv(sd);
-
-	WBUFW(buf,0)=cmd;
-	WBUFL(buf,2)=sd->status.account_id;
+#endif
+
+	nullpo_retv(sd);
+	if( map[sd->bl.m].flag.fvf ) return;
+
+	WBUFW(buf,0)=cmd;
+	WBUFL(buf,2)=sd->status.account_id;
 #if PACKETVER < 20100126
 	if(sd->battle_status.max_hp > INT16_MAX) {  //To correctly display the %hp bar. [Skotlex]
 		WBUFW(buf,6) = sd->battle_status.hp/(sd->battle_status.max_hp/100);
@@ -6630,12 +7111,17 @@
 	fd=sd->fd;
 	if(!battle_config.supports_castle_gvg && map_flag_gvg(sd->bl.m)) {
 		//Disable pet hatching in GvG grounds during Guild Wars [Skotlex]
-		clif_displaymessage(fd, msg_txt(666));
-		return;
-	}
-	WFIFOHEAD(fd, MAX_INVENTORY * 2 + 4);
-	WFIFOW(fd,0)=0x1a6;
-	for(i=0,n=0; i<MAX_INVENTORY; i++) {
+		clif_displaymessage(fd, msg_txt(666));
+		return;
+	}
+	if( map[sd->bl.m].flag.ancient )
+	{
+		clif_displaymessage(fd, "Pets are not allowed in Ancient WoE.");
+		return;
+	}
+	WFIFOHEAD(fd, MAX_INVENTORY * 2 + 4);
+	WFIFOW(fd,0)=0x1a6;
+	for(i=0,n=0;i<MAX_INVENTORY;i++){
 		if(sd->status.inventory[i].nameid<=0 || sd->inventory_data[i] == NULL ||
 		   sd->inventory_data[i]->type!=IT_PETEGG ||
 		   sd->status.inventory[i].amount<=0)
@@ -6986,12 +7472,17 @@
 ///     &0x01 = allow invite
 ///     &0x10 = allow expel
 void clif_guild_belonginfo(struct map_session_data *sd, struct guild *g)
-{
-	int ps,fd;
-	nullpo_retv(sd);
-	nullpo_retv(g);
-
-	fd=sd->fd;
+{
+	int ps,fd;
+	nullpo_retv(sd);
+	if( battle_config.bg_eAmod_mode && sd->bg_id )
+	{
+		clif_bg_belonginfo(sd);
+		return;
+	}
+	nullpo_retv(g);
+
+	fd=sd->fd;
 	ps=guild_getposition(g,sd);
 	WFIFOHEAD(fd,packet_len(0x16c));
 	WFIFOW(fd,0)=0x16c;
@@ -7104,22 +7595,28 @@
 /// 01b6 <guild id>.L <level>.L <member num>.L <member max>.L <exp>.L <max exp>.L <points>.L <honor>.L <virtue>.L <emblem id>.L <name>.24B <master name>.24B <manage land>.16B <zeny>.L (ZC_GUILD_INFO2)
 void clif_guild_basicinfo(struct map_session_data *sd)
 {
-	int fd;
-	struct guild *g;
-
-	nullpo_retv(sd);
-	fd = sd->fd;
-
-	if((g = guild_search(sd->status.guild_id)) == NULL)
-		return;
-
-	WFIFOHEAD(fd,packet_len(0x1b6));
-	WFIFOW(fd, 0)=0x1b6;//0x150;
-	WFIFOL(fd, 2)=g->guild_id;
-	WFIFOL(fd, 6)=g->guild_lv;
-	WFIFOL(fd,10)=g->connect_member;
-	WFIFOL(fd,14)=g->max_member;
-	WFIFOL(fd,18)=g->average_lv;
+	int fd;
+	struct guild *g;
+	struct battleground_data *bg = NULL;
+
+	nullpo_retv(sd);
+	fd = sd->fd;
+
+	if( battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL )
+		bg = bg_team_search(sd->bg_id);
+	else
+		g = guild_search(sd->status.guild_id);
+
+	if( g == NULL )
+		return;
+
+	WFIFOHEAD(fd,packet_len(0x1b6));
+	WFIFOW(fd, 0)=0x1b6;//0x150;
+	WFIFOL(fd, 2)=g->guild_id;
+	WFIFOL(fd, 6)=g->guild_lv;
+	WFIFOL(fd,10)=bg?bg->count:g->connect_member;
+	WFIFOL(fd,14)=g->max_member;
+	WFIFOL(fd,18)=g->average_lv;
 	WFIFOL(fd,22)=(uint32)cap_value(g->exp,0,INT32_MAX);
 	WFIFOL(fd,26)=g->next_exp;
 	WFIFOL(fd,30)=0;    // Tax Points
@@ -7141,13 +7638,15 @@
 void clif_guild_allianceinfo(struct map_session_data *sd)
 {
 	int fd,i,c;
-	struct guild *g;
-
-	nullpo_retv(sd);
-	if((g = guild_search(sd->status.guild_id)) == NULL)
-		return;
-
-	fd = sd->fd;
+	struct guild *g;
+
+	nullpo_retv(sd);
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = guild_search(sd->status.guild_id);
+	if( g == NULL )
+		return;
+
+	fd = sd->fd;
 	WFIFOHEAD(fd, MAX_GUILDALLIANCE * 32 + 4);
 	WFIFOW(fd, 0)=0x14c;
 	for(i=c=0; i<MAX_GUILDALLIANCE; i++) {
@@ -7177,12 +7676,17 @@
 	int i,c;
 	struct guild *g;
 	nullpo_retv(sd);
-
-	if((fd = sd->fd) == 0)
-		return;
-	if((g = guild_search(sd->status.guild_id)) == NULL)
-		return;
-
+
+	if( (fd = sd->fd) == 0 )
+		return;
+	if( battle_config.bg_eAmod_mode && sd->bg_id )
+	{
+		clif_bg_memberlist(sd);
+		return;
+	}
+	if( (g = guild_search(sd->status.guild_id)) == NULL )
+		return;
+
 	WFIFOHEAD(fd, g->max_member * 104 + 4);
 	WFIFOW(fd, 0)=0x154;
 	for(i=0,c=0; i<g->max_member; i++) {
@@ -7244,13 +7748,16 @@
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if((g = guild_search(sd->status.guild_id)) == NULL)
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = guild_search(sd->status.guild_id);
+
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
 	WFIFOHEAD(fd, MAX_GUILDPOSITION * 16 + 4);
 	WFIFOW(fd, 0)=0x160;
-	for(i=0; i<MAX_GUILDPOSITION; i++) {
+	for(i=0;i<MAX_GUILDPOSITION;i++){
 		struct guild_position *p=&g->position[i];
 		WFIFOL(fd,i*16+ 4)=i;
 		WFIFOL(fd,i*16+ 8)=p->mode;
@@ -7348,28 +7855,31 @@
 	nullpo_retv(bl);
 
 	// TODO this packet doesn't force the update of ui components that have the emblem visible
-	//      (emblem in the flag npcs and emblem over the head in agit maps) [FlavioJS]
-	WBUFW(buf,0) = 0x1b4;
-	WBUFL(buf,2) = bl->id;
-	WBUFL(buf,6) = status_get_guild_id(bl);
-	WBUFW(buf,10) = status_get_emblem_id(bl);
-	clif_send(buf, 12, bl, AREA_WOS);
-}
+	//      (emblem in the flag npcs and emblem over the head in agit maps) [FlavioJS]
+	WBUFW(buf,0) = 0x1b4;
+	WBUFL(buf,2) = bl->id;
+	WBUFL(buf,6) = clif_visual_guild_id(bl);
+	WBUFW(buf,10) = clif_visual_emblem_id(bl);
+	clif_send(buf, 12, bl, AREA_WOS);
+}
+
 
-
 /// Sends guild skills (ZC_GUILD_SKILLINFO).
 /// 0162 <packet len>.W <skill points>.W { <skill id>.W <type>.L <level>.W <sp cost>.W <atk range>.W <skill name>.24B <upgradable>.B }*
 void clif_guild_skillinfo(struct map_session_data *sd)
 {
 	int fd;
 	struct guild *g;
-	int i,c;
-
-	nullpo_retv(sd);
-	if((g = guild_search(sd->status.guild_id)) == NULL)
-		return;
-
-	fd = sd->fd;
+	int i,c;
+
+	nullpo_retv(sd);
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = guild_search(sd->status.guild_id);
+
+	if( g == NULL )
+		return;
+
+	fd = sd->fd;
 	WFIFOHEAD(fd, 6 + MAX_GUILDSKILL*37);
 	WFIFOW(fd,0) = 0x0162;
 	WFIFOW(fd,4) = g->skill_point;
@@ -7507,15 +8017,17 @@
 #endif
 	int fd, i, c = 0;
 	struct guild *g;
-
-	nullpo_retv(sd);
-
-	if((g = guild_search(sd->status.guild_id)) == NULL)
-		return;
-
-	fd = sd->fd;
-
-	WFIFOHEAD(fd,4 + MAX_GUILDEXPULSION * offset);
+
+	nullpo_retv(sd);
+
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = guild_search(sd->status.guild_id);
+
+	if( g == NULL ) return;
+
+	fd = sd->fd;
+
+	WFIFOHEAD(fd,4 + MAX_GUILDEXPULSION * offset);
 	WFIFOW(fd,0) = 0x163;
 
 	for(i = 0; i < MAX_GUILDEXPULSION; i++) {
@@ -8192,35 +8704,175 @@
 	clif_weather_check(sd);
 	if(sd->chatID)
 		chat_leavechat(sd,0);
-	if(sd->state.vending)
-		clif_openvending(sd, sd->bl.id, sd->vending);
-	if(pc_issit(sd))
-		clif_sitting(&sd->bl); // FIXME: just send to self, not area
-	if(pc_isdead(sd))   // When you refresh, resend the death packet.
-		clif_clearunit_single(sd->bl.id,CLR_DEAD,sd->fd);
-	else
+	if( sd->state.vending )
+		clif_openvending(sd, sd->bl.id, sd->vending);
+	if( pc_issit(sd) )
+		clif_sitting(&sd->bl,false); // FIXME: just send to self, not area
+	if( pc_isdead(sd) ) // When you refresh, resend the death packet.
+		clif_clearunit_single(sd->bl.id,CLR_DEAD,sd->fd);
+	else
 		clif_changed_dir(&sd->bl, SELF);
-
-	// unlike vending, resuming buyingstore crashes the client.
-	buyingstore_close(sd);
-
-	mail_clear(sd);
-}
-
-
-/// Updates the object's (bl) name on client.
-/// 0095 <id>.L <char name>.24B (ZC_ACK_REQNAME)
-/// 0195 <id>.L <char name>.24B <party name>.24B <guild name>.24B <position name>.24B (ZC_ACK_REQNAMEALL)
-void clif_charnameack(int fd, struct block_list *bl)
-{
-	unsigned char buf[103];
-	int cmd = 0x95, i, ps = -1;
-
-	nullpo_retv(bl);
-
-	WBUFW(buf,0) = cmd;
-	WBUFL(buf,2) = bl->id;
-
+
+	// unlike vending, resuming buyingstore crashes the client.
+	buyingstore_close(sd);
+	clif_sendaurastoone(sd,sd);
+
+	mail_clear(sd);
+}
+
+int clif_mobnameack_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd;
+	unsigned char *buf, *sbuf;
+	int fd, len, is_hp_update;
+
+	nullpo_ret(bl);
+	nullpo_ret(sd = (struct map_session_data *)bl);
+	if( !(fd = sd->fd) || session[fd] == NULL ) return 0;
+
+	buf = va_arg(ap,unsigned char*);
+	len = va_arg(ap,int);
+	sbuf = va_arg(ap,unsigned char*);
+	is_hp_update = va_arg(ap,int);
+
+	if( is_hp_update && !sd->state.view_mob_info )
+		return 0; // Do not send info to normal users
+
+	if( sd->state.view_mob_info )
+	{
+		len = packet_len(0x195);
+		WFIFOHEAD(fd,len);
+		memcpy(WFIFOP(fd,0),sbuf,len);
+	}
+	else
+	{
+		WFIFOHEAD(fd,len);
+		memcpy(WFIFOP(fd,0),buf,len);
+	}
+
+	WFIFOSET(fd,len);
+	return 0;
+}
+
+void clif_mobnameack(struct map_session_data *sd, struct mob_data *md, int is_hp_update)
+{
+	unsigned char buf[102], sbuf[102];
+	struct guild *g;
+	struct battleground_data *bg;
+	struct region_data* rd;
+	int cmd, fd, len;
+
+	if( !md ) return;
+	rd = region_search(map[md->bl.m].region_id);
+
+	// Basic Packet Header
+	WBUFW(buf,0) = cmd = 0x95;
+	WBUFW(sbuf,0) = 0x195;
+	WBUFL(buf,2) = WBUFL(sbuf,2) = md->bl.id;
+	memcpy(WBUFP(buf,6), md->name, NAME_LENGTH);
+	memcpy(WBUFP(sbuf,6), md->name, NAME_LENGTH);
+
+	// Building Monster Name
+	if( md->guardian_data && md->guardian_data->guild_id )
+	{
+		WBUFW(buf,0) = cmd = 0x195;
+		WBUFB(buf,30) = WBUFB(sbuf,30) = 0;
+		memcpy(WBUFP(buf,54), md->guardian_data->guild_name, NAME_LENGTH);
+		memcpy(WBUFP(buf,78), md->guardian_data->castle->castle_name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,54), md->guardian_data->guild_name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,78), md->guardian_data->castle->castle_name, NAME_LENGTH);
+	}
+	else if( battle_config.bg_eAmod_mode && md->bg_id && (bg = bg_team_search(md->bg_id)) != NULL && (g = bg->g) != NULL )
+	{
+		WBUFW(buf,0) = cmd = 0x195;
+		WBUFB(buf,30) = WBUFB(sbuf,30) = 0;
+		memcpy(WBUFP(buf,54), g->name, NAME_LENGTH);
+		memcpy(WBUFP(buf,78), g->position[0].name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,54), g->name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,78), g->position[0].name, NAME_LENGTH);
+	}
+	else if( rd && md->option.is_war && md->option.guild_id && (g = guild_search(md->option.guild_id)) != NULL )
+	{
+		WBUFW(buf,0) = cmd = 0x195;
+		WBUFB(buf,30) = WBUFB(sbuf,30) = 0;
+		memcpy(WBUFP(buf,54), g->name, NAME_LENGTH);
+		memcpy(WBUFP(buf,78), rd->name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,54), g->name, NAME_LENGTH);
+		memcpy(WBUFP(sbuf,78), rd->name, NAME_LENGTH);
+	}
+	else if( battle_config.show_mob_info || md->option.hp_show > 1 )
+	{
+		char mobhp[50], *str_p = mobhp;
+		WBUFW(buf,0) = cmd = 0x195;
+		if( battle_config.show_mob_info&4 )
+			str_p += sprintf(str_p, "Lv. %d | ", md->level);
+		if( battle_config.show_mob_info&1 || md->option.hp_show == 2 )
+			str_p += sprintf(str_p, "HP: %u/%u | ", md->status.hp, md->status.max_hp);
+		if( battle_config.show_mob_info&2 || md->option.hp_show == 3 )
+			str_p += sprintf(str_p, "HP: %d%% | ", get_percentage(md->status.hp, md->status.max_hp));
+		if( str_p != mobhp )
+		{
+			*(str_p-3) = '\0'; //Remove trailing space + pipe.
+			memcpy(WBUFP(buf,30), mobhp, NAME_LENGTH);
+			memcpy(WBUFP(sbuf,30), mobhp, NAME_LENGTH);
+			WBUFB(buf,54) = WBUFB(sbuf,54) = 0;
+			memcpy(WBUFP(buf,78), mobhp, NAME_LENGTH);
+			memcpy(WBUFP(sbuf,78), mobhp, NAME_LENGTH);
+			is_hp_update = 0; // To notify everybody around
+		}
+	}
+	else
+	{ // Build the "view_mob_hp" feature
+		char mobhp[NAME_LENGTH];
+		snprintf(mobhp, NAME_LENGTH, "HP: %u/%u (%d%%)", md->status.hp, md->status.max_hp, get_percentage(md->status.hp, md->status.max_hp));
+		memcpy(WBUFP(sbuf,30), mobhp, NAME_LENGTH);
+		WBUFB(sbuf,54) = 0;
+		memcpy(WBUFP(sbuf,78), mobhp, NAME_LENGTH);
+	}
+
+	if( sd )
+	{ // Single User
+		fd = sd->fd;
+		if( sd->state.view_mob_info )
+		{ // Send Special Buff
+			len = packet_len(0x195);
+			WFIFOHEAD(fd,len);
+			memcpy(WFIFOP(fd,0),sbuf,len);
+		}
+		else
+		{ // Send Normal Buff
+			len = packet_len(cmd);
+			WFIFOHEAD(fd,len);
+			memcpy(WFIFOP(fd,0),buf,len);
+		}
+
+		WFIFOSET(fd,len);
+		return;
+	}
+
+	len = packet_len(cmd);
+	map_foreachinarea(clif_mobnameack_sub, md->bl.m, md->bl.x - AREA_SIZE, md->bl.y - AREA_SIZE, md->bl.x + AREA_SIZE, md->bl.y + AREA_SIZE, BL_PC, buf, len, sbuf, is_hp_update);
+}
+
+/// Updates the object's (bl) name on client.
+/// 0095 <id>.L <char name>.24B (ZC_ACK_REQNAME)
+/// 0195 <id>.L <char name>.24B <party name>.24B <guild name>.24B <position name>.24B (ZC_ACK_REQNAMEALL)
+void clif_charnameack (struct map_session_data *sd, struct block_list *bl)
+{
+	unsigned char buf[103];
+	int cmd = 0x95, i, ps = -1, fd = 0;
+
+	nullpo_retv(bl);
+	if( bl->type == BL_MOB )
+	{
+		clif_mobnameack(sd, (struct mob_data *)bl, 0);
+		return;
+	}
+
+	if( sd ) fd = sd->fd;
+	WBUFW(buf,0) = cmd;
+	WBUFL(buf,2) = bl->id;
+
 	switch(bl->type) {
 		case BL_PC: {
 				struct map_session_data *ssd = (struct map_session_data *)bl;
@@ -8231,29 +8883,25 @@
 				if(ssd->fd == fd && ssd->disguise)
 					WBUFL(buf,2) = -bl->id;
 
-				if(ssd->fakename[0]) {
-					WBUFW(buf, 0) = cmd = 0x195;
+				if( ssd->fakename[0] )
 					memcpy(WBUFP(buf,6), ssd->fakename, NAME_LENGTH);
-					WBUFB(buf,30) = WBUFB(buf,54) = WBUFB(buf,78) = 0;
-					break;
-				}
-				memcpy(WBUFP(buf,6), ssd->status.name, NAME_LENGTH);
+				else
+					memcpy(WBUFP(buf,6), ssd->status.name, NAME_LENGTH); // Cambiado para Fakename mostrando Guild Name
 
-				if(ssd->status.party_id) {
+				if( ssd->status.party_id )
 					p = party_search(ssd->status.party_id);
+
+				if( battle_config.bg_eAmod_mode && ssd->bg_id )
+				{
+					g = bg_guild_get(ssd->bg_id);
+					ps = ssd->bmaster_flag ? 0 : 1;
 				}
-				if(ssd->status.guild_id) {
-					if((g = guild_search(ssd->status.guild_id)) != NULL) {
-						ARR_FIND(0, g->max_member, i, g->member[i].account_id == ssd->status.account_id && g->member[i].char_id == ssd->status.char_id);
-						if(i < g->max_member) ps = g->member[i].position;
-					}
+				else if( ssd->status.guild_id && (g = guild_search(ssd->status.guild_id)) != NULL )
+				{
+					ARR_FIND(0, g->max_member, i, g->member[i].account_id == ssd->status.account_id && g->member[i].char_id == ssd->status.char_id);
+					if( i < g->max_member ) ps = g->member[i].position;
 				}
 
-				if(!battle_config.display_party_name && g == NULL) {
-					// do not display party unless the player is also in a guild
-					p = NULL;
-				}
-
 				if(p == NULL && g == NULL)
 					break;
 
@@ -8285,36 +8933,6 @@
 		case BL_NPC:
 			memcpy(WBUFP(buf,6), ((TBL_NPC *)bl)->name, NAME_LENGTH);
 			break;
-		case BL_MOB: {
-				struct mob_data *md = (struct mob_data *)bl;
-				nullpo_retv(md);
-
-				memcpy(WBUFP(buf,6), md->name, NAME_LENGTH);
-				if(md->guardian_data && md->guardian_data->guild_id) {
-					WBUFW(buf, 0) = cmd = 0x195;
-					WBUFB(buf,30) = 0;
-					memcpy(WBUFP(buf,54), md->guardian_data->guild_name, NAME_LENGTH);
-					memcpy(WBUFP(buf,78), md->guardian_data->castle->castle_name, NAME_LENGTH);
-				} else if(battle_config.show_mob_info) {
-					char mobhp[50], *str_p = mobhp;
-					WBUFW(buf, 0) = cmd = 0x195;
-					if(battle_config.show_mob_info&4)
-						str_p += sprintf(str_p, "Lv. %d | ", md->level);
-					if(battle_config.show_mob_info&1)
-						str_p += sprintf(str_p, "HP: %u/%u | ", md->status.hp, md->status.max_hp);
-					if(battle_config.show_mob_info&2)
-						str_p += sprintf(str_p, "HP: %d%% | ", get_percentage(md->status.hp, md->status.max_hp));
-					//Even thought mobhp ain't a name, we send it as one so the client
-					//can parse it. [Skotlex]
-					if(str_p != mobhp) {
-						*(str_p-3) = '\0'; //Remove trailing space + pipe.
-						memcpy(WBUFP(buf,30), mobhp, NAME_LENGTH);
-						WBUFB(buf,54) = 0;
-						WBUFB(buf,78) = 0;
-					}
-				}
-			}
-			break;
 		case BL_CHAT:   //FIXME: Clients DO request this... what should be done about it? The chat's title may not fit... [Skotlex]
 //		memcpy(WBUFP(buf,6), (struct chat*)->title, NAME_LENGTH);
 //		break;
@@ -8349,23 +8967,23 @@
 
 	nullpo_retv(ssd);
 
-	if(ssd->fakename[0])
-		return; //No need to update as the party/guild was not displayed anyway.
-
 	WBUFW(buf,0) = cmd;
 	WBUFL(buf,2) = ssd->bl.id;
 
-	memcpy(WBUFP(buf,6), ssd->status.name, NAME_LENGTH);
+	if( strlen(ssd->fakename) > 1 )
+		memcpy(WBUFP(buf,6), ssd->fakename, NAME_LENGTH);
+	else
+		memcpy(WBUFP(buf,6), ssd->status.name, NAME_LENGTH);
+		
+	if( ssd->status.party_id > 0 )
+		p = party_search(ssd->status.party_id);	
 
-	if(!battle_config.display_party_name) {
-		if(ssd->status.party_id > 0 && ssd->status.guild_id > 0 && (g = guild_search(ssd->status.guild_id)) != NULL)
-			p = party_search(ssd->status.party_id);
-	} else {
-		if(ssd->status.party_id > 0)
-			p = party_search(ssd->status.party_id);
+	if( battle_config.bg_eAmod_mode && ssd->bg_id > 0 ) {
+		g = bg_guild_get(ssd->bg_id);
+		ps = ssd->bmaster_flag ? 0 : 1;
 	}
-
-	if(ssd->status.guild_id > 0 && (g = guild_search(ssd->status.guild_id)) != NULL) {
+	else if( ssd->status.guild_id > 0 && (g = guild_search(ssd->status.guild_id)) != NULL )
+	{
 		int i;
 		ARR_FIND(0, g->max_member, i, g->member[i].account_id == ssd->status.account_id && g->member[i].char_id == ssd->status.char_id);
 		if(i < g->max_member) ps = g->member[i].position;
@@ -8657,13 +9275,13 @@
 		// Add refine, identify flag, element, etc.
 		clif_item_sub(WBUFP(buf,0), n*s+45, &tsd->status.inventory[i], tsd->inventory_data[i], pc_equippoint(tsd, i));
 		// Add cards
-		clif_addcards(WBUFP(buf, n*s+55), &tsd->status.inventory[i]);
-		// Expiration date stuff, if all of those are set to 0 then the client doesn't show anything related (6 bytes)
-		WBUFL(buf, n*s+63) = tsd->status.inventory[i].expire_time;
-		WBUFW(buf, n*s+67) = 0;
-#if PACKETVER >= 20100629
-		if(tsd->inventory_data[i]->equip&EQP_VISIBLE)
-			WBUFW(buf, n*s+69) = tsd->inventory_data[i]->look;
+		clif_addcards(WBUFP(buf, n*s+55), &tsd->status.inventory[i]);
+		// Expiration date stuff, if all of those are set to 0 then the client doesn't show anything related (6 bytes)
+		WBUFL(buf, n*s+63) = tsd->status.inventory[i].expire_time;
+		WBUFW(buf, n*s+67) = tsd->status.inventory[i].bound ? 2 : 0;
+#if PACKETVER >= 20100629
+		if (tsd->inventory_data[i]->equip&EQP_VISIBLE)
+			WBUFW(buf, n*s+69) = tsd->inventory_data[i]->look;
 		else
 			WBUFW(buf, n*s+69) = 0;
 #endif
@@ -8989,12 +9607,14 @@
 
 
 /// Notification from the client, that it has finished map loading and is about to display player's character (CZ_NOTIFY_ACTORINIT).
-/// 007d
-void clif_parse_LoadEndAck(int fd,struct map_session_data *sd)
-{
-	if(sd->bl.prev != NULL)
-		return;
-
+/// 007d
+void clif_parse_LoadEndAck(int fd,struct map_session_data *sd)
+{
+	struct region_data* rd = NULL;
+
+	if(sd->bl.prev != NULL)
+		return;
+
 	if(!sd->state.active) {
 		//Character loading is not complete yet!
 		//Let pc_reg_received reinvoke this when ready.
@@ -9038,12 +9658,18 @@
 
 	// guild
 	// (needs to go before clif_spawn() to show guild emblems correctly)
-	if(sd->status.guild_id)
-		guild_send_memberinfoshort(sd,1);
-
-	if(battle_config.pc_invincible_time > 0) {
-		if(map_flag_gvg(sd->bl.m))
-			pc_setinvincibletimer(sd,battle_config.pc_invincible_time<<1);
+	if(sd->status.guild_id)
+		guild_send_memberinfoshort(sd,1);
+
+	// Set User Custom Aura if any
+	if( sd->state.pvpmode && map_flag_nopvpmode(sd->bl.m) )
+		pc_pvpmodeoff(sd,1,0);
+
+	sd->view_aura = pc_get_aura(sd);
+
+	if(battle_config.pc_invincible_time > 0) {
+		if(map_flag_gvg(sd->bl.m))
+			pc_setinvincibletimer(sd,battle_config.pc_invincible_time<<1);
 		else
 			pc_setinvincibletimer(sd,battle_config.pc_invincible_time);
 	}
@@ -9060,47 +9686,67 @@
 	}
 	sd->state.debug_remove_map = 0; // temporary state to track double remove_map's [FlavioJS]
 
-	// reset the callshop flag if the player changes map
-	sd->state.callshop = 0;
-
-	map_addblock(&sd->bl);
-	clif_spawn(&sd->bl);
-
+	// reset the callshop flag if the player changes map
+	sd->state.callshop = 0;
+
+	if( map[sd->bl.m].region_id > 0 && (rd = region_search(map[sd->bl.m].region_id)) != NULL )
+		rd->users++;
+
+	map_addblock(&sd->bl);
+	clif_spawn(&sd->bl);
+
 	// Party
 	// (needs to go after clif_spawn() to show hp bars correctly)
 	if(sd->status.party_id) {
 		party_send_movemap(sd);
 		clif_party_hp(sd); // Show hp after displacement [LuzZza]
-	}
-
-	if(sd->bg_id) clif_bg_hp(sd);   // BattleGround System
-
-	if(map[sd->bl.m].flag.pvp && !(sd->sc.option&OPTION_INVISIBLE)) {
-		if(!battle_config.pk_mode) { // remove pvp stuff for pk_mode [Valaris]
-			if(!map[sd->bl.m].flag.pvp_nocalcrank)
-				sd->pvp_timer = add_timer(gettick()+200, pc_calc_pvprank_timer, sd->bl.id, 0);
+	}
+
+	if( sd->bg_id ) clif_bg_hp(sd); // BattleGround System
+	if( map[sd->bl.m].flag.fvf ) clif_faction_hp(sd);
+
+	if( battle_config.bg_eAmod_mode && sd->state.changemap && map[sd->bl.m].flag.battleground )
+	{
+		clif_map_type(sd, MAPTYPE_BATTLEFIELD); // Battleground Mode
+		if( map[sd->bl.m].flag.battleground >= 2 )
+			clif_bg_updatescore_single(sd); // Score board only need update on change map
+	}
+
+	if( map[sd->bl.m].flag.pvp_event )
+		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+	else if(map[sd->bl.m].flag.pvp && !(sd->sc.option&OPTION_INVISIBLE)) {
+		if(!battle_config.pk_mode) { // remove pvp stuff for pk_mode [Valaris]
+			if (!map[sd->bl.m].flag.pvp_nocalcrank)
+				sd->pvp_timer = add_timer(gettick()+200, pc_calc_pvprank_timer, sd->bl.id, 0);
 			sd->pvp_rank = 0;
 			sd->pvp_lastusers = 0;
 			sd->pvp_point = 5;
 			sd->pvp_won = 0;
 			sd->pvp_lost = 0;
 		}
-		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
-	} else
-		// set flag, if it's a duel [LuzZza]
-		if(sd->duel_group)
-			clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+	} else
+	// set flag, if it's a duel [LuzZza]
+	if(sd->duel_group || sd->state.pvpmode)
+		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+
+	if (map[sd->bl.m].flag.gvg_dungeon)
+		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE); //TODO: Figure out the real packet to send here.
+
+	if( map_flag_gvg(sd->bl.m) || (battle_config.bg_eAmod_mode && map[sd->bl.m].flag.battleground) )
+		clif_map_property(sd, MAPPROPERTY_AGITZONE);
+	else if( battle_config.guild_wars && sd->status.guild_id )
+	{ // At War!!
+		struct guild *g = guild_search( sd->status.guild_id );
+		if( g && g->war && !map_flag_noguildwar(sd->bl.m) )
+			clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+	}
+
+
+	// info about nearby objects
+	// must use foreachinarea (CIRCULAR_AREA interferes with foreachinrange)
+	map_foreachinarea(clif_getareachar, sd->bl.m, sd->bl.x-AREA_SIZE, sd->bl.y-AREA_SIZE, sd->bl.x+AREA_SIZE, sd->bl.y+AREA_SIZE, BL_ALL, sd);
 
-	if(map[sd->bl.m].flag.gvg_dungeon)
-		clif_map_property(sd, MAPPROPERTY_FREEPVPZONE); //TODO: Figure out the real packet to send here.
-
-	if(map_flag_gvg(sd->bl.m))
-		clif_map_property(sd, MAPPROPERTY_AGITZONE);
-
-	// info about nearby objects
-	// must use foreachinarea (CIRCULAR_AREA interferes with foreachinrange)
-	map_foreachinarea(clif_getareachar, sd->bl.m, sd->bl.x-AREA_SIZE, sd->bl.y-AREA_SIZE, sd->bl.x+AREA_SIZE, sd->bl.y+AREA_SIZE, BL_ALL, sd);
-
 	// pet
 	if(sd->pd) {
 		if(!battle_config.supports_castle_gvg && map_flag_gvg(sd->bl.m)) {   //Return the pet to egg. [Skotlex]
@@ -9120,16 +9766,21 @@
 		if(!battle_config.supports_castle_gvg && map_flag_gvg(sd->bl.m)) {
 			clif_hominfo(sd, sd->hd, 0);
 		} else {
-			map_addblock(&sd->hd->bl);
-			clif_spawn(&sd->hd->bl);
-			clif_send_homdata(sd,SP_ACK,0);
-			clif_hominfo(sd,sd->hd,1);
-			clif_hominfo(sd,sd->hd,0); //for some reason, at least older clients want this sent twice
-			clif_homskillinfoblock(sd);
-			if(battle_config.hom_setting&0x8)
-				status_calc_bl(&sd->hd->bl, SCB_SPEED); //Homunc mimic their master's speed on each map change
-			if(!(battle_config.hom_setting&0x2))
-				skill_unit_move(&sd->hd->bl,gettick(),1); // apply land skills immediately
+			if( map[sd->bl.m].flag.ancient )
+				merc_hom_vaporize(sd, 0);
+			else
+			{
+				map_addblock(&sd->hd->bl);
+				clif_spawn(&sd->hd->bl);
+				clif_send_homdata(sd,SP_ACK,0);
+				clif_hominfo(sd,sd->hd,1);
+				clif_hominfo(sd,sd->hd,0); //for some reason, at least older clients want this sent twice
+				clif_homskillinfoblock(sd);
+				if( battle_config.hom_setting&0x8 )
+					status_calc_bl(&sd->hd->bl, SCB_SPEED); //Homunc mimic their master's speed on each map change
+				if( !(battle_config.hom_setting&0x2) )
+					skill_unit_move(&sd->hd->bl,gettick(),1); // apply land skills immediately
+			}
 		}
 	}
 
@@ -9246,11 +9897,13 @@
 			clif_status_load(&sd->bl, SI_NIGHT, 0);
 		}
 
-		if(map[sd->bl.m].flag.battleground) {
+		if( !battle_config.bg_eAmod_mode && map[sd->bl.m].flag.battleground ) {
 			clif_map_type(sd, MAPTYPE_BATTLEFIELD); // Battleground Mode
-			if(map[sd->bl.m].flag.battleground == 2)
+			if( map[sd->bl.m].flag.battleground >= 2 )
 				clif_bg_updatescore_single(sd);
 		}
+		
+		if( map[sd->bl.m].flag.fvf ) clif_map_type(sd, MAPTYPE_BATTLEFIELD); // Faction simulates official BG packets
 
 		if(map[sd->bl.m].flag.allowks && !map_flag_ks(sd->bl.m)) {
 			char output[128];
@@ -9282,7 +9935,44 @@
 
 		map_iwall_get(sd); // Updates Walls Info on this Map to Client
 		//status_calc_pc(sd, false);/* some conditions are map-dependent so we must recalculate */
-		sd->state.changemap = false;
+		achievement_validate_explore(sd,sd->bl.m);
+ 		sd->state.changemap = false;
+		
+		pc_setregstr(sd, add_str("@maploaded$"), map[sd->bl.m].name);
+		npc_script_event(sd, NPCE_LOADMAP);
+	}
+	
+	if( sd->state.changeregion )
+	{
+		if( rd && battle_config.region_display )
+		{
+			struct guild *g = guild_search(rd->guild_id);
+			char output[256];
+ 
+			snprintf(output,sizeof(output),"[ %s ]",rd->name);
+			clif_broadcast2(&sd->bl,output,strlen(output) + 1,0x00CCFF,0x190,20,0,0,SELF);
+
+			if( g != NULL )
+			{
+				if( sd->status.guild_id && sd->status.guild_id == g->guild_id )
+				{
+					snprintf(output,sizeof(output),"Guild Territory [ + %d%% Exp | + %d%% Job | + %d%% Drop ]",rd->bonus_bexp,rd->bonus_jexp,rd->bonus_drop);
+					clif_disp_onlyself(sd,output,strlen(output));
+				}
+				else if( sd->status.guild_id && guild_isenemy(sd->status.guild_id, g->guild_id) )
+				{
+					snprintf(output,sizeof(output),"Alert!! Entering the Enemy Guild [ %s ] Territory.",g->name);
+					clif_disp_onlyself(sd,output,strlen(output));
+				}
+				else
+				{
+					snprintf(output,sizeof(output),"Entering Neutral Territory of [ %s ].",g->name);
+					clif_disp_onlyself(sd,output,strlen(output));
+				}
+			}
+		}
+
+		sd->state.changeregion = false;
 	}
 
 	mail_clear(sd);
@@ -9297,15 +9987,12 @@
 
 	if(sd->state.vending) {   /* show we have a vending */
 		clif_openvending(sd,sd->bl.id,sd->vending);
-		clif_showvendingboard(&sd->bl,sd->message,0);
-	}
-
-	if(map[sd->bl.m].flag.loadevent) // Lance
-		npc_script_event(sd, NPCE_LOADMAP);
-
-	if(pc_checkskill(sd, SG_DEVIL) && !pc_nextjobexp(sd))
-		clif_status_load(&sd->bl, SI_DEVIL, 1);  //blindness [Komurka]
-
+		clif_showvendingboard(&sd->bl,sd->message,0);
+	}
+
+	if (pc_checkskill(sd, SG_DEVIL) && !pc_nextjobexp(sd))
+		clif_status_load(&sd->bl, SI_DEVIL, 1);  //blindness [Komurka]
+
 	if(sd->sc.opt2)  //Client loses these on warp.
 		clif_changeoption(&sd->bl);
 
@@ -9321,16 +10008,14 @@
 	if(!sd->status.hp && !pc_isdead(sd) && status_isdead(&sd->bl))
 		pc_setdead(sd);
 
-	// If player is dead, and is spawned (such as @refresh) send death packet. [Valaris]
-	if(pc_isdead(sd))
-		clif_clearunit_area(&sd->bl, CLR_DEAD);
-	else {
-		skill_usave_trigger(sd);
-		clif_changed_dir(&sd->bl, SELF);
-	}
-
-// Trigger skill effects if you appear standing on them
-	if(!battle_config.pc_invincible_time)
+	// If player is dead, and is spawned (such as @refresh) send death packet. [Valaris]
+	if(pc_isdead(sd))
+		clif_clearunit_area(&sd->bl, CLR_DEAD);
+	else
+		clif_changed_dir(&sd->bl, SELF);
+
+// Trigger skill effects if you appear standing on them
+	if(!battle_config.pc_invincible_time)
 		skill_unit_move(&sd->bl,gettick(),1);
 }
 
@@ -9466,20 +10151,20 @@
 	else if(pc_cant_act(sd))
 		return;
 
-	if(sd->sc.data[SC_RUN] || sd->sc.data[SC_WUGDASH])
-		return;
+	if(sd->sc.data[SC_RUN] || sd->sc.data[SC_WUGDASH])
+		return;
+
+	if( !pc_update_last_action(sd,2) )
+		return;
+
+	pc_delinvincibletimer(sd);
+
+	RFIFOPOS(fd, packet_db[sd->packet_ver][RFIFOW(fd,0)].pos[0], &x, &y, NULL);
+
+	unit_walktoxy(&sd->bl, x, y, 4);
+}
+
 
-	pc_delinvincibletimer(sd);
-
-	RFIFOPOS(fd, packet_db[sd->packet_ver][RFIFOW(fd,0)].pos[0], &x, &y, NULL);
-
-	//Set last idle time... [Skotlex]
-	sd->idletime = last_tick;
-
-	unit_walktoxy(&sd->bl, x, y, 4);
-}
-
-
 /// Notification about the result of a disconnect request (ZC_ACK_REQ_DISCONNECT).
 /// 018b <result>.W
 /// result:
@@ -9547,30 +10232,29 @@
 	    // information is sent to all online GMs
 	    intif_wis_message_to_gm(wisp_server_name, battle_config.hack_info_GM_level, gm_msg);
 	    return;
-	}
-	*/
-
-	clif_charnameack(fd, bl);
-}
-
-
+	}
+	*/
+
+	clif_charnameack(sd, bl);
+}
+
+
 /// Validates and processes global messages
 /// 008c <packet len>.W <text>.?B (<name> : <message>) 00 (CZ_REQUEST_CHAT)
 /// There are various variants of this packet.
 void clif_parse_GlobalMessage(int fd, struct map_session_data *sd)
-{
-	const char *text = (char *)RFIFOP(fd,4);
-	int textlen = RFIFOW(fd,2) - 4;
+{
+	const char* text = (char*)RFIFOP(fd,4);
+	int textlen = RFIFOW(fd,2) - 4;
+	int tick = gettick();
+
+	char *name, *message;
+	int namelen, messagelen;
+
+	// validate packet and retrieve name and message
+	if( !clif_process_message(sd, 0, &name, &namelen, &message, &messagelen) )
+		return;
 
-	char *name, *message, *fakename = NULL;
-	int namelen, messagelen;
-
-	bool is_fake;
-
-	// validate packet and retrieve name and message
-	if(!clif_process_message(sd, 0, &name, &namelen, &message, &messagelen))
-		return;
-
 	if(is_atcommand(fd, sd, message, 1))
 		return;
 
@@ -9579,40 +10263,129 @@
 
 	if(battle_config.min_chat_delay) {
 		//[Skotlex]
-		if(DIFF_TICK(sd->cantalk_tick, gettick()) > 0)
+		if (DIFF_TICK(sd->cantalk_tick, tick) > 0)
 			return;
-		sd->cantalk_tick = gettick() + battle_config.min_chat_delay;
+		sd->cantalk_tick = tick + battle_config.min_chat_delay;
 	}
-	/**
-	 * Fake Name Design by FatalEror (bug report #9)
-	 **/
-	if((is_fake = (sd->fakename[0]))) {
-		fakename = (char *) aMalloc(strlen(sd->fakename)+messagelen+3);
-		strcpy(fakename, sd->fakename);
-		strcat(fakename, " : ");
-		strcat(fakename, message);
-		textlen = strlen(fakename) + 1;
+	// [Flood Protection - Automute]
+	if( battle_config.chat_allowed_per_interval && battle_config.chat_time_interval )
+	{
+		if( sd->last_talk_message == 0 )
+			 sd->last_talk_message = tick;
+		if( DIFF_TICK(tick, sd->last_talk_message) < 0 && sd->message_count >= battle_config.chat_allowed_per_interval )
+		{ // Deny
+			if( battle_config.chat_flood_automute )
+			{
+				sd->status.manner -= battle_config.chat_flood_automute;
+				sc_start(NULL, &sd->bl,SC_NOCHAT,100,0,0); // Mute Player
+			}
+			return;
+		}
+		
+		if( DIFF_TICK(tick, sd->last_talk_message) > 0 )
+		{
+			sd->message_count = 0;
+			sd->last_talk_message = tick + battle_config.chat_time_interval * 1000;
+		}
+		sd->message_count++;
 	}
-	// send message to others (using the send buffer for temp. storage)
+	
 	WFIFOHEAD(fd, 8 + textlen);
 	WFIFOW(fd,0) = 0x8d;
 	WFIFOW(fd,2) = 8 + textlen;
 	WFIFOL(fd,4) = sd->bl.id;
-	safestrncpy((char *)WFIFOP(fd,8), is_fake ? fakename : text, textlen);
-	//FIXME: chat has range of 9 only
-	clif_send(WFIFOP(fd,0), WFIFOW(fd,2), &sd->bl, sd->chatID ? CHAT_WOS : AREA_CHAT_WOC);
+	safestrncpy((char*)WFIFOP(fd,8), text, textlen);
 
-	// send back message to the speaker
-	if(is_fake) {
-		WFIFOW(fd,0) = 0x8e;
-		WFIFOW(fd,2) = textlen + 4;
-		safestrncpy((char *)WFIFOP(fd,4), fakename, textlen);
-		aFree(fakename);
-	} else {
-		memcpy(WFIFOP(fd,0), RFIFOP(fd,0), RFIFOW(fd,2));
-		WFIFOW(fd,0) = 0x8e;
+	//////////////////////////////////////////////////////////////
+	// Language + Faction System
+	//////////////////////////////////////////////////////////////
+	{
+		struct faction_data* faction;
+		struct lang_data* ld = NULL;
+		uint8 buf[256];
+		int gm_level;
+
+		char other_lang_mes[CHAT_SIZE_MAX], same_lang_mes[CHAT_SIZE_MAX];
+		int other_lang_len = 0, same_lang_len = 0;
+
+		memset(other_lang_mes,0,sizeof(other_lang_mes));
+		memset(same_lang_mes,0,sizeof(same_lang_mes));
+		gm_level = cap_value(pc_get_group_id(sd),0,99);
+
+		if( sd->lang_id && (ld = lang_search(sd->lang_id)) != NULL )
+		{ // Convert to Spoken Language
+			char tmp[CHAT_SIZE_MAX];
+			lang_convert(tmp,message,sizeof(tmp),sd->lang_id);
+
+			snprintf(other_lang_mes,sizeof(other_lang_mes),"%s : (%s) %s",sd->status.name,ld->name,tmp);
+			other_lang_len = strlen(other_lang_mes) + 1;
+
+			snprintf(same_lang_mes,sizeof(same_lang_mes),"%s : (%s) %s",sd->status.name,ld->name,message);
+			same_lang_len = strlen(same_lang_mes) + 1;
+		}
+
+		if( !sd->chatID && sd->status.faction_id && (faction = faction_search(sd->status.faction_id)) != NULL )
+		{ // Colored Message by Faction
+			WBUFW(buf,0) = 0x2c1;
+			WBUFW(buf,2) = ( ld ? same_lang_len : textlen ) + 12;
+			WBUFL(buf,4) = sd->bl.id;
+			WBUFL(buf,8) = faction->font_color;
+			safestrncpy((char*)WBUFP(buf,12),( ld ? same_lang_mes : text ),( ld ? same_lang_len : textlen ));
+
+			if( !ld )
+				clif_send(buf,WBUFW(buf,2),&sd->bl,OTHER_FACTION_AREA_CHAT_WOC);
+			else
+			{
+				clif_send(buf,WBUFW(buf,2),&sd->bl,OTHER_FACTION_LANG_AREA_CHAT_WOC); // Others Factions but Same Lang
+				WBUFW(buf,2) = other_lang_len + 12;
+				safestrncpy((char*)WBUFP(buf,12),other_lang_mes,other_lang_len);
+				clif_send(buf,WBUFW(buf,2),&sd->bl,OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC); // Others Factions with other Lang
+			}
+
+			if( !ld || ld->lang_id == faction->lang_id )
+				clif_send(WFIFOP(fd,0),WFIFOW(fd,2),&sd->bl,FACTION_AREA_CHAT_WOC); // Same Faction read you normally
+			else
+			{
+				clif_send(WFIFOP(fd,0),WFIFOW(fd,2),&sd->bl,FACTION_LANG_AREA_CHAT_WOC); // Same Faction Same Lang
+				WBUFW(buf,0) = 0x8d;
+				WBUFW(buf,2) = other_lang_len + 8;
+				safestrncpy((char*)WBUFP(buf,8),other_lang_mes,other_lang_len);
+				clif_send(buf,WBUFW(buf,2),&sd->bl,FACTION_OTHER_LANG_AREA_CHAT_WOC); // Same Faction Different Lang
+			}
+		}
+		else
+		{
+			if( !ld )
+			{
+				if( sd->chatID || gm_color[gm_level] == -1 )
+					clif_send(WFIFOP(fd,0),WFIFOW(fd,2),&sd->bl,( sd->chatID ? CHAT_WOS : AREA_CHAT_WOC )); // This is the Base Normal Send
+				else
+				{ // Colored Message by gm_color_db.txt
+					WBUFW(buf,0) = 0x2c1;
+					WBUFW(buf,2) = textlen + 12;
+					WBUFL(buf,4) = sd->bl.id;
+					WBUFL(buf,8) = gm_color[gm_level];
+					safestrncpy((char*)WBUFP(buf,12),text,textlen);
+					clif_send(buf,WBUFW(buf,2),&sd->bl,AREA_CHAT_WOC);
+				}
+			}
+			else
+			{
+				WBUFW(buf,0) = 0x8d;
+				WBUFW(buf,2) = other_lang_len + 8;
+				WBUFL(buf,4) = sd->bl.id;
+				safestrncpy((char*)WBUFP(buf,8),other_lang_mes,other_lang_len);
+				
+				clif_send(buf,WBUFW(buf,2),&sd->bl,( sd->chatID ? OTHER_LANG_CHAT_WOS : OTHER_LANG_AREA_CHAT_WOC ));
+				clif_send(WFIFOP(fd,0),WFIFOW(fd,2),&sd->bl,( sd->chatID ? LANG_CHAT_WOS : LANG_AREA_CHAT_WOC ));
+			}
+		}
 	}
-	WFIFOSET(fd, WFIFOW(fd,2));
+	//////////////////////////////////////////////////////////////
+
+	memcpy(WFIFOP(fd,0),RFIFOP(fd,0),RFIFOW(fd,2));
+	WFIFOW(fd,0) = 0x8e;
+	WFIFOSET(fd,WFIFOW(fd,2));
 #ifdef PCRE_SUPPORT
 	// trigger listening npcs
 	map_foreachinrange(npc_chat_sub, &sd->bl, AREA_SIZE, BL_NPC, text, textlen, &sd->bl);
@@ -9784,55 +10557,61 @@
 				if(DIFF_TICK(tick, sd->ud.canact_tick) < 0) {
 					clif_skill_fail(sd, 1, USESKILL_FAIL_SKILLINTERVAL, 0);
 					return;
-				}
-			}
-
-			pc_delinvincibletimer(sd);
-			sd->idletime = last_tick;
-			unit_attack(&sd->bl, target_id, action_type != 0);
-			break;
-		case 0x02: // sitdown
+			}
+		}
+
+		if( !pc_update_last_action(sd,2) )
+			return;
+
+		pc_delinvincibletimer(sd);
+		unit_attack(&sd->bl, target_id, action_type != 0);
+	break;
+	case 0x02: // sitdown
 			if(battle_config.basic_skill_check && pc_checkskill(sd, NV_BASIC) < 3) {
 				clif_skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 2);
 				break;
 			}
-
-			if(pc_issit(sd)) {
-				//Bugged client? Just refresh them.
-				clif_sitting(&sd->bl);
-				return;
-			}
-
+
+		if(pc_issit(sd)) {
+			//Bugged client? Just refresh them.
+			clif_sitting(&sd->bl,false);
+			return;
+		}
+
 			if(sd->ud.skilltimer != INVALID_TIMER || (sd->sc.opt1 && sd->sc.opt1 != OPT1_BURNING))
 				break;
 
 			if(sd->sc.count && (
 			       sd->sc.data[SC_DANCING] ||
 			       (sd->sc.data[SC_GRAVITATION] && sd->sc.data[SC_GRAVITATION]->val3 == BCT_SELF)
-			   )) //No sitting during these states either.
-				break;
+		)) //No sitting during these states either.
+			break;
+
+		if( !pc_update_last_action(sd,1) )
+			break;
+
+		pc_setsit(sd);
+		skill_sit(sd,1);
+		clif_sitting(&sd->bl,true);
+	break;
+	case 0x03: // standup
+		if (!pc_issit(sd)) {
+			//Bugged client? Just refresh them.
+			clif_standing(&sd->bl,false);
+			return;
+		}
+
+		if( !pc_update_last_action(sd,1) )
+			break;
+
+		pc_setstand(sd);
+		skill_sit(sd,0);
+		clif_standing(&sd->bl,true);
+	break;
+	}
+}
 
-			sd->idletime = last_tick;
-			pc_setsit(sd);
-			skill_sit(sd,1);
-			clif_sitting(&sd->bl);
-			break;
-		case 0x03: // standup
-			if(!pc_issit(sd)) {
-				//Bugged client? Just refresh them.
-				clif_standing(&sd->bl);
-				return;
-			}
 
-			sd->idletime = last_tick;
-			pc_setstand(sd);
-			skill_sit(sd,0);
-			clif_standing(&sd->bl);
-			break;
-	}
-}
-
-
 /// Request for an action.
 /// 0089 <target id>.L <action>.B (CZ_REQUEST_ACT)
 /// 0437 <target id>.L <action>.B (CZ_REQUEST_ACT2)
@@ -9881,12 +10660,13 @@
 
 /// Validates and processes whispered messages (CZ_WHISPER).
 /// 0096 <packet len>.W <nick>.24B <message>.?B
-void clif_parse_WisMessage(int fd, struct map_session_data *sd)
-{
-	struct map_session_data *dstsd;
-	int i;
-
-	char *target, *message;
+void clif_parse_WisMessage(int fd, struct map_session_data* sd)
+{
+	struct map_session_data* dstsd;
+	char chatroom_symbol = '#';
+	int i;
+
+	char *target, *message;
 	int namelen, messagelen;
 
 	// validate packet and retrieve name and message
@@ -9947,20 +10727,24 @@
 
 			sprintf(output, "%s::OnWhisperGlobal", npc->exname);
 			npc_event(sd,output,0); // Calls the NPC label
-
-			return;
-		}
-	} else if(strcmpi(target, main_chat_nick) == 0) { // Main chat [LuzZza]
-		if(!sd->state.mainchat)
-			clif_displaymessage(fd, msg_txt(388)); // You should enable main chat with "@main on" command.
-		else {
-			// send the main message using inter-server system
-			intif_main_message(sd, message);
-		}
-
-		return;
-	}
-
+
+			return;
+		}
+	}
+
+	// Chat Channels [Zephyrus]
+	if( battle_config.channel_system_enable && target[0] == chatroom_symbol )
+	{
+		if( battle_config.channel_min_chat_delay && DIFF_TICK(sd->channel_cantalk_tick, gettick()) > 0 )
+			clif_displaymessage(sd->fd, msg_txt(876));
+		else
+		{
+			channel_message(sd, target, message);
+			sd->channel_cantalk_tick = gettick() + battle_config.channel_min_chat_delay;
+		}
+		return;
+	}
+
 	// searching destination character
 	dstsd = map_nick2sd(target);
 
@@ -9971,12 +10755,18 @@
 		// and if we ask for 'Test', we must not contact 'test' player
 		// so, we send information to inter-server, which is the only one which decide (and copy correct name).
 		intif_wis_message(sd, target, message, messagelen);
-		return;
-	}
-
-	// if player ignores everyone
-	if(dstsd->state.ignoreAll) {
-		if(dstsd->sc.option & OPTION_INVISIBLE && pc_get_group_level(sd) < pc_get_group_level(dstsd))
+		return;
+	}
+
+	if( !battle_config.faction_allow_chat && dstsd->status.faction_id != sd->status.faction_id )
+	{
+		clif_displaymessage(fd,"You cannot talk with other faction members.");
+		return;
+	}
+
+	// if player ignores everyone
+	if (dstsd->state.ignoreAll) {
+		if (dstsd->sc.option & OPTION_INVISIBLE && pc_get_group_level(sd) < pc_get_group_level(dstsd))
 			clif_wis_end(fd, 1); // 1: target character is not loged in
 		else
 			clif_wis_end(fd, 3); // 3: everyone ignored by target
@@ -10081,12 +10871,15 @@
 		       sd->sc.data[SC_AUTOCOUNTER] ||
 		       sd->sc.data[SC_BLADESTOP] ||
 		       (sd->sc.data[SC_NOCHAT] && sd->sc.data[SC_NOCHAT]->val1&MANNER_NOITEM)
-		   ))
-			break;
-
-		if(!pc_dropitem(sd, item_index, item_amount))
-			break;
-
+		))
+			break;
+
+		if (battle_config.super_woe_enable == 2 )
+			break; // Cannot drop items on super woe servers
+
+		if (!pc_dropitem(sd, item_index, item_amount))
+			break;
+
 		return;
 	}
 
@@ -10109,14 +10902,16 @@
 	}
 
 	if ((!sd->npc_id && pc_istrading(sd)) || sd->chatID)
+		return;
+
+	//Whether the item is used or not is irrelevant, the char ain't idle. [Skotlex]
+	if( !pc_update_last_action(sd,1) )
+		return;
+
+	n = RFIFOW(fd,packet_db[sd->packet_ver][RFIFOW(fd,0)].pos[0])-2;
+
+	if(n <0 || n >= MAX_INVENTORY)
 		return;
-
-	//Whether the item is used or not is irrelevant, the char ain't idle. [Skotlex]
-	sd->idletime = last_tick;
-	n = RFIFOW(fd,packet_db[sd->packet_ver][RFIFOW(fd,0)].pos[0])-2;
-
-	if(n <0 || n >= MAX_INVENTORY)
-		return;
 	if(!pc_useitem(sd,n))
 		clif_useitemack(sd,n,0,false); //Send an empty ack packet or the client gets stuck.
 }
@@ -10256,12 +11051,17 @@
 	int n = (RFIFOW(fd,2)-4) /4;
 	unsigned short *item_list = (unsigned short *)RFIFOP(fd,4);
 	int result;
-
-	if(sd->state.trading || !sd->npc_shopid)
-		result = 1;
-	else
-		result = npc_buylist(sd,n,item_list);
-
+
+	if( sd->state.trading || !sd->npc_shopid )
+		result = 1;
+	else if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't buy. Blocked with @security");
+		result = 1;
+	}
+	else
+		result = npc_buylist(sd,n,item_list);
+
 	sd->npc_shopid = 0; //Clear shop data.
 
 	clif_npc_buy_result(sd, result);
@@ -10291,12 +11091,17 @@
 
 	n = (RFIFOW(fd,2)-4) /4;
 	item_list = (unsigned short *)RFIFOP(fd,4);
-
-	if(sd->state.trading || !sd->npc_shopid)
-		fail = 1;
-	else
-		fail = npc_selllist(sd,n,item_list);
-
+
+	if (sd->state.trading || !sd->npc_shopid)
+		fail = 1;
+	else if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't sell. Blocked with @security");
+		fail = 1;
+	}
+	else
+		fail = npc_selllist(sd,n,item_list);
+
 	sd->npc_shopid = 0; //Clear shop data.
 
 	clif_npc_sell_result(sd, fail);
@@ -10441,13 +11246,19 @@
 
 	if(battle_config.basic_skill_check && pc_checkskill(sd,NV_BASIC) < 1) {
 		clif_skill_fail(sd,1,USESKILL_FAIL_LEVEL,0);
-		return;
-	}
+		return;
+	}
+
+	if( ( battle_config.super_woe_enable == 2 || ( battle_config.super_woe_enable == 1 && t_sd && t_sd->status.guild_id != sd->status.guild_id ) ) )
+	{
+		clif_displaymessage(fd, "- Event Server * Cannot Trade items to other guild members -");
+		return;
+	}
+	
+	trade_traderequest(sd,t_sd);
+}
+
 
-	trade_traderequest(sd,t_sd);
-}
-
-
 /// Answer to a trade request (CZ_ACK_EXCHANGE_ITEM).
 /// 00e6 <result>.B
 /// result:
@@ -10511,22 +11322,24 @@
 {
 	if(pc_istrading(sd))
 		return;
-	if(!pc_iscarton(sd))
-		return;
-	pc_putitemtocart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4));
-}
-
-
+	if (!pc_iscarton(sd))
+		return;
+	pc_putitemtocart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4));
+	pc_update_last_action(sd,0);
+}
+
+
 /// Request to move an item from cart to inventory (CZ_MOVE_ITEM_FROM_CART_TO_BODY).
 /// 0127 <index>.W <amount>.L
 void clif_parse_GetItemFromCart(int fd,struct map_session_data *sd)
 {
-	if(!pc_iscarton(sd))
-		return;
-	pc_getitemfromcart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4));
-}
-
-
+	if (!pc_iscarton(sd))
+		return;
+	pc_getitemfromcart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4));
+	pc_update_last_action(sd,0);
+}
+
+
 /// Request to remove cart/falcon/peco/dragon (CZ_REQ_CARTOFF).
 /// 012a
 void clif_parse_RemoveOption(int fd,struct map_session_data *sd)
@@ -10719,7 +11532,11 @@
 		return;
 
 	// Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
-	sd->idletime = last_tick;
+	sd->idletime = last_tick;
+	
+	// Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
+	if( !pc_update_last_action(sd,1 + (tmp&INF_SELF_SKILL ? 0 : 2)) )
+		return;
 
 	if(sd->npc_id){
 #ifdef RENEWAL
@@ -10770,18 +11587,52 @@
 		unit_skilluse_id(&sd->bl, target_id, skill_id, skill_lv);
 		return;
 	}
-
-	sd->skillitem = sd->skillitemlv = 0;
-
-	if(skill_id >= GD_SKILLBASE) {
-		if(sd->state.gmaster_flag)
-			skill_lv = guild_checkskill(sd->state.gmaster_flag, skill_id);
-		else
-			skill_lv = 0;
-	} else {
-		tmp = pc_checkskill(sd, skill_id);
-		if(skill_lv > tmp)
-			skill_lv = tmp;
+
+	sd->skillitem = sd->skillitemlv = 0;
+
+	if( skill_id >= GD_SKILLBASE )
+	{
+		int idx = battle_config.guild_skills_separed_delay ? skill_id - GD_SKILLBASE : 0;
+		if( idx < 0 || idx >= MAX_GUILDSKILL )
+			skill_lv = 0;
+		else if( !map[sd->bl.m].flag.battleground )
+		{
+			struct guild *g;
+			if( (g = sd->state.gmaster_flag) != NULL )
+			{
+				if( g->skill_block_timer[idx] == INVALID_TIMER )
+					skill_lv = guild_checkskill(g, skill_id);
+				else
+				{
+					guild_block_skill_status(g, skill_id);
+					skill_lv = 0;
+				}
+			}
+			else
+				skill_lv = 0;
+		}
+		else
+		{
+			struct battleground_data *bg;
+			if( (bg = sd->bmaster_flag) != NULL )
+			{
+				if( bg->skill_block_timer[idx] == INVALID_TIMER )
+					skill_lv = bg_checkskill(bg, skill_id);
+				else
+				{
+					bg_block_skill_status(bg, skill_id);
+					skill_lv = 0;
+				}
+			}
+			else
+				skill_lv = 0;
+		}
+	}
+	else
+	{
+		tmp = pc_checkskill(sd, skill_id);
+		if( skill_lv > tmp )
+			skill_lv = tmp;
 	}
 
 	pc_delinvincibletimer(sd);
@@ -10808,13 +11659,14 @@
 	if(skill_id >= MC_SKILLBASE && skill_id < MC_SKILLBASE + MAX_MERCSKILL) {
 		clif_parse_UseSkillToPos_mercenary(sd->md, sd, tick, skill_id, skill_lv, x, y, skillmoreinfo);
 		return;
-	}
-
-	//Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
-	sd->idletime = last_tick;
-
-	if(skillnotok(skill_id, sd))
-		return;
+	}
+
+	//Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
+	if( !pc_update_last_action(sd,3) )
+		return;
+
+	if( skillnotok(skill_id, sd) )
+		return;
 	if(skillmoreinfo != -1) {
 		if(pc_issit(sd)) {
 			clif_skill_fail(sd, skill_id, USESKILL_FAIL_LEVEL, 0);
@@ -11013,14 +11865,14 @@
 void clif_parse_WeaponRefine(int fd, struct map_session_data *sd)
 {
 	int idx;
-
-	if(sd->menuskill_id != WS_WEAPONREFINE)  //Packet exploit?
+
+	if (sd->menuskill_id != WS_WEAPONREFINE) //Packet exploit?
+		return;
+	if (pc_istrading(sd) || battle_config.super_woe_enable) {
+		//Make it fail to avoid shop exploits where you sell something different than you see.
+		clif_skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
+		clif_menuskill_clear(sd);
 		return;
-	if(pc_istrading(sd)) {
-		//Make it fail to avoid shop exploits where you sell something different than you see.
-		clif_skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
-		clif_menuskill_clear(sd);
-		return;
 	}
 	idx = RFIFOL(fd,packet_db[sd->packet_ver][RFIFOW(fd,0)].pos[0]);
 	skill_weaponrefine(sd, idx-2);
@@ -11146,12 +11998,15 @@
 		case GC_POISONINGWEAPON:
 			skill_poisoningweapon(sd,RFIFOW(fd,2));
 			break;
-		case NC_MAGICDECOY:
-			skill_magicdecoy(sd,RFIFOW(fd,2));
-			break;
-	}
-
-	clif_menuskill_clear(sd);
+		case NC_MAGICDECOY:
+			skill_magicdecoy(sd,RFIFOW(fd,2));
+			break;
+		case MC_VENDING: // Extended Vending System
+			skill_vending(sd,RFIFOW(fd,2));
+			break;
+	}
+
+	clif_menuskill_clear(sd);
 }
 
 
@@ -11254,8 +12109,13 @@
 	if(sd->state.storage_flag == 1)
 		storage_storageadd(sd, item_index, item_amount);
 	else if(sd->state.storage_flag == 2)
-		storage_guild_storageadd(sd, item_index, item_amount);
-}
+		storage_guild_storageadd(sd, item_index, item_amount);
+	else
+	if (sd->state.storage_flag == 3)
+		ext_storage_add(sd, item_index, item_amount);
+	else return;
+	pc_update_last_action(sd,0);
+}
 
 
 /// Request to move an item from storage to inventory.
@@ -11272,8 +12132,13 @@
 	if(sd->state.storage_flag == 1)
 		storage_storageget(sd, item_index, item_amount);
 	else if(sd->state.storage_flag == 2)
-		storage_guild_storageget(sd, item_index, item_amount);
-}
+		storage_guild_storageget(sd, item_index, item_amount);
+	else
+	if (sd->state.storage_flag == 3)
+		ext_storage_get(sd, item_index, item_amount);
+	else return;
+	pc_update_last_action(sd,0);
+}
 
 
 /// Request to move an item from cart to storage (CZ_MOVE_ITEM_FROM_CART_TO_STORE).
@@ -11288,8 +12153,13 @@
 	if(sd->state.storage_flag == 1)
 		storage_storageaddfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
 	else if(sd->state.storage_flag == 2)
-		storage_guild_storageaddfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
-}
+		storage_guild_storageaddfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
+	else
+	if(sd->state.storage_flag == 3)
+		ext_storage_addfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
+	else return;
+	pc_update_last_action(sd,0);
+}
 
 
 /// Request to move an item from storage to cart (CZ_MOVE_ITEM_FROM_STORE_TO_CART).
@@ -11304,18 +12174,25 @@
 	if(sd->state.storage_flag == 1)
 		storage_storagegettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
 	else if(sd->state.storage_flag == 2)
-		storage_guild_storagegettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
-}
+		storage_guild_storagegettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
+	else
+	if (sd->state.storage_flag == 3)
+		ext_storage_gettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
+	else return;
+	pc_update_last_action(sd,0);
+}
 
 
 /// Request to close storage (CZ_CLOSE_STORE).
 /// 00f7
 void clif_parse_CloseKafra(int fd, struct map_session_data *sd)
 {
-	if(sd->state.storage_flag == 1)
+	if( sd->state.storage_flag == 1 || sd->state.storage_flag == 3 )
 		storage_storageclose(sd);
 	else if(sd->state.storage_flag == 2)
 		storage_guild_storageclose(sd);
+	else return;
+	pc_update_last_action(sd,0);
 }
 
 
@@ -11806,34 +12683,87 @@
 /// result:
 ///     0 = canceled
 ///     1 = open
-void clif_parse_OpenVending(int fd, struct map_session_data *sd)
+void clif_parse_OpenVending(int fd, struct map_session_data* sd)
 {
 	short len = (short)RFIFOW(fd,2) - 85;
-	const char *message = (char *)RFIFOP(fd,4);
+	const char* message = (char*)RFIFOP(fd,4);
 	bool flag = (bool)RFIFOB(fd,84);
-	const uint8 *data = (uint8 *)RFIFOP(fd,85);
+	const uint8* data = (uint8*)RFIFOP(fd,85);
+	char out_msg[MESSAGE_SIZE];
 
-	if(!flag)
+	if( !flag )
 		sd->state.prevend = 0;
 
-	if(sd->sc.data[SC_NOCHAT] && sd->sc.data[SC_NOCHAT]->val1&MANNER_NOROOM)
+	if( sd->sc.data[SC_NOCHAT] && sd->sc.data[SC_NOCHAT]->val1&MANNER_NOROOM )
 		return;
-	if(map[sd->bl.m].flag.novending || pc_has_permission(sd,PC_PERM_CAN_SHOP)) {
-		clif_displaymessage(sd->fd, msg_txt(276));  // "You can't open a shop on this map"
+	if( map[sd->bl.m].flag.novending ) {
+		clif_displaymessage (sd->fd, msg_txt(276)); // "You can't open a shop on this map"
 		return;
 	}
-	if(map_getcell(sd->bl.m,sd->bl.x,sd->bl.y,CELL_CHKNOVENDING)) {
-		clif_displaymessage(sd->fd, msg_txt(1398));  // "You can't open a shop on this cell."
+	if( map[sd->bl.m].flag.vending_cell != map_getcell(sd->bl.m,sd->bl.x,sd->bl.y,CELL_CHKNOVENDING) ) {
+		clif_displaymessage (sd->fd, msg_txt(204)); // "You can't open a shop on this cell."
 		return;
 	}
+	if( battle_config.super_woe_enable )
+	{
+		clif_displaymessage (sd->fd, "Vending not available on Super WoE / GvG Events.");
+		return;
+	}
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't open vending. Blocked with @security");
+		return;
+	}
 
-	if(message[0] == '\0')   // invalid input
+	if( message[0] == '\0' ) // invalid input
 		return;
 
-	vending_openvending(sd, message, data, len/8);
+	if( battle_config.vending_zeny_id ) // Extended Vending System
+		snprintf(out_msg,MESSAGE_SIZE,"[%s] %s",itemdb_jname(sd->vend_coin),message);
+	else
+		safestrncpy(out_msg,message,MESSAGE_SIZE);
+
+	vending_openvending(sd, out_msg, data, len/8);
 }
+
+int clif_vend(struct map_session_data *sd, int skill_lv)
+{
+	int c, i;
+	int fd;
+
+	nullpo_ret(sd);
+	fd = sd->fd;
+	c = 0;
+
+	WFIFOHEAD(fd,MAX_COIN_DB*2+4);
+	WFIFOW(fd,0) = 0x1ad;
+
+	// Zeny Reserved ItemID
+	WFIFOW(fd,c*2+4) = battle_config.vending_zeny_id;
+	c++;
+
+	if( battle_config.vending_cash_id )
+	{
+		WFIFOW(fd,c*2+4) = battle_config.vending_cash_id;
+		c++;
+	}
+
+	i = 0;
+	while( i < MAX_COIN_DB && coins_db[i] > 0 )
+	{
+		WFIFOW(fd,c*2+4) = coins_db[i];
+		c++;
+		i++;
+	}
+
+	sd->menuskill_id = MC_VENDING;
+	sd->menuskill_val = skill_lv;
+	WFIFOW(fd,2) = c*2+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+
+	return 1;
+}
 
-
 /// Guild creation request (CZ_REQ_MAKE_GUILD).
 /// 0165 <char id>.L <guild name>.24B
 void clif_parse_CreateGuild(int fd,struct map_session_data *sd)
@@ -11933,16 +12863,21 @@
 
 /// Request for guild emblem data (CZ_REQ_GUILD_EMBLEM_IMG).
 /// 0151 <guild id>.L
-void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd)
-{
-	struct guild *g;
-	int guild_id = RFIFOL(fd,2);
-
-	if((g = guild_search(guild_id)) != NULL)
-		clif_guild_emblem(sd,g);
-}
-
-
+void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd)
+{
+	struct guild* g;
+	int guild_id = RFIFOL(fd,2), i;
+
+	if( (g = guild_search(guild_id)) != NULL )
+		clif_guild_emblem(sd,g);
+	else if( guild_id > INT16_MAX - 13 && guild_id <= INT16_MAX )
+	{
+		i = (int)(INT16_MAX - guild_id);
+		clif_bg_emblem(sd, &bg_guild[i]);
+	}
+}
+
+
 /// Validates data of a guild emblem (compressed bitmap)
 static bool clif_validate_emblem(const uint8 *emblem, unsigned long emblem_len)
 {
@@ -12043,6 +12978,17 @@
 		clif_displaymessage(fd, msg_txt(228));
 		return;
 	}
+	if( battle_config.super_woe_enable )
+	{
+		clif_displaymessage(fd, "You can't leave a Guild in Champions Arena.");
+		return;
+	}
+
+	if( !guild_canescape(sd) )
+	{	//Guild locked.
+		clif_displaymessage(fd, "You can't leave until 10 seconds of No War Actions.");
+		return;
+	}
 	if(sd->bg_id) {
 		clif_displaymessage(fd, msg_txt(670)); //"You can't leave battleground guilds."
 		return;
@@ -12058,13 +13004,20 @@
 {
 	if(map[sd->bl.m].flag.guildlock || sd->bg_id) {
 		// Guild locked.
-		clif_displaymessage(fd, msg_txt(228));
-		return;
-	}
-	guild_expulsion(sd,RFIFOL(fd,2),RFIFOL(fd,6),RFIFOL(fd,10),(char *)RFIFOP(fd,14));
-}
+		clif_displaymessage(fd, msg_txt(228));
+		return;
+	}
+
+	if( battle_config.super_woe_enable )
+	{
+		clif_displaymessage(fd, "You can't expel a member from your guild. Use Guild Control on your guild Flag.");
+		return;
+	}
+
+	guild_expulsion(sd,RFIFOL(fd,2),RFIFOL(fd,6),RFIFOL(fd,10),(char*)RFIFOP(fd,14));
+}
+
 
-
 /// Validates and processes guild messages (CZ_GUILD_CHAT).
 /// 017e <packet len>.W <text>.?B (<name> : <message>) 00
 void clif_parse_GuildMessage(int fd, struct map_session_data *sd)
@@ -12089,16 +13042,15 @@
 		//[Skotlex]
 		if(DIFF_TICK(sd->cantalk_tick, gettick()) > 0)
 			return;
-		sd->cantalk_tick = gettick() + battle_config.min_chat_delay;
-	}
-
-	// Reset idle time when using guild chat.
-	sd->idletime = last_tick;
-
-	if(sd->bg_id)
-		bg_send_message(sd, text, textlen);
-	else
-		guild_send_message(sd, text, textlen);
+		sd->cantalk_tick = gettick() + battle_config.min_chat_delay;
+	}
+
+	pc_update_last_action(sd,0);
+
+	if( battle_config.bg_eAmod_mode && sd->bg_id )
+		bg_send_message(sd, text, textlen);
+	else
+		guild_send_message(sd, text, textlen);
 }
 
 
@@ -13186,24 +14138,54 @@
 
 /// /pk list (ZC_KILLER_RANK).
 /// 0238 { <name>.24B }*10 { <point>.L }*10
-void clif_ranking_pk(struct map_session_data *sd)
+void clif_ranking_pk(struct map_session_data* sd)
+{
+	int i, fd = sd->fd;
+	const char* name;
+
+	WFIFOHEAD(fd,packet_len(0x238));
+	WFIFOW(fd,0) = 0x238;
+	for(i = 0;i < 10 && i < MAX_FAME_LIST; i++) {
+		if (pvprank_fame_list[i].id > 0) {
+			if (strcmp(pvprank_fame_list[i].name, "-") == 0 &&
+				(name = map_charid2nick(pvprank_fame_list[i].id)) != NULL)
+			{
+				memcpy(WFIFOP(fd, i * 24 + 2), name, NAME_LENGTH);
+			} else
+				memcpy(WFIFOP(fd, i * 24 + 2), pvprank_fame_list[i].name, NAME_LENGTH);
+		} else
+			memcpy(WFIFOP(fd,i*24+2), "None", NAME_LENGTH);
+		WFIFOL(fd,i * 4 + 242) = pvprank_fame_list[i].fame;
+	}
+	for(;i < 10; i++) { //In case the MAX is less than 10.
+		memcpy(WFIFOP(fd, i * 24 + 2), "Unavailable", NAME_LENGTH);
+		WFIFOL(fd, i * 4 + 242) = 0;
+	}
+	WFIFOSET(fd, packet_len(0x238));
+}
+
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag)
+{
+	char message[100];
+	if( points <= 0 )
+		return;
+
+	if( !flag )
+	{
+		sprintf(message, "[Your Player Killer Rank +%d = %d points]", points, total);
+		clif_specialeffect(&sd->bl,9,AREA);
+	}
+	else
+		sprintf(message, "[Your Battleground Rank +%d = %d points]", points, total);
+
+	clif_displaymessage(sd->fd, message);
+}
+
+
+/// /pk (CZ_KILLER_RANK).
+/// 0237
+void clif_parse_RankingPk(int fd,struct map_session_data *sd)
 {
-	int i, fd = sd->fd;
-
-	WFIFOHEAD(fd,packet_len(0x238));
-	WFIFOW(fd,0) = 0x238;
-	for(i=0; i<10; i++) {
-		memcpy(WFIFOP(fd,i*24+2), "Unknown", NAME_LENGTH);
-		WFIFOL(fd,i*4+242) = 0;
-	}
-	WFIFOSET(fd, packet_len(0x238));
-}
-
-
-/// /pk (CZ_KILLER_RANK).
-/// 0237
-void clif_parse_RankingPk(int fd,struct map_session_data *sd)
-{
 	clif_ranking_pk(sd);
 }
 
@@ -13995,12 +14977,19 @@
 	if((item = itemdb_exists(sd->status.inventory[idx].nameid)) != NULL && !(item->type == IT_ARMOR || item->type == IT_PETARMOR || item->type == IT_WEAPON || item->type == IT_CARD || item->type == IT_ETC)) {
 		// Consumable or pets are not allowed
 		clif_Auction_setitem(sd->fd, idx, true);
-		return;
-	}
-
-	if(!pc_can_give_items(sd) || sd->status.inventory[idx].expire_time ||
-	   !sd->status.inventory[idx].identify ||
-	   !itemdb_canauction(&sd->status.inventory[idx],pc_get_group_level(sd))) {  // Quest Item or something else
+		return;
+	}
+
+	if( sd->state.secure_items )
+	{
+		clif_Auction_setitem(sd->fd, idx, true);
+		clif_displaymessage(sd->fd, "You can't open auction. Blocked with @security");
+		return;
+	}
+
+	if( !pc_can_give_items(sd) || sd->status.inventory[idx].expire_time ||
+			!sd->status.inventory[idx].identify ||
+				!itemdb_canauction(&sd->status.inventory[idx],pc_get_group_level(sd)) ) { // Quest Item or something else
 		clif_Auction_setitem(sd->fd, idx, true);
 		return;
 	}
@@ -14200,46 +15189,89 @@
 	short type = RFIFOW(fd,2) + 6;
 	clif_parse_Auction_cancelreg(fd, sd);
 
-	intif_Auction_requestlist(sd->status.char_id, type, 0, "", 1);
-}
-
-
-/// CASH/POINT SHOP
-///
-
+	intif_Auction_requestlist(sd->status.char_id, type, 0, "", 1);
+}
+
+static int clif_min_badges(struct map_session_data *sd)
+{
+	int i, i7828 = 0, i7829 = 0, i7773 = 0;
+	if( !sd ) return 0;
+
+	i = pc_search_inventory(sd,7828);
+	if( i >= 0 ) i7828 = sd->status.inventory[i].amount;
+	i = pc_search_inventory(sd,7829);
+	if( i >= 0 ) i7829 = sd->status.inventory[i].amount;
+	i = pc_search_inventory(sd,7773);
+	if( i >= 0 ) i7773 = sd->status.inventory[i].amount;
+
+	return min(min(i7828,i7829),i7773);
+}
+
+/// CASH/POINT SHOP
+///
+
 /// List of items offered in a cash shop (ZC_PC_CASH_POINT_ITEMLIST).
 /// 0287 <packet len>.W <cash point>.L { <sell price>.L <discount price>.L <item type>.B <name id>.W }*
 /// 0287 <packet len>.W <cash point>.L <kafra point>.L { <sell price>.L <discount price>.L <item type>.B <name id>.W }* (PACKETVER >= 20070711)
 void clif_cashshop_show(struct map_session_data *sd, struct npc_data *nd)
 {
-	int fd,i;
-#if PACKETVER < 20070711
-	const int offset = 8;
-#else
-	const int offset = 12;
-#endif
+	int fd,i,type = 0;
+	unsigned int val;
+	int value1 = 0, // Cash Points client slot
+		value2 = 0; // Free Points client slot
 
 	nullpo_retv(sd);
 	nullpo_retv(nd);
 
 	fd = sd->fd;
 	sd->npc_shopid = nd->bl.id;
-	WFIFOHEAD(fd,offset+nd->u.shop.count*11);
+	WFIFOHEAD(fd, 200 * 11 + 12);
 	WFIFOW(fd,0) = 0x287;
-	WFIFOW(fd,2) = offset+nd->u.shop.count*11;
-	WFIFOL(fd,4) = sd->cashPoints; // Cash Points
-#if PACKETVER >= 20070711
-	WFIFOL(fd,8) = sd->kafraPoints; // Kafra Points
-#endif
+	WFIFOW(fd,2) = 12 + nd->u.shop.count*11;
+ 
+	if( nd->subtype == SPSHOP )
+	{
+		if( nd->cashitem < 0 )
+		{
+			value1 = clif_min_badges(sd);
+			type = 1; // BG Shop Flag
+		}
+		else if( (i = pc_search_inventory(sd,nd->cashitem)) >= 0 )
+		{
+			value1 = sd->status.inventory[i].amount;
+			type = 2; // Item Shop Flag
+		}
+	}
+	else
+	{
+		value1 = pc_readregistry(sd,nd->u.shop.cash_var,nd->u.shop.cash_vartype);
+		value2 = (nd->u.shop.point_vartype != -1) ? pc_readregistry(sd,nd->u.shop.point_var,nd->u.shop.point_vartype) : 0;
+	}
 
+	WFIFOL(fd,4) = value1; // Cash Points
+	WFIFOL(fd,8) = value2; // Kafra Points
+
 	for(i = 0; i < nd->u.shop.count; i++) {
 		struct item_data *id = itemdb_search(nd->u.shop.shop_item[i].nameid);
-		WFIFOL(fd,offset+0+i*11) = nd->u.shop.shop_item[i].value;
-		WFIFOL(fd,offset+4+i*11) = nd->u.shop.shop_item[i].value; // Discount Price
-		WFIFOB(fd,offset+8+i*11) = itemtype(id->type);
-		WFIFOW(fd,offset+9+i*11) = (id->view_id > 0) ? id->view_id : id->nameid;
+		val = nd->u.shop.shop_item[i].value;
+
+		WFIFOL(fd,12+i*11) = val;
+		WFIFOL(fd,16+i*11) = val;
+		WFIFOB(fd,20+i*11) = itemtype(id->type);
+		WFIFOW(fd,21+i*11) = ( id->view_id > 0 ) ? id->view_id : id->nameid;
 	}
 	WFIFOSET(fd,WFIFOW(fd,2));
+	
+	if( type > 0 )
+	{
+		char output[128];
+		if( type == 1 )
+			sprintf(output,"This is a Battleground Shop. Bravery, Honor and Valour badges in the same amount are required to exchange items.");
+		else
+			sprintf(output,"This is a Item Exchange Shop. You need %s (%d) to exchange items.", itemdb_search(nd->cashitem)->jname, nd->cashitem);
+
+		clif_displaymessage(fd, output);
+	}
 }
 
 
@@ -14253,23 +15285,43 @@
 ///     3 = You are over your Weight Limit. (ERROR_TYPE_INVENTORY_WEIGHT)
 ///     4 = You cannot purchase items while you are in a trade. (ERROR_TYPE_EXCHANGE)
 ///     5 = The Purchase has failed because the Item Information was incorrect. (ERROR_TYPE_ITEM_ID)
-///     6 = You do not have enough Kafra Credit Points. (ERROR_TYPE_MONEY)
-///     7 = You can purchase up to 10 items.
-///     8 = Some items could not be purchased.
-void clif_cashshop_ack(struct map_session_data *sd, int error)
-{
-	int fd = sd->fd;
-
-	WFIFOHEAD(fd, packet_len(0x289));
-	WFIFOW(fd,0) = 0x289;
-	WFIFOL(fd,2) = sd->cashPoints;
-#if PACKETVER < 20070711
-	WFIFOW(fd,6) = TOW(error);
-#else
-	WFIFOL(fd,6) = sd->kafraPoints;
-	WFIFOW(fd,10) = TOW(error);
-#endif
-	WFIFOSET(fd, packet_len(0x289));
+///     6 = You do not have enough Kafra Credit Points. (ERROR_TYPE_MONEY)
+///     7 = You can purchase up to 10 items.
+///     8 = Some items could not be purchased.
+void clif_cashshop_ack(struct map_session_data* sd, struct npc_data* nd, int error)
+{
+	int fd = sd->fd, i;
+	int value1 = 0, // Cash Points client slot
+		value2 = 0; // Free Points client slot
+
+	if( !nd || (nd->subtype != CASHSHOP && nd->subtype != SPSHOP) )
+		error = 1;
+	else
+	{
+		if( nd->subtype == SPSHOP )
+		{
+			if( nd->cashitem < 0 )
+				value1 = clif_min_badges(sd);
+			else if( (i = pc_search_inventory(sd,nd->cashitem)) >= 0 )
+				value1 = sd->status.inventory[i].amount;
+		}
+		else
+		{
+			value1 = pc_readregistry(sd,nd->u.shop.cash_var,nd->u.shop.cash_vartype);
+			value2 = (nd->u.shop.point_vartype != -1) ? pc_readregistry(sd,nd->u.shop.point_var,nd->u.shop.point_vartype) : 0;
+		}
+	}
+
+	WFIFOHEAD(fd, packet_len(0x289));
+	WFIFOW(fd,0) = 0x289;
+	WFIFOL(fd,2) = value1;
+#if PACKETVER < 20070711
+	WFIFOW(fd,6) = TOW(error);
+#else
+	WFIFOL(fd,6) = value2;
+	WFIFOW(fd,10) = TOW(error);
+#endif
+	WFIFOSET(fd, packet_len(0x289));
 }
 
 
@@ -14280,11 +15332,21 @@
 void clif_parse_cashshop_buy(int fd, struct map_session_data *sd)
 {
 	int fail = 0;
+	struct npc_data *nd;
 	nullpo_retv(sd);
 
-	if(sd->state.trading || !sd->npc_shopid)
+	if( (nd = (struct npc_data *)map_id2bl(sd->npc_shopid)) == NULL )
+		return;
+
+	if( sd->state.trading || !sd->npc_shopid )
 		fail = 1;
-	else {
+	else if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't shop. Blocked with @security");
+		fail = 1;
+	}
+	else
+	{
 #if PACKETVER < 20101116
 		short nameid = RFIFOW(fd,2);
 		short amount = RFIFOW(fd,4);
@@ -14295,9 +15357,10 @@
 		int len = RFIFOW(fd,2);
 		int points = RFIFOL(fd,4);
 		int count = RFIFOW(fd,8);
-		unsigned short *item_list = (unsigned short *)RFIFOP(fd,10);
+		unsigned short* item_list = (unsigned short*)RFIFOP(fd,10);
 
-		if(len < 10 || len != 10 + count * 4) {
+		if( len < 10 || len != 10 + count * 4)
+		{
 			ShowWarning("Player %u sent incorrect cash shop buy packet (len %u:%u)!\n", sd->status.char_id, len, 10 + count * 4);
 			return;
 		}
@@ -14305,7 +15368,7 @@
 #endif
 	}
 
-	clif_cashshop_ack(sd,fail);
+	clif_cashshop_ack(sd,nd,fail);
 }
 
 
@@ -14839,13 +15902,64 @@
 	WFIFOW(fd,0) = 0x294;
 	WFIFOL(fd,2) = book_id;
 	WFIFOL(fd,6) = page;
-	WFIFOSET(fd,packet_len(0x294));
-}
-
-
-/// Battlegrounds
-///
-
+	WFIFOSET(fd,packet_len(0x294));
+}
+
+/// Faction System
+/// - Take code from official battleground packets
+
+/// 02e0 <account id>.L <name>.24B <hp>.W <max hp>.W
+void clif_faction_hp(struct map_session_data *sd)
+{
+	unsigned char buf[34];
+	const int cmd = 0x2e0;
+	nullpo_retv(sd);
+
+	WBUFW(buf,0) = cmd;
+	WBUFL(buf,2) = sd->status.account_id;
+	memcpy(WBUFP(buf,6), sd->status.name, NAME_LENGTH);
+
+	if( sd->battle_status.max_hp > INT16_MAX )
+	{ // To correctly display the %hp bar. [Skotlex]
+		WBUFW(buf,30) = sd->battle_status.hp/(sd->battle_status.max_hp/100);
+		WBUFW(buf,32) = 100;
+	}
+	else
+	{
+		WBUFW(buf,30) = sd->battle_status.hp;
+		WBUFW(buf,32) = sd->battle_status.max_hp;
+	}
+
+	clif_send(buf, packet_len(cmd), &sd->bl, FACTION_AREA_WOS);
+}
+
+/// 02dd <account id>.L <name>.24B <camp>.W
+void clif_faction_area(struct map_session_data *sd)
+{
+	unsigned char buf[33];
+	nullpo_retv(sd);
+
+	WBUFW(buf, 0) = 0x2dd;
+	WBUFL(buf,2) = sd->bl.id;
+	safestrncpy((char*)WBUFP(buf,6), sd->status.name, NAME_LENGTH);
+	WBUFW(buf,30) = sd->status.faction_id;
+	clif_send(buf,packet_len(0x2dd), &sd->bl, AREA);
+}
+
+void clif_faction_single(int fd, struct map_session_data *sd)
+{
+	nullpo_retv(sd);
+	WFIFOHEAD(fd,32);
+	WFIFOW(fd,0) = 0x2dd;
+	WFIFOL(fd,2) = sd->bl.id;
+	safestrncpy((char*)WFIFOP(fd,6), sd->status.name, NAME_LENGTH);
+	WFIFOW(fd,30) = sd->status.faction_id;
+	WFIFOSET(fd,packet_len(0x2dd));
+}
+
+/// Battlegrounds
+///
+
 /// Updates HP bar of a camp member (ZC_BATTLEFIELD_NOTIFY_HP).
 /// 02e0 <account id>.L <name>.24B <hp>.W <max hp>.W
 void clif_bg_hp(struct map_session_data *sd)
@@ -14853,11 +15967,11 @@
 	unsigned char buf[34];
 	const int cmd = 0x2e0;
 	nullpo_retv(sd);
-
-	WBUFW(buf,0) = cmd;
-	WBUFL(buf,2) = sd->status.account_id;
-	memcpy(WBUFP(buf,6), sd->status.name, NAME_LENGTH);
-
+
+	WBUFW(buf,0) = cmd;
+	WBUFL(buf,2) = sd->bl.id;
+	memcpy(WBUFP(buf,6), sd->status.name, NAME_LENGTH);
+
 	if(sd->battle_status.max_hp > INT16_MAX) {
 		// To correctly display the %hp bar. [Skotlex]
 		WBUFW(buf,30) = sd->battle_status.hp/(sd->battle_status.max_hp/100);
@@ -14867,13 +15981,35 @@
 		WBUFW(buf,32) = sd->battle_status.max_hp;
 	}
 
-	clif_send(buf, packet_len(cmd), &sd->bl, BG_AREA_WOS);
-}
-
-
-/// Updates the position of a camp member on the minimap (ZC_BATTLEFIELD_NOTIFY_POSITION).
-/// 02df <account id>.L <name>.24B <class>.W <x>.W <y>.W
-void clif_bg_xy(struct map_session_data *sd)
+	clif_send(buf, packet_len(cmd), &sd->bl, BG_AREA_WOS);
+}
+
+void clif_bg_hp_single(int fd, struct map_session_data* ssd)
+{
+	const int cmd = 0x2e0;
+	nullpo_retv(ssd);
+
+	WFIFOHEAD(fd,packet_len(cmd));
+	WFIFOW(fd,0) = cmd;
+	WFIFOL(fd,2) = ssd->bl.id;
+	memcpy(WFIFOP(fd,6),ssd->status.name, NAME_LENGTH);
+	if( ssd->battle_status.max_hp > INT16_MAX )
+	{
+		WFIFOW(fd,30) = ssd->battle_status.hp/(ssd->battle_status.max_hp/100);
+		WFIFOW(fd,32) = 100;
+	}
+	else
+	{
+		WFIFOW(fd,30) = ssd->battle_status.hp;
+		WFIFOW(fd,32) = ssd->battle_status.max_hp;
+	}
+
+	WFIFOSET(fd,packet_len(cmd));
+}
+
+/// Updates the position of a camp member on the minimap (ZC_BATTLEFIELD_NOTIFY_POSITION).
+/// 02df <account id>.L <name>.24B <class>.W <x>.W <y>.W
+void clif_bg_xy(struct map_session_data *sd)
 {
 	unsigned char buf[36];
 	nullpo_retv(sd);
@@ -14900,13 +16036,141 @@
 	WBUFW(buf,32)=-1;
 	WBUFW(buf,34)=-1;
 
-	clif_send(buf, packet_len(0x2df), &sd->bl, BG_SAMEMAP_WOS);
-}
-
-
-/// Notifies clients of a battleground message (ZC_BATTLEFIELD_CHAT).
-/// 02dc <packet len>.W <account id>.L <name>.24B <message>.?B
-void clif_bg_message(struct battleground_data *bg, int src_id, const char *name, const char *mes, int len)
+	clif_send(buf, packet_len(0x2df), &sd->bl, BG_SAMEMAP_WOS);
+}
+
+void clif_bg_belonginfo(struct map_session_data *sd)
+{
+	int fd;
+	struct guild *g;
+	nullpo_retv(sd);
+
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,packet_len(0x16c));
+	memset(WFIFOP(fd,0),0,packet_len(0x16c));
+	WFIFOW(fd,0) = 0x16c;
+	WFIFOL(fd,2) = g->guild_id;
+	WFIFOL(fd,6) = g->emblem_id;
+	WFIFOL(fd,10) = 0;
+	WFIFOB(fd,14) = 0;
+	WFIFOL(fd,15) = 0;
+	memcpy(WFIFOP(fd,19), g->name, NAME_LENGTH);
+	WFIFOSET(fd,packet_len(0x16c));
+}
+
+int clif_visual_guild_id(struct block_list *bl)
+{
+	struct battleground_data *bg;
+	int bg_id;
+	nullpo_ret(bl);
+
+	if( battle_config.bg_eAmod_mode && (bg_id = bg_team_get_id(bl)) > 0 && (bg = bg_team_search(bg_id)) != NULL && bg->g )
+		return bg->g->guild_id;
+	else
+		return status_get_guild_id(bl);
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	struct battleground_data *bg;
+	int bg_id;
+	nullpo_ret(bl);
+
+	if( battle_config.bg_eAmod_mode && (bg_id = bg_team_get_id(bl)) > 0 && (bg = bg_team_search(bg_id)) != NULL && bg->g )
+		return bg->g->emblem_id;
+	else
+		return status_get_emblem_id(bl);
+}
+
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_memberlist(struct map_session_data *sd)
+{
+	int fd, i, c;
+	struct battleground_data *bg;
+	struct map_session_data *psd;
+	nullpo_retv(sd);
+
+	if( (fd = sd->fd) == 0 )
+		return;
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (bg = bg_team_search(sd->bg_id)) != NULL) )
+		return;
+
+	WFIFOHEAD(fd,bg->count * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for( i = 0, c = 0; i < bg->count; i++ )
+	{
+		if( (psd = bg->members[i].sd) == NULL )
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = psd->bg_kills; // Exp slot used to show kills
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->bmaster_flag ? 0 : 1; // Position
+		if( psd->state.bg_afk )
+			memcpy(WFIFOP(fd,c*104+34),"AFK",50);
+		else
+			memset(WFIFOP(fd,c*104+34),0,50);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave(struct map_session_data *sd, const char *name, const char *mes)
+{
+	unsigned char buf[128];
+	nullpo_retv(sd);
+
+	WBUFW(buf,0)=0x15a;
+	memcpy(WBUFP(buf, 2),name,NAME_LENGTH);
+	memcpy(WBUFP(buf,26),mes,40);
+	clif_send(buf,packet_len(0x15a),&sd->bl,BG);
+}
+
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,66);
+	WFIFOW(fd,0) = 0x15a;
+	memcpy(WFIFOP(fd,2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd,26), mes, 40);
+	WFIFOSET(fd,66);
+}
+
+/// Notifies clients of a battleground message (ZC_BATTLEFIELD_CHAT).
+/// 02dc <packet len>.W <account id>.L <name>.24B <message>.?B
+void clif_bg_message(struct battleground_data *bg, int src_id, const char *name, const char *mes, int len)
 {
 	struct map_session_data *sd;
 	unsigned char *buf;
@@ -14923,13 +16187,27 @@
 	clif_send(buf,WBUFW(buf,2), &sd->bl, BG);
 
 	if(buf)
-		aFree(buf);
-}
-
-
-/// Validates and processes battlechat messages [pakpil] (CZ_BATTLEFIELD_CHAT).
-/// 0x2db <packet len>.W <text>.?B (<name> : <message>) 00
-void clif_parse_BattleChat(int fd, struct map_session_data *sd)
+		aFree(buf);
+}
+
+void clif_bg_expulsion_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd, 90);
+	WFIFOW(fd,0) = 0x15c;
+	safestrncpy((char*)WFIFOP(fd,2), name, NAME_LENGTH);
+	safestrncpy((char*)WFIFOP(fd,26), mes, 40);
+	safestrncpy((char*)WFIFOP(fd,66), "", NAME_LENGTH);
+	WFIFOSET(fd,90);
+}
+
+
+/// Validates and processes battlechat messages [pakpil] (CZ_BATTLEFIELD_CHAT).
+/// 0x2db <packet len>.W <text>.?B (<name> : <message>) 00
+void clif_parse_BattleChat(int fd, struct map_session_data* sd)
 {
 	const char *text = (char *)RFIFOP(fd,4);
 	int textlen = RFIFOW(fd,2) - 4;
@@ -14975,25 +16253,57 @@
 	WBUFW(buf,4) = map[m].bgscore_eagle;
 	clif_send(buf,packet_len(0x2de),&bl,ALL_SAMEMAP);
 }
-
-void clif_bg_updatescore_single(struct map_session_data *sd)
+
+void clif_bg_updatescore_single(struct map_session_data *sd)
+{
+	struct battleground_data *bg;
+	int fd;
+	nullpo_retv(sd);
+	fd = sd->fd;
+
+	WFIFOHEAD(fd,packet_len(0x2de));
+	WFIFOW(fd,0) = 0x2de;
+	if( map[sd->bl.m].flag.battleground == 2 )
+	{ // Score Board on Map. Team vs Team
+		WFIFOW(fd,2) = map[sd->bl.m].bgscore_lion;
+		WFIFOW(fd,4) = map[sd->bl.m].bgscore_eagle;
+	}
+	else if( map[sd->bl.m].flag.battleground == 3 && (bg = bg_team_search(sd->bg_id)) != NULL )
+	{ // Score Board Multiple. Team vs Best Score
+		WFIFOW(fd,2) = bg->team_score;
+		WFIFOL(fd,4) = map[sd->bl.m].bgscore_top;
+	}
+	WFIFOSET(fd,packet_len(0x2de));
+}
+
+void clif_bg_updatescore_team(struct battleground_data *bg)
+{
+	unsigned char buf[6];
+	struct map_session_data *sd;
+	int i, m;
+
+	nullpo_retv(bg);
+
+	if( (m = map_mapindex2mapid(bg->mapindex)) < 0 )
+		return;
+
+	WBUFW(buf,0) = 0x2de;
+	WBUFW(buf,2) = bg->team_score;
+	WBUFW(buf,4) = map[m].bgscore_top;
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bg->members[i].sd) == NULL || sd->bl.m != m )
+			continue;
+
+		clif_send(buf,packet_len(0x2de),&sd->bl,SELF);
+	}
+}
+
+/// Battleground camp belong-information (ZC_BATTLEFIELD_NOTIFY_CAMPINFO).
+/// 02dd <account id>.L <name>.24B <camp>.W
+void clif_sendbgemblem_area(struct map_session_data *sd)
 {
-	int fd;
-	nullpo_retv(sd);
-	fd = sd->fd;
-
-	WFIFOHEAD(fd,packet_len(0x2de));
-	WFIFOW(fd,0) = 0x2de;
-	WFIFOW(fd,2) = map[sd->bl.m].bgscore_lion;
-	WFIFOW(fd,4) = map[sd->bl.m].bgscore_eagle;
-	WFIFOSET(fd,packet_len(0x2de));
-}
-
-
-/// Battleground camp belong-information (ZC_BATTLEFIELD_NOTIFY_CAMPINFO).
-/// 02dd <account id>.L <name>.24B <camp>.W
-void clif_sendbgemblem_area(struct map_session_data *sd)
-{
 	unsigned char buf[33];
 	nullpo_retv(sd);
 
@@ -16452,15 +17762,15 @@
 		0,  0,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		85, -1, -1,107,  6, -1,  7,  7, 22,191,  0,  8,  0,  0,  0,  0,
 		//#0x02C0
-		0, -1,  0,  0,  0, 30, 30,  0,  0,  3,  0, 65,  4, 71, 10,  0,
-		-1, -1, -1,  0, 29,  0,  6, -1, 10, 10,  3,  0, -1, 32,  6, 36,
-		34, 33,  0,  0,  0,  0,  0,  0, -1, -1, -1, 13, 67, 59, 60,  8,
-		10,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0300
+	    0, -1,  0,  0,  0, 30, 30,  0,  0,  3,  0, 65,  4, 71, 10,  0,
+	   -1, -1, -1,  0, 29,  0,  6, -1, 10, 10,  3,  0, -1, 32,  6, 36,
+	   34, 33,  0,  0,  0,  0,  0,  0, -1, -1, -1, 13, 67, 59, 60,  8,
+	   10,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,
+	//#0x0300
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		//#0x0340
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -16491,15 +17801,15 @@
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x04C0
+	//#0x04C0
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0500
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0500
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 25,
 		//#0x0540
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -16526,16 +17836,16 @@
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0680
+	//#0x0680
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0, 22,  0, 19, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x06C0
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x06C0
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		//#0x0700
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -16563,41 +17873,51 @@
 		//#0x0800
 #if PACKETVER < 20091229
 		-1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 14, 20,
-#else // for Party booking ( PACKETVER >= 20091229 )
-		-1, -1, 18,  4,  8,  6,  2,  4, 14, 50, 18,  6,  2,  3, 14, 20,
-#endif
-		3, -1,  8, -1,  86, 2,  6,  6, -1, -1,  4, 10, 10,  0,  0,  0,
-		0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0, -1, -1,  3,  2, 66,  5,  2, 12,  6,  0,  0,
-		//#0x0840
+#else // for Party booking ( PACKETVER >= 20091229 )
+	   -1, -1, 18,  4,  8,  6,  2,  4, 14, 50, 18,  6,  2,  3, 14, 20,
+#endif
+	    3, -1,  8, -1, 86,  2,  6,  6, -1, -1,  4, 10, 10, 22,  8,  0,
+	    0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0, -1, -1,  3,  2, 66,  5,  2, 12,  6,  0,  0,
+	//#0x0840
 		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 		0,  0,  0,  0,  0,  0, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0880
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x08C0
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
-		0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0900
-		0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		//#0x0940
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-		0,  0,  0,  0,  0,  0,  0, 14,  0,  0,  0,  0,  0,  0,  0,  0,
-
-	};
-	struct {
-		void (*func)(int, struct map_session_data *);
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0880
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x08C0
+		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
+		0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0900
+	    5,  0,  0,  0,  0,  0,  0,  4,  5,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0940
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0, 14,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0980
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x09C0
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	//#0x0A00 ...
+	};
+	struct {
+		void (*func)(int, struct map_session_data *);
 		char *name;
 	} clif_parse_func[]= {
 		{clif_parse_WantToConnection,"wanttoconnection"},
@@ -16959,13 +18279,13 @@
 		ShowFatalError("Failed to bind to port '"CL_WHITE"%d"CL_RESET"'\n",map_port);
 		exit(EXIT_FAILURE);
 	}
-
-	add_timer_func_list(clif_clearunit_delayed_sub, "clif_clearunit_delayed_sub");
-	add_timer_func_list(clif_delayquit, "clif_delayquit");
-
-	delay_clearunit_ers = ers_new(sizeof(struct block_list),"clif.c::delay_clearunit_ers",ERS_OPT_CLEAR);
-
-	return 0;
+
+	add_timer_func_list(clif_clearunit_delayed_sub, "clif_clearunit_delayed_sub");
+	add_timer_func_list(clif_delayquit, "clif_delayquit");
+	clif_load_gm_color();
+	delay_clearunit_ers = ers_new(sizeof(struct block_list),"clif.c::delay_clearunit_ers",ERS_OPT_CLEAR);
+
+	return 0;
 }
 
 void do_final_clif(void)
Index: src/map/clif.h
===================================================================
--- src/map/clif.h	(revision 1953)
+++ src/map/clif.h	(working copy)
@@ -18,21 +18,23 @@
 #define _CLIF_H_
 
 #include "../common/cbasetypes.h"
-//#include "../common/mmo.h"
-struct item;
-struct storage_data;
-struct guild_storage;
-//#include "map.h"
-struct block_list;
+//#include "../common/mmo.h"
+struct item;
+struct storage_data;
+struct extra_storage_data;
+struct guild_storage;
+//#include "map.h"
+struct block_list;
 struct unit_data;
 struct map_session_data;
 struct homun_data;
-struct pet_data;
-struct mob_data;
-struct npc_data;
-struct chat_data;
-struct flooritem_data;
-struct skill_unit;
+struct pet_data;
+struct mob_data;
+struct npc_data;
+struct channel_data;
+struct chat_data;
+struct flooritem_data;
+struct skill_unit;
 struct s_vending;
 struct party;
 struct party_data;
@@ -84,18 +86,41 @@
     GUILD_AREA,
     GUILD_AREA_WOS,
     GUILD_NOBG,
-    DUEL,
-    DUEL_WOS,
-    CHAT_MAINCHAT,      // everyone on main chat
-    SELF,
-    BG,                 // BattleGround System
-    BG_WOS,
-    BG_SAMEMAP,
-    BG_SAMEMAP_WOS,
-    BG_AREA,
-    BG_AREA_WOS,
-} send_target;
-
+	DUEL,
+	DUEL_WOS,
+	SELF,
+	ALL_REGION,
+	BG,					// BattleGround System
+	BG_WOS,
+	BG_SAMEMAP,
+	BG_SAMEMAP_WOS,
+	BG_AREA,
+	BG_AREA_WOS,
+	BG_LISTEN,			// All players listening BG announcements
+	AREA_IWS,			// area, using intravision and self
+	AREA_IWOS,			// area, using intravision without self
+	AREA_WOI,			// area, without intravision
+
+// Faction and Language System
+
+	LANG_AREA_CHAT_WOC,						// Same Language, Area Chat, Without ChatRooms or Self
+	OTHER_LANG_AREA_CHAT_WOC,				// Other Language, Area Chat, Without ChatRooms or Self
+	LANG_CHAT_WOS,							// Same Language, Same Chat Room, Without Self
+	OTHER_LANG_CHAT_WOS,					// Other Language, Same Chat Room, Without Self
+
+	FACTION_AREA_CHAT_WOC,					// Same Faction, Area Chat, Without ChatRooms or Self
+	OTHER_FACTION_AREA_CHAT_WOC,			// Others Faction, Area Chat, Without Chatrooms or Self
+
+	FACTION_LANG_AREA_CHAT_WOC,				// Same Faction, Same Language, Without Chatrooms or Self
+	FACTION_OTHER_LANG_AREA_CHAT_WOC,		// Same Faction, Other Language, Without Chatrooms or Self
+
+	OTHER_FACTION_LANG_AREA_CHAT_WOC,		// Other Faction, Same Language, Area Chat, Without ChatRooms or Self
+	OTHER_FACTION_OTHER_LANG_AREA_CHAT_WOC,	// Other Faction, Other Language, Area Chat, Without ChatRooms or Self
+
+	FACTION_AREA_WOS,					// Same Faction on map without self
+
+} send_target;
+
 typedef enum emotion_type {
     E_GASP = 0,     // /!
     E_WHAT,         // /?
@@ -340,18 +365,20 @@
 void clif_dropflooritem(struct flooritem_data *fitem);
 void clif_clearflooritem(struct flooritem_data *fitem, int fd);
 
-void clif_clearunit_single(int id, clr_type type, int fd);
-void clif_clearunit_area(struct block_list *bl, clr_type type);
-void clif_clearunit_delayed(struct block_list *bl, clr_type type, unsigned int tick);
-int clif_spawn(struct block_list *bl);  //area
-void clif_walkok(struct map_session_data *sd);  // self
-void clif_move(struct unit_data *ud); //area
-void clif_changemap(struct map_session_data *sd, short map, int x, int y);  //self
-void clif_changemapserver(struct map_session_data *sd, unsigned short map_index, int x, int y, uint32 ip, uint16 port); //self
-void clif_blown(struct block_list *bl); // area
-void clif_slide(struct block_list *bl, int x, int y); // area
-void clif_fixpos(struct block_list *bl);    // area
-void clif_npcbuysell(struct map_session_data *sd, int id);  //self
+void clif_clearunit_single(int id, clr_type type, int fd);
+void clif_clearunit_area(struct block_list* bl, clr_type type);
+void clif_clearunit_delayed(struct block_list* bl, clr_type type, unsigned int tick);
+void clif_clearunit_invisible(struct block_list *bl);
+int clif_spawn(struct block_list *bl);	//area
+void clif_walkok(struct map_session_data *sd);	// self
+void clif_move(struct unit_data *ud); //area
+void clif_changemap(struct map_session_data *sd, short map, int x, int y);	//self
+void clif_changemapserver(struct map_session_data* sd, unsigned short map_index, int x, int y, uint32 ip, uint16 port);	//self
+void clif_blown(struct block_list *bl); // area
+void clif_blown_slide(struct block_list *bl); // area
+void clif_slide(struct block_list *bl, int x, int y); // area
+void clif_fixpos(struct block_list *bl);	// area
+void clif_npcbuysell(struct map_session_data* sd, int id);	//self
 void clif_buylist(struct map_session_data *sd, struct npc_data *nd);    //self
 void clif_selllist(struct map_session_data *sd);    //self
 void clif_scriptmes(struct map_session_data *sd, int npcid, const char *mes);   //self
@@ -366,14 +393,14 @@
 void clif_dropitem(struct map_session_data *sd,int n,int amount);   //self
 void clif_delitem(struct map_session_data *sd,int n,int amount, short reason); //self
 void clif_updatestatus(struct map_session_data *sd,int type);   //self
-void clif_changestatus(struct map_session_data *sd,int type,int val);   //area
-int clif_damage(struct block_list *src, struct block_list *dst, unsigned int tick, int sdelay, int ddelay, int damage, int div, int type, int damage2); // area
-void clif_takeitem(struct block_list *src, struct block_list *dst);
-void clif_sitting(struct block_list *bl);
-void clif_standing(struct block_list *bl);
-void clif_changelook(struct block_list *bl,int type,int val);   // area
-void clif_changetraplook(struct block_list *bl,int val); // area
-void clif_refreshlook(struct block_list *bl,int id,int type,int val,enum send_target target); //area specified in 'target'
+void clif_changestatus(struct map_session_data* sd,int type,int val);	//area
+int clif_damage(struct block_list* src, struct block_list* dst, unsigned int tick, int sdelay, int ddelay, int damage, int div, int type, int damage2);	// area
+void clif_takeitem(struct block_list* src, struct block_list* dst);
+void clif_sitting(struct block_list* bl, bool area);
+void clif_standing(struct block_list* bl, bool area);
+void clif_changelook(struct block_list *bl,int type,int val);	// area
+void clif_changetraplook(struct block_list *bl,int val); // area
+void clif_refreshlook(struct block_list *bl,int id,int type,int val,enum send_target target); //area specified in 'target'
 void clif_arrowequip(struct map_session_data *sd,int val); //self
 void clif_arrow_fail(struct map_session_data *sd,int type); //self
 void clif_arrow_create_list(struct map_session_data *sd);   //self
@@ -396,12 +423,13 @@
 void clif_changechatstatus(struct chat_data *cd);   // chat
 void clif_refresh(struct map_session_data *sd); // self
 
-void clif_fame_blacksmith(struct map_session_data *sd, int points);
-void clif_fame_alchemist(struct map_session_data *sd, int points);
-void clif_fame_taekwon(struct map_session_data *sd, int points);
-
-void clif_emotion(struct block_list *bl,int type);
-void clif_talkiebox(struct block_list *bl, const char *talkie);
+void clif_fame_blacksmith(struct map_session_data *sd, int points);
+void clif_fame_alchemist(struct map_session_data *sd, int points);
+void clif_fame_taekwon(struct map_session_data *sd, int points);
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag);
+
+void clif_emotion(struct block_list *bl,int type);
+void clif_talkiebox(struct block_list* bl, const char* talkie);
 void clif_wedding_effect(struct block_list *bl);
 void clif_divorced(struct map_session_data *sd, const char *name);
 void clif_callpartner(struct map_session_data *sd);
@@ -429,12 +457,15 @@
 void clif_storageitemremoved(struct map_session_data *sd, int index, int amount);
 void clif_storageclose(struct map_session_data *sd);
 
-int clif_insight(struct block_list *bl,va_list ap); // map_forallinmovearea callback
-int clif_outsight(struct block_list *bl,va_list ap);    // map_forallinmovearea callback
-
-void clif_class_change(struct block_list *bl,int class_,int type);
-#define clif_mob_class_change(md, class_) clif_class_change(&md->bl, class_, 1)
-
+int clif_insight(struct block_list *bl,va_list ap);	// map_forallinmovearea callback
+int clif_outsight(struct block_list *bl,va_list ap);	// map_forallinmovearea callback
+
+int clif_insight_bl2tbl(struct block_list *bl,va_list ap);
+int clif_insight_tbl2bl(struct block_list *bl,va_list ap);
+
+void clif_class_change(struct block_list *bl,int class_,int type);
+#define clif_mob_class_change(md, class_) clif_class_change(&md->bl, class_, 1)
+
 void clif_skillinfoblock(struct map_session_data *sd);
 void clif_skillup(struct map_session_data *sd,uint16 skill_id);
 void clif_skillinfo(struct map_session_data *sd,int skill, int inf);
@@ -474,13 +505,14 @@
 void clif_status_change(struct block_list *bl,int type,int flag,int tick,int val1, int val2, int val3);
 
 void clif_wis_message(int fd, const char *nick, const char *mes, int mes_len);
-void clif_wis_end(int fd, int flag);
-
-void clif_solved_charname(int fd, int charid, const char *name);
-void clif_charnameack(int fd, struct block_list *bl);
-void clif_charnameupdate(struct map_session_data *ssd);
-
-void clif_use_card(struct map_session_data *sd,int idx);
+void clif_wis_end(int fd, int flag);
+
+void clif_solved_charname(int fd, int charid, const char* name);
+void clif_charnameack(struct map_session_data *sd, struct block_list *bl);
+void clif_mobnameack(struct map_session_data *sd, struct mob_data *md, int is_hp_update);
+void clif_charnameupdate(struct map_session_data *ssd);
+
+void clif_use_card(struct map_session_data *sd,int idx);
 void clif_insert_card(struct map_session_data *sd,int idx_equip,int idx_card,int flag);
 
 void clif_inventorylist(struct map_session_data *sd);
@@ -560,17 +592,27 @@
 void clif_guild_xy(struct map_session_data *sd);
 void clif_guild_xy_single(int fd, struct map_session_data *sd);
 void clif_guild_xy_remove(struct map_session_data *sd);
-
-// Battleground
-void clif_bg_hp(struct map_session_data *sd);
-void clif_bg_xy(struct map_session_data *sd);
-void clif_bg_xy_remove(struct map_session_data *sd);
-void clif_bg_message(struct battleground_data *bg, int src_id, const char *name, const char *mes, int len);
-void clif_bg_updatescore(int16 m);
-void clif_bg_updatescore_single(struct map_session_data *sd);
-void clif_sendbgemblem_area(struct map_session_data *sd);
-void clif_sendbgemblem_single(int fd, struct map_session_data *sd);
-
+
+// Battleground
+void clif_bg_hp(struct map_session_data *sd);
+void clif_bg_hp_single(int fd, struct map_session_data* ssd);
+void clif_bg_xy(struct map_session_data *sd);
+void clif_bg_xy_remove(struct map_session_data *sd);
+void clif_bg_belonginfo(struct map_session_data *sd);
+int clif_visual_guild_id(struct block_list *bl);
+int clif_visual_emblem_id(struct block_list *bl);
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g);
+void clif_bg_memberlist(struct map_session_data *sd);
+void clif_bg_leave(struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_message(struct battleground_data *bg, int src_id, const char *name, const char *mes, int len);
+void clif_bg_expulsion_single(struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_updatescore(int16 m);
+void clif_bg_updatescore_single(struct map_session_data *sd);
+void clif_bg_updatescore_team(struct battleground_data *bg);
+void clif_sendbgemblem_area(struct map_session_data *sd);
+void clif_sendbgemblem_single(int fd, struct map_session_data *sd);
+
 // Instancing
 int clif_instance(int instance_id, int type, int flag);
 void clif_instance_join(int fd, int instance_id);
@@ -581,13 +623,13 @@
 
 // atcommand
 void clif_displaymessage(const int fd, const char *mes);
-void clif_disp_onlyself(struct map_session_data *sd, const char *mes, int len);
-void clif_disp_message(struct block_list *src, const char *mes, int len, enum send_target target);
-void clif_broadcast(struct block_list *bl, const char *mes, int len, int type, enum send_target target);
-void clif_MainChatMessage(const char *message);
-void clif_broadcast2(struct block_list *bl, const char *mes, int len, unsigned long fontColor, short fontType, short fontSize, short fontAlign, short fontY, enum send_target target);
-void clif_heal(int fd,int type,int val);
-void clif_resurrection(struct block_list *bl,int type);
+void clif_disp_onlyself(struct map_session_data *sd, const char *mes, int len);
+void clif_disp_message(struct block_list* src, const char* mes, int len, enum send_target target);
+void clif_broadcast(struct block_list* bl, const char* mes, int len, int type, enum send_target target);
+void clif_channel_message(struct channel_data* cd, const char* message, int color);
+void clif_broadcast2(struct block_list* bl, const char* mes, int len, unsigned long fontColor, short fontType, short fontSize, short fontAlign, short fontY, enum send_target target);
+void clif_heal(int fd,int type,int val);
+void clif_resurrection(struct block_list *bl,int type);
 void clif_map_property(struct map_session_data *sd, enum map_property property);
 void clif_pvpset(struct map_session_data *sd, int pvprank, int pvpnum,int type);
 void clif_map_property_mapall(int map, enum map_property property);
@@ -663,12 +705,16 @@
 void clif_displayexp(struct map_session_data *sd, unsigned int exp, char type, bool quest);
 
 int clif_send(const uint8 *buf, int len, struct block_list *bl, enum send_target type);
-int do_init_clif(void);
-void do_final_clif(void);
-
-// MAIL SYSTEM
-void clif_Mail_window(int fd, int flag);
-void clif_Mail_read(struct map_session_data *sd, int mail_id);
+int do_init_clif(void);
+void do_final_clif(void);
+
+// [@aura]
+void clif_sendauras(struct map_session_data *sd,  enum send_target type);
+void clif_mobhpmeter(struct mob_data *md);
+
+// MAIL SYSTEM
+void clif_Mail_window(int fd, int flag);
+void clif_Mail_read(struct map_session_data *sd, int mail_id);
 void clif_Mail_delete(int fd, int mail_id, short fail);
 void clif_Mail_return(int fd, int mail_id, short fail);
 void clif_Mail_send(int fd, bool fail);
@@ -733,12 +779,24 @@
 
 /// Search Store System
 void clif_search_store_info_ack(struct map_session_data *sd);
-void clif_search_store_info_failed(struct map_session_data *sd, unsigned char reason);
-void clif_open_search_store_info(struct map_session_data *sd);
-void clif_search_store_info_click_ack(struct map_session_data *sd, short x, short y);
-/**
- * 3CeAM
- **/
+void clif_search_store_info_failed(struct map_session_data* sd, unsigned char reason);
+void clif_open_search_store_info(struct map_session_data* sd);
+void clif_search_store_info_click_ack(struct map_session_data* sd, short x, short y);
+
+// Favorite Items
+void clif_favorite_item(struct map_session_data* sd, unsigned short index);
+
+// Faction
+void clif_faction_hp(struct map_session_data *sd);
+void clif_faction_area(struct map_session_data *sd);
+void clif_faction_single(int fd, struct map_session_data *sd);
+
+// Extended Vending
+int clif_vend(struct map_session_data *sd, int skill_lv);
+
+/**
+ * 3CeAM
+ **/
 void clif_msgtable(int fd, int line);
 void clif_msgtable_num(int fd, int line, int num);
 
Index: src/map/guild.c
===================================================================
--- src/map/guild.c	(revision 1953)
+++ src/map/guild.c	(working copy)
@@ -20,14 +20,16 @@
 #include "../common/malloc.h"
 #include "../common/mapindex.h"
 #include "../common/showmsg.h"
-#include "../common/ers.h"
-#include "../common/strlib.h"
-#include "../common/utils.h"
-
-#include "map.h"
-#include "guild.h"
-#include "storage.h"
-#include "battle.h"
+#include "../common/ers.h"
+#include "../common/strlib.h"
+#include "../common/utils.h"
+#include "../common/socket.h"
+
+#include "map.h"
+#include "duel.h"
+#include "guild.h"
+#include "storage.h"
+#include "battle.h"
 #include "npc.h"
 #include "pc.h"
 #include "status.h"
@@ -80,12 +82,165 @@
 
 /* guild flags cache */
 struct npc_data **guild_flags;
-unsigned short guild_flags_count;
-
-/*==========================================
- * Retrieves and validates the sd pointer for this guild member [Skotlex]
- *------------------------------------------*/
-static TBL_PC *guild_sd_check(int guild_id, int account_id, int char_id)
+unsigned short guild_flags_count;
+
+/*==========================================
+ * Guild Wars
+ *------------------------------------------*/
+bool guild_isatwar(int guild_id)
+{
+	struct guild *g;
+
+	if( guild_id == 0 ) return false;
+
+	if( battle_config.guild_wars && (g = guild_search(guild_id)) != NULL && g->war )
+		return true;
+
+	return false;
+}
+
+bool guild_canescape(struct map_session_data *sd)
+{
+	if( !guild_isatwar(sd->status.guild_id) )
+		return true;
+
+	if( DIFF_TICK(gettick(), sd->canescape_tick) > 10000 )
+		return true;
+
+	return false;
+}
+
+bool guild_isenemy(int guild_id, int tguild_id)
+{
+	struct guild *g = guild_search(guild_id), *tg;
+	int i;
+
+	if( !(battle_config.guild_wars && g && g->war && guild_id && tguild_id) )
+		return false;
+
+	ARR_FIND(0, MAX_GUILDALLIANCE, i, g->alliance[i].guild_id == tguild_id);
+	if( i >= MAX_GUILDALLIANCE ) return false;
+
+	tg = guild_search(tguild_id);
+
+	if( tg && g->alliance[i].war && g->alliance[i].opposition )
+	{
+		g->war_tick = tg->war_tick = last_tick + 600;
+		return true;
+	}
+
+	return false;
+}
+
+bool guild_wardamage(struct map_session_data *sd)
+{
+	struct guild *g = guild_search(sd->status.guild_id);
+
+	if( !(battle_config.guild_wars && g) || sd->state.pvpmode || sd->duel_group > 0 || map_flag_noguildwar(sd->bl.m) || agit_flag || agit2_flag )
+		return false;
+
+	return g->war;
+}
+
+bool guild_can_breakwar(int guild_id, int tguild_id)
+{
+	struct guild *g = guild_search(guild_id);
+	int i;
+
+	if( !battle_config.guild_wars || !g ) return true;
+
+	ARR_FIND(0, MAX_GUILDALLIANCE, i, g->alliance[i].guild_id == tguild_id);
+	if( i >= MAX_GUILDALLIANCE ) return true; // ??
+
+	if( g->alliance[i].war && g->alliance[i].opposition	&& DIFF_TICK(g->war_tick, last_tick) > 0 )
+		return false;
+
+	return true;
+}
+
+void guild_war_init(struct guild *g, struct guild *eg, bool starting)
+{
+	int i, len;
+	struct map_session_data *pl_sd;
+	char output[256];
+	sprintf(output, "Your Guild is at War with %s.", eg->name);
+
+	len = strlen(output);
+
+	if( starting )
+	{
+		for( i = 0; i < g->max_member; i++ )
+		{
+			if( (pl_sd = g->member[i].sd ) == NULL )
+				continue;
+
+			clif_disp_onlyself(pl_sd, output, len);
+
+			if( g->war || map_flag_noguildwar(pl_sd->bl.m) )
+				continue;
+
+			if( pl_sd->state.pvpmode )
+				pc_pvpmodeoff(pl_sd, 1, 1); // Cannot be in PVPMODE at GuildWar
+			else if( pl_sd->duel_group )
+				duel_leave(pl_sd->duel_group, pl_sd);
+			
+			clif_map_property(pl_sd, MAPPROPERTY_FREEPVPZONE);
+		}
+
+		g->war_tick = last_tick + 600; // 10 Minutes Cannot remove the Opposition
+	}
+
+	g->war = true;
+}
+
+void guild_war_end(struct guild *g, struct guild *eg, bool surrender)
+{
+	int i, j, len;
+	struct map_session_data *pl_sd;
+	char output[256];
+
+	if( !g || !eg )
+		return;
+
+	if( surrender )
+		sprintf(output, "Your Guild has surrender to %s.", eg->name);
+	else
+		sprintf(output, "Your Guild has won the War against %s.", eg->name);
+
+	len = strlen(output);
+
+	for( i = j = 0; i < MAX_GUILDALLIANCE; i++ )
+	{
+		if( g->alliance[i].guild_id <= 0 || g->alliance[i].opposition != 1 )
+			continue;
+
+		if( g->alliance[i].guild_id == eg->guild_id )
+			g->alliance[i].war = false;
+		else if( g->alliance[i].war )
+			j++; // To know if War is over
+	}
+
+	if( j == 0 )
+		g->war = false; // No more enemy guilds
+
+	for( i = 0; i < g->max_member; i++ )
+	{
+		if( (pl_sd = g->member[i].sd ) == NULL )
+			continue;
+
+		clif_disp_onlyself(pl_sd, output, len);
+	}
+
+	if( surrender ) return;
+
+	sprintf(output, "Guild [%s] has surrender against Guild [%s]", eg->name, g->name);
+	clif_broadcast(NULL, output, strlen(output) + 1, 0, ALL_CLIENT);
+}
+
+/*==========================================
+ * Retrieves and validates the sd pointer for this guild member [Skotlex]
+ *------------------------------------------*/
+static TBL_PC* guild_sd_check(int guild_id, int account_id, int char_id)
 {
 	TBL_PC *sd = map_id2sd(account_id);
 
@@ -474,6 +629,7 @@
 			sd->status.guild_id=0;
 			sd->guild_emblem_id=0;
 			ShowWarning("guild: check_member %d[%s]  nao e um membro\n",sd->status.account_id,sd->status.name);
+			status_calc_pc(sd,0); // Regional System
 		}
 	}
 	mapit_free(iter);
@@ -489,9 +645,12 @@
 
 	iter = mapit_getallusers();
 	for(sd = (TBL_PC *)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC *)mapit_next(iter)) {
-		if(sd->status.guild_id == guild_id)
-			sd->status.guild_id = 0; // erase guild
-	}
+		if( sd->status.guild_id == guild_id )
+		{
+			sd->status.guild_id = 0; // erase guild
+			status_calc_pc(sd,0); // Regional System
+		}
+	}
 	mapit_free(iter);
 
 	return 0;
@@ -517,20 +676,21 @@
 		//Perform the check on the user because the first load
 		guild_check_member(sg);
 		if((sd = map_nick2sd(sg->master)) != NULL) {
-			//If the guild master is online the first time the guild_info is received,
-			//that means he was the first to join, so apply guild skill blocking here.
-			if(battle_config.guild_skill_relog_delay)
-				guild_block_skill(sd, 300000);
-
-			//Also set the guild master flag.
 			sd->state.gmaster_flag = g;
 			clif_charnameupdate(sd); // [LuzZza]
 			clif_guild_masterormember(sd);
 		}
 	} else
 		before=*g;
-	memcpy(g,sg,sizeof(struct guild));
-
+	memcpy(g,sg,sizeof(struct guild));
+	for( i = 0; i < MAX_GUILDSKILL; i++ )
+	{
+		if( guild_new )
+			g->skill_block_timer[i] = INVALID_TIMER;
+		else
+			g->skill_block_timer[i] = before.skill_block_timer[i];
+	}
+
 	if(g->max_member > MAX_GUILD) {
 		ShowError("guild_recv_info: Guilda recebida com %d membros, mas MAX_GUILD e de apenas %d. Membros extra perdidos!\n", g->max_member, MAX_GUILD);
 		g->max_member = MAX_GUILD;
@@ -571,8 +731,31 @@
 			sd->guild_emblem_id = g->emblem_id;
 		}
 	}
-
-	//Occurrence of an event
+
+	if( battle_config.guild_wars )
+	{
+		struct guild *eg; // To hold Enemy Data
+		int j;
+
+		for( i = 0; i < MAX_GUILDALLIANCE; i++ )
+		{
+			if( !g->alliance[i].guild_id || g->alliance[i].opposition == 0 )
+				continue;
+
+			if( (eg = idb_get(guild_db, g->alliance[i].guild_id)) == NULL )
+				continue; // This guild is not loaded
+
+			ARR_FIND(0, MAX_GUILDALLIANCE, j, eg->alliance[j].guild_id == g->guild_id && eg->alliance[j].opposition != 0 );
+			if( j < MAX_GUILDALLIANCE )
+			{ // Double Opposition = War
+				g->alliance[i].war = eg->alliance[i].war = true;
+				guild_war_init(g, eg, guild_new);
+				guild_war_init(eg, g, guild_new);
+			}
+		}
+	}
+
+    //Occurrence of an event
 	if(guild_infoevent_db->remove(guild_infoevent_db, db_i2key(sg->guild_id), &data)) {
 		struct eventlist *ev = db_data2ptr(&data), *ev2;
 		while(ev) {
@@ -598,12 +781,18 @@
 
 	g=guild_search(sd->status.guild_id);
 
-	if(tsd==NULL || g==NULL)
-		return 0;
-
-	if((i=guild_getposition(g,sd))<0 || !(g->position[i].mode&0x0001))
-		return 0; //Invite permission.
-
+	if(tsd==NULL || g==NULL)
+		return 0;
+
+	if( !battle_config.faction_allow_guild && sd->status.faction_id != tsd->status.faction_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot invite to guild other faction's members.");
+		return 0;
+	}
+
+	if( (i=guild_getposition(g,sd))<0 || !(g->position[i].mode&0x0001) )
+		return 0; //Invite permission.
+
 	if(!battle_config.invite_request_check) {
 		if(tsd->party_invite > 0 || tsd->trade_partner || tsd->adopt_invite) {  //checking if there no other invitation pending
 			clif_guild_inviteack(sd,0);
@@ -692,13 +881,13 @@
 }
 
 //Invoked when a player joins.
-//- If guild is not in memory, it is requested
-//- Otherwise sd pointer is set up.
-//- Player must be authed and must belong to a guild before invoking this method
-void guild_member_joined(struct map_session_data *sd)
-{
-	struct guild *g;
-	int i;
+//- If guild is not in memory, it is requested
+//- Otherwise sd pointer is set up.
+//- Player must be authed and must belong to a guild before invoking this method
+void guild_member_joined(struct map_session_data *sd, bool calc)
+{
+	struct guild* g;
+	int i;
 	g=guild_search(sd->status.guild_id);
 	if(!g) {
 		guild_request_info(sd->status.guild_id);
@@ -706,16 +895,17 @@
 	}
 	if(strcmp(sd->status.name,g->master) == 0) {
 		// set the Guild Master flag
-		sd->state.gmaster_flag = g;
-		// prevent Guild Skills from being used directly after relog
-		if(battle_config.guild_skill_relog_delay)
-			guild_block_skill(sd, 300000);
-	}
-	i = guild_getindex(g, sd->status.account_id, sd->status.char_id);
-	if(i == -1)
-		sd->status.guild_id = 0;
-	else
-		g->member[i].sd = sd;
+		sd->state.gmaster_flag = g;
+		// prevent Guild Skills from being used directly after relog
+	}
+	i = guild_getindex(g, sd->status.account_id, sd->status.char_id);
+	if (i == -1)
+	{
+		sd->status.guild_id = 0;
+		if( calc ) status_calc_pc(sd,0); // Regional System
+	}
+	else
+		g->member[i].sd = sd;
 }
 
 /*==========================================
@@ -750,12 +940,13 @@
 	//if all ok add player to guild
 	sd->status.guild_id = g->guild_id;
 	sd->guild_emblem_id = g->emblem_id;
-	//Packets which were sent in the previous 'guild_sent' implementation.
-	clif_guild_belonginfo(sd,g);
-	clif_guild_notice(sd,g);
-
-	//TODO: send new emblem info to others
-
+	//Packets which were sent in the previous 'guild_sent' implementation.
+	clif_guild_belonginfo(sd,g);
+	clif_guild_notice(sd,g);
+	status_calc_pc(sd,0); // Regional System
+
+	//TODO: send new emblem info to others
+
 	if(sd2!=NULL)
 		clif_guild_inviteack(sd2,2);
 
@@ -860,13 +1051,14 @@
 
 		sd->status.guild_id = 0;
 		sd->guild_emblem_id = 0;
+		
+		clif_charnameupdate(sd); //Update display name [Skotlex]
+		//TODO: send emblem update to self and people around
+		status_calc_pc(sd,0); // Regional System
+	}
+	return 0;
+}
 
-		clif_charnameupdate(sd); //Update display name [Skotlex]
-		//TODO: send emblem update to self and people around
-	}
-	return 0;
-}
-
 int guild_send_memberinfoshort(struct map_session_data *sd,int online)
 {
 	// cleaned up [LuzZza]
@@ -932,8 +1124,9 @@
 		struct map_session_data *sd = map_id2sd(account_id);
 		if(sd && sd->status.char_id == char_id) {
 			sd->status.guild_id=0;
-			sd->guild_emblem_id=0;
-		}
+			sd->guild_emblem_id=0;
+			status_calc_pc(sd,0); // Regional System
+		}
 		ShowWarning("guild: Membro %d,%d nao encontrado em %d[%s]\n",   account_id,char_id,guild_id,g->name);
 		return 0;
 	}
@@ -1233,12 +1426,18 @@
 		c->exp = UINT64_MAX;
 	else
 		c->exp += exp;
-	return exp;
-}
-
-/*====================================================
- * Ask to increase guildskill skill_id
- *---------------------------------------------------*/
+	return exp;
+}
+
+// Zephyrus
+int guild_score_saved(int guild_id, int index)
+{
+	return 0;
+}
+
+/*====================================================
+ * Ask to increase guildskill skill_id
+ *---------------------------------------------------*/
 int guild_skillup(TBL_PC *sd, uint16 skill_id)
 {
 	struct guild *g;
@@ -1301,13 +1500,13 @@
 		return;
 	if(!skill_lv)
 		return;
-	if(sd->sc.data[type] && (group = skill_id2group(sd->sc.data[type]->val4))) {
+	if( sd->sc.data[type] && (group = skill_id2group(sd->sc.data[type]->val4)) ) {
 		skill_delunitgroup(group);
-		status_change_end(&sd->bl,type,INVALID_TIMER);
+		status_change_end(&sd->bl,(sc_type)type,INVALID_TIMER);
 	}
 	group = skill_unitsetting(&sd->bl,skill_id,skill_lv,sd->bl.x,sd->bl.y,0);
-	if(group) {
-		sc_start4(NULL,&sd->bl,type,100,(battle_config.guild_aura&16)?0:skill_lv,0,0,group->group_id,600000);//duration doesn't matter these status never end with val4
+	if( group ) {
+		sc_start4(NULL, &sd->bl,(sc_type)type,100,(battle_config.guild_aura&16)?0:skill_lv,0,0,group->group_id,600000);//duration doesn't matter these status never end with val4
 	}
 	return;
 }
@@ -1330,20 +1529,70 @@
 			c++;
 	}
 	return c;
-}
-
-// Blocks all guild skills which have a common delay time.
-void guild_block_skill(struct map_session_data *sd, int time)
-{
-	uint16 skill_id[] = { GD_BATTLEORDER, GD_REGENERATION, GD_RESTORE, GD_EMERGENCYCALL };
-	int i;
-	for(i = 0; i < 4; i++)
-		skill_blockpc_start_(sd, skill_id[i], time , true);
-}
-
-/*====================================================
- * Check relation between guild_id1 and guild_id2.
- * Flag:
+}
+
+// Blocks all guild skills which have a common delay time.
+int guild_block_skill_end(int tid, unsigned int tick, int id, intptr_t data)
+{
+	struct guild *g;
+	char output[128];
+	int idx = battle_config.guild_skills_separed_delay ? (int)data - GD_SKILLBASE : 0;
+
+	if( (g = guild_search(id)) == NULL )
+		return 1;
+
+	if( idx < 0 || idx >= MAX_GUILDSKILL )
+	{
+		ShowError("guild_block_skill_end invalid skill_id %d.\n", (int)data);
+		return 0;
+	}
+
+	if( tid != g->skill_block_timer[idx] )
+	{
+		ShowError("guild_block_skill_end %d != %d.\n", g->skill_block_timer[idx], tid);
+		return 0;
+	}
+
+	sprintf(output, "%s : Guild Skill %s Ready!!", g->name, skill_get_desc((int)data));
+	g->skill_block_timer[idx] = INVALID_TIMER;
+	clif_guild_message(g, 0, output, strlen(output));
+
+	return 1;
+}
+
+void guild_block_skill_status(struct guild *g, int skill_id)
+{
+	const struct TimerData * td;
+	char output[128];
+	int seconds, idx;
+	
+	idx = battle_config.guild_skills_separed_delay ? skill_id - GD_SKILLBASE : 0;
+	if( g == NULL || idx < 0 || idx >= MAX_GUILDSKILL || g->skill_block_timer[idx] == INVALID_TIMER )
+		return;
+
+	if( (td = get_timer(g->skill_block_timer[idx])) == NULL )
+		return;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "%s : Cannot use guild skill %s. %d seconds remaining...", g->name, skill_get_desc(skill_id), seconds);
+	clif_guild_message(g, 0, output, strlen(output));
+}
+
+void guild_block_skill_start(struct guild *g, int skill_id, int time)
+{
+	int idx = battle_config.guild_skills_separed_delay ? skill_id - GD_SKILLBASE : 0;
+	if( g == NULL || idx < 0 || idx >= MAX_GUILDSKILL )
+		return;
+
+	if( g->skill_block_timer[idx] != INVALID_TIMER )
+		delete_timer(g->skill_block_timer[idx], guild_block_skill_end);
+	
+	g->skill_block_timer[idx] = add_timer(gettick() + time, guild_block_skill_end, g->guild_id, skill_id);
+}
+
+/*====================================================
+ * Check relation between guild_id1 and guild_id2.
+ * Flag:
  *  0 = allied
  *  1 = enemy
  * Returns true if yes.
@@ -1489,13 +1738,18 @@
 
 	if((!battle_config.alliance_in_woe) && (agit_flag || agit2_flag))  {     // Disable alliance breaking during woe [Valaris]
 		clif_displaymessage(sd->fd,msg_txt(677)); //"Alliances cannot be broken during Guild Wars!"
-		return 0;
-	}   // end addition [Valaris]
+		return 0;
+	}	// end addition [Valaris]
+
+	if( flag && !guild_can_breakwar(sd->status.guild_id, guild_id) ) {
+		clif_displaymessage(sd->fd,"Opposition cannot be broken at War. You need to wait 10 minutes of No Hostile activity.");
+		return 0;
+	}
+
+	intif_guild_alliance( sd->status.guild_id,guild_id,sd->status.account_id,0,flag|8 );
+	return 0;
+}
 
-	intif_guild_alliance(sd->status.guild_id,guild_id,sd->status.account_id,0,flag|8);
-	return 0;
-}
-
 /*====================================================
  * Player sd, asking player tsd a formal enemy relation between their 2 guilds
  *---------------------------------------------------*/
@@ -1511,14 +1765,14 @@
 		return 0;
 
 	// Prevent creation opposition with same guilds [LuzZza]
-	if(sd->status.guild_id == tsd->status.guild_id)
-		return 0;
+	if(sd->status.guild_id == tsd->status.guild_id)
+		return 0;
+
+	if( guild_get_alliance_count(g,1) >= battle_config.max_guild_opposition )	{
+		clif_guild_oppositionack(sd,1);
+		return 0;
+	}
 
-	if(guild_get_alliance_count(g,1) >= battle_config.max_guild_alliance)  {
-		clif_guild_oppositionack(sd,1);
-		return 0;
-	}
-
 	for(i = 0; i < MAX_GUILDALLIANCE; i++) {  // checking relations
 		if(g->alliance[i].guild_id==tsd->status.guild_id) {
 			if(g->alliance[i].opposition == 1) {  // check if not already hostile
@@ -1573,6 +1827,7 @@
 	}
 
 	if(!(flag&0x08)) {  // new relationship
+	j = MAX_GUILDALLIANCE;
 		for(i=0; i<2-(flag&1); i++) {
 			if(g[i]!=NULL) {
 				ARR_FIND(0, MAX_GUILDALLIANCE, j, g[i]->alliance[j].guild_id == 0);
@@ -1582,13 +1837,39 @@
 					g[i]->alliance[j].opposition=flag&1;
 				}
 			}
-		}
-	} else { // remove relationship
+		}
+
+		// Guild Wars
+		if( battle_config.guild_wars && (flag&1) && g[0] && g[1] && j < MAX_GUILDALLIANCE )
+		{ // Opossition Created
+			char output[256];
+
+			ARR_FIND(0, MAX_GUILDALLIANCE, i, g[1]->alliance[i].guild_id == guild_id[0] && g[1]->alliance[i].opposition != 0);
+			if( i < MAX_GUILDALLIANCE )
+			{
+				sprintf(output, "Guild [%s] and Guild [%s] are now at War!!", g[0]->name, g[1]->name);
+
+				g[0]->alliance[j].war = true;
+				g[1]->alliance[i].war = true;
+				guild_war_init(g[0], g[1], true);
+				guild_war_init(g[1], g[0], true);
+
+				clif_broadcast(NULL, output, strlen(output) + 1, 0, ALL_CLIENT);
+			}
+		}
+    } else { // remove relationship
 		for(i=0; i<2-(flag&1); i++) {
 			if(g[i]!=NULL) {
 				ARR_FIND(0, MAX_GUILDALLIANCE, j, g[i]->alliance[j].guild_id == guild_id[1-i] && g[i]->alliance[j].opposition == (flag&1));
 				if(j < MAX_GUILDALLIANCE)
+				{
+					if( battle_config.guild_wars && g[i]->alliance[j].war && (flag&1) )
+					{
+						guild_war_end(g[0], g[1], true);
+						guild_war_end(g[1], g[0], false);
+					}
 					g[i]->alliance[j].guild_id = 0;
+				}
 			}
 			if(sd[i]!=NULL)   // notify players
 				clif_guild_delalliance(sd[i],guild_id[1-i],(flag&1));
@@ -1670,19 +1951,56 @@
 	struct map_session_data *sd = NULL;
 	int i;
 
-	if(flag!=0 || g==NULL)
-		return 0;
-
-	for(i=0; i<g->max_member; i++) { // Destroy all relationships
-		if((sd=g->member[i].sd)!=NULL) {
-			if(sd->state.storage_flag == 2)
-				storage_guild_storage_quit(sd,1);
-			sd->status.guild_id=0;
-			clif_guild_broken(g->member[i].sd,0);
-			clif_charnameupdate(sd); // [LuzZza]
-		}
-	}
-
+	if(flag!=0 || g==NULL)
+		return 0;
+
+	// Guild Skills Timers
+	for( i = 0; i < MAX_GUILDSKILL; ++i )
+	{
+		if( g->skill_block_timer[i] == INVALID_TIMER )
+			continue;
+		delete_timer(g->skill_block_timer[i], guild_block_skill_end);
+	}
+
+	// Guild Master Cleanup
+	if( (sd = map_nick2sd(g->master)) != NULL )
+	{
+		struct skill_unit_group* group;
+		const enum sc_type scs[] = { SC_LEADERSHIP, SC_GLORYWOUNDS, SC_SOULCOLD, SC_HAWKEYES };
+
+		for( i = 0; i < ARRAYLENGTH(scs); i++ )
+		{
+			if( !sd->sc.data[scs[i]] )
+				continue;
+			if( (group = skill_id2group(sd->sc.data[scs[i]]->val4)) != NULL )
+				skill_delunitgroup(group);
+		}
+
+		// Guild Aura Changes here ...
+		sd->state.gmaster_flag = NULL;
+	}
+
+	for(i=0;i<g->max_member;i++){	// Destroy all relationships
+		if((sd=g->member[i].sd)!=NULL){
+			if(sd->state.storage_flag == 2)
+				storage_guild_storage_quit(sd,1);
+			sd->status.guild_id=0;
+
+			// Guild Aura Effects
+			if( sd->sc.count )
+			{
+				status_change_end(&sd->bl,SC_LEADERSHIP,INVALID_TIMER);
+				status_change_end(&sd->bl,SC_GLORYWOUNDS,INVALID_TIMER);
+				status_change_end(&sd->bl,SC_SOULCOLD,INVALID_TIMER);
+				status_change_end(&sd->bl,SC_HAWKEYES,INVALID_TIMER);
+			}
+
+			clif_guild_broken(g->member[i].sd,0);
+			clif_charnameupdate(sd); // [LuzZza]
+			status_calc_pc(sd,0); // Regional System
+		}
+	}
+
 	guild_db->foreach(guild_db,guild_broken_sub,guild_id);
 	castle_db->foreach(castle_db,castle_guild_broken_sub,guild_id);
 	guild_storage_delete(guild_id);
@@ -1713,13 +2031,14 @@
 
 //Notification from Char server that a guild's master has changed. [Skotlex]
 int guild_gm_changed(int guild_id, int account_id, int char_id)
-{
-	struct guild *g;
-	struct guild_member gm;
-	int pos, i;
+{
+	struct guild *g;
+	struct guild_member gm;
+	char output[128];
+	int pos, i;
+
+	g=guild_search(guild_id);
 
-	g=guild_search(guild_id);
-
 	if(!g)
 		return 0;
 
@@ -1737,8 +2056,13 @@
 	g->member[pos].position = g->member[0].position;
 	g->member[0].position = 0; //Position 0: guild Master.
 	strcpy(g->master, g->member[0].name);
+	
+	sprintf(output, "The Guild Master of [%s] has been changed to [%s]", g->name, g->master);
+	clif_broadcast(NULL, output, strlen(output) + 1, 0, ALL_CLIENT);
 
 	if(g->member[pos].sd && g->member[pos].sd->fd) {
+		if( battle_config.at_changegm_cost && g->member[pos].sd->status.zeny >= battle_config.at_changegm_cost )
+			pc_payzeny(g->member[pos].sd, battle_config.at_changegm_cost,LOG_TYPE_NONE,NULL);
 		clif_displaymessage(g->member[pos].sd->fd, msg_txt(678)); //"You no longer are the Guild Master."
 		g->member[pos].sd->state.gmaster_flag = 0;
 	}
@@ -1746,13 +2070,11 @@
 	if(g->member[0].sd && g->member[0].sd->fd) {
 		clif_displaymessage(g->member[0].sd->fd, msg_txt(679)); //"You have become the Guild Master!"
 		g->member[0].sd->state.gmaster_flag = g;
-		//Block his skills for 5 minutes to prevent abuse.
-		guild_block_skill(g->member[0].sd, 300000);
 	}
 
 	// announce the change to all guild members
 	for(i = 0; i < g->max_member; i++) {
-		if(g->member[i].sd && g->member[i].sd->fd) {
+		if( g->member[i].sd && g->member[i].sd->fd && !(battle_config.bg_eAmod_mode && g->member[i].sd->bg_id) ) {
 			clif_guild_basicinfo(g->member[i].sd);
 			clif_guild_memberlist(g->member[i].sd);
 		}
@@ -1837,25 +2159,70 @@
 
 	switch(index) {
 		case 1: { // The castle's owner has changed? Update or remove Guardians too. [Skotlex]
-				int i;
-				struct mob_data *gd;
-				gc->guild_id = value;
-				for(i = 0; i < MAX_GUARDIANS; i++)
+		int i;
+		struct mob_data *gd;
+		struct guild *g;
+		int m = map_mapindex2mapid(gc->mapindex);
+		if( map_allowed_woe(m) && gc->guild_id && (g = guild_search(gc->guild_id)) != NULL )
+		{ // Current WoE
+			int i = gc->castle_id,
+				addtime = DIFF_TICK(last_tick, gc->capture_tick),
+				score = (addtime / 300) * (1 + (gc->economy / 25));
+
+			g->castle[i].posesion_time += addtime;
+			g->castle[i].defensive_score += score;
+			g->castle[i].changed = true;
+		}
+
+		gc->capture_tick = last_tick;
+		gc->guild_id = value;
+		for (i = 0; i < MAX_GUARDIANS; i++)
 					if(gc->guardian[i].visible && (gd = map_id2md(gc->guardian[i].id)) != NULL)
 						mob_guardian_guildchange(gd);
 				break;
 			}
 		case 2:
-			gc->economy = value; break;
+		{
+			struct guild *g = gc->guild_id ? guild_search(gc->guild_id) : NULL;
+			if( g && gc->economy < value )
+			{
+				int eco = value - gc->economy;
+				add2limit(g->castle[gc->castle_id].invest_eco, eco, USHRT_MAX);
+				if( g->castle[gc->castle_id].top_eco < value )
+					g->castle[gc->castle_id].top_eco = value;
+				g->castle[gc->castle_id].changed = true;
+				if( !agit_flag )
+				{
+					intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+					g->castle[gc->castle_id].changed = false;
+				}
+			}
+			gc->economy = value;
+			break;
+		}
 		case 3: { // defense invest change -> recalculate guardian hp
-				int i;
-				struct mob_data *gd;
-				gc->defense = value;
-				for(i = 0; i < MAX_GUARDIANS; i++)
-					if(gc->guardian[i].visible && (gd = map_id2md(gc->guardian[i].id)) != NULL)
-						status_calc_mob(gd, 0);
-				break;
+			int i;
+			struct mob_data *gd;
+			struct guild *g = gc->guild_id ? guild_search(gc->guild_id) : NULL;
+			if( g && gc->defense < value )
+			{
+				int def = value - gc->defense;
+				add2limit(g->castle[gc->castle_id].invest_def, def, USHRT_MAX);
+				if( g->castle[gc->castle_id].top_def < value )
+					g->castle[gc->castle_id].top_def = value;
+				g->castle[gc->castle_id].changed = true;
+				if( !agit_flag )
+				{
+					intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+					g->castle[gc->castle_id].changed = false;
+				}
 			}
+			gc->defense = value;
+			for(i = 0; i < MAX_GUARDIANS; i++)
+				if(gc->guardian[i].visible && (gd = map_id2md(gc->guardian[i].id)) != NULL)
+					status_calc_mob(gd, 0);
+			break;
+		}
 		case 4:
 			gc->triggerE = value; break;
 		case 5:
@@ -1951,6 +2318,70 @@
 	return 0;
 }
 
+/*------------------------------------------
+ * Guild Ranking System
+ *------------------------------------------*/
+int guild_ranking_save(int flag)
+{
+	struct guild_castle *gc;
+	struct guild *g;
+	DBIterator* iter;
+	struct map_session_data *sd;
+	int i, j, m, index, cc;
+
+	iter = castle_db->iterator(castle_db);
+	for( gc = (struct guild_castle*)dbi_first(iter); dbi_exists(iter); gc = (struct guild_castle*)dbi_next(iter) )
+	{
+		if( gc->guild_id == 0 )
+			continue;
+		
+		if( woe_set && (m = map_mapindex2mapid(gc->mapindex)) >= 0 && map[m].flag.woe_set != woe_set )
+			continue; // Not considered on this ranking
+
+		index = gc->castle_id;
+
+		if( index >= RANK_CASTLES || (flag == 1 && index >= 24) || (flag == 2 && index < 24) )
+			continue;
+
+		if( (g = guild_search(gc->guild_id)) != NULL )
+		{
+			int addtime = DIFF_TICK(last_tick, gc->capture_tick),
+				score = (addtime / 300) * (1 + (gc->economy / 25));
+
+			g->castle[index].capture++;
+			g->castle[index].posesion_time += addtime;
+			g->castle[index].defensive_score += score;
+			g->castle[index].changed = true;
+
+			// Capture counter for members
+			for( j = 0; j < MAX_GUILD; j++ )
+			{
+				if( (sd = g->member[j].sd) == NULL )
+					continue;
+
+				cc = pc_readaccountreg(sd,"#GC_CAPTURES");
+				pc_setaccountreg(sd,"#GC_CAPTURES",++cc);
+			}
+		}
+	}
+	iter->destroy(iter);
+
+	iter = guild_db->iterator(guild_db);
+	for( g = (struct guild*)dbi_first(iter); dbi_exists(iter); g = (struct guild*)dbi_next(iter) )
+	{
+		for( i = 0; i < RANK_CASTLES; i++ )
+		{
+			if( !g->castle[i].changed )
+				continue;
+
+			intif_guild_save_score(g->guild_id, i, &g->castle[i]);
+			g->castle[i].changed = false;
+		}
+	}
+	iter->destroy(iter);
+	return 0;
+}
+
 /*====================================================
  * Start normal woe and triggers all npc OnAgitStart
  *---------------------------------------------------*/
@@ -1958,7 +2389,19 @@
 {
 	// Run All NPC_Event[OnAgitStart]
 	int c = npc_event_doall("OnAgitStart");
+	struct guild_castle* gc;
+	DBIterator *iter = db_iterator(castle_db);
 	ShowStatus("NPC_Event:[OnAgitStart] Executados (%d) Eventos por @AgitStart.\n",c);
+	for( gc = (struct guild_castle*)dbi_first(iter); dbi_exists(iter); gc = (struct guild_castle*)dbi_next(iter) )
+	{
+		if( gc->castle_id >= 24 )
+			continue; // WoE SE Castle
+		if( !gc->guild_id )
+			continue; // No owner
+
+		gc->capture_tick = last_tick;
+	}
+	dbi_destroy(iter);
 }
 
 /*====================================================
@@ -1969,6 +2412,8 @@
 	// Run All NPC_Event[OnAgitEnd]
 	int c = npc_event_doall("OnAgitEnd");
 	ShowStatus("NPC_Event:[OnAgitEnd] Executados (%d) Eventos por @AgitEnd.\n",c);
+	// Stop auto saving
+	guild_ranking_save(1);
 }
 
 /*====================================================
@@ -1978,7 +2423,20 @@
 {
 	// Run All NPC_Event[OnAgitStart2]
 	int c = npc_event_doall("OnAgitStart2");
+	struct guild_castle* gc;
+	DBIterator *iter = db_iterator(castle_db);
 	ShowStatus("NPC_Event:[OnAgitStart2] Executados (%d) Eventos por @AgitStart2.\n",c);
+	
+	for( gc = (struct guild_castle*)dbi_first(iter); dbi_exists(iter); gc = (struct guild_castle*)dbi_next(iter) )
+	{
+		if( gc->castle_id < 24 )
+			continue; // Non WoE SE Castle
+		if( !gc->guild_id )
+			continue; // No owner
+
+		gc->capture_tick = last_tick;
+	}
+	dbi_destroy(iter);
 }
 
 /*====================================================
@@ -1989,6 +2447,8 @@
 	// Run All NPC_Event[OnAgitEnd2]
 	int c = npc_event_doall("OnAgitEnd2");
 	ShowStatus("NPC_Event:[OnAgitEnd2] Executados (%d) Eventos por @AgitEnd2.\n",c);
+	// Stop auto saving
+	guild_ranking_save(2);
 }
 
 // How many castles does this guild have?
Index: src/map/guild.h
===================================================================
--- src/map/guild.h	(revision 1953)
+++ src/map/guild.h	(working copy)
@@ -54,39 +54,43 @@
 struct map_session_data *guild_getavailablesd(struct guild *g);
 int guild_getindex(struct guild *g,int account_id,int char_id);
 int guild_getposition(struct guild *g, struct map_session_data *sd);
-unsigned int guild_payexp(struct map_session_data *sd,unsigned int exp);
-int guild_getexp(struct map_session_data *sd,int exp); // [Celest]
-
-int guild_create(struct map_session_data *sd, const char *name);
-int guild_created(int account_id,int guild_id);
-int guild_request_info(int guild_id);
+unsigned int guild_payexp(struct map_session_data *sd,unsigned int exp);
+int guild_getexp(struct map_session_data *sd,int exp); // [Celest]
+
+int guild_score_saved(int guild_id, int index);
+
+int guild_create(struct map_session_data *sd, const char *name);
+int guild_created(int account_id,int guild_id);
+int guild_request_info(int guild_id);
 int guild_recv_noinfo(int guild_id);
 int guild_recv_info(struct guild *sg);
-int guild_npc_request_info(int guild_id,const char *ev);
-int guild_invite(struct map_session_data *sd,struct map_session_data *tsd);
-int guild_reply_invite(struct map_session_data *sd,int guild_id,int flag);
-void guild_member_joined(struct map_session_data *sd);
-int guild_member_added(int guild_id,int account_id,int char_id,int flag);
-int guild_leave(struct map_session_data *sd,int guild_id,
-                int account_id,int char_id,const char *mes);
+int guild_npc_request_info(int guild_id,const char *ev);
+int guild_invite(struct map_session_data *sd,struct map_session_data *tsd);
+int guild_reply_invite(struct map_session_data *sd,int guild_id,int flag);
+void guild_member_joined(struct map_session_data *sd, bool calc);
+int guild_member_added(int guild_id,int account_id,int char_id,int flag);
+int guild_leave(struct map_session_data *sd,int guild_id,
+	int account_id,int char_id,const char *mes);
 int guild_member_withdraw(int guild_id,int account_id,int char_id,int flag,
                           const char *name,const char *mes);
-int guild_expulsion(struct map_session_data *sd,int guild_id,
-                    int account_id,int char_id,const char *mes);
-int guild_skillup(struct map_session_data *sd, uint16 skill_id);
-void guild_block_skill(struct map_session_data *sd, int time);
-int guild_reqalliance(struct map_session_data *sd,struct map_session_data *tsd);
-int guild_reply_reqalliance(struct map_session_data *sd,int account_id,int flag);
-int guild_alliance(int guild_id1,int guild_id2,int account_id1,int account_id2);
+int guild_expulsion(struct map_session_data *sd,int guild_id,
+	int account_id,int char_id,const char *mes);
+int guild_skillup(struct map_session_data* sd, uint16 skill_id);
+int guild_reqalliance(struct map_session_data *sd,struct map_session_data *tsd);
+int guild_reply_reqalliance(struct map_session_data *sd,int account_id,int flag);
+int guild_alliance(int guild_id1,int guild_id2,int account_id1,int account_id2);
 int guild_allianceack(int guild_id1,int guild_id2,int account_id1,int account_id2,
                       int flag,const char *name1,const char *name2);
 int guild_delalliance(struct map_session_data *sd,int guild_id,int flag);
-int guild_opposition(struct map_session_data *sd,struct map_session_data *tsd);
-int guild_check_alliance(int guild_id1, int guild_id2, int flag);
-
-int guild_send_memberinfoshort(struct map_session_data *sd,int online);
-int guild_recv_memberinfoshort(int guild_id,int account_id,int char_id,int online,int lv,int class_);
-int guild_change_memberposition(int guild_id,int account_id,int char_id,short idx);
+int guild_opposition(struct map_session_data *sd,struct map_session_data *tsd);
+int guild_check_alliance(int guild_id1, int guild_id2, int flag);
+
+void guild_block_skill_start(struct guild *g, int skillnum, int time);
+void guild_block_skill_status(struct guild *g, int skillnum);
+
+int guild_send_memberinfoshort(struct map_session_data *sd,int online);
+int guild_recv_memberinfoshort(int guild_id,int account_id,int char_id,int online,int lv,int class_);
+int guild_change_memberposition(int guild_id,int account_id,int char_id,short idx);
 int guild_memberposition_changed(struct guild *g,int idx,int pos);
 int guild_change_position(int guild_id,int idx,int mode,int exp_mode,const char *name);
 int guild_position_changed(int guild_id,int idx,struct guild_position *p);
@@ -105,12 +109,18 @@
 
 void guild_castle_map_init(void);
 int guild_castledatasave(int castle_id,int index,int value);
-int guild_castledataloadack(int len, struct guild_castle *gc);
-void guild_castle_reconnect(int castle_id, int index, int value);
-
-void guild_agit_start(void);
-void guild_agit_end(void);
-
+int guild_castledataloadack(int len, struct guild_castle *gc);
+void guild_castle_reconnect(int castle_id, int index, int value);
+
+// Guild Wars
+bool guild_isatwar(int guild_id);
+bool guild_canescape(struct map_session_data *sd);
+bool guild_isenemy(int guild_id, int tguild_id);
+bool guild_wardamage(struct map_session_data *sd);
+
+void guild_agit_start(void);
+void guild_agit_end(void);
+
 void guild_agit2_start(void);
 void guild_agit2_end(void);
 /* guild flag cachin */
Index: src/map/homunculus.c
===================================================================
--- src/map/homunculus.c	(revision 1953)
+++ src/map/homunculus.c	(working copy)
@@ -717,13 +717,13 @@
 
 	if(!flag || !strlen(name)) {
 		clif_displaymessage(sd->fd, msg_txt(280)); // You cannot use this name
-		return 0;
-	}
-	safestrncpy(hd->homunculus.name,name,NAME_LENGTH);
-	clif_charnameack(0,&hd->bl);
-	hd->homunculus.rename_flag = 1;
-	clif_hominfo(sd,hd,0);
-	return 1;
+		return 0;
+	}
+	safestrncpy(hd->homunculus.name,name,NAME_LENGTH);
+	clif_charnameack (NULL,&hd->bl);
+	hd->homunculus.rename_flag = 1;
+	clif_hominfo(sd,hd,0);
+	return 1;
 }
 
 int search_homunculusDB_index(int key,int type)
@@ -804,12 +804,15 @@
 }
 
 int merc_call_homunculus(struct map_session_data *sd)
-{
-	struct homun_data *hd;
-
-	if(!sd->status.hom_id)  //Create a new homun.
-		return merc_create_homunculus_request(sd, HM_CLASS_BASE + rnd_value(0, 7)) ;
-
+{
+	struct homun_data *hd;
+
+	if( map[sd->bl.m].flag.ancient )
+		return 0; // Cannot call homunculus on Ancient WoE
+
+	if (!sd->status.hom_id) //Create a new homun.
+		return merc_create_homunculus_request(sd, HM_CLASS_BASE + rnd_value(0, 7)) ;
+
 	// If homunc not yet loaded, load it
 	if(!sd->hd)
 		return intif_homunculus_requestload(sd->status.account_id, sd->status.hom_id);
@@ -923,12 +926,15 @@
 	struct homun_data *hd;
 	nullpo_ret(sd);
 
-	if(!sd->status.hom_id)
-		return 0; // no homunculus
-
-	if(!sd->hd)  //Load homun data;
-		return intif_homunculus_requestload(sd->status.account_id, sd->status.hom_id);
-
+	if (!sd->status.hom_id)
+		return 0; // no homunculus
+
+	if( map[sd->bl.m].flag.ancient )
+		return 0; // Cannot revive homunculus on Ancient WoE
+
+	if (!sd->hd) //Load homun data;
+		return intif_homunculus_requestload(sd->status.account_id, sd->status.hom_id);
+
 	hd = sd->hd;
 
 	if(hd->homunculus.vaporize)
Index: src/map/homunculus.h
===================================================================
--- src/map/homunculus.h	(revision 1953)
+++ src/map/homunculus.h	(working copy)
@@ -41,6 +41,12 @@
 enum { MH_MD_FIGHTING=1, MH_MD_GRAPPLING };
 
 enum {
+	HOM_ST_ACTIVE	= 0,
+	HOM_ST_REST		= 1,
+	HOM_ST_MORPH	= 2,
+};
+
+enum {
     SP_ACK      = 0x0,
     SP_INTIMATE = 0x1,
     SP_HUNGRY   = 0x2,
Index: src/map/intif.c
===================================================================
--- src/map/intif.c	(revision 1953)
+++ src/map/intif.c	(working copy)
@@ -19,12 +19,13 @@
 #include "../common/timer.h"
 #include "../common/nullpo.h"
 #include "../common/malloc.h"
-#include "../common/strlib.h"
-#include "map.h"
-#include "battle.h"
-#include "chrif.h"
-#include "clif.h"
-#include "pc.h"
+#include "../common/strlib.h"
+#include "map.h"
+#include "battle.h"
+#include "channel.h"
+#include "chrif.h"
+#include "clif.h"
+#include "pc.h"
 #include "intif.h"
 #include "log.h"
 #include "storage.h"
@@ -34,12 +35,13 @@
 #include "atcommand.h"
 #include "mercenary.h"
 #include "homunculus.h"
-#include "elemental.h"
-#include "mail.h"
-#include "quest.h"
-
-#include <sys/types.h>
-#include <stdio.h>
+#include "elemental.h"
+#include "mail.h"
+#include "quest.h"
+#include "achievement.h"
+
+#include <sys/types.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <fcntl.h>
@@ -48,14 +50,14 @@
 
 static const int packet_len_table[]= {
 	-1,-1,27,-1, -1, 0,37,-1,  0, 0, 0, 0,  0, 0,  0, 0, //0x3800-0x380f
-	0, 0, 0, 0,  0, 0, 0, 0, -1,11, 0, 0,  0, 0,  0, 0, //0x3810
-	39,-1,15,15, 14,19, 7,-1,  0, 0, 0, 0,  0, 0,  0, 0, //0x3820
-	10,-1,15, 0, 79,19, 7,-1,  0,-1,-1,-1, 14,67,186,-1, //0x3830
-	-1, 0, 0,14,  0, 0, 0, 0, -1,74,-1,11, 11,-1,  0, 0, //0x3840
-	-1,-1, 7, 7,  7,11, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3850  Auctions [Zephyrus]
-	-1, 7, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3860  Quests [Kevin] [Inkfish]
-	-1, 3, 3, 0,  0, 0, 0, 0,  0, 0, 0, 0, -1, 3,  3, 0, //0x3870  Mercenaries [Zephyrus] / Elemental [pakpil]
-	11,-1, 7, 3,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3880
+	 0, 0, 0, 0,  0, 0, 0, 0, -1,11, 0, 0,  0, 0,  0, 0, //0x3810
+	39,-1,15,15, 14,19, 7,-1,  0, 0, 0, 0,  0, 0,  0, 0, //0x3820
+	10,-1,15, 0, 79,19, 7,-1,  0,-1,-1,-1, 14,67,186,-1, //0x3830
+	-1, 0, 0,14,  8, 0, 0, 0, -1,74,-1,11, 11,-1,  0, 0, //0x3840  3844 - Guild Rank
+	-1,-1, 7, 7,  7,11,-1, 0,  0, 0,-1, 7,  0, 0,  0, 0, //0x3850  Auctions [Zephyrus] + Achievement
+	-1, 7, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3860  Quests [Kevin] [Inkfish]
+	-1, 3, 3, 0,  0, 0, 0, 0,  0, 0, 0, 0, -1, 3,  3, 0, //0x3870  Mercenaries [Zephyrus] / Elemental [pakpil]
+	11,-1, 7, 3,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3880
 	-1,-1, 7, 3,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3890  Homunculus [albator]
 };
 
@@ -180,17 +182,14 @@
 	return 0;
 }
 
-int intif_broadcast2(const char *mes, int len, unsigned long fontColor, short fontType, short fontSize, short fontAlign, short fontY)
-{
-	// Send to the local players
-	if(fontColor == 0xFE000000)  // This is main chat message [LuzZza]
-		clif_MainChatMessage(mes);
-	else
-		clif_broadcast2(NULL, mes, len, fontColor, fontType, fontSize, fontAlign, fontY, ALL_CLIENT);
+int intif_broadcast2(const char* mes, int len, unsigned long fontColor, short fontType, short fontSize, short fontAlign, short fontY)
+{
+	// Send to the local players
+	clif_broadcast2(NULL, mes, len, fontColor, fontType, fontSize, fontAlign, fontY, ALL_CLIENT);
+
+	if (CheckForCharServer())
+		return 0;
 
-	if(CheckForCharServer())
-		return 0;
-
 	if(other_mapserver_count < 1)
 		return 0; //No need to send.
 
@@ -204,34 +203,13 @@
 	WFIFOW(inter_fd,14) = fontY;
 	memcpy(WFIFOP(inter_fd,16), mes, len);
 	WFIFOSET(inter_fd, WFIFOW(inter_fd,2));
-	return 0;
-}
-
-/// send a message using the main chat system
-/// <sd>         the source of message
-/// <message>    the message that was sent
-int intif_main_message(struct map_session_data *sd, const char *message)
-{
-	char output[256];
-
+	return 0;
+}
+
+// The transmission of Wisp/Page to inter-server (player not found on this server)
+int intif_wis_message(struct map_session_data *sd, char *nick, char *mes, int mes_len)
+{
 	nullpo_ret(sd);
-
-	// format the message for main broadcasting
-	snprintf(output, sizeof(output), msg_txt(386), sd->status.name, message);
-
-	// send the message using the inter-server broadcast service
-	intif_broadcast2(output, strlen(output) + 1, 0xFE000000, 0, 0, 0, 0);
-
-	// log the chat message
-	log_chat(LOG_CHAT_MAINCHAT, 0, sd->status.char_id, sd->status.account_id, mapindex_id2name(sd->mapindex), sd->bl.x, sd->bl.y, NULL, message);
-
-	return 0;
-}
-
-// The transmission of Wisp/Page to inter-server (player not found on this server)
-int intif_wis_message(struct map_session_data *sd, char *nick, char *mes, int mes_len)
-{
-	nullpo_ret(sd);
 	if(CheckForCharServer())
 		return 0;
 
@@ -757,12 +735,27 @@
 	memcpy(WFIFOP(inter_fd,6),mes1,MAX_GUILDMES1);
 	memcpy(WFIFOP(inter_fd,66),mes2,MAX_GUILDMES2);
 	WFIFOSET(inter_fd,186);
-	return 0;
-}
-
-// Request to change guild emblem
-int intif_guild_emblem(int guild_id,int len,const char *data)
-{
+	return 0;
+}
+
+int intif_guild_save_score(int guild_id, int castle, struct guild_rank_data *grd)
+{
+	if( CheckForCharServer() )
+		return 0;
+
+	WFIFOHEAD(inter_fd,14);
+	WFIFOW(inter_fd,0) = 0x3042;
+	WFIFOW(inter_fd,2) = sizeof(struct guild_rank_data) + 10;
+	WFIFOL(inter_fd,4) = guild_id;
+	WFIFOW(inter_fd,8) = castle;
+	memcpy(WFIFOP(inter_fd,10), grd, sizeof(struct guild_rank_data));
+	WFIFOSET(inter_fd,WFIFOW(inter_fd,2));
+	return 1;
+}
+
+// Request to change guild emblem
+int intif_guild_emblem(int guild_id,int len,const char *data)
+{
 	if(CheckForCharServer())
 		return 0;
 	if(guild_id<=0 || len<0 || len>2000)
@@ -1261,12 +1254,18 @@
 // ACK change of guild notice
 int intif_parse_GuildNotice(int fd)
 {
-	guild_notice_changed(RFIFOL(fd,2),(char *) RFIFOP(fd,6),(char *) RFIFOP(fd,66));
-	return 0;
-}
-
-// ACK change of guild emblem
-int intif_parse_GuildEmblem(int fd)
+	guild_notice_changed(RFIFOL(fd,2),(char *) RFIFOP(fd,6),(char *) RFIFOP(fd,66));
+	return 0;
+}
+// [Zephyrus] GuildRank
+int intif_parse_Guild_score_saved(int fd)
+{
+	guild_score_saved(RFIFOL(fd,2),RFIFOW(fd,6));
+	return 0;
+}
+
+// ACK change of guild emblem
+int intif_parse_GuildEmblem(int fd)
 {
 	guild_emblem_changed(RFIFOW(fd,2)-12,RFIFOL(fd,4),RFIFOL(fd,8), (char *)RFIFOP(fd,12));
 	return 0;
@@ -1398,13 +1397,98 @@
 	if(RFIFOB(fd,2) != 1)
 		ShowError("Homunculus data delete failure\n");
 
-	return 0;
-}
+	return 0;
+}
+
+/////////////////////////////////////////////////////////////
+// Achievement System
+/////////////////////////////////////////////////////////////
+int intif_request_achievement(struct map_session_data* sd)
+{
+	WFIFOHEAD(inter_fd,6);
+	WFIFOW(inter_fd,0) = 0x305a;
+	WFIFOL(inter_fd,2) = sd->status.char_id;
+	WFIFOSET(inter_fd,6);
+	return 0;
+}
+
+int intif_parse_Achievement_data(int fd)
+{
+	int i, received, count, char_id = RFIFOL(fd,4);
+	struct map_session_data* sd = map_charid2sd(char_id);
+	if( !sd ) return -1;
+	
+	received = (RFIFOW(fd,2) - 8) / sizeof(struct s_achievement);
+	memset(&sd->achievement,0,sizeof(sd->achievement));
+
+	for( i = 0, count = 0; i < received; i++ )
+	{ // Load Achievements
+		memcpy(&sd->achievement[count],RFIFOP(fd,i * sizeof(struct s_achievement) + 8),sizeof(struct s_achievement));
+		if( achievement_search(sd->achievement[count].id) == NULL )
+		{
+			memset(&sd->achievement[count],0,sizeof(struct s_achievement));
+			sd->save_achievement = true;
+			continue;
+		}
+		count++;
+	}
+
+	sd->achievement_count = count; // Number of Achievements on process
+
+	// Check if new Achievements of type AT_ACHIEVEMENT are implemented
+	for( i = 0; i < count; i++ )
+	{
+		if( !sd->achievement[i].completed )
+			continue;
+		achievement_validate_achievement(sd,sd->achievement[i].id);
+	}
+
+	if( received != count )
+		ShowError("intif_parse_Achievement_data: Deleted some Achievements from Character %s [%d].\n",sd->status.name,sd->status.char_id);
+
+	return 0;
+}
+
+int intif_achievement_save(struct map_session_data* sd)
+{
+	int len;
+	if( CheckForCharServer() )
+		return 0;
+
+	len = 8 + sizeof(struct s_achievement) * sd->achievement_count;
+	sd->save_achievement = false;
+
+	WFIFOHEAD(inter_fd,len);
+	WFIFOW(inter_fd,0) = 0x305b;
+	WFIFOW(inter_fd,2) = len;
+	WFIFOL(inter_fd,4) = sd->status.char_id;
+	if( sd->achievement_count )
+		memcpy(WFIFOP(inter_fd,8), &sd->achievement, sizeof(struct s_achievement) * sd->achievement_count);
+	WFIFOSET(inter_fd, len);
+
+	return 0;
+}
+
+int intif_parse_Achievement_save(int fd)
+{
+	int char_id = RFIFOL(fd,2);
+	struct map_session_data* sd = map_id2sd(char_id);
+
+	if( !RFIFOB(fd,6) )
+	{
+		if( sd ) sd->save_achievement = true;
+		ShowError("intif_parse_Achievement_save: Failed to save Achievements(s) for character %d!\n", char_id);
+	}
+
+	return 0;
+}
+
+/////////////////////////////////////////////////////////////
+
+/**************************************
+
+QUESTLOG SYSTEM FUNCTIONS
 
-/**************************************
-
-QUESTLOG SYSTEM FUNCTIONS
-
 ***************************************/
 
 int intif_request_questlog(TBL_PC *sd)
@@ -1441,14 +1525,17 @@
 			sd->num_quests--;
 			i--;
 			continue;
-		}
+		}
+
+		if( sd->quest_log[i].state == Q_COMPLETE )
+		{
+			achievement_validate_quest(sd,sd->quest_log[i].quest_id); // Maybe new achievements implemented of type AT_QUEST
+			sd->avail_quests--;
+		}
+	}
+
+	quest_pc_login(sd);
 
-		if(sd->quest_log[i].state == Q_COMPLETE)
-			sd->avail_quests--;
-	}
-
-	quest_pc_login(sd);
-
 	return 0;
 }
 
@@ -1802,12 +1889,37 @@
 	if(RFIFOW(fd,2) - 4 != sizeof(struct auction_data)) {
 		ShowError("intif_parse_Auction_register: data size error %d %d\n", RFIFOW(fd,2) - 4, sizeof(struct auction_data));
 		return;
-	}
-
-	memcpy(&auction, RFIFOP(fd,4), sizeof(struct auction_data));
-	if((sd = map_charid2sd(auction.seller_id)) == NULL)
-		return;
-
+	}
+
+	memcpy(&auction, RFIFOP(fd,4), sizeof(struct auction_data));
+
+	if( battle_config.channel_announces&1 && server_channel[CHN_VENDING] && auction.auction_id > 0 )
+	{ // Vending Chat Announces
+		char chat_message[256], item_name[64];
+		struct item_data *i_data = itemdb_search(auction.item.nameid);
+
+		if( i_data != NULL )
+		{
+			if( i_data->type == IT_ARMOR || auction.type == IT_WEAPON )
+			{
+				if( auction.item.refine > 0 )
+					sprintf(item_name, "+%d %s[%d]", auction.item.refine, i_data->jname, i_data->slot);
+				else
+					sprintf(item_name, "%s[%d]", i_data->jname, i_data->slot);
+			}
+			else
+				sprintf(item_name, "%s", i_data->jname);
+		}
+		else
+			sprintf(item_name, "%s", auction.item_name);
+
+		sprintf(chat_message, msg_txt(824), server_channel[CHN_VENDING]->name, auction.seller_name, item_name, auction.price, auction.buynow, auction.hours);
+		clif_channel_message(server_channel[CHN_VENDING], chat_message, 22);
+	}
+
+	if( (sd = map_charid2sd(auction.seller_id)) == NULL )
+		return;
+
 	if(auction.auction_id > 0) {
 		clif_Auction_message(sd->fd, 1); // Confirmation Packet ??
 		if(save_settings&32)
@@ -1918,12 +2030,59 @@
 		// To update the list, display your buy list
 		clif_parse_Auction_cancelreg(fd, sd);
 		intif_Auction_requestlist(sd->status.char_id, 7, 0, "", 1);
-	}
-}
-
-// Used to send 'You have won the auction' and 'You failed to won the auction' messages
-static void intif_parse_Auction_message(int fd)
-{
+	}
+}
+
+static void intif_parse_Auction_data(int fd)
+{
+	struct auction_data auction;
+	unsigned char result = RFIFOB(fd,4);
+
+	if( RFIFOW(fd,2) - 5 != sizeof(struct auction_data) )
+	{
+		ShowError("intif_parse_Auction_data: data size error %d %d\n", RFIFOW(fd,2) - 5, sizeof(struct auction_data));
+		return;
+	}
+
+	memcpy(&auction, RFIFOP(fd,5), sizeof(struct auction_data));
+	if( battle_config.channel_announces&1 && server_channel[CHN_VENDING] && auction.auction_id > 0 )
+	{ // Vending Chat Announces
+		char chat_message[256], item_name[64];
+		struct item_data *i_data = itemdb_search(auction.item.nameid);
+
+		if( i_data != NULL )
+		{
+			if( i_data->type == IT_ARMOR || auction.type == IT_WEAPON )
+			{
+				if( auction.item.refine > 0 )
+					sprintf(item_name, "+%d %s[%d]", auction.item.refine, i_data->jname, i_data->slot);
+				else
+					sprintf(item_name, "%s[%d]", i_data->jname, i_data->slot);
+			}
+			else
+				sprintf(item_name, "%s", i_data->jname);
+		}
+		else
+			sprintf(item_name, "%s", auction.item_name);
+
+		switch( result )
+		{
+		case 0: sprintf(chat_message, msg_txt(825), server_channel[CHN_VENDING]->name, auction.buyer_name, auction.price, item_name, auction.seller_name); break;
+		case 1: sprintf(chat_message, msg_txt(826), server_channel[CHN_VENDING]->name, auction.buyer_name, item_name, auction.seller_name, auction.price); break;
+		case 2:
+			if( auction.buyer_id )
+				sprintf(chat_message, msg_txt(827), server_channel[CHN_VENDING]->name, item_name, auction.seller_name, auction.buyer_name, auction.price);
+			else
+				sprintf(chat_message, msg_txt(828), server_channel[CHN_VENDING]->name, item_name, auction.seller_name);
+			break;
+		}
+		clif_channel_message(server_channel[CHN_VENDING], chat_message, 22);
+	}
+}
+
+// Used to send 'You have won the auction' and 'You failed to won the auction' messages
+static void intif_parse_Auction_message(int fd)
+{
 	struct map_session_data *sd = map_charid2sd(RFIFOL(fd,2));
 	unsigned char result = RFIFOB(fd,6);
 
@@ -2166,14 +2325,12 @@
 	}
 	// Processing branch
 	switch(cmd) {
-		case 0x3800:
-			if(RFIFOL(fd,4) == 0xFF000000)  //Normal announce.
-				clif_broadcast(NULL, (char *) RFIFOP(fd,16), packet_len-16, 0, ALL_CLIENT);
-			else if(RFIFOL(fd,4) == 0xFE000000)  //Main chat message [LuzZza]
-				clif_MainChatMessage((char *)RFIFOP(fd,16));
-			else //Color announce.
-				clif_broadcast2(NULL, (char *) RFIFOP(fd,16), packet_len-16, RFIFOL(fd,4), RFIFOW(fd,8), RFIFOW(fd,10), RFIFOW(fd,12), RFIFOW(fd,14), ALL_CLIENT);
-			break;
+	case 0x3800:
+		if (RFIFOL(fd,4) == 0xFF000000) //Normal announce.
+			clif_broadcast(NULL, (char *) RFIFOP(fd,16), packet_len-16, 0, ALL_CLIENT);
+		else //Color announce.
+			clif_broadcast2(NULL, (char *) RFIFOP(fd,16), packet_len-16, RFIFOL(fd,4), RFIFOW(fd,8), RFIFOW(fd,10), RFIFOW(fd,12), RFIFOW(fd,14), ALL_CLIENT);
+		break;
 		case 0x3801:    intif_parse_WisMessage(fd); break;
 		case 0x3802:    intif_parse_WisEnd(fd); break;
 		case 0x3803:    mapif_parse_WisToGM(fd); break;
@@ -2203,12 +2360,13 @@
 		case 0x383c:    intif_parse_GuildSkillUp(fd); break;
 		case 0x383d:    intif_parse_GuildAlliance(fd); break;
 		case 0x383e:    intif_parse_GuildNotice(fd); break;
-		case 0x383f:    intif_parse_GuildEmblem(fd); break;
-		case 0x3840:    intif_parse_GuildCastleDataLoad(fd); break;
-		case 0x3843:    intif_parse_GuildMasterChanged(fd); break;
-
-			//Quest system
-		case 0x3860:    intif_parse_questlog(fd); break;
+	case 0x383f:	intif_parse_GuildEmblem(fd); break;
+	case 0x3840:	intif_parse_GuildCastleDataLoad(fd); break;
+	case 0x3843:	intif_parse_GuildMasterChanged(fd); break;
+	case 0x3844:	intif_parse_Guild_score_saved(fd); break;
+
+	//Quest system
+	case 0x3860:	intif_parse_questlog(fd); break;
 		case 0x3861:    intif_parse_questsave(fd); break;
 
 // Mail System
@@ -2222,12 +2380,16 @@
 		case 0x3850:    intif_parse_Auction_results(fd); break;
 		case 0x3851:    intif_parse_Auction_register(fd); break;
 		case 0x3852:    intif_parse_Auction_cancel(fd); break;
-		case 0x3853:    intif_parse_Auction_close(fd); break;
-		case 0x3854:    intif_parse_Auction_message(fd); break;
-		case 0x3855:    intif_parse_Auction_bid(fd); break;
-
-// Mercenary System
-		case 0x3870:    intif_parse_mercenary_received(fd); break;
+	case 0x3853:	intif_parse_Auction_close(fd); break;
+	case 0x3854:	intif_parse_Auction_message(fd); break;
+	case 0x3855:	intif_parse_Auction_bid(fd); break;
+	case 0x3856:	intif_parse_Auction_data(fd); break;
+// Achievement System
+	case 0x385a:	intif_parse_Achievement_data(fd); break;
+	case 0x385b:	intif_parse_Achievement_save(fd); break;
+
+// Mercenary System
+	case 0x3870:	intif_parse_mercenary_received(fd); break;
 		case 0x3871:    intif_parse_mercenary_deleted(fd); break;
 		case 0x3872:    intif_parse_mercenary_saved(fd); break;
 // Elemental System
Index: src/map/intif.h
===================================================================
--- src/map/intif.h	(revision 1953)
+++ src/map/intif.h	(working copy)
@@ -24,12 +24,13 @@
 struct s_pet;
 struct s_homunculus;
 struct s_mercenary;
-struct s_elemental;
-struct mail_message;
-struct auction_data;
-
-int intif_parse(int fd);
-
+struct s_elemental;
+struct mail_message;
+struct auction_data;
+struct guild_rank_data;
+
+int intif_parse(int fd);
+
 int intif_broadcast(const char *mes, int len, int type);
 int intif_broadcast2(const char *mes, int len, unsigned long fontColor, short fontType, short fontSize, short fontAlign, short fontY);
 int intif_main_message(struct map_session_data *sd, const char *message);
@@ -67,12 +68,15 @@
 int intif_guild_change_basicinfo(int guild_id, int type, const void *data, int len);
 int intif_guild_change_memberinfo(int guild_id, int account_id, int char_id, int type, const void *data, int len);
 int intif_guild_position(int guild_id, int idx, struct guild_position *p);
-int intif_guild_skillup(int guild_id, uint16 skill_id, int account_id, int max);
-int intif_guild_alliance(int guild_id1, int guild_id2, int account_id1, int account_id2, int flag);
-int intif_guild_notice(int guild_id, const char *mes1, const char *mes2);
-int intif_guild_emblem(int guild_id, int len, const char *data);
-int intif_guild_castle_dataload(int num, int *castle_ids);
-int intif_guild_castle_datasave(int castle_id, int index, int value);
+int intif_guild_skillup(int guild_id, uint16 skill_id, int account_id, int max);
+int intif_guild_alliance(int guild_id1, int guild_id2, int account_id1, int account_id2, int flag);
+int intif_guild_notice(int guild_id, const char *mes1, const char *mes2);
+
+int intif_guild_save_score(int guild_id, int castle, struct guild_rank_data *grd);
+
+int intif_guild_emblem(int guild_id, int len, const char *data);
+int intif_guild_castle_dataload(int num, int *castle_ids);
+int intif_guild_castle_datasave(int castle_id, int index, int value);
 
 int intif_create_pet(int account_id, int char_id, short pet_type, short pet_lv, short pet_egg_id,
                      short pet_equip, short intimate, short hungry, char rename_flag, char incuvate, char *pet_name);
@@ -85,13 +89,17 @@
 #define intif_rename_hom(sd, name) intif_rename(sd, 2, name)
 int intif_homunculus_create(int account_id, struct s_homunculus *sh);
 int intif_homunculus_requestload(int account_id, int homun_id);
-int intif_homunculus_requestsave(int account_id, struct s_homunculus *sh);
-int intif_homunculus_requestdelete(int homun_id);
+int intif_homunculus_requestsave(int account_id, struct s_homunculus* sh);
+int intif_homunculus_requestdelete(int homun_id);
+
+// ACHIEVEMENT SYSTEM
+int intif_request_achievement(struct map_session_data* sd);
+int intif_achievement_save(struct map_session_data* sd);
+
+/******QUEST SYTEM*******/
+int intif_request_questlog(struct map_session_data * sd);
+int intif_quest_save(struct map_session_data * sd);
 
-/******QUEST SYTEM*******/
-int intif_request_questlog(struct map_session_data *sd);
-int intif_quest_save(struct map_session_data *sd);
-
 // MERCENARY SYSTEM
 int intif_mercenary_create(struct s_mercenary *merc);
 int intif_mercenary_request(int merc_id, int char_id);
Index: src/map/itemdb.c
===================================================================
--- src/map/itemdb.c	(revision 1953)
+++ src/map/itemdb.c	(working copy)
@@ -31,12 +31,13 @@
 #include <string.h>
 
 static struct item_data *itemdb_array[MAX_ITEMDB];
-static DBMap            *itemdb_other;// int nameid -> struct item_data*
-
-static struct item_group itemgroup_db[MAX_ITEMGROUP];
-
-struct item_data dummy_item; //This is the default dummy item used for non-existant items. [Skotlex]
-
+static DBMap*            itemdb_other;// int nameid -> struct item_data*
+
+static struct item_group itemgroup_db[MAX_ITEMGROUP];
+int coins_db[MAX_COIN_DB]; // Extended Vending System
+
+struct item_data dummy_item; //This is the default dummy item used for non-existant items. [Skotlex]
+
 /**
  * Search for item name
  * name = item alias, so we should find items aliases first. if not found then look for "jname" (full name)
@@ -574,12 +575,157 @@
 {
 	itemdb_read_itemgroup_sub();
 	return;
-}
-
-/*==========================================
- * Read item forbidden by mapflag (can't equip item)
- *------------------------------------------*/
-static bool itemdb_read_noequip(char *str[], int columns, int current)
+}
+
+/*==========================================
+ * [Zephyrus] Custom Item Logs
+ *------------------------------------------*/
+static int itemdb_read_logenable(void)
+{
+	FILE *fp;
+	char line[1024];
+	int ln=0;
+	int nameid,j;
+	char *str[2],*p;
+	struct item_data *id;
+
+	sprintf(line, "%s/item_db_logs.txt", db_path);
+	if( (fp = fopen(line,"r")) == NULL )
+	{
+		ShowError("can't read %s\n", line);
+		return -1;
+	}
+
+	while( fgets(line, sizeof(line), fp) )
+	{
+		if( line[0] == '/' && line[1] == '/' )
+			continue;
+
+		memset(str, 0, sizeof(str));
+		for( j = 0, p = line; j < 2 && p; j++ )
+		{
+			str[j] = p;
+			p = strchr(p,',');
+			if( p ) *p++=0;
+		}
+		if( str[0] == NULL )
+			continue;
+
+		nameid = atoi(str[0]);
+		if( nameid <= 0 || !(id = itemdb_exists(nameid)) )
+			continue;
+
+		id->log = (bool)atoi(str[1]);
+		ln++;
+	}
+	fclose(fp);
+	if( ln > 0 )
+		ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n",ln,"item_db_logs.txt.txt");
+
+	return 0;
+}
+
+/*==========================================
+ * [Zephyrus] Ancient Items
+ *------------------------------------------*/
+static int itemdb_read_ancientdb(void)
+{
+	FILE *fp;
+	char line[1024];
+	int ln=0;
+	int nameid,j;
+	char *str[2],*p;
+	struct item_data *id;
+
+	sprintf(line, "%s/item_db_ancient.txt", db_path);
+	if( (fp = fopen(line,"r")) == NULL )
+	{
+		ShowError("can't read %s\n", line);
+		return -1;
+	}
+
+	while( fgets(line, sizeof(line), fp) )
+	{
+		if( line[0] == '/' && line[1] == '/' )
+			continue;
+
+		memset(str, 0, sizeof(str));
+		for( j = 0, p = line; j < 2 && p; j++ )
+		{
+			str[j] = p;
+			p = strchr(p,',');
+			if( p ) *p++=0;
+		}
+		if( str[0] == NULL )
+			continue;
+
+		nameid = atoi(str[0]);
+		if( nameid <= 0 || !(id = itemdb_exists(nameid)) )
+			continue;
+
+		id->ancient = (bool)atoi(str[1]);
+		ln++;
+	}
+	fclose(fp);
+	if( ln > 0 )
+		ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n",ln,"item_db_ancient.txt");
+
+	return 0;
+}
+
+/*==========================================
+ * [Zephyrus] DB de Items con Drop Alterado
+ *------------------------------------------*/
+static int itemdb_read_customrates(void)
+{
+	FILE *fp;
+	char line[1024];
+	int ln=0;
+	int nameid,j;
+	char *str[3],*p;
+	struct item_data *id;
+
+	sprintf(line, "%s/item_customrates.txt", db_path);
+	if( (fp = fopen(line,"r")) == NULL )
+	{
+		ShowError("can't read %s\n", line);
+		return -1;
+	}
+
+	while( fgets(line, sizeof(line), fp) )
+	{
+		if( line[0] == '/' && line[1] == '/' )
+			continue;
+
+		memset(str, 0, sizeof(str));
+		for( j = 0, p = line; j < 3 && p; j++ )
+		{
+			str[j] = p;
+			p = strchr(p,',');
+			if( p ) *p++=0;
+		}
+		if( str[0] == NULL )
+			continue;
+
+		nameid = atoi(str[0]);
+		if( nameid <= 0 || !(id = itemdb_exists(nameid)) )
+			continue;
+
+		id->dropRate = atoi(str[1]);
+		id->add_dropRate = atoi(str[2]);
+		ln++;
+	}
+	fclose(fp);
+	if( ln > 0 )
+		ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n",ln,"item_customrates.txt");
+
+	return 0;
+}
+
+/*==========================================
+ * Read item forbidden by mapflag (can't equip item)
+ *------------------------------------------*/
+static bool itemdb_read_noequip(char* str[], int columns, int current)
 {
 	// <nameid>,<mode>
 	int nameid;
@@ -652,7 +798,7 @@
 	delay = atoi(str[1]);
 
 	if(delay < 0) {
-		ShowWarning("itemdb_read_itemdelay: Invalid delay %d for item id %d.\n", id->delay, nameid);
+		ShowWarning("itemdb_read_itemdelay: Invalid delay %d for item id %d.\n", delay, nameid);
 		return false;
 	}
 
@@ -972,12 +1118,16 @@
 	itemdb_re_split_atoi(str[16],&id->elv,&id->elvmax);
 #else
 	id->elv = atoi(str[16]);
-#endif
-	id->flag.no_refine = atoi(str[17]) ? 0 : 1; //FIXME: verify this
-	id->look = atoi(str[18]);
-
-	id->flag.available = 1;
-	id->view_id = 0;
+#endif
+	id->flag.no_refine = atoi(str[17]) ? 0 : 1; //FIXME: verify this
+	id->look = atoi(str[18]);
+	
+	id->dropRate = 0;
+	id->ancient = false;
+	id->add_dropRate = 0;
+
+	id->flag.available = 1;
+	id->view_id = 0;
 	id->sex = itemdb_gendercheck(id); //Apply gender filtering.
 
 	if(id->script) {
@@ -1086,25 +1236,63 @@
 	return 0;
 }
 
-
-/*====================================
+
+
+// Extended Vending System
+static bool itemdb_read_vending(char* fields[], int columns, int current)
+{
+	struct item_data* id;
+	int nameid;
+
+	nameid = atoi(fields[0]);
+
+	if( ( id = itemdb_exists(nameid) ) == NULL )
+	{
+		ShowWarning("itemdb_read_vending: Invalid item id %d.\n", nameid);
+		return false;
+	}
+
+	if( !itemdb_isstackable2(id) )
+	{
+		ShowWarning("itemdb_read_vending: Cannot use a non stackable item. ID %d.\n", nameid);
+		return false;
+	}
+
+	if( id->weight > 0 )
+	{
+		ShowWarning("itemdb_read_vending: Coins only can have 0 weight. Cannot use ID %d.\n", nameid);
+		return false;
+	}
+
+	coins_db[current] = nameid;
+	return true;
+}
+
+/*====================================
  * read all item-related databases
  *------------------------------------*/
 static void itemdb_read(void)
 {
 	itemdb_read_sqldb();
-	itemdb_read_combos();
-	itemdb_read_itemgroup();
+	itemdb_read_combos();
+	itemdb_read_customrates(); // [Zephyrus] Drop Rate Bonus
+	itemdb_read_ancientdb();
+	itemdb_read_logenable();
+	itemdb_read_itemgroup();
 	sv_readsqldb(get_database_name(20), NULL, 2, -1, &itemdb_read_itemavail);
 	sv_readsqldb(get_database_name(21), NULL, 2, -1, &itemdb_read_noequip);
 	sv_readsqldb(get_database_name(22), NULL, 3, -1, &itemdb_read_itemtrade);
 	sv_readsqldb(get_database_name(23), NULL, 2, -1, &itemdb_read_itemdelay);
 	sv_readsqldb(get_database_name(24), NULL, 3, -1, &itemdb_read_stack);
 	sv_readsqldb(get_database_name(25), NULL, 1, -1, &itemdb_read_buyingstore);
-
-	itemdb_uid_load();
-}
-
+	
+	itemdb_uid_load();
+
+	// Extended Vending System
+	memset(coins_db, 0, sizeof(coins_db));
+	sv_readdb(db_path, "item_vending.txt", ',', 1, 1, MAX_COIN_DB,    &itemdb_read_vending);
+}
+
 /*==========================================
  * Initialize / Finalize
  *------------------------------------------*/
Index: src/map/itemdb.h
===================================================================
--- src/map/itemdb.h	(revision 1953)
+++ src/map/itemdb.h	(working copy)
@@ -22,18 +22,19 @@
 #include "map.h"
 
 // 32k array entries in array (the rest goes to the db)
-#define MAX_ITEMDB 0x8000
+#define MAX_ITEMDB 0x8000
+
+#define MAX_RANDITEM	11000
+#define MAX_COIN_DB		10
+
+// The maximum number of item delays
+#define MAX_ITEMDELAYS	10
+
+#define MAX_SEARCH	10  //Designed for search functions, species max number of matches to display.
+
+/* maximum amount of items a combo may require */
+#define MAX_ITEMS_PER_COMBO 6
 
-#define MAX_RANDITEM    11000
-
-// The maximum number of item delays
-#define MAX_ITEMDELAYS  10
-
-#define MAX_SEARCH  5  //Designed for search functions, species max number of matches to display.
-
-/* maximum amount of items a combo may require */
-#define MAX_ITEMS_PER_COMBO 6
-
 enum item_itemid {
     ITEMID_EMPERIUM = 714,
     ITEMID_YELLOW_GEMSTONE = 715,
@@ -43,12 +44,13 @@
     ITEMID_STONE = 7049,
     ITEMID_SKULL_ = 7420,
     ITEMID_TOKEN_OF_SIEGFRIED = 7621,
-    ITEMID_TRAP_ALLOY = 7940,
-    ITEMID_ANCILLA = 12333,
-    ITEMID_REINS_OF_MOUNT = 12622,
-};
-
-/**
+	ITEMID_TRAP_ALLOY = 7940,
+	ITEMID_ANCILLA = 12333,
+	ITEMID_REINS_OF_MOUNT = 12622,
+	ITEMID_POISONBOTTLE = 678,
+};
+
+/**
  * Rune Knight
  **/
 
@@ -91,13 +93,14 @@
 #define CARD0_FORGE 0x00FF
 #define CARD0_CREATE 0x00FE
 #define CARD0_PET ((short)0xFF00)
+
+//Marks if the card0 given is "special" (non-item id used to mark pets/created items. [Skotlex]
+#define itemdb_isspecial(i) (i == CARD0_FORGE || i == CARD0_CREATE || i == CARD0_PET)
+#define itemdb_isenchant(i) (i >= 4700 && i <= 4999)
+
+//Use apple for unknown items.
+#define UNKNOWN_ITEM_ID 512
 
-//Marks if the card0 given is "special" (non-item id used to mark pets/created items. [Skotlex]
-#define itemdb_isspecial(i) (i == CARD0_FORGE || i == CARD0_CREATE || i == CARD0_PET)
-
-//Use apple for unknown items.
-#define UNKNOWN_ITEM_ID 512
-
 struct item_data {
 	uint16 nameid;
 	char name[ITEM_NAME_LENGTH],jname[ITEM_NAME_LENGTH];
@@ -120,19 +123,22 @@
 	int view_id;
 #ifdef RENEWAL
 	int matk;
-	int elvmax;/* maximum level for this item */
-#endif
-
-	int delay;
-//Lupus: I rearranged order of these fields due to compatibility with ITEMINFO script command
-//		some script commands should be revised as well...
-	unsigned int class_base[3]; //Specifies if the base can wear this item (split in 3 indexes per type: 1-1, 2-1, 2-2)
-	unsigned class_upper : 4; //Specifies if the upper-type can equip it (bitfield, 1: normal, 2: upper, 3: baby,4:third)
-	struct {
-		unsigned short chance;
-		int id;
-	} mob[MAX_SEARCH]; //Holds the mobs that have the highest drop rate for this item. [Skotlex]
-	struct script_code *script; //Default script for everything.
+	int elvmax;/* maximum level for this item */
+#endif
+
+	unsigned int dropRate;
+	unsigned int add_dropRate;
+	bool ancient, log, changed;
+	int delay;
+//Lupus: I rearranged order of these fields due to compatibility with ITEMINFO script command
+//		some script commands should be revised as well...
+	unsigned int class_base[3];	//Specifies if the base can wear this item (split in 3 indexes per type: 1-1, 2-1, 2-2)
+	unsigned class_upper : 4; //Specifies if the upper-type can equip it (bitfield, 1: normal, 2: upper, 3: baby,4:third)
+	struct {
+		unsigned short chance, bchance;
+		int id;
+	} mob[MAX_SEARCH]; //Holds the mobs that have the highest drop rate for this item. [Skotlex]
+	struct script_code *script;	//Default script for everything.
 	struct script_code *equip_script;   //Script executed once when equipping.
 	struct script_code *unequip_script;//Script executed once when unequipping.
 	struct {
@@ -233,11 +239,12 @@
 int itemdb_isidentified(int);
 int itemdb_isstackable(int);
 int itemdb_isstackable2(struct item_data *);
-uint64 itemdb_unique_id(int8 flag, int64 value); // Unique Item ID
+uint64 itemdb_unique_id(int8 flag, int64 value); // Unique Item ID
+
+void itemdb_reload(void);
+extern int coins_db[MAX_COIN_DB];
+
+void do_final_itemdb(void);
+int do_init_itemdb(void);
 
-void itemdb_reload(void);
-
-void do_final_itemdb(void);
-int do_init_itemdb(void);
-
 #endif /* _ITEMDB_H_ */
Index: src/map/log.c
===================================================================
--- src/map/log.c	(revision 1953)
+++ src/map/log.c	(working copy)
@@ -117,12 +117,13 @@
 	struct item_data *id;
 
 	if((id = itemdb_exists(nameid)) == NULL)
-		return false;
-
-	if((filter&LOG_FILTER_ALL) ||
-	   (filter&LOG_FILTER_HEALING && id->type == IT_HEALING) ||
-	   (filter&LOG_FILTER_ETC_AMMO && (id->type == IT_ETC || id->type == IT_AMMO)) ||
-	   (filter&LOG_FILTER_USABLE && (id->type == IT_USABLE || id->type == IT_CASH)) ||
+		return false;
+
+	if( ( filter&LOG_FILTER_ALL ) ||
+		( id->log ) || // Should have log because of item_db_log
+		( filter&LOG_FILTER_HEALING && id->type == IT_HEALING ) ||
+		( filter&LOG_FILTER_ETC_AMMO && ( id->type == IT_ETC || id->type == IT_AMMO ) ) ||
+		( filter&LOG_FILTER_USABLE && ( id->type == IT_USABLE || id->type == IT_CASH ) ) ||
 	   (filter&LOG_FILTER_WEAPON && id->type == IT_WEAPON) ||
 	   (filter&LOG_FILTER_ARMOR && id->type == IT_ARMOR) ||
 	   (filter&LOG_FILTER_CARD && id->type == IT_CARD) ||
@@ -178,9 +179,40 @@
 	}
 }
 
+void log_bg_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id)
+{
+	char esc_sname[NAME_LENGTH*2+1];
+	char esc_tname[NAME_LENGTH*2+1];
+
+	Sql_EscapeStringLen(mmysql_handle, esc_sname, ssd->status.name, strnlen(ssd->status.name, NAME_LENGTH));
+	Sql_EscapeStringLen(mmysql_handle, esc_tname, tsd->status.name, strnlen(tsd->status.name, NAME_LENGTH));
+
+	if( SQL_ERROR == Sql_Query(mmysql_handle,LOG_QUERY " INTO `char_bg_log` (`time`,`killer`,`killer_id`,`killed`,`killed_id`,`map`,`skill`) VALUES (NOW(), '%s', '%d', '%s', '%d', '%s', '%d')", esc_sname, ssd->status.char_id, esc_tname, tsd->status.char_id, map[tsd->bl.m].name, skill_id) )
+		Sql_ShowDebug(mmysql_handle);
+
+	return;
+}
+
+void log_woe_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id)
+{
+	char esc_sname[NAME_LENGTH*2+1];
+	char esc_tname[NAME_LENGTH*2+1];
+
+	Sql_EscapeStringLen(mmysql_handle, esc_sname, ssd->status.name, strnlen(ssd->status.name, NAME_LENGTH));
+	Sql_EscapeStringLen(mmysql_handle, esc_tname, tsd->status.name, strnlen(tsd->status.name, NAME_LENGTH));
+
+	if( SQL_ERROR == Sql_Query(mmysql_handle,LOG_QUERY " INTO `char_woe_log` (`time`,`killer`,`killer_id`,`killed`,`killed_id`,`map`,`skill`) VALUES (NOW(), '%s', '%d', '%s', '%d', '%s', '%d')", esc_sname, ssd->status.char_id, esc_tname, tsd->status.char_id, map[tsd->bl.m].name, skill_id) )
+		Sql_ShowDebug(mmysql_handle);
+
+	return;
+}
+
 /// logs item transactions (generic)
-void log_pick(int id, int16 m, e_log_pick_type type, int amount, struct item *itm)
+void log_pick(struct block_list* bl, int16 m, e_log_pick_type type, int amount, struct item* itm)
 {
+	const char* mapname;
+	int id = 0, account_id = 0;
+	char esc_name[NAME_LENGTH*2+1] = "";
 	nullpo_retv(itm);
 	if((log_config.enable_logs&type) == 0) {
 		// disabled
@@ -189,17 +221,40 @@
 
 	if(!should_log_item(itm->nameid, amount, itm->refine))
 		return; //we skip logging this item set - it doesn't meet our logging conditions [Lupus]
+		
+	//either PLAYER or MOB (here we get map name and objects ID)
+	if( bl == NULL )
+	{
+		ShowError("log_pick: bl == NULL\n");
+	}
+	else switch( bl->type )
+	{
+		case BL_PC:
+			id = ((TBL_PC*)bl)->status.char_id;
+			account_id = ((TBL_PC*)bl)->status.account_id;
+			Sql_EscapeStringLen(logmysql_handle, esc_name, ((TBL_PC*)bl)->status.name, NAME_LENGTH);
+			break;
+		case BL_MOB:
+			id = ((TBL_MOB*)bl)->class_;
+			account_id = 0;
+			Sql_EscapeStringLen(logmysql_handle, esc_name, ((TBL_MOB*)bl)->name, NAME_LENGTH);
+			break;
+		default:
+			ShowDebug("log_pick: Unhandled bl type %d.\n", bl->type);
+	}
 
+	mapname = map[bl->m].name;
+
 	if(log_config.sql_logs) {
 #ifdef BETA_THREAD_TEST
 		char entry[512];
 		int e_length = 0;
-		e_length = sprintf(entry, LOG_QUERY " INTO `%s` (`time`, `char_id`, `type`, `nameid`, `amount`, `refine`, `card0`, `card1`, `card2`, `card3`, `map`, `unique_id`) VALUES (NOW(), '%d', '%c', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%"PRIu64"')",
-		                   log_config.log_pick, id, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], map[m].name?map[m].name:"", itm->unique_id);
+		e_length = sprintf(entry, LOG_QUERY " INTO `%s` (`time`, `account_id`, `char_id`, `name`, `type`, `nameid`, `amount`, `refine`, `card0`, `card1`, `card2`, `card3`, `map`, `unique_id`) VALUES (NOW(), '%d', '%d', '%s', '%c', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%"PRIu64"')",
+				log_config.log_pick, account_id, id, esc_name, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], mapname, itm->unique_id);
 		queryThread_log(entry,e_length);
 #else
-		if(SQL_ERROR == Sql_Query(logmysql_handle, LOG_QUERY " INTO `%s` (`time`, `char_id`, `type`, `nameid`, `amount`, `refine`, `card0`, `card1`, `card2`, `card3`, `map`, `unique_id`) VALUES (NOW(), '%d', '%c', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%"PRIu64"')",
-		                          log_config.log_pick, id, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], map[m].name?map[m].name:"", itm->unique_id)) {
+		if( SQL_ERROR == Sql_Query(logmysql_handle, LOG_QUERY " INTO `%s` (`time`, `account_id`, `char_id`, `name`, `type`, `nameid`, `amount`, `refine`, `card0`, `card1`, `card2`, `card3`, `map`, `unique_id`) VALUES (NOW(), '%d', '%d', '%s', '%c', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%"PRIu64"')",
+			log_config.log_pick, account_id, id, esc_name, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], mapname, itm->unique_id) ) {
 			Sql_ShowDebug(logmysql_handle);
 			return;
 		}
@@ -210,30 +265,30 @@
 		FILE *logfp;
 
 		if((logfp = fopen(log_config.log_pick, "a")) == NULL)
-			return;
-		time(&curtime);
-		strftime(timestring, sizeof(timestring), "%m/%d/%Y %H:%M:%S", localtime(&curtime));
-		fprintf(logfp,"%s - %d\t%c\t%d,%d,%d,%d,%d,%d,%d,%s,'%"PRIu64"'\n", timestring, id, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], map[m].name?map[m].name:"", itm->unique_id);
-		fclose(logfp);
-	}
-}
+			return;
+		time(&curtime);
+		strftime(timestring, sizeof(timestring), "%m/%d/%Y %H:%M:%S", localtime(&curtime));
+		fprintf(logfp,"%s - %d\t%c\t%d,%d,%d,%d,%d,%d,%d,%s,'%"PRIu64"'\n", timestring, id, log_picktype2char(type), itm->nameid, amount, itm->refine, itm->card[0], itm->card[1], itm->card[2], itm->card[3], mapname, itm->unique_id);
+		fclose(logfp);
+	}
+}
 
 /// logs item transactions (players)
-void log_pick_pc(struct map_session_data *sd, e_log_pick_type type, int amount, struct item *itm)
-{
-	nullpo_retv(sd);
-	log_pick(sd->status.char_id, sd->bl.m, type, amount, itm);
-}
-
-
+void log_pick_pc(struct map_session_data* sd, e_log_pick_type type, int amount, struct item* itm)
+{
+	nullpo_retv(sd);
+	log_pick(&sd->bl, sd->bl.m, type, amount, itm);
+}
+
+
 /// logs item transactions (monsters)
-void log_pick_mob(struct mob_data *md, e_log_pick_type type, int amount, struct item *itm)
-{
-	nullpo_retv(md);
-	log_pick(md->class_, md->bl.m, type, amount, itm);
-}
-
-/// logs zeny transactions
+void log_pick_mob(struct mob_data* md, e_log_pick_type type, int amount, struct item* itm)
+{
+	nullpo_retv(md);
+	log_pick(&md->bl, md->bl.m, type, amount, itm);
+}
+
+/// logs zeny transactions
 void log_zeny(struct map_session_data *sd, e_log_pick_type type, struct map_session_data *src_sd, int amount)
 {
 	nullpo_retv(sd);
@@ -401,7 +456,7 @@
 		return;
 	}
 
-	if(log_config.log_chat_woe_disable && (agit_flag || agit2_flag)) {
+	if( log_config.log_chat_woe_disable && (agit_flag || agit2_flag) ) {
 		// no chat logging during woe
 		return;
 	}
Index: src/map/log.h
===================================================================
--- src/map/log.h	(revision 1953)
+++ src/map/log.h	(working copy)
@@ -69,13 +69,16 @@
 void log_zeny(struct map_session_data *sd, e_log_pick_type type, struct map_session_data *src_sd, int amount);
 
 void log_npc(struct map_session_data *sd, const char *message);
-void log_chat(e_log_chat_type type, int type_id, int src_charid, int src_accid, const char *map, int x, int y, const char *dst_charname, const char *message);
-void log_atcommand(struct map_session_data *sd, const char *message);
+void log_chat(e_log_chat_type type, int type_id, int src_charid, int src_accid, const char* map, int x, int y, const char* dst_charname, const char* message);
+void log_atcommand(struct map_session_data* sd, const char* message);
+
+void log_bg_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id);
+void log_woe_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id);
+
+/// old, but useful logs
+void log_branch(struct map_session_data* sd);
+void log_mvpdrop(struct map_session_data* sd, int monster_id, int* log_mvp);
 
-/// old, but useful logs
-void log_branch(struct map_session_data *sd);
-void log_mvpdrop(struct map_session_data *sd, int monster_id, int *log_mvp);
-
 int log_config_read(const char *cfgName);
 
 extern struct Log_Config {
Index: src/map/mail.c
===================================================================
--- src/map/mail.c	(revision 1953)
+++ src/map/mail.c	(working copy)
@@ -69,11 +69,21 @@
 
 unsigned char mail_setitem(struct map_session_data *sd, int idx, int amount)
 {
-
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't attach. Blocked with @security");
+		return 1;
+	}
 	if(pc_istrading(sd))
 		return 1;
 
-	if(idx == 0) {   // Zeny Transfer
+	if( battle_config.super_woe_enable )
+	{
+		clif_displaymessage(sd->fd, "Super WoE don't allow send items/zeny with attachments");
+		return 1;
+	}
+
+	if( idx == 0 ) { // Zeny Transfer
 		if(amount < 0 || !pc_can_give_items(sd))
 			return 1;
 
Index: src/map/Makefile.in
===================================================================
--- src/map/Makefile.in	(revision 1953)
+++ src/map/Makefile.in	(working copy)
@@ -13,22 +13,22 @@
 LIBCONFIG_INCLUDE = -I../../3rdparty/libconfig
 
 MAP_OBJ = map.o chrif.o clif.o pc.o status.o npc.o \
-	npc_chat.o chat.o path.o itemdb.o mob.o script.o \
-	storage.o skill.o atcommand.o battle.o battleground.o \
-	intif.o trade.o party.o vending.o guild.o pet.o \
-	log.o mail.o date.o unit.o homunculus.o mercenary.o quest.o instance.o \
-	buyingstore.o searchstore.o duel.o pc_groups.o elemental.o
-MAP_SQL_OBJ = $(MAP_OBJ:%=obj_sql/%) \
-	obj_sql/mapreg_sql.o
-MAP_H = map.h chrif.h clif.h pc.h status.h npc.h \
-	chat.h itemdb.h mob.h script.h path.h \
-	storage.h skill.h atcommand.h battle.h battleground.h \
-	intif.h trade.h party.h vending.h guild.h pet.h \
-	log.h mail.h date.h unit.h homunculus.h mercenary.h quest.h instance.h mapreg.h \
-	buyingstore.h searchstore.h duel.h pc_groups.h \
-	../config/core.h ../config/renewal.h ../config/secure.h ../config/const.h \
-	../config/classes/general.h elemental.h
-
+	npc_chat.o chat.o path.o itemdb.o mob.o script.o \
+	storage.o skill.o atcommand.o battle.o battleground.o \
+	intif.o trade.o party.o vending.o guild.o pet.o \
+	log.o mail.o date.o channel.o unit.o homunculus.o mercenary.o quest.o instance.o \
+	buyingstore.o searchstore.o duel.o pc_groups.o elemental.o achievement.o region.o faction.o
+MAP_SQL_OBJ = $(MAP_OBJ:%=obj_sql/%) \
+	obj_sql/mapreg_sql.o
+MAP_H = map.h chrif.h clif.h pc.h status.h npc.h \
+	chat.h itemdb.h mob.h script.h path.h \
+	storage.h skill.h atcommand.h battle.h battleground.h \
+	intif.h trade.h party.h vending.h guild.h pet.h \
+	log.h mail.h date.h channel.h unit.h homunculus.h mercenary.h quest.h instance.h mapreg.h \
+	buyingstore.h searchstore.h duel.h pc_groups.h  achievement.h region.h faction.h\
+	../config/core.h ../config/renewal.h ../config/secure.h ../config/const.h \
+	../config/classes/general.h elemental.h
+
 HAVE_MYSQL=@HAVE_MYSQL@
 ifeq ($(HAVE_MYSQL),yes)
 	ALL_DEPENDS=txt sql
Index: src/map/map.c
===================================================================
--- src/map/map.c	(revision 1953)
+++ src/map/map.c	(working copy)
@@ -35,12 +35,13 @@
 #include "npc.h"
 #include "pc.h"
 #include "status.h"
-#include "mob.h"
-#include "npc.h" // npc_setcells(), npc_unsetcells()
-#include "chat.h"
-#include "itemdb.h"
-#include "storage.h"
-#include "skill.h"
+#include "mob.h"
+#include "npc.h" // npc_setcells(), npc_unsetcells()
+#include "chat.h"
+#include "channel.h"
+#include "itemdb.h"
+#include "storage.h"
+#include "skill.h"
 #include "trade.h"
 #include "party.h"
 #include "unit.h"
@@ -54,12 +55,15 @@
 #include "homunculus.h"
 #include "instance.h"
 #include "mercenary.h"
-#include "elemental.h"
-#include "atcommand.h"
-#include "log.h"
-#include "mail.h"
-#include <stdio.h>
-#include <stdlib.h>
+#include "elemental.h"
+#include "atcommand.h"
+#include "log.h"
+#include "achievement.h"
+#include "region.h"
+#include "faction.h"
+#include "mail.h"
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <math.h>
@@ -92,10 +96,6 @@
 char db_db2name[32] = "db";
 Sql *dbmysql_handle;
 
-// This param using for sending mainchat
-// messages like whispers to this nick. [LuzZza]
-char main_chat_nick[16] = "Main";
-
 char *INTER_CONF_NAME;
 char *LOG_CONF_NAME;
 char *MAP_CONF_NAME;
@@ -136,12 +136,14 @@
 
 int autosave_interval = DEFAULT_AUTOSAVE_INTERVAL;
 int minsave_interval = 100;
-int save_settings = 0xFFFF;
-int agit_flag = 0;
-int agit2_flag = 0;
-int night_flag = 0; // 0=day, 1=night [Yor]
-
-struct charid_request {
+int save_settings = 0xFFFF;
+int agit_flag = 0;
+int agit2_flag = 0;
+int woe_set = 0; // eAmod WoE
+int pvpevent_flag = 0; // Ranking System
+int night_flag = 0; // 0=day, 1=night [Yor]
+
+struct charid_request {
 	struct charid_request *next;
 	int charid;// who want to be notified of the nick
 };
@@ -1430,14 +1432,15 @@
  * Parameters
  * @item_data item attributes
  * @amount quantity
- * @m, @x, @y mapid,x,y
- * @first_charid, @second_charid, @third_charid, looting priority
- * @flag: &1 MVP item. &2 do stacking check.
- *------------------------------------------*/
-int map_addflooritem(struct item *item_data,int amount,int16 m,int16 x,int16 y,int first_charid,int second_charid,int third_charid,int flags)
-{
-	int r;
-	struct flooritem_data *fitem=NULL;
+ * @m, @x, @y mapid,x,y
+ * @first_charid, @second_charid, @third_charid, looting priority
+ * @flag: &1 MVP item. &2 do stacking check.
+ * type flag: &4 No greed allowed to get the item
+ *------------------------------------------*/
+int map_addflooritem(struct item *item_data,int amount,int16 m,int16 x,int16 y,int first_charid,int second_charid,int third_charid,int guild_id,int flags)
+{
+	int r;
+	struct flooritem_data *fitem=NULL;
 
 	nullpo_ret(item_data);
 
@@ -1460,26 +1463,58 @@
 	fitem->first_get_charid = first_charid;
 	fitem->first_get_tick = gettick() + (flags&1 ? battle_config.mvp_item_first_get_time : battle_config.item_first_get_time);
 	fitem->second_get_charid = second_charid;
-	fitem->second_get_tick = fitem->first_get_tick + (flags&1 ? battle_config.mvp_item_second_get_time : battle_config.item_second_get_time);
-	fitem->third_get_charid = third_charid;
-	fitem->third_get_tick = fitem->second_get_tick + (flags&1 ? battle_config.mvp_item_third_get_time : battle_config.item_third_get_time);
-
-	memcpy(&fitem->item_data,item_data,sizeof(*item_data));
-	fitem->item_data.amount=amount;
-	fitem->subx=(r&3)*3+3;
-	fitem->suby=((r>>2)&3)*3+3;
-	fitem->cleartimer=add_timer(gettick()+battle_config.flooritem_lifetime,map_clearflooritem_timer,fitem->bl.id,0);
-
-	map_addiddb(&fitem->bl);
-	map_addblock(&fitem->bl);
+	fitem->second_get_tick = fitem->first_get_tick + (flags&1 ? battle_config.mvp_item_second_get_time : battle_config.item_second_get_time);
+	fitem->third_get_charid = third_charid;
+	fitem->third_get_tick = fitem->second_get_tick + (flags&1 ? battle_config.mvp_item_third_get_time : battle_config.item_third_get_time);
+	fitem->guild_id = guild_id;
+
+	memcpy(&fitem->item_data,item_data,sizeof(*item_data));
+	fitem->item_data.amount=amount;
+	fitem->subx=(r&3)*3+3;
+	fitem->suby=((r>>2)&3)*3+3;
+	fitem->cleartimer=add_timer(gettick()+battle_config.flooritem_lifetime,map_clearflooritem_timer,fitem->bl.id,0);
+	fitem->no_bsgreed = ( (flags&4) != 0 ); // [Zephyrus] @flooritem
+
+	map_addiddb(&fitem->bl);
+	map_addblock(&fitem->bl);
 	clif_dropflooritem(fitem);
 
-	return fitem->bl.id;
-}
-
-/**
- * @see DBCreateData
- */
+	return fitem->bl.id;
+}
+
+int map_addflooritem_area(struct block_list* bl, int16 m, int16 x, int16 y, int nameid, int amount)
+{
+	struct item item_tmp;
+	int count, range, i;
+	short mx, my;
+
+	memset(&item_tmp, 0, sizeof(item_tmp));
+	item_tmp.nameid = nameid;
+	item_tmp.identify = 1;
+
+	if( bl != NULL ) m = bl->m;
+
+	count = 0;
+	range = (int)sqrt(amount) +2;
+	for( i = 0; i < amount; i++ )
+	{
+		if( bl != NULL )
+			map_search_freecell(bl, 0, &mx, &my, range, range, 0);
+		else
+		{
+			mx = x; my = y;
+			map_search_freecell(NULL, m, &mx, &my, range, range, 1);
+		}
+
+		count += (map_addflooritem(&item_tmp, 1, m, mx, my, 0, 0, 0, 0, 4) != 0) ? 1 : 0;
+	}
+
+	return count;
+}
+
+/**
+ * @see DBCreateData
+ */
 static DBData create_charid2nick(DBKey key, va_list args)
 {
 	struct charid2nick *p;
@@ -1544,8 +1579,32 @@
 	struct map_session_data *tsd;
 
 	nullpo_retv(sd);
-
-	tsd = map_charid2sd(charid);
+
+	if( battle_config.bg_reserved_char_id && battle_config.bg_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "Battleground");
+		return;
+	}
+
+	if( battle_config.woe_reserved_char_id && battle_config.woe_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "WoE");
+		return;
+	}
+
+	if( battle_config.ancient_reserved_char_id && battle_config.ancient_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "Ancient");
+		return;
+	}
+
+	if( battle_config.costume_reserved_char_id && battle_config.costume_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "Costume");
+		return;
+	}
+
+	tsd = map_charid2sd(charid);
 	if(tsd) {
 		clif_solved_charname(sd->fd, charid, tsd->status.name);
 		return;
@@ -1631,25 +1690,28 @@
 		npc_timerevent_quit(sd);
 
 	if(sd->npc_id)
-		npc_event_dequeue(sd);
-
-	if(sd->bg_id)
-		bg_team_leave(sd,1);
-
-	pc_itemcd_do(sd,false);
-
-	npc_script_event(sd, NPCE_LOGOUT);
-
-	//Unit_free handles clearing the player related data,
+		npc_event_dequeue(sd);
+
+	if( sd->bg_id )
+	{
+		bg_team_leave(sd,1);
+		sd->status.bgstats.deserter++;
+	}
+
+	pc_itemcd_do(sd,false);
+	npc_script_event(sd, NPCE_LOGOUT);
+
+	//Unit_free handles clearing the player related data,
 	//map_quit handles extra specific data which is related to quitting normally
 	//(changing map-servers invokes unit_free but bypasses map_quit)
 	if(sd->sc.count) {
-		//Status that are not saved...
-		status_change_end(&sd->bl, SC_BOSSMAPINFO, INVALID_TIMER);
-		status_change_end(&sd->bl, SC_AUTOTRADE, INVALID_TIMER);
-		status_change_end(&sd->bl, SC_SPURT, INVALID_TIMER);
-		status_change_end(&sd->bl, SC_BERSERK, INVALID_TIMER);
-		status_change_end(&sd->bl, SC__BLOODYLUST, INVALID_TIMER);
+		//Status that are not saved...
+		status_change_end(&sd->bl, SC_BOSSMAPINFO, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_AUTOTRADE, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_AUTOREFRESH, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_SPURT, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_BERSERK, INVALID_TIMER);
+		status_change_end(&sd->bl, SC__BLOODYLUST, INVALID_TIMER);
 		status_change_end(&sd->bl, SC_TRICKDEAD, INVALID_TIMER);
 		status_change_end(&sd->bl, SC_LEADERSHIP, INVALID_TIMER);
 		status_change_end(&sd->bl, SC_GLORYWOUNDS, INVALID_TIMER);
@@ -1693,15 +1755,15 @@
 			if(!pc_isequip(sd , sd->equip_index[ i ]))
 				pc_unequipitem(sd , sd->equip_index[ i ] , 2);
 	}
-
-	// Return loot to owner
-	if(sd->pd) pet_lootitem_drop(sd->pd, sd);
-
-	if(sd->state.storage_flag == 1) sd->state.storage_flag = 0;   // No need to Double Save Storage on Quit.
-
-	if(sd->ed) {
-		elemental_clean_effect(sd->ed);
-		unit_remove_map(&sd->ed->bl,CLR_TELEPORT);
+
+	// Return loot to owner
+	if( sd->pd ) pet_lootitem_drop(sd->pd, sd);
+	if( sd->state.storage_flag == 1 || sd->state.storage_flag == 3 )
+		sd->state.storage_flag = 0; // No need to Double Save Storage on Quit.
+
+	if( sd->ed ) {
+		elemental_clean_effect(sd->ed);
+		unit_remove_map(&sd->ed->bl,CLR_TELEPORT);
 	}
 
 	unit_remove_map_pc(sd,CLR_TELEPORT);
@@ -3359,11 +3421,8 @@
 		if(line[0] == '/' && line[1] == '/')
 			continue;
 		if(sscanf(line,"%[^:]: %[^\r\n]",w1,w2) < 2)
-			continue;
-
-		if(strcmpi(w1, "main_chat_nick")==0)
-			safestrncpy(main_chat_nick, w2, sizeof(main_chat_nick));
-		else
+			continue;
+		else
 			//Map Server SQL DB
 			if(strcmpi(w1,"map_server_ip")==0)
 				strcpy(map_server_ip, w2);
@@ -3702,12 +3761,13 @@
 	id_db->foreach(id_db,cleanup_db_sub);
 	chrif_char_reset_offline();
 	chrif_flush_fifo();
-
-	do_final_atcommand();
-	do_final_battle();
-	do_final_chrif();
-	do_final_clif();
-	do_final_npc();
+
+	do_final_atcommand();
+	do_final_battle();
+	do_final_channel();
+	do_final_chrif();
+	do_final_clif();
+	do_final_npc();
 	do_final_script();
 	do_final_instance();
 	do_final_itemdb();
@@ -3723,7 +3783,10 @@
 	do_final_unit();
 	do_final_battleground();
 	do_final_duel();
-	do_final_elemental();
+	do_final_elemental();	
+	do_final_achievement();
+	do_final_region();
+	do_final_faction();
 	do_final_maps();
 
 	map_db->destroy(map_db, map_db_final);
@@ -3991,12 +4054,13 @@
 	add_timer_func_list(map_clearflooritem_timer, "map_clearflooritem_timer");
 	add_timer_func_list(map_removemobs_timer, "map_removemobs_timer");
 	add_timer_interval(gettick()+1000, map_freeblock_timer, 0, 0, 60*1000);
-
-	do_init_atcommand();
-	do_init_battle();
-	do_init_instance();
-	do_init_chrif();
-	do_init_clif();
+
+	do_init_atcommand();
+	do_init_battle();
+	do_init_channel();
+	do_init_instance();
+	do_init_chrif();
+	do_init_clif();
 	do_init_script();
 	do_init_itemdb();
 	do_init_skill();
@@ -4012,12 +4076,15 @@
 	do_init_elemental();
 	do_init_quest();
 	do_init_npc();
-	do_init_unit();
-	do_init_battleground();
-	do_init_duel();
-
-	npc_event_do_oninit();  // Init npcs (OnInit)
-
+	do_init_unit();
+	do_init_battleground();
+	do_init_duel();
+	do_init_achievement();
+	do_init_faction();
+	do_init_region();
+
+	npc_event_do_oninit();	// Init npcs (OnInit)
+
 	if(console) {
 		//##TODO invoke a CONSOLE_START plugin event
 	}
Index: src/map/map.h
===================================================================
--- src/map/map.h	(revision 1953)
+++ src/map/map.h	(working copy)
@@ -55,12 +55,13 @@
 #define MAX_LEVEL 175
 #define MAX_DROP_PER_MAP 48
 #define MAX_IGNORE_LIST 20 // official is 14
-#define MAX_VENDING 12
-#define MAX_MAP_SIZE 512*512 // Wasn't there something like this already? Can't find it.. [Shinryo]
-
-// Added definitions for WoESE objects. [L0ne_W0lf]
-enum MOBID {
-    MOBID_EMPERIUM = 1288,
+#define MAX_VENDING 12
+#define MAX_MAP_SIZE 512*512 // Wasn't there something like this already? Can't find it.. [Shinryo]
+
+#define MAX_REGIONS 30
+// Added definitions for WoESE objects. [L0ne_W0lf]
+enum MOBID {
+    MOBID_EMPERIUM = 1288,
     MOBID_TREAS01 = 1324,
     MOBID_TREAS40 = 1363,
     MOBID_BARRICADE1 = 1905,
@@ -235,20 +236,38 @@
 //24 for npc name + 24 for label + 2 for a "::" and 1 for EOS
 #define EVENT_NAME_LENGTH ( NAME_LENGTH * 2 + 3 )
 
-#define DEFAULT_AUTOSAVE_INTERVAL 5*60*1000
-
-//Specifies maps where players may hit each other
-#define map_flag_vs(m) (map[m].flag.pvp || map[m].flag.gvg_dungeon || map[m].flag.gvg || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle) || map[m].flag.battleground)
-//Specifies maps that have special GvG/WoE restrictions
-#define map_flag_gvg(m) (map[m].flag.gvg || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle))
-//Specifies if the map is tagged as GvG/WoE (regardless of agit_flag status)
-#define map_flag_gvg2(m) (map[m].flag.gvg || map[m].flag.gvg_castle)
-// No Kill Steal Protection
-#define map_flag_ks(m) (map[m].flag.town || map[m].flag.pvp || map[m].flag.gvg || map[m].flag.battleground)
-
-//This stackable implementation does not means a BL can be more than one type at a time, but it's 
-//meant to make it easier to check for multiple types at a time on invocations such as map_foreach* calls [Skotlex]
-enum bl_type { 
+#define DEFAULT_AUTOSAVE_INTERVAL 5*60*1000
+
+//Specifies maps where players may hit each other
+#define map_flag_vs(m) (map[m].flag.pvp || map[m].flag.gvg_dungeon || map[m].flag.gvg || map[m].flag.fvf || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle) || map[m].flag.battleground || (pvpevent_flag && map[m].flag.pvp_event))
+//Specifies maps that have special GvG/WoE restrictions
+#define map_flag_gvg(m) (map[m].flag.gvg || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle))
+//Specifies if the map is tagged as GvG/WoE (regardless of agit_flag status)
+#define map_flag_gvg2(m) (map[m].flag.gvg || map[m].flag.gvg_castle)
+//Specifies maps that shares some GvG rules on battle/skills
+#define map_flag_gvg3(m) (map[m].flag.gvg || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle) || map[m].flag.battleground || (pvpevent_flag && map[m].flag.pvp_event))
+
+// Allow GvG item usage
+#define map_gvg_items(m) (map[m].flag.gvg || ((agit_flag || agit2_flag) && map[m].flag.gvg_castle) || map[m].flag.allow_woe_items)
+// Allow BG item usage
+#define map_bg_items(m) (map[m].flag.battleground || map[m].flag.pvp_event || (map[m].flag.pvp && battle_config.bg_items_on_pvp) || map[m].flag.allow_bg_items)
+
+// PK Mode - Not PK maps
+#define map_flag_nopvpmode(m) (map[m].flag.gvg || map[m].flag.pvp || map[m].flag.nopvpmode || map[m].flag.gvg_castle || map[m].flag.battleground || (pvpevent_flag && map[m].flag.pvp_event) || map[m].flag.fvf)
+// No Guild War Maps
+#define map_flag_noguildwar(m) (map[m].flag.town || map[m].flag.gvg || map[m].flag.fvf || map[m].flag.pvp || map[m].flag.noguildwar || map[m].flag.gvg_castle || map[m].flag.battleground || (pvpevent_flag && map[m].flag.pvp_event))
+// No Kill Steal Protection
+#define map_flag_ks(m) (map[m].flag.town || map[m].flag.pvp || map[m].flag.gvg || map[m].flag.fvf || map[m].flag.battleground || (pvpevent_flag && map[m].flag.pvp_event))
+// PvP Event Map
+#define map_pvpevent(m) (map[m].flag.pvp_event && pvpevent_flag)
+
+// WoE Map Types
+#define map_blocked_woe(m) ((agit_flag || agit2_flag) && woe_set && map[m].flag.gvg && map[m].flag.gvg_castle && woe_set != map[m].flag.woe_set)
+#define map_allowed_woe(m) ((agit_flag || agit2_flag) && map[m].flag.gvg && map[m].flag.gvg_castle && (!woe_set || woe_set == map[m].flag.woe_set))
+
+//This stackable implementation does not means a BL can be more than one type at a time, but it's
+//meant to make it easier to check for multiple types at a time on invocations such as map_foreach* calls [Skotlex]
+enum bl_type {
 	BL_NUL   = 0x000,
 	BL_PC    = 0x001,
 	BL_MOB   = 0x002,
@@ -264,13 +283,13 @@
 	BL_ALL   = 0xFFF,
 };
 
-//For common mapforeach calls. Since pets cannot be affected, they aren't included here yet.
-#define BL_CHAR (BL_PC|BL_MOB|BL_HOM|BL_MER|BL_ELEM)
-
-enum npc_subtype { WARP, SHOP, SCRIPT, CASHSHOP, TOMB };
-
-enum {
-	RC_FORMLESS=0,
+//For common mapforeach calls. Since pets cannot be affected, they aren't included here yet.
+#define BL_CHAR (BL_PC|BL_MOB|BL_HOM|BL_MER|BL_ELEM)
+
+enum npc_subtype { WARP, SHOP, SCRIPT, CASHSHOP, TOMB, SPSHOP };
+
+enum {
+	RC_FORMLESS=0,
 	RC_UNDEAD,
 	RC_BRUTE,
 	RC_PLANT,
@@ -318,12 +337,22 @@
 	ATF_LONG=0x08,
 	ATF_WEAPON=0x10,
 	ATF_MAGIC=0x20,
-	ATF_MISC=0x40,
-};
-
-struct block_list {
-	struct block_list *next,*prev;
-	int id;
+	ATF_MISC=0x40,
+};
+
+// Ranking System
+struct Ranking_Slot {
+	char name[NAME_LENGTH];
+	short class_;
+	int kills;
+	int score;
+	int dies;
+	int char_id;
+};
+
+struct block_list {
+	struct block_list *next,*prev;
+	int id;
 	int16 m,x,y;
 	enum bl_type type;
 };
@@ -353,12 +382,14 @@
 struct flooritem_data {
 	struct block_list bl;
 	unsigned char subx,suby;
-	int cleartimer;
-	int first_get_charid,second_get_charid,third_get_charid;
-	unsigned int first_get_tick,second_get_tick,third_get_tick;
-	struct item item_data;
-};
-
+	int cleartimer;
+	int first_get_charid,second_get_charid,third_get_charid;
+	unsigned int first_get_tick,second_get_tick,third_get_tick;
+	int guild_id; // Super WoE Security
+	bool no_bsgreed; // [Zephyrus] @flooritem
+	struct item item_data;
+};
+
 enum _sp {
 	SP_SPEED,SP_BASEEXP,SP_JOBEXP,SP_KARMA,SP_MANNER,SP_HP,SP_MAXHP,SP_SP,	// 0-7
 	SP_MAXSP,SP_STATUSPOINT,SP_0a,SP_BASELEVEL,SP_SKILLPOINT,SP_STR,SP_AGI,SP_VIT,	// 8-15
@@ -522,22 +553,33 @@
 	char name[MAP_NAME_LENGTH];
 	uint16 index; // The map index used by the mapindex* functions.
 	struct mapcell* cell; // Holds the information of each map cell (NULL if the map is not on this map-server).
-	struct block_list **block;
-	struct block_list **block_mob;
-	int16 m;
-	int16 xs,ys; // map dimensions (in cells)
-	int16 bxs,bys; // map dimensions (in blocks)
-	int16 bgscore_lion, bgscore_eagle; // Battleground ScoreBoard
-	int npc_num;
-	int users;
-	int users_pvp;
-	int iwall_num; // Total of invisible walls in this map
-	struct map_flag {
-		unsigned town : 1; // [Suggestion to protect Mail System]
-		unsigned autotrade : 1;
-		unsigned allowks : 1; // [Kill Steal Protection]
-		unsigned nomemo : 1;
-		unsigned noteleport : 1;
+	struct block_list **block;
+	struct block_list **block_mob;
+	int16 m;
+	int region_id;
+	int16 xs,ys; // map dimensions (in cells)
+	int16 bxs,bys; // map dimensions (in blocks)
+	int16 bgscore_lion, bgscore_eagle, bgscore_top; // Battleground ScoreBoard
+
+	bool pvpe_area;
+	short pvpe_x1, pvpe_y1, pvpe_x2, pvpe_y2; // PVP Event Reward and Points Area
+
+	int npc_num;
+	int users;
+	int users_pvp;
+	int pjmuertos, mobmuertos;
+	int iwall_num; // Total of invisible walls in this map
+	struct map_flag {
+		unsigned diecounter : 1;
+		unsigned residentevil : 2;
+		unsigned nopvpmode : 1;
+		unsigned noguildwar : 1;
+		unsigned town : 1; // [Suggestion to protect Mail System]
+		unsigned autotrade : 1;
+		unsigned noemergencycall : 1;
+		unsigned allowks : 1; // [Kill Steal Protection]
+		unsigned nomemo : 1;
+		unsigned noteleport : 1;
 		unsigned noreturn : 1;
 		unsigned monster_noteleport : 1;
 		unsigned nosave : 1;
@@ -545,17 +587,19 @@
 		unsigned noexppenalty : 1;
 		unsigned pvp : 1;
 		unsigned pvp_noparty : 1;
-		unsigned pvp_noguild : 1;
-		unsigned pvp_nightmaredrop :1;
-		unsigned pvp_nocalcrank : 1;
-		unsigned gvg_castle : 1;
-		unsigned gvg : 1; // Now it identifies gvg versus maps that are active 24/7
-		unsigned gvg_dungeon : 1; // Celest
-		unsigned gvg_noparty : 1;
-		unsigned battleground : 2; // [BattleGround System]
-		unsigned nozenypenalty : 1;
-		unsigned notrade : 1;
-		unsigned noskill : 1;
+		unsigned pvp_noguild : 1;
+		unsigned pvp_nightmaredrop :1;
+		unsigned pvp_nocalcrank : 1;
+		unsigned pvp_event : 1;
+		unsigned gvg_castle : 1;
+		unsigned gvg : 1; // Now it identifies gvg versus maps that are active 24/7
+		unsigned gvg_dungeon : 1; // Celest
+		unsigned gvg_noparty : 1;
+		unsigned gvg_noalliance : 1;
+		unsigned battleground : 3; // [BattleGround System]
+		unsigned nozenypenalty : 1;
+		unsigned notrade : 1;
+		unsigned noskill : 1;
 		unsigned nowarp : 1;
 		unsigned nowarpto : 1;
 		unsigned noicewall : 1; // [Valaris]
@@ -577,16 +621,28 @@
 		unsigned nomobloot	: 1; // [Lorky]
 		unsigned nomvploot	: 1; // [Lorky]
 		unsigned nightenabled :1; //For night display. [Skotlex]
-		unsigned restricted	: 1; // [Komurka]
-		unsigned nodrop : 1;
-		unsigned novending : 1;
-		unsigned loadevent : 1;
-		unsigned nochat :1;
-		unsigned partylock :1;
-		unsigned guildlock :1;
-		unsigned src4instance : 1; // To flag this map when it's used as a src map for instances
-		unsigned reset :1; // [Daegaladh]
-	} flag;
+		unsigned restricted	: 1; // [Komurka]
+		unsigned nodrop : 1;
+		unsigned novending : 1;
+		unsigned vending_cell : 1;
+		unsigned loadevent : 1;
+		unsigned nochat :1;
+		unsigned partylock :1;
+		unsigned guildlock :1;
+
+		unsigned nostorage : 1;
+		unsigned noguildstorage : 1;
+
+		unsigned blocked : 1; // Blocked Map
+		unsigned int woe_set; // WoE Flag
+		unsigned ancient : 1; // Ancient Map "Second Class - First Class - Novice" Only
+		unsigned allow_woe_items : 1;
+		unsigned allow_bg_items : 1;
+		unsigned fvf : 1; // Faction versus Faction
+
+		unsigned src4instance : 1; // To flag this map when it's used as a src map for instances
+		unsigned reset :1; // [Daegaladh]
+	} flag;
 	struct point save;
 	struct npc_data *npc[MAX_NPC_PER_MAP];
 	struct {
@@ -598,12 +654,15 @@
 	struct spawn_data *moblist[MAX_MOB_LIST_PER_MAP]; // [Wizputer]
 	int mob_delete_timer;	// [Skotlex]
 	int zone;	// zone number (for item/skill restrictions)
-	int jexp;	// map experience multiplicator
-	int bexp;	// map experience multiplicator
-	int nocommand; //Blocks @/# commands for non-gms. [Skotlex]
-	/**
-	 * Ice wall reference counter for bugreport:3574
-	 * - since there are a thounsand mobs out there in a lot of maps checking on,
+	int jexp;	// map experience multiplicator
+	int bexp;	// map experience multiplicator
+	int nocommand; //Blocks @/# commands for non-gms. [Skotlex]
+	int guild_max;
+	int party_max;
+
+	/**
+	 * Ice wall reference counter for bugreport:3574
+	 * - since there are a thounsand mobs out there in a lot of maps checking on,
 	 * - every targetting for icewall on attack path would just be a waste, so,
 	 * - this counter allows icewall checking be only run when there is a actual ice wall on the map
 	 **/
@@ -640,12 +699,14 @@
 
 extern int autosave_interval;
 extern int minsave_interval;
-extern int save_settings;
-extern int agit_flag;
-extern int agit2_flag;
-extern int night_flag; // 0=day, 1=night [Yor]
-extern int enable_spy; //Determines if @spy commands are active.
-extern char db_path[256];
+extern int save_settings;
+extern int agit_flag;
+extern int agit2_flag;
+extern int woe_set; 
+extern int pvpevent_flag; // Ranking System
+extern int night_flag; // 0=day, 1=night [Yor]
+extern int enable_spy; //Determines if @spy commands are active.
+extern char db_path[256];
 
 extern char motd_txt[];
 extern char help_txt[];
@@ -689,13 +750,14 @@
 bool map_addnpc(int16 m,struct npc_data *);
 
 // map item
-int map_clearflooritem_timer(int tid, unsigned int tick, int id, intptr_t data);
-int map_removemobs_timer(int tid, unsigned int tick, int id, intptr_t data);
-void map_clearflooritem(struct block_list* bl);
-int map_addflooritem(struct item *item_data,int amount,int16 m,int16 x,int16 y,int first_charid,int second_charid,int third_charid,int flags);
-
-// player to map session
-void map_addnickdb(int charid, const char* nick);
+int map_clearflooritem_timer(int tid, unsigned int tick, int id, intptr_t data);
+int map_removemobs_timer(int tid, unsigned int tick, int id, intptr_t data);
+void map_clearflooritem(struct block_list* bl);
+int map_addflooritem(struct item *item_data,int amount,int16 m,int16 x,int16 y,int first_charid,int second_charid,int third_charid,int guild_id,int flags);
+int map_addflooritem_area(struct block_list* bl, int16 m, int16 x, int16 y, int nameid, int amount); // [Zephyrus]
+
+// player to map session
+void map_addnickdb(int charid, const char* nick);
 void map_delnickdb(int charid, const char* nick);
 void map_reqnickdb(struct map_session_data* sd,int charid);
 const char* map_charid2nick(int charid);
@@ -793,15 +855,12 @@
 typedef struct mercenary_data   TBL_MER;
 typedef struct elemental_data	TBL_ELEM;
 
-#define BL_CAST(type_, bl) \
-	( ((bl) == (struct block_list*)NULL || (bl)->type != (type_)) ? (T ## type_ *)NULL : (T ## type_ *)(bl) )
-
-
-extern char main_chat_nick[16];
-
-#ifdef BETA_THREAD_TEST
-
-extern char default_codepage[32];
+#define BL_CAST(type_, bl) \
+	( ((bl) == (struct block_list*)NULL || (bl)->type != (type_)) ? (T ## type_ *)NULL : (T ## type_ *)(bl) )
+
+#ifdef BETA_THREAD_TEST
+
+extern char default_codepage[32];
 extern int map_server_port;
 extern char map_server_ip[32];
 extern char map_server_id[32];
Index: src/map/mapreg_sql.c
===================================================================
--- src/map/mapreg_sql.c	(revision 1953)
+++ src/map/mapreg_sql.c	(working copy)
@@ -20,12 +20,15 @@
 #include "../common/showmsg.h"
 #include "../common/sql.h"
 #include "../common/strlib.h"
-#include "../common/timer.h"
-#include "map.h" // mmysql_handle
-#include "script.h"
-#include <stdlib.h>
-#include <string.h>
-
+#include "../common/timer.h"
+#include "map.h" // mmysql_handle
+#include "script.h"
+#include "itemdb.h"
+#include "region.h"
+
+#include <stdlib.h>
+#include <string.h>
+
 static DBMap *mapreg_db = NULL; // int var_id -> int value
 static DBMap *mapregstr_db = NULL; // int var_id -> char* value
 
@@ -52,7 +55,11 @@
 	int num = (uid & 0x00ffffff);
 	int i   = (uid & 0xff000000) >> 24;
 	const char *name = get_str(num);
+	struct region_data* rd;
 
+	if( !stricmp(name,"$Region") && i > 0 && i < SCRIPT_MAX_ARRAYSIZE && (rd = region_search(i)) != NULL )
+		region_set_guild(i,val);
+
 	if(val != 0) {
 		if(idb_iput(mapreg_db,uid,val))
 			mapreg_dirty = true; // already exists, delay write
Index: src/map/mob.c
===================================================================
--- src/map/mob.c	(revision 1953)
+++ src/map/mob.c	(working copy)
@@ -25,12 +25,13 @@
 #include "../common/strlib.h"
 #include "../common/utils.h"
 #include "../common/socket.h"
-
-#include "map.h"
-#include "path.h"
-#include "clif.h"
-#include "intif.h"
-#include "pc.h"
+
+#include "map.h"
+#include "path.h"
+#include "channel.h"
+#include "clif.h"
+#include "intif.h"
+#include "pc.h"
 #include "pet.h"
 #include "status.h"
 #include "mob.h"
@@ -45,12 +46,14 @@
 #include "npc.h"
 #include "log.h"
 #include "script.h"
-#include "atcommand.h"
-#include "date.h"
-#include "quest.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "atcommand.h"
+#include "date.h"
+#include "quest.h"
+#include "achievement.h"
+#include "region.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <math.h>
@@ -106,12 +109,13 @@
 
 /*==========================================
  * Local prototype declaration   (only required thing)
- *------------------------------------------*/
-static int mob_makedummymobdb(int);
-static int mob_spawn_guardian_sub(int tid, unsigned int tick, int id, intptr_t data);
-int mob_skill_id2skill_idx(int class_,uint16 skill_id);
-
-/*==========================================
+ *------------------------------------------*/
+static int mob_makedummymobdb(int);
+static int mob_spawn_guardian_sub(int tid, unsigned int tick, int id, intptr_t data);
+int mobskill_use(struct mob_data *md,unsigned int tick,int event);
+int mob_skill_id2skill_idx(int class_,uint16 skill_id);
+
+/*==========================================
  * Mob is searched with a name.
  *------------------------------------------*/
 int mobdb_searchname(const char *str)
@@ -216,13 +220,13 @@
  * Founds up to N matches. Returns number of matches [Skotlex]
  *------------------------------------------*/
 int mobdb_searchname_array(struct mob_db **data, int size, const char *str)
-{
-	int count = 0, i;
-	struct mob_db *mob;
-	for(i=0; i<=MAX_MOB_DB; i++) {
-		mob = mob_db(i);
-		if(mob == mob_dummy || mob_is_clone(i))   //keep clones out (or you leak player stats)
-			continue;
+{
+	int count = 0, i;
+	struct mob_db* mob;
+	for(i=MIN_MOB_DB;i<=MAX_MOB_DB;i++){
+		mob = mob_db(i);
+		if (mob == mob_dummy || mob_is_clone(i) ) //keep clones out (or you leak player stats)
+			continue;
 		if(!mobdb_searchname_array_sub(mob, str)) {
 			if(count < size)
 				data[count] = mob;
@@ -230,12 +234,32 @@
 		}
 	}
 	return count;
-}
-
-/*==========================================
- * Id Mob is checked.
- *------------------------------------------*/
-int mobdb_checkid(const int id)
+}
+
+/*==========================================
+ * Mob Search by Level. Returns number of matches
+ *------------------------------------------*/
+int mobdb_searchlevel_array(struct mob_db **data, int size, int level)
+{
+	int count = 0, i;
+	struct mob_db *mob;
+	for( i = MIN_MOB_DB; i <= MAX_MOB_DB; i++ )
+	{
+		mob = mob_db(i);
+		if( mob == mob_dummy || mob_is_clone(i) || mob->lv != level || !(mob->base_exp || mob->job_exp) || mob->spawn[0].qty < 1 )
+			continue;
+		if( count < size )
+			data[count] = mob;
+		count++;
+	}
+
+	return count;
+}
+
+/*==========================================
+ * Id Mob is checked.
+ *------------------------------------------*/
+int mobdb_checkid(const int id)
 {
 	if(mob_db(id) == mob_dummy)
 		return 0;
@@ -348,12 +372,37 @@
 
 	if(i >= MAX_MOB_DB)  // no suitable monster found, use fallback for given list
 		class_ = mob_db_data[0]->summonper[type];
-	return class_;
-}
-
-/*==========================================
- * Kill Steal Protection [Zephyrus]
- *------------------------------------------*/
+	return class_;
+}
+
+int mob_get_random_id_lv(int lv, int range)
+{
+	int i, count = 0;
+	struct mob_db* mob;
+	int lv_min = lv - range;
+	int lv_max = lv + range;
+	int Mob_id[MOB_CLONE_START];
+
+	// Count Mobs
+	for( i = MIN_MOB_DB; i < MOB_CLONE_START; i++ )
+	{
+		mob = mob_db(i);
+		if( mob == mob_dummy || !mob->hunting || mob->lv < lv_min || mob->lv > lv_max )
+			continue;
+
+		Mob_id[count] = i; // Store Valid ID
+		count++;
+	}
+
+	if( count == 0 )
+		return 0; // Nothing to do
+
+	return Mob_id[rand()%count];
+}
+
+/*==========================================
+ * Kill Steal Protection [Zephyrus]
+ *------------------------------------------*/
 bool mob_ksprotected(struct block_list *src, struct block_list *target)
 {
 	struct block_list *s_bl, *t_bl;
@@ -385,15 +434,15 @@
 	t_sd = BL_CAST(BL_PC,s_bl);
 
 	do {
-		if(map[md->bl.m].flag.allowks || map_flag_ks(md->bl.m))
-			return false; // Ignores GVG, PVP and AllowKS map flags
+		if( map[md->bl.m].flag.allowks || map_flag_ks(md->bl.m) )
+			return false; // Ignores GVG, PVP and AllowKS map flags
+
+		if( md->db->mexp || md->master_id || md->option.is_event || md->db->ffa )
+			return false; // MVP, Slaves and Event mobs ignores KS
+
+		if( (sce = md->sc.data[SC_KSPROTECTED]) == NULL )
+			break; // No KS Protected
 
-		if(md->db->mexp || md->master_id)
-			return false; // MVP, Slaves mobs ignores KS
-
-		if((sce = md->sc.data[SC_KSPROTECTED]) == NULL)
-			break; // No KS Protected
-
 		if(sd->bl.id == sce->val1 ||  // Same Owner
 		   (sce->val2 == 2 && sd->status.party_id && sd->status.party_id == sce->val3) || // Party KS allowed
 		   (sce->val2 == 3 && sd->status.guild_id && sd->status.guild_id == sce->val4))  // Guild KS allowed
@@ -433,6 +482,104 @@
 	status_change_start(src, target, SC_KSPROTECTED, 10000, sd->bl.id, sd->state.noks, sd->status.party_id, sd->status.guild_id, battle_config.ksprotection, 0);
 
 	return false;
+}
+
+/*==========================================
+ * Script de Evento - Crea un Area de Explosiones que puede dañar segun el tipo:
+ * 0 = Jugadores y Mob
+ * 1 = Solamente Mob
+ *------------------------------------------*/
+int mob_demolition (int map, short x, short y, short ratio, int type, int amount, unsigned int power)
+{
+	struct mob_data *md = NULL;
+	short x1 = x - (ratio / 2), y1 = y - (ratio / 2);
+	int count;
+
+	if (ratio <= 0)
+		ratio = 1;
+
+	for (count = 0; count < amount; count++) {
+		md = mob_once_spawn_sub(NULL, map, rand()%(ratio)+x1, rand()%(ratio)+y1, "--ja--", 1142, "", SZ_SMALL, AI_NONE);
+		
+		if (!md)
+			continue;
+
+		md->option.is_event = md->option.no_expdrop = true;
+		md->option.ai_type = (type < 1)?0:1;
+		if( md->option.ai_type == 1 ) md->special_state.ai = 1;
+		md->option.max_hp = power;
+		mob_spawn (md); // Crea el MOB
+		clif_misceffect(&md->bl, 92); // Meteor Storm
+
+		mobskill_use(md, gettick(), (rand()%100<50)?MSC_AFTERSKILL:MSC_SKILLUSED);
+	}
+
+	return 0;
+}
+
+// The MOB appearance for one time (for scripts) [TAB]
+// Creacion de MOB especial sin Drop ni EXP para los GM's menores a 40
+
+int mob_once_spawn_especial(struct map_session_data *sd, const char *mapname, short x, short y, const char *mobname, int class_, int amount, const char *event, int hp_mod, short size, short ai_type, bool no_slaves, short allow_warp, short hp_show, bool announce_hprate, bool announce_killer, bool no_expdrop, int TeamID, short item_drop, short item_amount, bool is_war, short exp_boost, bool drop_boost)
+{
+	struct mob_data *md = NULL;
+	struct region_data* rd;
+	int m, count, lv = 255;
+
+	if(sd) lv = sd->status.base_level;
+
+	if( sd && strcmp(mapname,"this") == 0 )
+		m = sd->bl.m;
+	else
+		m = map_mapname2mapid(mapname);
+
+	if( m < 0 || amount <= 0 )
+		return 0;
+
+	size = cap_value(size, 0, 2);
+
+	for( count = 0; count < amount; count++ )
+	{
+		if( (md = mob_once_spawn_sub(sd ? &sd->bl : NULL, m, x, y, mobname, (class_ < 0 ? mob_get_random_id(-class_-1, battle_config.random_monster_checklv ? 3 : 1, lv) : class_) + (MAX_MOB_DB * size), item_drop == -1 ? "DoTreasure::OnTreasureOpen" : event, SZ_SMALL, AI_NONE)) == NULL )
+			continue;
+
+		// Mob Configuration:
+		md->option.is_event = true;
+		md->option.no_expdrop = no_expdrop;
+		md->option.ai_type = ai_type;
+		if( ai_type == 1 ) md->special_state.ai = 1;
+		md->option.no_slaves = no_slaves;
+		md->option.allow_warp = allow_warp;
+		md->option.hp_show = hp_show;
+		md->option.announce_hprate = announce_hprate;
+		md->option.announce_killer = announce_killer;
+		if( map[m].flag.gvg ) md->option.guild_id = TeamID;
+		else if( map[m].flag.pvp ) md->option.party_id = TeamID;
+		else if( map[m].flag.fvf ) md->option.faction_id = TeamID;
+		md->option.exp_boost = exp_boost;
+		md->option.drop_boost = drop_boost;
+		if( item_drop > 0 )
+		{
+			md->option.item_drop = item_drop;
+			md->option.item_amount = cap_value(item_amount,1,200);
+		}
+
+		if( is_war && (rd = region_search(map[m].region_id)) != NULL && !map_flag_vs(m) )
+		{
+			struct guild *g = guild_search(rd->guild_id);
+			md->option.is_war = is_war;
+			md->option.guild_id = rd->guild_id;
+			md->option.guild_emblem_id = (g == NULL) ? 0 : g->emblem_id;
+		}
+
+		if( hp_mod > 0 )
+			md->option.max_hp = hp_mod;
+
+		mob_spawn (md);
+		if( class_ < 0 && battle_config.dead_branch_active )
+			sc_start4(NULL, &md->bl, SC_MODECHANGE, 100, 1, 0, MD_AGGRESSIVE|MD_CANATTACK|MD_CANMOVE, 0, 60000);
+	}
+	return (md)?md->bl.id : 0;
 }
 
 struct mob_data *mob_once_spawn_sub(struct block_list *bl, int16 m, int16 x, int16 y, const char *mobname, int class_, const char *event, unsigned int size, unsigned int ai) {
@@ -505,12 +652,13 @@
 					memcpy(md->guardian_data->guild_name, g->name, NAME_LENGTH);
 				} else if(gc->guild_id) //Guild not yet available, retry in 5.
 					add_timer(gettick()+5000,mob_spawn_guardian_sub,md->bl.id,md->guardian_data->guild_id);
-			}
-		}   // end addition [Valaris]
-
-		mob_spawn(md);
-
-		if(class_ < 0 && battle_config.dead_branch_active)
+			}
+		}	// end addition [Valaris]
+
+		memset(&md->option, 0, sizeof(md->option)); // MobSettings
+		mob_spawn(md);
+
+		if (class_ < 0 && battle_config.dead_branch_active)
 			//Behold Aegis's masterful decisions yet again...
 			//"I understand the "Aggressive" part, but the "Can Move" and "Can Attack" is just stupid" - Poki#3
 			sc_start4(NULL,&md->bl, SC_MODECHANGE, 100, 1, 0, MD_AGGRESSIVE|MD_CANATTACK|MD_CANMOVE|MD_ANGRY, 0, 60000);
@@ -716,13 +864,13 @@
 	return md->bl.id;
 }
 
-/*==========================================
- * Summoning BattleGround [Zephyrus]
- *------------------------------------------*/
-int mob_spawn_bg(const char *mapname, short x, short y, const char *mobname, int class_, const char *event, unsigned int bg_id)
-{
-	struct mob_data *md = NULL;
-	struct spawn_data data;
+/*==========================================
+ * Summoning BattleGround [Zephyrus]
+ *------------------------------------------*/
+int mob_spawn_bg(const char* mapname, short x, short y, const char* mobname, int class_, const char* event, int bg_id)
+{
+	struct mob_data *md = NULL;
+	struct spawn_data data;
 	int16 m;
 
 	if((m = map_mapname2mapid(mapname)) < 0) {
@@ -832,13 +980,13 @@
 	return 0;
 }
 
-/*==========================================
- * spawn timing calculation
- *------------------------------------------*/
-int mob_setdelayspawn(struct mob_data *md)
-{
-	unsigned int spawntime, mode;
-	struct mob_db *db;
+/*==========================================
+ * spawn timing calculation
+ *------------------------------------------*/
+int mob_setdelayspawn(struct mob_data* md, struct map_session_data* sd)
+{
+	unsigned int spawntime, mode;
+	struct mob_db *db;
 
 	if(!md->spawn)  //Doesn't has respawn data!
 		return unit_free(&md->bl,CLR_DEAD);
@@ -866,13 +1014,19 @@
 
 	if(spawntime < 500)  //Min respawn time (is it needed?)
 		spawntime = 500;
+
+	if( md->spawn_timer != INVALID_TIMER )
+		delete_timer(md->spawn_timer, mob_delayspawn);
+
+	if( sd && battle_config.mob_graveyard && (md->status.mode&MD_BOSS) && spawntime >= 60000 )
+	{ // Graveyard System - Only MVP with 1 minute spawn or more
+		npc_duplicate4graveyard(&md->bl,&sd->bl);
+	}
+
+	md->spawn_timer = add_timer(gettick()+spawntime, mob_delayspawn, md->bl.id, 0);
+	return 0;
+}
 
-	if(md->spawn_timer != INVALID_TIMER)
-		delete_timer(md->spawn_timer, mob_delayspawn);
-	md->spawn_timer = add_timer(gettick()+spawntime, mob_delayspawn, md->bl.id, 0);
-	return 0;
-}
-
 int mob_count_sub(struct block_list *bl, va_list ap)
 {
 	int mobid[10], i;
@@ -961,13 +1115,20 @@
 	md->lootitem_count = 0;
 
 	if(md->db->option)
-		// Added for carts, falcons and pecos for cloned monsters. [Valaris]
-		md->sc.option = md->db->option;
+		// Added for carts, falcons and pecos for cloned monsters. [Valaris]
+		md->sc.option = md->db->option;
+
+	if( md->graveyard_npc_id )
+	{ // Unload Graveyard NPC
+		struct npc_data* nd = map_id2nd(md->graveyard_npc_id);
+		if( nd ) npc_unload(nd,true);
+		md->graveyard_npc_id = 0;
+	}
+
+	// MvP tomb [GreenBox]
+	if ( md->tomb_nid )
+		mvptomb_destroy(md);
 
-	// MvP tomb [GreenBox]
-	if(md->tomb_nid)
-		mvptomb_destroy(md);
-
 	map_addblock(&md->bl);
 	if(map[md->bl.m].users)
 		clif_spawn(&md->bl);
@@ -1362,13 +1523,13 @@
 }
 
 int mob_warpchase(struct mob_data *md, struct block_list *target)
-{
-	struct npc_data *warp = NULL;
-	int distance = AREA_SIZE;
-	if(!(target && battle_config.mob_ai&0x40 && battle_config.mob_warp&1))
-		return 0; //Can't warp chase.
-
-	if(target->m == md->bl.m && check_distance_bl(&md->bl, target, AREA_SIZE))
+{
+	struct npc_data *warp = NULL;
+	int distance = AREA_SIZE;
+	if (!(target && battle_config.mob_ai&0x40 && battle_config.mob_warp&1) || !md->option.allow_warp)
+		return 0; //Can't warp chase.
+
+	if (target->m == md->bl.m && check_distance_bl(&md->bl, target, AREA_SIZE))
 		return 0; //No need to do a warp chase.
 
 	if(md->ud.walktimer != INVALID_TIMER &&
@@ -1785,50 +1946,62 @@
 	struct item_drop *ditem, *ditem_prev;
 	list=(struct item_drop_list *)data;
 	ditem = list->item;
-	while(ditem) {
-		map_addflooritem(&ditem->item_data,ditem->item_data.amount,
-		                 list->m,list->x,list->y,
-		                 list->first_charid,list->second_charid,list->third_charid,0);
-		ditem_prev = ditem;
-		ditem = ditem->next;
-		ers_free(item_drop_ers, ditem_prev);
+	while (ditem) {
+		map_addflooritem(&ditem->item_data,ditem->item_data.amount,
+			list->m,list->x,list->y,
+			list->first_charid,list->second_charid,list->third_charid,0,0);
+		ditem_prev = ditem;
+		ditem = ditem->next;
+		ers_free(item_drop_ers, ditem_prev);
 	}
 	ers_free(item_drop_list_ers, list);
 	return 0;
 }
 
 /*==========================================
- * Sets the item_drop into the item_drop_list.
- * Also performs logging and autoloot if enabled.
- * rate is the drop-rate of the item, required for autoloot.
- * flag : Killed only by homunculus?
- *------------------------------------------*/
-static void mob_item_drop(struct mob_data *md, struct item_drop_list *dlist, struct item_drop *ditem, int loot, int drop_rate, unsigned short flag)
-{
-	TBL_PC *sd;
+ * Sets the item_drop into the item_drop_list.
+ * Also performs logging and autoloot if enabled.
+ * rate is the drop-rate of the item, required for autoloot.
+ * flag : Killed only by AI (Mer-Hom)?
+ *------------------------------------------*/
+static void mob_item_drop(struct mob_data *md, struct item_drop_list *dlist, struct item_drop *ditem, int loot, int drop_rate, bool flag)
+{
+	TBL_PC* sd;
+	int i = MAX_AUTOLOOTID;
+
+	//Logs items, dropped by mobs [Lupus]
+	log_pick_mob(md, loot?LOG_TYPE_LOOT:LOG_TYPE_PICKDROP_MONSTER, -ditem->item_data.amount, &ditem->item_data);
 
-	//Logs items, dropped by mobs [Lupus]
-	log_pick_mob(md, loot?LOG_TYPE_LOOT:LOG_TYPE_PICKDROP_MONSTER, -ditem->item_data.amount, &ditem->item_data);
-
-	sd = map_charid2sd(dlist->first_charid);
-	if(sd == NULL) sd = map_charid2sd(dlist->second_charid);
-	if(sd == NULL) sd = map_charid2sd(dlist->third_charid);
-
-	if(sd
-	   && (drop_rate <= sd->state.autoloot || pc_isautolooting(sd, ditem->item_data.nameid))
-	   && (battle_config.idle_no_autoloot == 0 || DIFF_TICK(last_tick, sd->idletime) < battle_config.idle_no_autoloot)
-	   && (battle_config.homunculus_autoloot?1:!flag)
-#ifdef AUTOLOOT_DISTANCE
-	   && sd->bl.m == md->bl.m
-	   && check_distance_blxy(&sd->bl, dlist->x, dlist->y, AUTOLOOT_DISTANCE)
-#endif
-	  ) { //Autoloot.
-		if(party_share_loot(party_search(sd->status.party_id),
-		                    sd, &ditem->item_data, sd->status.char_id) == 0
-		  ) {
-			ers_free(item_drop_ers, ditem);
-			return;
-		}
+	sd = map_charid2sd(dlist->first_charid);
+	if( sd == NULL ) sd = map_charid2sd(dlist->second_charid);
+	if( sd == NULL ) sd = map_charid2sd(dlist->third_charid);
+	
+	// Display Drop
+	if( sd && sd->state.displaydrop && drop_rate <= sd->state.displaydrop )
+	{
+		char message[128];
+		sprintf(message, "Monster dropped %d %s (drop rate: %0.02f%%)", ditem->item_data.amount, itemdb_exists(ditem->item_data.nameid)->jname, (float)drop_rate / 100.);
+		clif_disp_onlyself(sd, message, strlen(message));
+	}
+
+	if( sd )
+		ARR_FIND(0, MAX_AUTOLOOTID, i, sd->aloot.nameid[i] == ditem->item_data.nameid);
+
+	if( sd
+		&& ( drop_rate <= sd->aloot.rate || i < MAX_AUTOLOOTID )
+		&& ( battle_config.idle_no_autoloot == 0 || DIFF_TICK(last_tick, sd->idletime) < battle_config.idle_no_autoloot )
+		&& ( battle_config.homunculus_autoloot?1:!flag )
+#ifdef AUTOLOOT_DISTANCE
+		&& sd->bl.m == md->bl.m
+		&& check_distance_blxy(&sd->bl, dlist->x, dlist->y, AUTOLOOT_DISTANCE)
+#endif
+	)
+	{ // Autoloot.
+		if( party_share_loot(party_search(sd->status.party_id), sd, &ditem->item_data, sd->status.char_id) == 0 )
+		{
+			ers_free(item_drop_ers, ditem);
+			return;
+		}
 	}
 	ditem->next = dlist->item;
 	dlist->item = ditem;
@@ -1885,13 +2058,48 @@
 
 	if(!bl) return 0;
 	status_revive(bl, (uint8)data, 0);
-	return 1;
-}
+	return 1;
+}
+
+// [Zephyrus] City Heart State
+
+void cityheartinfo(struct mob_data *md, int damage)
+{
+	double hp_after_rate, hp_before_rate, hp_rate;
+	char output[255];
+	int i;
+	
+	hp_after_rate = (double)(md->status.hp + damage) * 100.0 / (double)md->status.max_hp; // % de HP antes del dao
+	hp_before_rate = (double)md->status.hp * 100.0 / (double)md->status.max_hp;
+
+	for( i = 9; i > 0; i-- )
+	{
+		hp_rate = (double)i * 10.0;
+		if( (hp_rate < hp_after_rate) && (hp_rate >= hp_before_rate) )
+		{ // El mob esta en el rango de avisos
+			if( md->option.ai_type == 1 )
+			{
+				sprintf(output, "[Aliado] %s al %d%% de su HP!", md->name, i * 10);
+				clif_broadcast2(&md->bl, output, strlen(output) + 1, 0x0066CC, 0x190, 12, 0, 0, ALL_SAMEMAP);
+			}
+			else
+			{
+				sprintf(output, "[Enemigo] %s al %d%% de su HP!", md->name, i * 10);
+				clif_broadcast2(&md->bl, output, strlen(output) + 1, 0xFFFFFF, 0x190, 12, 0, 0, ALL_SAMEMAP);
+			}
+			return;
+		}
+		else if( hp_rate < hp_before_rate )
+			return; // Termina la revisin ya que no est en el rango
+	}
+
+	return;
+}
+
+void mob_log_damage(struct mob_data *md, struct block_list *src, int damage)
+{
+	int char_id = 0, flag = MDLF_NORMAL;
 
-void mob_log_damage(struct mob_data *md, struct block_list *src, int damage)
-{
-	int char_id = 0, flag = MDLF_NORMAL;
-
 	if(damage < 0)
 		return; //Do nothing for absorbed damage.
 	if(!damage && !(src->type&DEFAULT_ENEMY_TYPE(md)))
@@ -1917,8 +2125,9 @@
 				break;
 			}
 		case BL_MER: {
-				struct mercenary_data *mer = (TBL_MER *)src;
-				if(mer->master)
+			struct mercenary_data *mer = (TBL_MER*)src;
+			flag = MDLF_MERC;
+			if( mer->master )
 					char_id = mer->master->status.char_id;
 				if(damage)
 					md->attacked_id = src->id;
@@ -2000,12 +2209,13 @@
 		else if(md->tdmg == UINT_MAX)
 			damage = 0; //Stop recording damage once the cap has been reached.
 		else { //Cap damage log...
-			damage = (int)(UINT_MAX - md->tdmg);
-			md->tdmg = UINT_MAX;
-		}
-		if(md->state.aggressive) {  //No longer aggressive, change to retaliate AI.
-			md->state.aggressive = 0;
-			if(md->state.skillstate== MSS_ANGRY)
+			damage = (int)(UINT_MAX - md->tdmg);
+			md->tdmg = UINT_MAX;
+		}
+		if (md->option.announce_hprate) cityheartinfo(md, damage);
+		if (md->state.aggressive) { //No longer aggressive, change to retaliate AI.
+			md->state.aggressive = 0;
+			if(md->state.skillstate== MSS_ANGRY)
 				md->state.skillstate = MSS_BERSERK;
 			if(md->state.skillstate== MSS_FOLLOW)
 				md->state.skillstate = MSS_RUSH;
@@ -2013,15 +2223,16 @@
 		//Log damage
 		if(src)
 			mob_log_damage(md, src, damage);
-		md->dmgtick = gettick();
-	}
+		md->dmgtick = gettick();
+	}
+
+	clif_mobnameack(NULL, md, 1);
+	if( md->option.hp_show == 1 )
+		clif_mobhpmeter(md);
+
+	if (!src)
+		return;
 
-	if(battle_config.show_mob_info&3)
-		clif_charnameack(0, &md->bl);
-
-	if(!src)
-		return;
-
 #if PACKETVER >= 20120404
 	if(!(md->status.mode&MD_BOSS)) {
 		int i;
@@ -2045,22 +2256,24 @@
  *------------------------------------------*/
 int mob_dead(struct mob_data *md, struct block_list *src, int type)
 {
-	struct status_data *status;
-	struct map_session_data *sd = NULL, *tmpsd[DAMAGELOG_SIZE];
-	struct map_session_data *mvp_sd = NULL, *second_sd = NULL, *third_sd = NULL;
-
-	struct {
-		struct party_data *p;
-		int id,zeny;
-		unsigned int base_exp,job_exp;
-	} pt[DAMAGELOG_SIZE];
-	int i, temp, count, m = md->bl.m, pnum = 0;
-	int dmgbltypes = 0;  // bitfield of all bl types, that caused damage to the mob and are elligible for exp distribution
-	unsigned int mvp_damage, tick = gettick();
-	bool rebirth, homkillonly;
-
-	status = &md->status;
-
+	struct status_data *status;
+	struct map_session_data *sd = NULL, *tmpsd[DAMAGELOG_SIZE];
+	struct map_session_data *mvp_sd = NULL, *second_sd = NULL, *third_sd = NULL;
+	struct region_data* rd;
+	
+	struct {
+		struct party_data *p;
+		int id,zeny;
+		unsigned int base_exp,job_exp;
+	} pt[DAMAGELOG_SIZE];
+	int i, temp, count, m = md->bl.m, pnum = 0, bonusdrop = 0;
+	int dmgbltypes = 0;  // bitfield of all bl types, that caused damage to the mob and are elligible for exp distribution
+	unsigned int mvp_damage, tick = gettick();
+	bool rebirth, aikillonly, droper = false;
+	char mensaje[256]; // [Zephyrus] Mensaje a los players
+
+	status = &md->status;
+
 	if(src && src->type == BL_PC) {
 		sd = (struct map_session_data *)src;
 		mvp_sd = sd;
@@ -2078,12 +2291,25 @@
 	map_freeblock_lock();
 
 	memset(pt,0,sizeof(pt));
-
-	if(src && src->type == BL_MOB)
-		mob_unlocktarget((struct mob_data *)src,tick);
-
-	// filter out entries not eligible for exp distribution
-	memset(tmpsd,0,sizeof(tmpsd));
+
+	if(src && src->type == BL_MOB)
+	{
+		mob_unlocktarget((struct mob_data *)src,tick);
+
+		if (md->option.announce_hprate) {
+			if (md->option.ai_type == 1) {
+				sprintf(mensaje, "[Aliado] %s ha sido eliminado!!", md->name);
+				clif_broadcast2(&md->bl, mensaje, strlen(mensaje) + 1, 0x0066CC, 0x190, 12, 0, 0, ALL_SAMEMAP);
+			} else {
+				sprintf(mensaje, "[Enemigo] %s ha sido eliminado!!", md->name);
+				clif_broadcast2(&md->bl, mensaje, strlen(mensaje) + 1, 0xFFFFFF, 0x190, 12, 0, 0, ALL_SAMEMAP);
+			}
+		}
+	}
+	
+
+	// filter out entries not eligible for exp distribution
+	memset(tmpsd,0,sizeof(tmpsd));
 	for(i = 0, count = 0, mvp_damage = 0; i < DAMAGELOG_SIZE && md->dmglog[i].id; i++) {
 		struct map_session_data *tsd = map_charid2sd(md->dmglog[i].id);
 
@@ -2115,9 +2341,9 @@
 		}
 	}
 
-	// determines, if the monster was killed by homunculus' damage only
-	homkillonly = (bool)((dmgbltypes&BL_HOM) && !(dmgbltypes&~BL_HOM));
-
+	// determines, if the monster was killed by homunculus' damage only
+	aikillonly = (bool)( !( dmgbltypes&BL_PC ) );
+
 	if(!battle_config.exp_calc_type && count > 1) {
 		//Apply first-attacker 200% exp share bonus
 		//TODO: Determine if this should go before calculating the MVP player instead of after.
@@ -2130,13 +2356,13 @@
 		}
 	}
 
-	if(!(type&2) && //No exp
-	   (!map[m].flag.pvp || battle_config.pvp_exp) && //Pvp no exp rule [MouseJstr]
-	   (!md->master_id || !md->special_state.ai) && //Only player-summoned mobs do not give exp. [Skotlex]
-	   (!map[m].flag.nobaseexp || !map[m].flag.nojobexp) //Gives Exp
-	  ) { //Experience calculation.
-		int bonus = 100; //Bonus on top of your share (common to all attackers).
-		if(md->sc.data[SC_RICHMANKIM])
+	if(!(type&2) && //No exp
+		(!map[m].flag.pvp || battle_config.pvp_exp) && //Pvp no exp rule [MouseJstr]
+		(!md->master_id || !md->special_state.ai) && //Only player-summoned mobs do not give exp. [Skotlex]
+		(!map[m].flag.nobaseexp || !map[m].flag.nojobexp) && !md->option.no_expdrop //Gives Exp
+	) { //Experience calculation.
+		int bonus = 100; //Bonus on top of your share (common to all attackers).
+		if (md->sc.data[SC_RICHMANKIM])
 			bonus += md->sc.data[SC_RICHMANKIM]->val2;
 		if(sd) {
 			temp = status_get_class(&md->bl);
@@ -2199,18 +2425,18 @@
 			if(bra_config.enable_system_vip && (sd && pc_isvip(sd)))
 				bonus += bra_config.extra_exp_vip;
 
-			if(map[m].flag.nobaseexp || !md->db->base_exp)
-				base_exp = 0;
-			else
-				base_exp = (unsigned int)cap_value(md->db->base_exp * per * bonus/100. * map[m].bexp/100., 1, UINT_MAX);
-
-			if(map[m].flag.nojobexp || !md->db->job_exp || md->dmglog[i].flag == MDLF_HOMUN)  //Homun earned job-exp is always lost.
-				job_exp = 0;
-			else
-				job_exp = (unsigned int)cap_value(md->db->job_exp * per * bonus/100. * map[m].jexp/100., 1, UINT_MAX);
-
-			if ( (temp = tmpsd[i]->status.party_id) > 0 ) {
-				int j;
+		if (map[m].flag.nobaseexp || !md->db->base_exp)
+			base_exp = 0;
+		else
+			base_exp = (unsigned int)cap_value((md->db->base_exp + (md->db->base_exp * battle_config.base_exp_rate_bonus/100.) + (md->db->base_exp * md->option.exp_boost/100.)) * per * bonus/100. * map[m].bexp/100., 1, UINT_MAX);
+
+		if (map[m].flag.nojobexp || !md->db->job_exp || md->dmglog[i].flag == MDLF_HOMUN) //Homun earned job-exp is always lost.
+			job_exp = 0;
+		else
+			job_exp = (unsigned int)cap_value((md->db->job_exp + (md->db->job_exp * battle_config.job_exp_rate_bonus/100.) + (md->db->job_exp * md->option.exp_boost/100.)) * per * bonus/100. * map[m].jexp/100., 1, UINT_MAX);
+
+		if ( ( temp = tmpsd[i]->status.party_id)>0 ) {
+			int j;
 				for(j = 0; j < pnum && pt[j].id != temp; j++); //Locate party.
 
 				if(j == pnum) { //Possibly add party.
@@ -2261,21 +2487,23 @@
 
 	} //End EXP giving.
 
-	if(!(type&1) && !map[m].flag.nomobloot && !md->state.rebirth && (
-	       !md->special_state.ai || //Non special mob
-	       battle_config.alchemist_summon_reward == 2 || //All summoned give drops
-	       (md->special_state.ai==2 && battle_config.alchemist_summon_reward == 1) //Marine Sphere Drops items.
-	   )) {
-		// Item Drop
+	rd = region_search(map[m].region_id);
+
+	if( !(type&1) && !map[m].flag.nomobloot && !md->state.rebirth && !md->option.no_expdrop && (
+		!md->special_state.ai || //Non special mob
+		battle_config.alchemist_summon_reward == 2 || //All summoned give drops
+		(md->special_state.ai==2 && battle_config.alchemist_summon_reward == 1) //Marine Sphere Drops items.
+		) )
+	{ // Item Drop
 		struct item_drop_list *dlist = ers_alloc(item_drop_list_ers, struct item_drop_list);
 		struct item_drop *ditem;
-		struct item_data *it = NULL;
-		int drop_rate;
+		struct item_data* it = NULL;
+		int drop_rate, bonus_drop_rate = 0;
 #ifdef RENEWAL_DROP
 		int drop_modifier = mvp_sd    ? pc_level_penalty_mod(mvp_sd, md->level, md->status.race, md->status.mode, 2)   :
-		                    second_sd ? pc_level_penalty_mod(second_sd, md->level, md->status.race, md->status.mode, 2):
-		                    third_sd  ? pc_level_penalty_mod(third_sd, md->level, md->status.race, md->status.mode, 2) :
-		                    100;/* no player was attached, we dont use any modifier (100 = rates are not touched) */
+							second_sd ? pc_level_penalty_mod(second_sd, md->level, md->status.race, md->status.mode, 2):
+							third_sd  ? pc_level_penalty_mod(third_sd, md->level, md->status.race, md->status.mode, 2) :
+							100;/* no player was attached, we dont use any modifier (100 = rates are not touched) */
 #endif
 		dlist->m = md->bl.m;
 		dlist->x = md->bl.x;
@@ -2296,8 +2524,12 @@
 					continue;
 				drop_rate = 1;
 			}
-
-			// change drops depending on monsters size [Valaris]
+
+			droper = true;
+			if( bonusdrop > 0 ) // Regional Bonus Drop
+				bonus_drop_rate = (int)(drop_rate * bonusdrop / 100.);
+
+			// change drops depending on monsters size [Valaris]
 			if(battle_config.mob_size_influence) {
 				if(md->special_state.size == SZ_MEDIUM && drop_rate >= 2)
 					drop_rate /= 2;
@@ -2317,21 +2549,25 @@
 			   (int)(md->level - sd->status.base_level) >= 20)
 				drop_rate = (int)(drop_rate*1.25); // pk_mode increase drops if 20 level difference [Valaris]
 
-			// Increase drop rate if user has SC_ITEMBOOST
-			if(sd && sd->sc.data[SC_ITEMBOOST])  // now rig the drop rate to never be over 90% unless it is originally >90%.
-				drop_rate = max(drop_rate,cap_value((int)(0.5+drop_rate*(sd->sc.data[SC_ITEMBOOST]->val1)/100.),0,9000));
-#ifdef RENEWAL_DROP
-			if(drop_modifier != 100) {
-				drop_rate = drop_rate * drop_modifier / 100;
+			// Increase drop rate if user has SC_ITEMBOOST
+			if (sd && sd->sc.data[SC_ITEMBOOST]) // now rig the drop rate to never be over 90% unless it is originally >90%.
+				drop_rate = max(drop_rate,cap_value((int)(0.5+drop_rate*(sd->sc.data[SC_ITEMBOOST]->val1)/100.),0,9000));
+			if( sd && rd && rd->bonus_drop )
+				drop_rate = max(drop_rate,cap_value((int)(0.5+drop_rate*rd->bonus_drop/100.),0,9000));
+			if( sd && pc_isPremium(sd) && battle_config.premium_dropboost )
+				drop_rate = max(drop_rate,cap_value((int)(0.5+drop_rate*battle_config.premium_dropboost/100.),0,9000));
+#ifdef RENEWAL_DROP
+			if( drop_modifier != 100 ) {
+				drop_rate = drop_rate * drop_modifier / 100;
 				if(drop_rate < 1)
 					drop_rate = 1;
-			}
-#endif
-			// attempt to drop the item
-			if(rnd() % 10000 >= drop_rate)
-				continue;
-
-			if(mvp_sd && it->type == IT_PETEGG) {
+			}
+#endif
+			// attempt to drop the item
+			if (rnd() % 10000 >= (drop_rate + bonus_drop_rate))
+					continue;
+
+			if( mvp_sd && it->type == IT_PETEGG ) {
 				pet_create_egg(mvp_sd, md->db->dropitem[i].nameid);
 				continue;
 			}
@@ -2344,21 +2580,31 @@
 				sprintf(message, msg_txt(541), mvp_sd->status.name, md->name, it->jname, (float)drop_rate/100);
 				//MSG: "'%s' won %s's %s (chance: %0.02f%%)"
 				intif_broadcast(message,strlen(message)+1,0);
-			}
-			// Announce first, or else ditem will be freed. [Lance]
-			// By popular demand, use base drop rate for autoloot code. [Skotlex]
-			mob_item_drop(md, dlist, ditem, 0, md->db->dropitem[i].p, homkillonly);
-		}
-
-		// Ore Discovery [Celest]
-		if(sd == mvp_sd && pc_checkskill(sd,BS_FINDINGORE)>0 && battle_config.finding_ore_rate/10 >= rnd()%10000) {
-			ditem = mob_setdropitem(itemdb_searchrandomid(IG_FINDINGORE), 1);
-			mob_item_drop(md, dlist, ditem, 0, battle_config.finding_ore_rate/10, homkillonly);
-		}
-
-		if(sd) {
-			// process script-granted extra drop bonuses
-			int itemid = 0;
+			}
+
+			if( mvp_sd && battle_config.channel_announces&2 && server_channel[CHN_VENDING] && it->type == IT_CARD )
+			{ // Card Drop Announce on Vending Channel
+				char message[128];
+				sprintf(message, msg_txt(823), server_channel[CHN_VENDING]->name, mvp_sd->status.name, it->jname);
+				clif_channel_message(server_channel[CHN_VENDING], message, status->mode&MD_BOSS?17:18);
+			}
+
+			if( mvp_sd ) achievement_validate_item(mvp_sd,AT_ITEM_FIND,it->nameid,1);
+
+			// Announce first, or else ditem will be freed. [Lance]
+			// By popular demand, use base drop rate for autoloot code. [Skotlex]
+			mob_item_drop(md, dlist, ditem, 0, md->db->dropitem[i].p, aikillonly);
+		}
+
+		// Ore Discovery [Celest]
+		if (sd == mvp_sd && pc_checkskill(sd,BS_FINDINGORE)>0 && battle_config.finding_ore_rate/10 >= rnd()%10000) {
+			ditem = mob_setdropitem(itemdb_searchrandomid(IG_FINDINGORE), 1);
+			mob_item_drop(md, dlist, ditem, 0, battle_config.finding_ore_rate/10, aikillonly);
+		}
+
+		if( sd && (droper || battle_config.mob_slave_adddrop) )
+		{ // process script-granted extra drop bonuses
+			int itemid = 0;
 			for(i = 0; i < ARRAYLENGTH(sd->add_drop) && (sd->add_drop[i].id || sd->add_drop[i].group); i++) {
 				if(sd->add_drop[i].race == -md->class_ ||
 				   (sd->add_drop[i].race > 0 && (
@@ -2376,13 +2622,13 @@
 						//it's positive, then it goes as it is
 						drop_rate = sd->add_drop[i].rate;
 
-					if(rnd()%10000 >= drop_rate)
-						continue;
-					itemid = (sd->add_drop[i].id > 0) ? sd->add_drop[i].id : itemdb_searchrandomid(sd->add_drop[i].group);
-					mob_item_drop(md, dlist, mob_setdropitem(itemid,1), 0, drop_rate, homkillonly);
-				}
-			}
-
+					if (rnd()%10000 >= drop_rate)
+						continue;
+					itemid = (sd->add_drop[i].id > 0) ? sd->add_drop[i].id : itemdb_searchrandomid(sd->add_drop[i].group);
+					mob_item_drop(md, dlist, mob_setdropitem(itemid,1), 0, drop_rate, aikillonly);
+				}
+			}
+
 			// process script-granted zeny bonus (get_zeny_num) [Skotlex]
 			if(sd->bonus.get_zeny_num && rnd()%100 < sd->bonus.get_zeny_rate) {
 				i = sd->bonus.get_zeny_num > 0 ? sd->bonus.get_zeny_num : -md->level * sd->bonus.get_zeny_num;
@@ -2391,33 +2637,33 @@
 			}
 		}
 
-		// process items looted by the mob
-		if(md->lootitem) {
-			for(i = 0; i < md->lootitem_count; i++)
-				mob_item_drop(md, dlist, mob_setlootitem(&md->lootitem[i]), 1, 10000, homkillonly);
-		}
-		if(dlist->item)  //There are drop items.
-			add_timer(tick + (!battle_config.delay_battle_damage?500:0), mob_delay_item_drop, 0, (intptr_t)dlist);
-		else //No drops
-			ers_free(item_drop_list_ers, dlist);
-	} else if(md->lootitem && md->lootitem_count) {     //Loot MUST drop!
-		struct item_drop_list *dlist = ers_alloc(item_drop_list_ers, struct item_drop_list);
-		dlist->m = md->bl.m;
-		dlist->x = md->bl.x;
+		// process items looted by the mob
+		if(md->lootitem) {
+			for(i = 0; i < md->lootitem_count; i++)
+				mob_item_drop(md, dlist, mob_setlootitem(&md->lootitem[i]), 1, 10000, aikillonly);
+		}
+		if (dlist->item) //There are drop items.
+			add_timer(tick + (!battle_config.delay_battle_damage?500:0), mob_delay_item_drop, 0, (intptr_t)dlist);
+		else //No drops
+			ers_free(item_drop_list_ers, dlist);
+	} else if (md->lootitem && md->lootitem_count && !md->option.no_expdrop) {	//Loot MUST drop!
+		struct item_drop_list *dlist = ers_alloc(item_drop_list_ers, struct item_drop_list);
+		dlist->m = md->bl.m;
+		dlist->x = md->bl.x;
 		dlist->y = md->bl.y;
 		dlist->first_charid = (mvp_sd ? mvp_sd->status.char_id : 0);
 		dlist->second_charid = (second_sd ? second_sd->status.char_id : 0);
-		dlist->third_charid = (third_sd ? third_sd->status.char_id : 0);
-		dlist->item = NULL;
-		for(i = 0; i < md->lootitem_count; i++)
-			mob_item_drop(md, dlist, mob_setlootitem(&md->lootitem[i]), 1, 10000, homkillonly);
-		add_timer(tick + (!battle_config.delay_battle_damage?500:0), mob_delay_item_drop, 0, (intptr_t)dlist);
-	}
-
-	if(mvp_sd && md->db->mexp > 0 && !md->special_state.ai) {
-		int log_mvp[2] = {0};
-		unsigned int mexp;
-		struct item item;
+		dlist->third_charid = (third_sd ? third_sd->status.char_id : 0);
+		dlist->item = NULL;
+		for(i = 0; i < md->lootitem_count; i++)
+			mob_item_drop(md, dlist, mob_setlootitem(&md->lootitem[i]), 1, 10000, aikillonly);
+		add_timer(tick + (!battle_config.delay_battle_damage?500:0), mob_delay_item_drop, 0, (intptr_t)dlist);
+	}
+
+	if( mvp_sd && md->db->mexp > 0 && !md->special_state.ai && !md->option.no_expdrop ) {
+		int log_mvp[2] = {0};
+		unsigned int mexp;
+		struct item item;
 		double exp;
 
 		//mapflag: noexp check [Lorky]
@@ -2486,7 +2732,7 @@
 
 				if((temp = pc_additem(mvp_sd,&item,1,LOG_TYPE_PICKDROP_PLAYER)) != 0) {
 					clif_additem(mvp_sd,0,0,temp);
-					map_addflooritem(&item,1,mvp_sd->bl.m,mvp_sd->bl.x,mvp_sd->bl.y,mvp_sd->status.char_id,(second_sd?second_sd->status.char_id:0),(third_sd?third_sd->status.char_id:0),1);
+					map_addflooritem(&item,1,mvp_sd->bl.m,mvp_sd->bl.x,mvp_sd->bl.y,mvp_sd->status.char_id,(second_sd?second_sd->status.char_id:0),(third_sd?third_sd->status.char_id:0),0,1);
 				}
 
 				//Logs items, MVP prizes [Lupus]
@@ -2496,30 +2742,68 @@
 		}
 
 		log_mvpdrop(mvp_sd, md->class_, log_mvp);
+		mvp_sd->custom_data.MVPKiller++;
+		pc_setglobalreg(mvp_sd,"MVPRank",mvp_sd->custom_data.MVPKiller);
 	}
 
-	if(type&2 && !sd && md->class_ == MOBID_EMPERIUM)
-		//Emperium destroyed by script. Discard mvp character. [Skotlex]
+	if (type&2 && !sd && md->class_ == MOBID_EMPERIUM)
+	  	//Emperium destroyed by script. Discard mvp character. [Skotlex]
 		mvp_sd = NULL;
 
-	rebirth = (md->sc.data[SC_KAIZEL] || (md->sc.data[SC_REBIRTH] && !md->state.rebirth));
-	if(!rebirth) {   // Only trigger event on final kill
-		md->status.hp = 0; //So that npc_event invoked functions KNOW that mob is dead
-		if(src) {
-			switch(src->type) { //allowed type
-				case BL_PET:
-				case BL_HOM:
-				case BL_MER:
-				case BL_ELEM:
-				case BL_MOB:
-				    sd = BL_CAST(BL_PC,battle_get_master(src));
+	md->graveyard_npc_id = 0;
+	rebirth =  ( md->sc.data[SC_KAIZEL] || (md->sc.data[SC_REBIRTH] && !md->state.rebirth) );
+	if( !rebirth ) { // Only trigger event on final kill
+		if( src ) switch( src->type )
+		{
+		case BL_PET: sd = ((TBL_PET*)src)->msd; break;
+		case BL_HOM: sd = ((TBL_HOM*)src)->master; break;
+		case BL_MER: sd = ((TBL_MER*)src)->master; break;
+		case BL_ELEM: sd = ((TBL_ELEM*)src)->master; break;
+		case BL_SKILL:
+			if( ((TBL_SKILL*)src)->group && ((TBL_SKILL*)src)->group->src_id )
+			{
+				struct block_list* sbl = map_id2bl(((TBL_SKILL*)src)->group->src_id);
+				sd = BL_CAST(BL_PC,sbl);
 			}
+			break;
+		case BL_MOB:
+			if( ((TBL_MOB*)src)->master_id )
+			{
+				struct block_list* sbl = map_id2bl(((TBL_MOB*)src)->master_id);
+				sd = BL_CAST(BL_PC,sbl);
+			}
+			break;
 		}
 
-		if(sd) {
-			if(sd->mission_mobid == md->class_) {  //TK_MISSION [Skotlex]
-				if(++sd->mission_count >= 100 && (temp = mob_get_random_id(0, 0xE, sd->status.base_level))) {
-					pc_addfame(sd, 1);
+		md->status.hp = 0; //So that npc_event invoked functions KNOW that mob is dead
+		if( sd ) {
+			if( md->option.announce_killer )
+			{ // Agregado Global al mapa si mobevent es tipo SHOW [Tab]
+				sprintf (mensaje, "[%s] has been killed by [%s]",md->db->jname,(mvp_sd?mvp_sd->status.name:"???"));
+				clif_broadcast(&sd->bl, mensaje, strlen(mensaje) + 1, 0, ALL_SAMEMAP);
+			}
+
+			if( md->option.item_drop > 0 && itemdb_exists(md->option.item_drop) && md->option.item_amount > 0 )
+			{
+				map_addflooritem_area(&md->bl, 0, 0, 0, md->option.item_drop, md->option.item_amount);
+				clif_misceffect(&md->bl,10);
+				md->option.item_drop = 0;
+				md->option.item_amount = 0;
+			}
+
+			if( map[sd->bl.m].flag.diecounter && (md->option.ai_type != 1) && !md->master_id && !md->special_state.ai )
+			{
+				map[sd->bl.m].mobmuertos--;
+				if( map[sd->bl.m].mobmuertos < 1 )
+				{
+					clif_broadcast(&sd->bl, "[- Victory to Human Defenses -]", strlen("[- Victory to Human Defenses -]") + 1, 0, ALL_SAMEMAP);
+					map[sd->bl.m].flag.diecounter = 0;
+				}
+			}
+
+			if( sd->mission_mobid == md->class_) { //TK_MISSION [Skotlex]
+				if( ++sd->mission_count >= 100 && (temp = mob_get_random_id(0, 0xE, sd->status.base_level)) ) {
+					pc_addfame(sd, 1, 0);
 					sd->mission_mobid = temp;
 					pc_setglobalreg(sd,"TK_MISSION_ID", temp);
 					sd->mission_count = 0;
@@ -2532,25 +2816,83 @@
 				map_foreachinrange(quest_update_objective_sub,&md->bl,AREA_SIZE,BL_PC,sd->status.party_id,md->class_);
 			else if(sd->avail_quests)
 				quest_update_objective(sd, md->class_);
-
-			if(sd->md && src && src->type != BL_HOM && mob_db(md->class_)->lv > sd->status.base_level/2)
-				mercenary_kills(sd->md);
-		}
-
-		if(md->npc_event[0] && !md->state.npc_killmonster) {
-			if(sd && battle_config.mob_npc_event_type) {
-				pc_setparam(sd, SP_KILLERRID, sd->bl.id);
-				npc_event(sd,md->npc_event,0);
-			} else if(mvp_sd) {
-				pc_setparam(mvp_sd, SP_KILLERRID, sd?sd->bl.id:0);
-				npc_event(mvp_sd,md->npc_event,0);
-			} else
-				npc_event_do(md->npc_event);
-		} else if(mvp_sd && !md->state.npc_killmonster) {
-			pc_setparam(mvp_sd, SP_KILLEDRID, md->class_);
-			npc_script_event(mvp_sd, NPCE_KILLNPC); // PCKillNPC [Lance]
-		}
-
+
+			if( sd->md && src && src->type != BL_HOM && mob_db(md->class_)->lv > sd->status.base_level/2 )
+				mercenary_kills(sd->md);
+
+			pc_record_mobkills(sd,md);
+			achievement_validate_mob(sd,md->class_);
+
+			if( !md->option.is_event )
+			{ // Hunting Missions [Zephyrus]
+				struct party_data *p = party_search(sd->status.party_id);
+				struct map_session_data *pl = NULL;
+				int c = 5;
+
+				if( p != NULL )
+				{ // Search into the party if someone is hunting the killed mob
+					for( i = 0; i < MAX_PARTY; i++ )
+					{
+						if( (pl = p->data[i].sd) == NULL || pl->bl.m != sd->bl.m )
+							continue;
+						if( pl->hunting[0].mob_id == 0 || pl->hunting_time < (int)time(NULL) )
+							continue;
+						if( pc_isdead(pl) )
+							continue;
+
+						ARR_FIND(0, 5, c, pl->hunting[c].mob_id == md->class_ && pl->hunting[c].count > 0);
+						if( c < 5 ) break;
+					}
+
+					if( i == MAX_PARTY ) pl = NULL; // No one in the party hunting this mob
+				}
+				else if( sd->hunting_time >= (int)time(NULL) )
+				{
+					ARR_FIND(0, 5, c, sd->hunting[c].mob_id == md->class_ && sd->hunting[c].count > 0);
+					if( c < 5 ) pl = sd;
+				}
+
+				if( pl != NULL && c < 5 && pl->hunting[c].count > 0 )
+				{
+					char varname[32], output[128];
+
+					pl->hunting[c].count--;
+					clif_specialeffect(&md->bl, 649, AREA);
+					clif_specialeffect(&pl->bl, 626, AREA);
+
+					sprintf(varname, "Mission_Count%d", c + 1);
+					pc_setglobalreg(pl, varname, pl->hunting[c].count);
+
+					if( pl->hunting[c].count > 0 )
+						sprintf(output, "[ Hunting Mission : %d '%s' remaining ]", pl->hunting[c].count, mob_db(md->class_)->jname);
+					else
+						sprintf(output, "[ Hunting Mission : '%s' hunting completed ]", mob_db(md->class_)->jname);
+
+					clif_broadcast2(&pl->bl, output, strlen(output) + 1, 0x00CCFF, 0x190, 12, 0, 0, SELF);
+				}
+			}
+		}
+
+		if( md->npc_event[0] && !md->state.npc_killmonster ) {
+			if( sd && battle_config.mob_npc_event_type ) {
+				pc_setparam(sd, SP_KILLEDRID, md->class_);
+				pc_setreg(sd,add_str("@killedx"),md->bl.x);
+				pc_setreg(sd,add_str("@killedy"),md->bl.y);
+				npc_event(sd,md->npc_event,0);
+			} else if( mvp_sd ) {
+				pc_setparam(mvp_sd, SP_KILLEDRID, md->class_);
+				pc_setreg(mvp_sd,add_str("@killedx"),md->bl.x);
+				pc_setreg(mvp_sd,add_str("@killedy"),md->bl.y);
+				npc_event(mvp_sd,md->npc_event,0);
+			} else
+				npc_event_do(md->npc_event);
+		} else if( mvp_sd && !md->state.npc_killmonster ) {
+			pc_setparam(mvp_sd, SP_KILLEDRID, md->class_);
+			pc_setreg(mvp_sd,add_str("@killedx"),md->bl.x);
+			pc_setreg(mvp_sd,add_str("@killedy"),md->bl.y);
+			npc_script_event(mvp_sd, NPCE_KILLNPC); // PCKillNPC [Lance]
+		}
+
 		md->status.hp = 1;
 	}
 
@@ -2586,13 +2928,13 @@
 
 	// MvP tomb [GreenBox]
 	if(battle_config.mvp_tomb_enabled && md->spawn->state.boss)
-		mvptomb_create(md, mvp_sd ? mvp_sd->status.name : NULL, time(NULL));
-
-	if(!rebirth)
-		mob_setdelayspawn(md); //Set respawning.
-	return 3; //Remove from map.
-}
-
+		mvptomb_create(md, mvp_sd ? mvp_sd->status.name : NULL, time(NULL));
+
+	if( !rebirth )
+		mob_setdelayspawn(md,(mvp_sd ? mvp_sd : sd)); //Set respawning.
+	return 3; //Remove from map.
+}
+
 void mob_revive(struct mob_data *md, unsigned int hp)
 {
 	unsigned int tick = gettick();
@@ -2605,14 +2947,15 @@
 	md->tdmg = 0;
 	if(!md->bl.prev)
 		map_addblock(&md->bl);
-	clif_spawn(&md->bl);
-	skill_unit_move(&md->bl,tick,1);
-	mobskill_use(md, tick, MSC_SPAWN);
-	if(battle_config.show_mob_info&3)
-		clif_charnameack(0, &md->bl);
-}
-
-int mob_guardian_guildchange(struct mob_data *md)
+	clif_spawn(&md->bl);
+	skill_unit_move(&md->bl,tick,1);
+	mobskill_use(md, tick, MSC_SPAWN);
+	clif_mobnameack(NULL, md, 1);
+	if( md->option.hp_show == 1 )
+		clif_mobhpmeter(md);
+}
+
+int mob_guardian_guildchange(struct mob_data *md)
 {
 	struct guild *g;
 	nullpo_ret(md);
@@ -2701,12 +3044,18 @@
 	if(mob_is_clone(md->class_))
 		return 0; //Clones
 
-	if(md->class_ == class_)
-		return 0; //Nothing to change.
-
-	hp_rate = get_percentage(md->status.hp, md->status.max_hp);
-	md->class_ = class_;
-	md->db = mob_db(class_);
+	if( md->class_ == class_ )
+		return 0; //Nothing to change.
+
+	if( md->option.is_event )
+		return 0; //Mobevent no cambian clases
+
+	if( map[md->bl.m].flag.town )
+		return 0;
+
+	hp_rate = get_percentage(md->status.hp, md->status.max_hp);
+	md->class_ = class_;
+	md->db = mob_db(class_);
 	if(battle_config.override_mob_names==1)
 		memcpy(md->name,md->db->name,NAME_LENGTH);
 	else
@@ -2735,24 +3084,25 @@
 		md->lootitem=(struct item *)aCalloc(LOOTITEM_SIZE,sizeof(struct item));
 
 	//Targets should be cleared no morph
-	md->target_id = md->attacked_id = 0;
+	md->target_id = md->attacked_id = 0;
+
+	//Need to update name display.
+	clif_mobnameack(NULL, md, 0);
+	status_change_end(&md->bl,SC_KEEPING,INVALID_TIMER);
+	return 0;
+}
 
-	//Need to update name display.
-	clif_charnameack(0, &md->bl);
-	status_change_end(&md->bl,SC_KEEPING,INVALID_TIMER);
-	return 0;
-}
-
 /*==========================================
  * mob heal, update display hp info of mob for players
- *------------------------------------------*/
-void mob_heal(struct mob_data *md,unsigned int heal)
-{
-	if(battle_config.show_mob_info&3)
-		clif_charnameack(0, &md->bl);
-}
-
-/*==========================================
+ *------------------------------------------*/
+void mob_heal(struct mob_data *md,unsigned int heal)
+{
+	clif_mobnameack(NULL, md, 1);
+	if( md->option.hp_show == 1 )
+		clif_mobhpmeter(md);
+}
+
+/*==========================================
  * Added by RoVeRT
  *------------------------------------------*/
 int mob_warpslave_sub(struct block_list *bl,va_list ap)
@@ -2872,12 +3222,25 @@
 		if(skill_id == NPC_SUMMONSLAVE) {
 			md->master_id=md2->bl.id;
 			md->special_state.ai = md2->special_state.ai;
-		}
-		mob_spawn(md);
-
-		if(hp_rate)  //Scale HP
-			md->status.hp = md->status.max_hp*hp_rate/100;
-
+		}
+		mob_spawn(md);
+
+		md->option.is_event = md2->option.is_event;
+		md->option.no_expdrop = md2->option.no_expdrop;
+		md->option.ai_type = md2->option.ai_type;
+		md->option.is_war = md2->option.is_war;
+		md->option.party_id = md2->option.party_id;
+		md->option.guild_id = md2->option.guild_id;
+
+		if( md2->deletetimer != INVALID_TIMER )
+		{
+			const struct TimerData *td = get_timer(md2->deletetimer);
+			if(td) md->deletetimer = add_timer(td->tick, mob_timer_delete, md->bl.id, 0);
+		}
+
+		if (hp_rate) //Scale HP
+			md->status.hp = md->status.max_hp*hp_rate/100;
+
 		//Inherit the aggressive mode of the master.
 		if(battle_config.slaves_inherit_mode && md->master_id) {
 			switch(battle_config.slaves_inherit_mode) {
@@ -3332,13 +3695,13 @@
 	fd = sd->fd;
 	sd->fd = 0;
 
-	//Go Backwards to give better priority to advanced skills.
-	for(i=0,j = MAX_SKILL_TREE-1; j>=0 && i< MAX_MOBSKILL ; j--) {
-		skill_id = skill_tree[pc_class2idx(sd->status.class_)][j].id;
-		if(!skill_id || sd->status.skill[skill_id].lv < 1 ||
-		   (skill_get_inf2(skill_id)&(INF2_WEDDING_SKILL|INF2_GUILD_SKILL)) ||
-		   skill_get_nocast(skill_id)&16
-		  )
+	//Go Backwards to give better priority to advanced skills.
+	for (i=0,j = MAX_SKILL_TREE-1;j>=0 && i< MAX_MOBSKILL ;j--) {
+		skill_id = skill_tree[pc_class2idx(sd->status.class_)][j].id;
+		if (!skill_id || sd->status.skill[skill_id].lv < 1 || !skill_get_blocked(skill_id) ||
+			(skill_get_inf2(skill_id)&(INF2_WEDDING_SKILL|INF2_GUILD_SKILL)) ||
+			skill_get_nocast(skill_id)&16
+		)
 			continue;
 		//Normal aggressive mob, disable skills that cannot help them fight
 		//against players (those with flags UF_NOMOB and UF_NOPC are specific
@@ -3651,12 +4014,16 @@
 			db->range3 = db->range2;
 	}
 
-	status->size = atoi(str[22]);
-	status->race = atoi(str[23]);
-
-	i = atoi(str[24]); //Element
-	status->def_ele = i%10;
-	status->ele_lv = i/20;
+	status->size = atoi(str[22]);
+	status->race = atoi(str[23]);
+
+	// Zephyrus
+	db->spawn_rate = 100;
+	db->ffa = false;
+
+	i = atoi(str[24]); //Element
+	status->def_ele = i%10;
+	status->ele_lv = i/20;
 	if(status->def_ele >= ELE_MAX) {
 		ShowError("mob_parse_dbrow: Invalid element type %d for monster ID %d (max=%d).\n", status->def_ele, class_, ELE_MAX-1);
 		return false;
@@ -3664,12 +4031,15 @@
 	if(status->ele_lv < 1 || status->ele_lv > 4) {
 		ShowError("mob_parse_dbrow: Invalid element level %d for monster ID %d, must be in range 1-4.\n", status->ele_lv, class_);
 		return false;
-	}
-
-	status->mode = (int)strtol(str[25], NULL, 0);
-	if(!battle_config.monster_active_enable)
-		status->mode &= ~MD_AGGRESSIVE;
-
+	}
+
+	status->mode = (int)strtol(str[25], NULL, 0);
+	db->b_base_exp = atoi(str[7]);
+	db->b_job_exp = atoi(str[8]);
+
+	if (!battle_config.monster_active_enable)
+		status->mode &= ~MD_AGGRESSIVE;
+
 	status->speed = atoi(str[26]);
 	status->aspd_rate = 1000;
 	i = atoi(str[27]);
@@ -3710,47 +4080,66 @@
 	//Since mobs always respawn with full life...
 	status->hp = status->max_hp;
 	status->sp = status->max_sp;
-
-	// MVP Drops: MVP1id,MVP1per,MVP2id,MVP2per,MVP3id,MVP3per
-	for(i = 0; i < MAX_MVP_DROP; i++) {
-		int rate_adjust = battle_config.item_rate_mvp;;
-		db->mvpitem[i].nameid = atoi(str[31+i*2]);
-		if(!db->mvpitem[i].nameid) {
-			db->mvpitem[i].p = 0; //No item....
-			continue;
-		}
-		item_dropratio_adjust(db->mvpitem[i].nameid, class_, &rate_adjust);
-		db->mvpitem[i].p = mob_drop_adjust(atoi(str[32+i*2]), rate_adjust, battle_config.item_drop_mvp_min, battle_config.item_drop_mvp_max);
-
-		//calculate and store Max available drop chance of the MVP item
-		if(db->mvpitem[i].p) {
-			struct item_data *id;
-			id = itemdb_search(db->mvpitem[i].nameid);
-			if(id->maxchance == -1 || (id->maxchance < db->mvpitem[i].p/10 + 1)) {
-				//item has bigger drop chance or sold in shops
-				id->maxchance = db->mvpitem[i].p/10 + 1; //reduce MVP drop info to not spoil common drop rate
-			}
-		}
-	}
-
-	for(i = 0; i < MAX_MOB_DROP; i++) {
+
+	// MVP Drops: MVP1id,MVP1per,MVP2id,MVP2per,MVP3id,MVP3per
+	for(i = 0; i < MAX_MVP_DROP; i++) {
+		struct item_data *id;
+		int rate_adjust = battle_config.item_rate_mvp;;
+		db->mvpitem[i].nameid = atoi(str[31+i*2]);
+		if (!db->mvpitem[i].nameid) {
+			db->mvpitem[i].p = 0; //No item....
+			db->mvpitem[i].base_p = 0;
+			continue;
+		}
+
+		if( (id = itemdb_exists(db->mvpitem[i].nameid)) == NULL )
+		{
+			db->mvpitem[i].p = 0;
+			db->mvpitem[i].base_p = 0;
+			ShowWarning("mob_parse_dbrow: Item ID %d does not exists in the item_db. MVP Drop, Mob ID %d.\n", db->mvpitem[i].nameid, class_);
+			db->mvpitem[i].nameid = 0;
+			continue;
+		}
+
+		item_dropratio_adjust(db->mvpitem[i].nameid, class_, &rate_adjust);
+		db->mvpitem[i].p = mob_drop_adjust(atoi(str[32+i*2]), rate_adjust, battle_config.item_drop_mvp_min, battle_config.item_drop_mvp_max);
+
+		//calculate and store Max available drop chance of the MVP item
+		if( db->mvpitem[i].p && (id->maxchance == -1 || (id->maxchance < db->mvpitem[i].p/10 + 1)) )
+			id->maxchance = db->mvpitem[i].p/10 + 1; // reduce MVP drop info to not spoil common drop rate
+	}
+
+	for(i = 0; i < MAX_MOB_DROP; i++) {
 		int rate = 0, rate_adjust, type;
 		unsigned short ratemin, ratemax;
 		struct item_data *id;
 		k = 31 + MAX_MVP_DROP*2 + i*2;
 		db->dropitem[i].nameid = atoi(str[k]);
 		if(!db->dropitem[i].nameid) {
-			db->dropitem[i].p = 0; //No drop.
+			db->dropitem[i].p = 0; //No drop.
+			db->dropitem[i].base_p = 0;
 			continue;
 		}
-		id = itemdb_search(db->dropitem[i].nameid);
+		if( (id = itemdb_exists(db->dropitem[i].nameid)) == NULL )
+		{
+			db->dropitem[i].p = 0; //No drop.
+			db->dropitem[i].base_p = 0;
+			ShowWarning("mob_parse_dbrow: Item ID %d does not exists in the item_db. Drop, Mob ID %d.\n", db->dropitem[i].nameid, class_);
+			db->dropitem[i].nameid = 0;
+			continue;
+		}
 		type = id->type;
-		rate = atoi(str[k+1]);
+		rate = db->dropitem[i].base_p = atoi(str[k+1]);
 		if((class_ >= 1324 && class_ <= 1363) || (class_ >= 1938 && class_ <= 1946)) {
 			//Treasure box drop rates [Skotlex]
 			rate_adjust = battle_config.item_rate_treasure;
 			ratemin = battle_config.item_drop_treasure_min;
 			ratemax = battle_config.item_drop_treasure_max;
+		} 
+		else if( id->dropRate ) { // Custom Drop Rates per Item
+			rate_adjust = id->dropRate;
+			ratemin = 1;
+			ratemax = 10000;
 		} else switch(type) {
 					// Added suport to restrict normal drops of MVP's [Reddozen]
 				case IT_HEALING:
@@ -3788,18 +4177,16 @@
 		//calculate and store Max available drop chance of the item
 		if(db->dropitem[i].p && (class_ < 1324 || class_ > 1363) && (class_ < 1938 || class_ > 1946)) {
 			//Skip treasure chests.
-			if(id->maxchance == -1 || (id->maxchance < db->dropitem[i].p)) {
+			if (id->maxchance == -1 || (id->maxchance < db->dropitem[i].p) )
 				id->maxchance = db->dropitem[i].p; //item has bigger drop chance or sold in shops
-			}
-			for(k = 0; k< MAX_SEARCH; k++) {
-				if(id->mob[k].chance <= db->dropitem[i].p)
-					break;
-			}
+			
+			ARR_FIND(0, MAX_SEARCH, k, id->mob[k].bchance <= db->dropitem[i].base_p);
 			if(k == MAX_SEARCH)
 				continue;
 
 			if(id->mob[k].id != class_)
-				memmove(&id->mob[k+1], &id->mob[k], (MAX_SEARCH-k-1)*sizeof(id->mob[0]));
+				memmove(&id->mob[k+1], &id->mob[k], (MAX_SEARCH-k-1)*sizeof(id->mob[0]));
+			id->mob[k].bchance = db->dropitem[i].base_p;
 			id->mob[k].chance = db->dropitem[i].p;
 			id->mob[k].id = class_;
 		}
@@ -4342,13 +4729,170 @@
 			continue;
 		}
 		mob_db_data[mobid]->race2 = race;
-	}
-	return true;
-}
-
-/**
- * Read mob_item_ratio.txt
- */
+	}
+	return true;
+}
+/*==========================================
+ * mob_customrates.txt reading [Zephyrus]
+ * MobID,Exp,Job,Drop
+ *------------------------------------------*/
+static int mob_readdb_bonus(void)
+{
+	FILE *fp;
+	char line[1024];
+	int ln = 0;
+	int i, j, k, value;
+	char *str[10],*p;
+	struct mob_db *db;
+	double exp;
+
+	sprintf(line, "%s/mob_customrates.txt", db_path);
+	if( (fp = fopen(line,"r")) == NULL )
+	{
+		ShowError("can't read %s\n", line);
+		return -1;
+	}
+
+	while( fgets(line, sizeof(line), fp) )
+	{
+		if(line[0] == '/' && line[1] == '/')
+			continue;
+
+		memset(str,0,sizeof(str));
+		for( j = 0, p = line; j < 10 && p; j++ )
+		{
+			str[j] = p;
+			p = strchr(p,',');
+			if( p )
+				*p++=0;
+		}
+
+		if( str[0] == NULL )
+			continue;
+
+		k = atoi(str[0]);
+		if( k > 0 && (db = mob_db(k)) != mob_dummy )
+		{
+			if( (value = atoi(str[1])) > 0 )
+			{ // Mod Base Exp Rate
+				exp = (double)db->b_base_exp * (double)( value ) / 100.;
+				db->base_exp = (unsigned int)cap_value(exp, 0, UINT_MAX);
+			}
+			if( (value = atoi(str[2])) > 0 )
+			{ // Mod Job Exp Rate
+				exp = (double)db->b_job_exp * (double)( value ) / 100.;
+				db->job_exp = (unsigned int)cap_value(exp, 0, UINT_MAX);
+			}
+
+			for( i = 0; i < MAX_MOB_DROP; i++ )
+			{
+				int rate = 0, rate_adjust, type;
+				unsigned short ratemin, ratemax;
+				struct item_data *id;
+
+				if( !db->dropitem[i].nameid )
+					continue;
+
+				id = itemdb_search(db->dropitem[i].nameid);
+				type = itemdb_type(db->dropitem[i].nameid);
+				rate = db->dropitem[i].base_p;
+
+				switch( type )
+				{
+				case IT_HEALING:
+					rate_adjust = atoi(str[4]);
+					ratemin = battle_config.item_drop_heal_min;
+					ratemax = battle_config.item_drop_heal_max;
+					break;
+				case IT_USABLE:
+					rate_adjust = atoi(str[6]);
+					ratemin = battle_config.item_drop_use_min;
+					ratemax = battle_config.item_drop_use_max;
+					break;
+				case IT_WEAPON:
+				case IT_ARMOR:
+				case IT_PETARMOR:
+					rate_adjust = atoi(str[7]);
+					ratemin = battle_config.item_drop_equip_min;
+					ratemax = battle_config.item_drop_equip_max;
+					break;
+				case IT_CARD:
+					rate_adjust = atoi(str[5]);
+					ratemin = battle_config.item_drop_card_min;
+					ratemax = battle_config.item_drop_card_max;
+					break;
+				default:
+					rate_adjust = atoi(str[3]);
+					ratemin = battle_config.item_drop_common_min;
+					ratemax = battle_config.item_drop_common_max;
+					break;
+				}
+
+				if( rate_adjust > 0 )
+					db->dropitem[i].p = mob_drop_adjust(rate, rate_adjust, ratemin, ratemax);
+			}
+
+			db->spawn_rate = atoi(str[8]);
+			db->ffa = (bool)atoi(str[9]);
+			ln++;
+		}
+	}
+	fclose(fp);
+	ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n",ln,"mob_customrates.txt");
+	return 0;
+}
+/*==========================================
+ * mob_hunting.txt reading [Zephyrus]
+ * MobID,Enable
+ *------------------------------------------*/
+static int mob_readdb_hunting(void)
+{
+	FILE *fp;
+	char line[1024];
+	int ln = 0;
+	int j, k;
+	char *str[2],*p;
+	struct mob_db *db;
+
+	sprintf(line, "%s/mob_hunting.txt", db_path);
+	if( (fp = fopen(line,"r")) == NULL )
+	{
+		ShowError("can't read %s\n", line);
+		return -1;
+	}
+
+	while( fgets(line, sizeof(line), fp) )
+	{
+		if(line[0] == '/' && line[1] == '/')
+			continue;
+
+		memset(str,0,sizeof(str));
+		for( j = 0, p = line; j < 2 && p; j++ )
+		{
+			str[j] = p;
+			p = strchr(p,',');
+			if( p )
+				*p++=0;
+		}
+
+		if( str[0] == NULL )
+			continue;
+
+		k = atoi(str[0]);
+		if( k > 0 && (db = mob_db(k)) != mob_dummy )
+		{
+			db->hunting = (bool)atoi(str[1]);
+			ln++;
+		}
+	}
+	fclose(fp);
+	ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n",ln,"mob_hunting.txt");
+	return 0;
+}
+
+/**
+ * Read mob_item_ratio.txt
+ */
 static bool mob_readdb_itemratio(char *str[], int columns, int current)
 {
 	int nameid, ratio, i;
@@ -4382,7 +4926,9 @@
 	mob_read_sqlskilldb();
 	sv_readsqldb(get_database_name(40), NULL, 2, -1, &mob_readdb_mobavail);
 	mob_read_randommonster();
-	sv_readsqldb(get_database_name(46), NULL, 2, -1, &mob_readdb_race2);
+	sv_readsqldb(get_database_name(46), NULL, 2, -1, &mob_readdb_race2);
+	mob_readdb_bonus();
+	mob_readdb_hunting();
 }
 
 void mob_reload(void)
@@ -4410,11 +4956,16 @@
 void mob_clear_spawninfo()
 {
 	//Clears spawn related information for a script reload.
-	int i;
-	for(i = 0; i < MAX_MOB_DB; i++)
-		if(mob_db_data[i])
-			memset(&mob_db_data[i]->spawn,0,sizeof(mob_db_data[i]->spawn));
-}
+	int i;
+	for( i = 0; i < MAX_MOB_DB; i++ )
+	{
+		if( mob_db_data[i] )
+		{
+			memset(&mob_db_data[i]->spawn,0,sizeof(mob_db_data[i]->spawn));
+			mob_db_data[i]->spawn_count = 0;
+		}
+	}
+}
 
 /*==========================================
  * Circumference initialization of mob
Index: src/map/mob.h
===================================================================
--- src/map/mob.h	(revision 1953)
+++ src/map/mob.h	(working copy)
@@ -29,6 +29,7 @@
 // Change this to increase the table size in your mob_db to accomodate a larger mob database.
 // Be sure to note that IDs 4001 to 4048 are reserved for advanced/baby/expanded classes.
 // Notice that the last 1000 entries are used for player clones, so always set this to desired value +1000
+#define MIN_MOB_DB 1000
 #define MAX_MOB_DB 5000
 
 //The number of drops all mobs have and the max drop-slot that the steal skill will attempt to steal from.
@@ -46,13 +47,20 @@
 
 // These define the range of available IDs for clones. [Valaris]
 #define MOB_CLONE_START (MAX_MOB_DB-999)
-#define MOB_CLONE_END MAX_MOB_DB
-
-//Used to determine default enemy type of mobs (for use in eachinrange calls)
-#define DEFAULT_ENEMY_TYPE(md) (md->special_state.ai?BL_CHAR:BL_MOB|BL_PC|BL_HOM|BL_MER)
-
-//Externals for the status effects. [Epoque]
-extern const int mob_manuk[8];
+#define MOB_CLONE_END MAX_MOB_DB
+
+//Used to determine default enemy type of mobs (for use in eachinrange calls)
+#define DEFAULT_ENEMY_TYPE( md ) ( \
+	( md->option.ai_type == 2 || md->option.party_id || md->option.guild_id || md->option.faction_id ) ? \
+	BL_CHAR : \
+	( md->option.ai_type == 3 ) ? \
+	BL_MOB : \
+	( md->special_state.ai ) ? \
+	BL_CHAR : \
+	BL_MOB|BL_PC|BL_HOM|BL_MER )
+
+//Externals for the status effects. [Epoque]
+extern const int mob_manuk[8];
 extern const int mob_splendide[5];
 
 //Mob skill states.
@@ -71,12 +79,13 @@
 
 enum MobDamageLogFlag
 {
-	MDLF_NORMAL = 0,
-	MDLF_HOMUN,
-	MDLF_PET,
-};
-
-enum size {
+	MDLF_NORMAL = 0,
+	MDLF_HOMUN,
+	MDLF_PET,
+	MDLF_MERC,
+};
+
+enum size {
 	SZ_SMALL = 0,
 	SZ_MEDIUM,
 	SZ_BIG,
@@ -114,25 +123,32 @@
 	unsigned short qty;
 };
 
-struct mob_db {
-	char sprite[NAME_LENGTH],name[NAME_LENGTH],jname[NAME_LENGTH];
-	unsigned int base_exp,job_exp;
-	unsigned int mexp;
-	short range2,range3;
-	short race2;	// celest
-	unsigned short lv;
-	struct { int nameid,p; } dropitem[MAX_MOB_DROP];
-	struct { int nameid,p; } mvpitem[MAX_MVP_DROP];
-	struct status_data status;
-	struct view_data vd;
-	unsigned int option;
+struct mob_db {
+	char sprite[NAME_LENGTH],name[NAME_LENGTH],jname[NAME_LENGTH];
+	unsigned int base_exp,job_exp;
+	unsigned int b_base_exp, b_job_exp;
+	unsigned int mexp;
+	short range2,range3;
+	short race2;	// celest
+	unsigned short lv;
+	// Custom Rates per Mob
+	int spawn_rate;
+	bool ffa; // Ignore noks protection
+	bool hunting; // Hunting Mission Allowed
+	// Mob Drops
+	struct { int nameid,p,base_p; } dropitem[MAX_MOB_DROP];
+	struct { int nameid,p,base_p; } mvpitem[MAX_MVP_DROP];
+	struct status_data status;
+	struct view_data vd;
+	unsigned int option;
 	int summonper[MAX_RANDOMMONSTER];
-	int maxskill;
-	struct mob_skill skill[MAX_MOBSKILL];
-	struct spawn_info spawn[10];
-};
-
-struct mob_data {
+	int maxskill;
+	struct mob_skill skill[MAX_MOBSKILL];
+	struct spawn_info spawn[10];
+	int spawn_count;
+};
+
+struct mob_data {
 	struct block_list bl;
 	struct unit_data  ud;
 	struct view_data *vd;
@@ -161,29 +177,43 @@
 		unsigned int rebirth: 1; // NPC_Rebirth used
 		unsigned int boss : 1;
 		enum MobSkillState skillstate;
-		unsigned char steal_flag; //number of steal tries (to prevent steal exploit on mobs with few items) [Lupus]
-		unsigned char attacked_count; //For rude attacked.
-		int provoke_flag; // Celest
-	} state;
-	struct guardian_data* guardian_data;
-	struct {
-		int id;
-		unsigned int dmg;
-		unsigned int flag : 2; //0: Normal. 1: Homunc exp. 2: Pet exp
-	} dmglog[DAMAGELOG_SIZE];
-	struct spawn_data *spawn; //Spawn data.
-	int spawn_timer; //Required for Convex Mirror
+		unsigned char steal_flag; //number of steal tries (to prevent steal exploit on mobs with few items) [Lupus]
+		unsigned char attacked_count; //For rude attacked.
+		int provoke_flag; // Celest
+		unsigned inmunity: 1; // Battleground Inmunity
+	} state;
+	struct guardian_data* guardian_data;
+	struct {
+		int id;
+		unsigned int dmg;
+		unsigned int flag : 3; //0: Normal. 1: Homunc exp. 2: Pet exp. 3: Mercenary exp.
+	} dmglog[DAMAGELOG_SIZE];
+	struct spawn_data *spawn; //Spawn data.
+	int spawn_timer; //Required for Convex Mirror
 	struct item *lootitem;
 	short class_;
 	unsigned int tdmg; //Stores total damage given to the mob, for exp calculations. [Skotlex]
-	int level;
-	int target_id,attacked_id;
-	int areanpc_id; //Required in OnTouchNPC (to avoid multiple area touchs)
-	unsigned int bg_id; // BattleGround System
-
-	unsigned int next_walktime,last_thinktime,last_linktime,last_pcneartime,dmgtick;
-	short move_fail_count;
-	short lootitem_count;
+	int level;
+	int target_id,attacked_id;
+	int areanpc_id; //Required in OnTouchNPC (to avoid multiple area touchs)
+	int bg_id; // BattleGround System
+
+	// Graveyard System
+	int graveyard_npc_id;
+
+	struct {
+		bool is_event, no_expdrop, no_slaves, announce_killer, announce_hprate, is_war, drop_boost;
+		unsigned hp_show : 3;
+		unsigned int max_hp; // Custom Max HP value
+		unsigned allow_warp : 2;
+		unsigned ai_type : 3;
+		int party_id, guild_id, guild_emblem_id, faction_id;
+		short item_drop, item_amount, exp_boost;
+	} option;
+
+	unsigned int next_walktime,last_thinktime,last_linktime,last_pcneartime,dmgtick;
+	short move_fail_count;
+	short lootitem_count;
 	short min_chase;
 
 	int deletetimer;
@@ -257,12 +287,13 @@
 	struct item_drop* item;            // linked list of drops
 };
 
-struct mob_db* mob_db(int class_);
-int mobdb_searchname(const char *str);
-int mobdb_searchname_array(struct mob_db** data, int size, const char *str);
-int mobdb_checkid(const int id);
-struct view_data* mob_get_viewdata(int class_);
-
+struct mob_db* mob_db(int class_);
+int mobdb_searchname(const char *str);
+int mobdb_searchname_array(struct mob_db** data, int size, const char *str);
+int mobdb_searchlevel_array(struct mob_db **data, int size, int level);
+int mobdb_checkid(const int id);
+struct view_data* mob_get_viewdata(int class_);
+
 struct mob_data *mob_once_spawn_sub(struct block_list *bl, int16 m,
 	short x, short y, const char *mobname, int class_, const char *event, unsigned int size, unsigned int ai);
 
@@ -270,48 +301,51 @@
 	const char* mobname, int class_, int amount, const char* event, unsigned int size, unsigned int ai);
 
 int mob_once_spawn_area(struct map_session_data* sd, int16 m,
-	int16 x0, int16 y0, int16 x1, int16 y1, const char* mobname, int class_, int amount, const char* event, unsigned int size, unsigned int ai);
-
-bool mob_ksprotected (struct block_list *src, struct block_list *target);
-
-int mob_spawn_guardian(const char* mapname, int16 x, int16 y, const char* mobname, int class_, const char* event, int guardian, bool has_index);	// Spawning Guardians [Valaris]
-int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int class_, const char* event, unsigned int bg_id);
-int mob_guardian_guildchange(struct mob_data *md); //Change Guardian's ownership. [Skotlex]
-
-int mob_randomwalk(struct mob_data *md,unsigned int tick);
+	int16 x0, int16 y0, int16 x1, int16 y1, const char* mobname, int class_, int amount, const char* event, unsigned int size, unsigned int ai);
+
+bool mob_ksprotected (struct block_list *src, struct block_list *target);
+int mob_demolition (int map, short x, short y, short ratio, int type, int amount, unsigned int power);
+int mob_once_spawn_especial(struct map_session_data *sd, const char *mapname, short x, short y, const char *mobname, int class_, int amount, const char *event, int hp_mod, short size, short ai_type, bool no_slaves, short allow_warp, short hp_show, bool announce_hprate, bool announce_killer, bool no_expdrop, int TeamID, short item_drop, short item_amount, bool is_war, short exp_boost, bool drop_boost);
+
+int mob_spawn_guardian(const char* mapname, int16 x, int16 y, const char* mobname, int class_, const char* event, int guardian, bool has_index);	// Spawning Guardians [Valaris]
+int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int class_, const char* event, int bg_id);
+int mob_guardian_guildchange(struct mob_data *md); //Change Guardian's ownership. [Skotlex]
+
+int mob_randomwalk(struct mob_data *md,unsigned int tick);
 int mob_warpchase(struct mob_data *md, struct block_list *target);
 int mob_target(struct mob_data *md,struct block_list *bl,int dist);
 int mob_unlocktarget(struct mob_data *md, unsigned int tick);
-struct mob_data* mob_spawn_dataset(struct spawn_data *data);
-int mob_spawn(struct mob_data *md);
-int mob_delayspawn(int tid, unsigned int tick, int id, intptr_t data);
-int mob_setdelayspawn(struct mob_data *md);
-int mob_parse_dataset(struct spawn_data *data);
-void mob_log_damage(struct mob_data *md, struct block_list *src, int damage);
-void mob_damage(struct mob_data *md, struct block_list *src, int damage);
+struct mob_data* mob_spawn_dataset(struct spawn_data *data);
+int mob_spawn(struct mob_data *md);
+int mob_delayspawn(int tid, unsigned int tick, int id, intptr_t data);
+int mob_setdelayspawn(struct mob_data* md, struct map_session_data* sd);
+int mob_parse_dataset(struct spawn_data *data);
+void mob_log_damage(struct mob_data *md, struct block_list *src, int damage);
+void mob_damage(struct mob_data *md, struct block_list *src, int damage);
 int mob_dead(struct mob_data *md, struct block_list *src, int type);
 void mob_revive(struct mob_data *md, unsigned int hp);
 void mob_heal(struct mob_data *md,unsigned int heal);
-
-#define mob_stop_walking(md, type) unit_stop_walking(&(md)->bl, type)
-#define mob_stop_attack(md) unit_stop_attack(&(md)->bl)
-#define mob_is_battleground(md) ( map[(md)->bl.m].flag.battleground && ((md)->class_ == MOBID_BARRICADE2 || ((md)->class_ >= MOBID_FOOD_STOR && (md)->class_ <= MOBID_PINK_CRYST)) )
-#define mob_is_gvg(md) (map[(md)->bl.m].flag.gvg_castle && ( (md)->class_ == MOBID_EMPERIUM || (md)->class_ == MOBID_BARRICADE1 || (md)->class_ == MOBID_GUARIDAN_STONE1 || (md)->class_ == MOBID_GUARIDAN_STONE2) )
-#define mob_is_treasure(md) (((md)->class_ >= MOBID_TREAS01 && (md)->class_ <= MOBID_TREAS40) || ((md)->class_ >= MOBID_TREAS41 && (md)->class_ <= MOBID_TREAS49))
-
+
+#define mob_stop_walking(md, type) unit_stop_walking(&(md)->bl, type)
+#define mob_stop_attack(md) unit_stop_attack(&(md)->bl)
+#define mob_is_battleground(md) ( map[(md)->bl.m].flag.battleground && ((md)->class_ == MOBID_BARRICADE2 || ((md)->class_ >= MOBID_FOOD_STOR && (md)->class_ <= MOBID_PINK_CRYST) || ((md)->class_ >= 2105 && (md)->class_ <= 2107)) )
+#define mob_is_gvg(md) (map[(md)->bl.m].flag.gvg_castle && ( (md)->class_ == MOBID_EMPERIUM || (md)->class_ == MOBID_BARRICADE1 || (md)->class_ == MOBID_GUARIDAN_STONE1 || (md)->class_ == MOBID_GUARIDAN_STONE2) )
+#define mob_is_treasure(md) (((md)->class_ >= MOBID_TREAS01 && (md)->class_ <= MOBID_TREAS40) || ((md)->class_ >= MOBID_TREAS41 && (md)->class_ <= MOBID_TREAS49))
+
 void mob_clear_spawninfo();
 int do_init_mob(void);
 int do_final_mob(void);
 
 int mob_timer_delete(int tid, unsigned int tick, int id, intptr_t data);
 int mob_deleteslave(struct mob_data *md);
+
+int mob_random_class (int *value, size_t count);
+int mob_get_random_id(int type, int flag, int lv);
+int mob_get_random_id_lv(int lv, int range);
+int mob_class_change(struct mob_data *md,int class_);
+int mob_warpslave(struct block_list *bl, int range);
+int mob_linksearch(struct block_list *bl,va_list ap);
 
-int mob_random_class (int *value, size_t count);
-int mob_get_random_id(int type, int flag, int lv);
-int mob_class_change(struct mob_data *md,int class_);
-int mob_warpslave(struct block_list *bl, int range);
-int mob_linksearch(struct block_list *bl,va_list ap);
-
 int mobskill_use(struct mob_data *md,unsigned int tick,int event);
 int mobskill_event(struct mob_data *md,struct block_list *src,unsigned int tick, int flag);
 int mobskill_castend_id( int tid, unsigned int tick, int id,int data );
Index: src/map/npc.c
===================================================================
--- src/map/npc.c	(revision 1953)
+++ src/map/npc.c	(working copy)
@@ -37,12 +37,13 @@
 #include "instance.h"
 #include "battle.h"
 #include "skill.h"
-#include "unit.h"
-#include "npc.h"
-#include "chat.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "unit.h"
+#include "npc.h"
+#include "chat.h"
+#include "achievement.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <time.h>
@@ -1170,12 +1171,13 @@
 		return 1;
 
 	switch(nd->subtype) {
-		case SHOP:
-			clif_npcbuysell(sd,nd->bl.id);
-			break;
-		case CASHSHOP:
-			clif_cashshop_show(sd,nd);
-			break;
+		case SHOP:
+			clif_npcbuysell(sd,nd->bl.id);
+			break;
+		case SPSHOP:
+		case CASHSHOP:
+			clif_cashshop_show(sd,nd);
+			break;
 		case SCRIPT:
 			run_script(nd->u.scr.script,0,sd->bl.id,nd->bl.id);
 			break;
@@ -1269,83 +1271,7 @@
 	}
 	return 0;
 }
-/*==========================================
-* Cash Shop Buy List
-*------------------------------------------*/
-int npc_cashshop_buylist(struct map_session_data *sd, int points, int count, unsigned short *item_list)
-{
-	int i, j, nameid, amount, new_, w, vt;
-	struct npc_data *nd = (struct npc_data *)map_id2bl(sd->npc_shopid);
 
-	if(!nd || nd->subtype != CASHSHOP)
-		return 1;
-
-	if(sd->state.trading)
-		return 4;
-
-	new_ = 0;
-	w = 0;
-	vt = 0; // Global Value
-
-	// Validating Process ----------------------------------------------------
-	for(i = 0; i < count; i++) {
-		nameid = item_list[i*2+1];
-		amount = item_list[i*2+0];
-
-		if(!itemdb_exists(nameid) || amount <= 0)
-			return 5;
-
-		ARR_FIND(0,nd->u.shop.count,j,nd->u.shop.shop_item[j].nameid == nameid);
-		if(j == nd->u.shop.count || nd->u.shop.shop_item[j].value <= 0)
-			return 5;
-
-		if(!itemdb_isstackable(nameid) && amount > 1) {
-			ShowWarning("Player %s (%d:%d) sent a hexed packet trying to buy %d of nonstackable item %d!\n", sd->status.name, sd->status.account_id, sd->status.char_id, amount, nameid);
-			amount = item_list[i*2+0] = 1;
-		}
-
-		switch(pc_checkadditem(sd,nameid,amount)) {
-			case ADDITEM_NEW:
-				new_++;
-				break;
-			case ADDITEM_OVERAMOUNT:
-				return 3;
-		}
-
-		vt += nd->u.shop.shop_item[j].value * amount;
-		w += itemdb_weight(nameid) * amount;
-	}
-
-	if(w + sd->weight > sd->max_weight)
-		return 3;
-	if(pc_inventoryblank(sd) < new_)
-		return 3;
-	if(points > vt) points = vt;
-
-	// Payment Process ----------------------------------------------------
-	if(sd->kafraPoints < points || sd->cashPoints < (vt - points))
-		return 6;
-	pc_paycash(sd,vt,points);
-
-	// Delivery Process ----------------------------------------------------
-	for(i = 0; i < count; i++) {
-		struct item item_tmp;
-
-		nameid = item_list[i*2+1];
-		amount = item_list[i*2+0];
-
-		memset(&item_tmp,0,sizeof(item_tmp));
-
-		if(!pet_create_egg(sd,nameid)) {
-			item_tmp.nameid = nameid;
-			item_tmp.identify = 1;
-			pc_additem(sd,&item_tmp,amount,LOG_TYPE_NPC);
-		}
-	}
-
-	return 0;
-}
-
 //npc_buylist for script-controlled shops.
 static int npc_buylist_sub(struct map_session_data *sd, int n, unsigned short *item_list, struct npc_data *nd)
 {
@@ -1371,25 +1297,147 @@
 	return 0;
 }
 
-/*==========================================
- * Cash Shop Buy
- *------------------------------------------*/
-int npc_cashshop_buy(struct map_session_data *sd, int nameid, int amount, int points)
-{
-	struct npc_data *nd = (struct npc_data *)map_id2bl(sd->npc_shopid);
-	struct item_data *item;
-	int i, price, w;
+/*==========================================
+ * Cash Shop Buy
+ *------------------------------------------*/
+int npc_cashshop_buylist(struct map_session_data *sd, int points, int count, unsigned short* item_list)
+{
+	int i, j, nameid, amount, new_, w, vt, vp;
+	struct npc_data *nd = (struct npc_data *)map_id2bl(sd->npc_shopid);
+
+	if( !nd || (nd->subtype != SPSHOP && nd->subtype != CASHSHOP) )
+		return 1;
+
+	if( sd->state.trading )
+		return 4;
+
+	new_ = 0;
+	w = 0;
+	vt = 0; // Global Value
+
+	// Validating Process ----------------------------------------------------
+	for( i = 0; i < count; i++ )
+	{
+		nameid = item_list[i*2+1];
+		amount = item_list[i*2+0];
+
+		if( !itemdb_exists(nameid) || amount <= 0 )
+			return 5;
+
+		ARR_FIND(0,nd->u.shop.count,j,nd->u.shop.shop_item[j].nameid == nameid);
+		if( j == nd->u.shop.count || nd->u.shop.shop_item[j].value <= 0 )
+			return 5;
+
+		if( !itemdb_isstackable(nameid) && amount > 1 )
+		{
+			ShowWarning("Player %s (%d:%d) sent a hexed packet trying to buy %d of nonstackable item %d!\n", sd->status.name, sd->status.account_id, sd->status.char_id, amount, nameid);
+			amount = item_list[i*2+0] = 1;
+		}
+
+		switch( pc_checkadditem(sd,nameid,amount) )
+		{
+			case ADDITEM_NEW:
+				new_++;
+				break;
+			case ADDITEM_OVERAMOUNT:
+				return 3;
+		}
+
+		vp = nd->u.shop.shop_item[j].value * amount;
+		vt += vp;
+		w += itemdb_weight(nameid) * amount;
+	}
+
+	if( w + sd->weight > sd->max_weight )
+		return 3;
+	if( pc_inventoryblank(sd) < new_ )
+		return 3;
+	if( points > vt ) points = vt;
+
+	// -------------------------------------------------------------------
+	// Payment Process
+	// -------------------------------------------------------------------
+	if( nd->subtype == SPSHOP )
+	{ // Special Shop
+		if( points > 0 )
+		{
+			ShowWarning("Player %s (%d:%d) sent a hexed packet trying to buy with points from a Special Shop.\n", sd->status.name, sd->status.account_id, sd->status.char_id);
+			return 6;
+		}
+
+		if( nd->cashitem < 0 )
+		{ // BG Shop
+			int indexs[3] = { 0,0,0 }, badges[3] = { 7828,7829,7773 };
+			for( j = 0; j < 3; j++ )
+			{
+				i = pc_search_inventory(sd,badges[j]);
+				if( i < 0 || sd->status.inventory[i].amount < vt )
+					return 6;
+				indexs[j] = i;
+			}
+
+			for( j = 0; j < 3; j++ )
+				pc_delitem(sd,indexs[j],vt,0,0,LOG_TYPE_NPC);
+		}	
+		else
+		{
+			i = pc_search_inventory(sd,nd->cashitem);
+			if( i < 0 || sd->status.inventory[i].amount < vt )
+				return 6;
+			pc_delitem(sd,i,vt,0,0,LOG_TYPE_NPC);
+		}
+	}
+	else
+	{ // Cash Shop
+		int value1 = pc_readregistry(sd,nd->u.shop.cash_var,nd->u.shop.cash_vartype),
+			value2 = ( nd->u.shop.point_vartype != -1 ) ? pc_readregistry(sd,nd->u.shop.point_var,nd->u.shop.point_vartype) : 0;
+
+		if( value2 < points || value1 < (vt - points) )
+			return 6;
+
+		pc_setregistry(sd,nd->u.shop.cash_var,value1 - (vt - points),nd->u.shop.cash_vartype);
+		if( nd->u.shop.point_vartype != -1 ) pc_setregistry(sd,nd->u.shop.point_var,value2 - points,nd->u.shop.point_vartype);
+	}
+	// -------------------------------------------------------------------
+
+	// Delivery Process ----------------------------------------------------
+	for( i = 0; i < count; i++ )
+	{
+		struct item item_tmp;
+
+		nameid = item_list[i*2+1];
+		amount = item_list[i*2+0];
+
+		memset(&item_tmp,0,sizeof(item_tmp));
+
+		if( !pet_create_egg(sd,nameid) )
+		{
+			item_tmp.nameid = nameid;
+			item_tmp.identify = 1;
+			pc_additem(sd,&item_tmp,amount,LOG_TYPE_NPC);
+		}
+	}
+
+	return 0;
+}
+
+int npc_cashshop_buy(struct map_session_data *sd, int nameid, int amount, int points)
+{
+	struct npc_data *nd = (struct npc_data *)map_id2bl(sd->npc_shopid);
+	struct item_data *item;
+	int i, price, w;
+	struct item item_tmp;
+
+	if( amount <= 0 )
+		return 5;
 
-	if(amount <= 0)
-		return 5;
-
-	if(points < 0)
-		return 6;
-
-	if(!nd || nd->subtype != CASHSHOP)
-		return 1;
-
-	if(sd->state.trading)
+	if( points < 0 )
+		return 6;
+
+	if( !nd || (nd->subtype != SPSHOP && nd->subtype != CASHSHOP) )
+		return 1;
+
+	if( sd->state.trading )
 		return 4;
 
 	if((item = itemdb_exists(nameid)) == NULL)
@@ -1431,14 +1479,55 @@
 	if(points > price)
 		points = price;
 
-	if((sd->kafraPoints < points) || (sd->cashPoints < price - points))
-		return 6;
+	// -------------------------------------------------------------------
+	// Payment Process
+	// -------------------------------------------------------------------
+	if( nd->subtype == SPSHOP )
+	{ // Special Shop
+		if( points > 0 )
+		{
+			ShowWarning("Player %s (%d:%d) sent a hexed packet trying to buy with points from a Special Shop.\n", sd->status.name, sd->status.account_id, sd->status.char_id);
+			return 6;
+		}
 
-	pc_paycash(sd, price, points);
+		if( nd->cashitem < 0 )
+		{ // BG Shop
+			int indexs[3] = { 0,0,0 }, badges[3] = { 7828,7829,7773 }, j;
+			for( j = 0; j < 3; j++ )
+			{
+				i = pc_search_inventory(sd,badges[j]);
+				if( i < 0 || sd->status.inventory[i].amount < price )
+					return 6;
+				indexs[j] = i;
+			}
+			
+			for( j = 0; j < 3; j++ )
+				pc_delitem(sd,indexs[j],price,0,0,LOG_TYPE_NPC);
+		}
+		else
+		{
+			i = pc_search_inventory(sd,nd->cashitem);
+			if( i < 0 || sd->status.inventory[i].amount < price )
+				return 6;
+			pc_delitem(sd,i,price,0,0,LOG_TYPE_NPC);
+		}
+	}
+	else
+	{ // Cash Shop
+		int value1 = pc_readregistry(sd,nd->u.shop.cash_var,nd->u.shop.cash_vartype),
+			value2 = ( nd->u.shop.point_vartype != -1 ) ? pc_readregistry(sd,nd->u.shop.point_var,nd->u.shop.point_vartype) : 0;
+ 
+		if( value2 < points || value1 < (price - points) )
+			return 6;
 
+		pc_setregistry(sd,nd->u.shop.cash_var,value1 - (price - points),nd->u.shop.cash_vartype);
+		if( nd->u.shop.point_vartype != -1 ) pc_setregistry(sd,nd->u.shop.point_var,value2 - points,nd->u.shop.point_vartype);
+	}
+	// -------------------------------------------------------------------
+
+	memset(&item_tmp, 0, sizeof(struct item));
+
 	if(!pet_create_egg(sd, nameid)) {
-		struct item item_tmp;
-		memset(&item_tmp, 0, sizeof(struct item));
 		item_tmp.nameid = nameid;
 		item_tmp.identify = 1;
 
@@ -1530,8 +1619,9 @@
 	if(pc_inventoryblank(sd) < new_)
 		return 3;   // Not enough space to store items
 
-	pc_payzeny(sd,(int)z,LOG_TYPE_NPC, NULL);
-
+	pc_payzeny(sd,(int)z,LOG_TYPE_NPC, NULL);
+	achievement_validate_zeny(sd,ATZ_USE_SHOP,(int)z);
+
 	for(i = 0; i < n; ++i) {
 		int nameid = item_list[i*2+1];
 		int amount = item_list[i*2+0];
@@ -1655,6 +1745,17 @@
 		if(!nameid || !sd->inventory_data[idx] || sd->status.inventory[idx].amount < amount) {
 			return 1;
 		}
+		
+		if( sd->status.inventory[idx].card[0] == CARD0_CREATE )
+		{
+			int char_id = MakeDWord(sd->status.inventory[idx].card[2],sd->status.inventory[idx].card[3]);
+			if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id )
+				return 1;
+			if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id )
+				return 1;
+			if( battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id )
+				return 1;
+		}
 
 		if(nd->master_nd) {
 			// Script-controlled shops decide by themselves, what can be sold and at what price.
@@ -1791,15 +1892,19 @@
 		if(npd && --npd->references == 0) {
 			strdb_remove(npc_path_db, nd->path);/* remove from db */
 			aFree(nd->path);/* remove now that no other instances exist */
-		}
-	}
+		}
+	}
+
+	if( (nd->subtype == SHOP || nd->subtype == CASHSHOP || nd->subtype == SPSHOP) && nd->src_id == 0 ) //src check for duplicate shops [Orcao]
+	{
+		aFree(nd->u.shop.shop_item);
+		if( nd->u.shop.cash_var ) aFree(nd->u.shop.cash_var);
+		if( nd->u.shop.point_var ) aFree(nd->u.shop.point_var);
+	}
+	else if( nd->subtype == SCRIPT ) {
+		struct s_mapiterator* iter;
+		struct block_list* bl;
 
-	if((nd->subtype == SHOP || nd->subtype == CASHSHOP) && nd->src_id == 0)  //src check for duplicate shops [Orcao]
-		aFree(nd->u.shop.shop_item);
-	else if(nd->subtype == SCRIPT) {
-		struct s_mapiterator *iter;
-		struct block_list *bl;
-
 		if(single)
 			ev_db->foreach(ev_db,npc_unload_ev,nd->exname); //Clean up all events related
 
@@ -2121,9 +2226,19 @@
 	struct npc_item_list items[MAX_SHOPITEM];
 	char *p;
 	int x, y, dir, m, i;
-	struct npc_data *nd;
-	enum npc_subtype type;
-
+	struct npc_data *nd;
+
+	// Special Shop
+	int cashitem = 0;
+
+	enum npc_subtype type;
+	if( !strcasecmp(w2,"shop") )
+		type = SHOP;
+	else if( !strcasecmp(w2,"sshop") )
+		type = SPSHOP;
+	else
+		type = CASHSHOP;
+
 	if(strcmp(w1,"-") == 0) {
 		// 'floating' shop?
 		x = y = dir = 0;
@@ -2131,19 +2246,34 @@
 	} else {
 		// w1=<map name>,<x>,<y>,<facing>
 		char mapname[32];
-		if(sscanf(w1, "%31[^,],%d,%d,%d", mapname, &x, &y, &dir) != 4
-		   ||  strchr(w4, ',') == NULL) {
-			ShowError("npc_parse_shop: Invalid shop definition in file '%s', line '%d'.\n * w1=%s\n * w2=%s\n * w3=%s\n * w4=%s\n", filepath, strline(buffer,start-buffer), w1, w2, w3, w4);
-			return strchr(start,'\n');// skip and continue
-		}
+		switch( type ) {
+			case SHOP:
+			case CASHSHOP:
+				if( sscanf(w1, "%31[^,],%d,%d,%d", mapname, &x, &y, &dir) != 4
+				||	strchr(w4, ',') == NULL )
+				{
+					ShowError("npc_parse_shop: Invalid shop definition in file '%s', line '%d'.\n * w1=%s\n * w2=%s\n * w3=%s\n * w4=%s\n", filepath, strline(buffer,start-buffer), w1, w2, w3, w4);
+					return strchr(start,'\n');// skip and continue
+				}
+				break;
+			case SPSHOP:
+				if( sscanf(w1, "%31[^,],%d,%d,%d,%d", mapname, &x, &y, &dir, &cashitem) != 5
+				||	strchr(w4, ',') == NULL )
+				{
+					ShowError("npc_parse_shop: Invalid special shop definition in file '%s', line '%d'.\n * w1=%s\n * w2=%s\n * w3=%s\n * w4=%s\n", filepath, strline(buffer,start-buffer), w1, w2, w3, w4);
+					return strchr(start,'\n');// skip and continue
+				}
+				break;
+			}
 
 		m = map_mapname2mapid(mapname);
 	}
 
-	if(!strcasecmp(w2,"cashshop"))
-		type = CASHSHOP;
-	else
-		type = SHOP;
+	if( type == SPSHOP && cashitem >= 0 && itemdb_exists(cashitem) == NULL )
+	{
+		ShowError("npc_parse_shop: Invalid special shop item in file '%s', line '%d'.\n * w1=%s\n * w2=%s\n * w3=%s\n * w4=%s\n", filepath, strline(buffer,start-buffer), w1, w2, w3, w4);
+		return strchr(start,'\n');
+	}
 
 	p = strchr(w4,',');
 	for(i = 0; i < ARRAYLENGTH(items) && p; ++i) {
@@ -2200,10 +2330,64 @@
 	npc_parsename(nd, w3, start, buffer, filepath);
 	nd->class_ = m==-1?-1:atoi(w4);
 	nd->speed = 200;
+	
+	nd->u.shop.cash_vartype = 0;
+	nd->u.shop.point_vartype = 0;
+ 
+	//assign cash shop var stuff here
+	if( type == CASHSHOP && !strcasecmp(w2,"cashshop") )
+	{ // Default Values
+		nd->u.shop.cash_var = aStrdup("#CASHPOINTS");
+		nd->u.shop.point_var = aStrdup("#KAFRAPOINTS");
+		nd->u.shop.cash_vartype = 2;
+		nd->u.shop.point_vartype = 2;
+	}
+	else if( type == CASHSHOP )
+	{ // Variables were defined as cashshop(<cashpoints>{,<kafrapoints>})
+		char cashvarname_temp[32];
+		char pointvarname_temp[32];
 
+		if( sscanf(w2,"cashshop(%32[^,],%32[^)])",cashvarname_temp,pointvarname_temp) == 2 )
+		{
+			nd->u.shop.cash_var = aStrdup(cashvarname_temp);
+			nd->u.shop.point_var = aStrdup(pointvarname_temp);
+		}
+		else if( sscanf(w2,"cashshop(%32[^)])",cashvarname_temp) == 1 )
+		{
+			nd->u.shop.cash_var = aStrdup(cashvarname_temp);
+			nd->u.shop.point_var = NULL;
+			nd->u.shop.point_vartype = -1; // Not using second var
+		}
+		else
+		{ // Set to defaults
+			nd->u.shop.cash_var = aStrdup("#CASHPOINTS");
+			nd->u.shop.point_var = aStrdup("#KAFRAPOINTS");
+			ShowError("npc_parse_shop: Cash Shop with unknown w2 \"%s\", assuming normal variables\n",w2);
+		}
+
+		// Get variable types
+		if( nd->u.shop.cash_var[0] == '#' && nd->u.shop.cash_var[1] == '#' )
+			nd->u.shop.cash_vartype = 1;
+		else if( nd->u.shop.cash_var[0] == '#' )
+			nd->u.shop.cash_vartype = 2;
+		else
+			nd->u.shop.cash_vartype = 3;
+
+		if( nd->u.shop.point_vartype != -1 )
+		{
+			if( nd->u.shop.point_var[0] == '#' && nd->u.shop.point_var[1] == '#' )
+				nd->u.shop.point_vartype = 1;
+			else if( nd->u.shop.point_var[0] == '#' )
+				nd->u.shop.point_vartype = 2;
+			else
+				nd->u.shop.point_vartype = 3;
+		}
+	}
+
 	++npc_shop;
 	nd->bl.type = BL_NPC;
 	nd->subtype = type;
+	nd->cashitem = cashitem;
 	if(m >= 0) {
 		// normal shop npc
 		map_addnpc(m,nd);
@@ -2488,7 +2672,7 @@
 	type = dnd->subtype;
 
 	// get placement
-	if((type==SHOP || type==CASHSHOP || type==SCRIPT) && strcmp(w1, "-") == 0) {
+	if( (type==SHOP || type==CASHSHOP || type==SPSHOP || type==SCRIPT) && strcmp(w1, "-") == 0 ) {
 		// floating shop/chashshop/script
 		x = y = dir = 0;
 		m = -1;
@@ -2528,16 +2712,21 @@
 			nd->u.scr.ys = ys;
 			nd->u.scr.script = dnd->u.scr.script;
 			nd->u.scr.label_list = dnd->u.scr.label_list;
-			nd->u.scr.label_list_num = dnd->u.scr.label_list_num;
+		nd->u.scr.label_list_num = dnd->u.scr.label_list_num;
+		break;
+
+	case CASHSHOP:
+		nd->u.shop.cash_var = dnd->u.shop.cash_var;
+		nd->u.shop.cash_vartype = dnd->u.shop.cash_vartype;
+		nd->u.shop.point_var = dnd->u.shop.point_var;
+		nd->u.shop.point_vartype = dnd->u.shop.point_vartype;
+	case SHOP:
+	case SPSHOP:
+		++npc_shop;
+		nd->u.shop.shop_item = dnd->u.shop.shop_item;
+		nd->u.shop.count = dnd->u.shop.count;
 			break;
 
-		case SHOP:
-		case CASHSHOP:
-			++npc_shop;
-			nd->u.shop.shop_item = dnd->u.shop.shop_item;
-			nd->u.shop.count = dnd->u.shop.count;
-			break;
-
 		case WARP:
 			++npc_warp;
 			if(!battle_config.warp_point_debug)
@@ -2589,6 +2778,63 @@
 	return end;
 }
 
+void npc_duplicate4graveyard(struct block_list* bl, struct block_list* sbl)
+{
+	char newname[NAME_LENGTH];
+	static char w1[50], w2[50], w3[50], w4[50];
+	const char* stat_buf = "- call from graveyard subsystem -\n";
+	struct npc_data* nd; // Source NPC
+
+	if( !bl || !sbl ) return; // No Killed or Killer
+
+	snprintf(newname, ARRAYLENGTH(newname), "grvrd_%d_", bl->id);
+	if( npc_name2id(newname) != NULL )
+	{
+		ShowError("npc_duplicate4graveyard: the npcname (%s) is already in use while trying to create a graveyard.\n", newname);
+		return;
+	}
+
+	if( (nd = npc_name2id("Graveyard_Base")) == NULL )
+	{
+		ShowError("npc_duplicate4graveyard: the source npc for graveyard cannot be found.\n");
+		return;
+	}
+
+	snprintf(w1, sizeof(w1), "%s,%d,%d,%d", map[bl->m].name, bl->x, bl->y, unit_getdir(bl));
+	snprintf(w2, sizeof(w2), "duplicate(%s)", nd->exname);
+	snprintf(w3, sizeof(w3), "%s#%d::%s", nd->name, bl->id, newname);
+	snprintf(w4, sizeof(w4), "%d", 565); // Graveyard sprite - JT_MOB_TOMB
+
+	npc_parse_duplicate(w1, w2, w3, w4, stat_buf, stat_buf, "GRAVEYARD SYSTEM");
+	if( (nd = npc_name2id(newname)) != NULL )
+	{
+		switch( bl->type )
+		{
+		case BL_MOB:
+			((TBL_MOB*)bl)->graveyard_npc_id = nd->bl.id;
+			safestrncpy(nd->graveyard.name,((TBL_MOB*)bl)->name,sizeof(nd->graveyard.name));
+			break;
+		case BL_PC:
+			((TBL_PC*)bl)->graveyard_npc_id = nd->bl.id;
+			safestrncpy(nd->graveyard.name,((TBL_PC*)bl)->status.name,sizeof(nd->graveyard.name));
+			break;
+		}
+
+		// Set Graveyard Information
+		switch( sbl->type )
+		{
+		case BL_MOB:
+			safestrncpy(nd->graveyard.killed_by,((TBL_MOB*)sbl)->name,sizeof(nd->graveyard.name));
+			break;
+		case BL_PC:
+			safestrncpy(nd->graveyard.killed_by,((TBL_PC*)sbl)->status.name,sizeof(nd->graveyard.name));
+			break;
+		}
+
+		time(&nd->graveyard.killed_time);
+	}
+}
+
 int npc_duplicate4instance(struct npc_data *snd, int16 m)
 {
 	char newname[NAME_LENGTH];
@@ -2752,13 +2998,13 @@
 void npc_setdisplayname(struct npc_data *nd, const char *newname)
 {
 	nullpo_retv(nd);
-
-	safestrncpy(nd->name, newname, sizeof(nd->name));
-	if(map[nd->bl.m].users)
-		clif_charnameack(0, &nd->bl);
-}
-
-/// Changes the display class of the npc.
+
+	safestrncpy(nd->name, newname, sizeof(nd->name));
+	if( map[nd->bl.m].users )
+		clif_charnameack(NULL, &nd->bl);
+}
+
+/// Changes the display class of the npc.
 ///
 /// @param nd Target npc
 /// @param class_ New display class
@@ -2979,16 +3225,17 @@
 	if(ai > 0 && ai <= 4)
 		mob.state.ai = ai;
 
-	if(mob.num > 1 && battle_config.mob_count_rate != 100) {
-		if((mob.num = mob.num * battle_config.mob_count_rate / 100) < 1)
-			mob.num = 1;
-	}
-
-	if(battle_config.force_random_spawn || (mob.x == 0 && mob.y == 0)) {
+	if( battle_config.force_random_spawn || (mob.x == 0 && mob.y == 0) ) {
 		//Force a random spawn anywhere on the map.
 		mob.x = mob.y = 0;
 		mob.xs = mob.ys = -1;
 	}
+	
+	if( mob.num > 1 && battle_config.mob_count_rate != 100 )
+	{
+		if( (mob.num = mob.num * battle_config.mob_count_rate / 100) < 1 )
+			mob.num = 1;
+	}
 
 	if(mob.delay1>0xfffffff || mob.delay2>0xfffffff) {
 		ShowError("npc_parse_mob: Invalid spawn delays %u %u (file '%s', line '%d').\n", mob.delay1, mob.delay2, filepath, strline(buffer,start-buffer));
@@ -3011,6 +3258,13 @@
 
 	//Update mob spawn lookup database
 	db = mob_db(class_);
+	if( mob.num > 1 && db->spawn_rate != 100 )
+	{
+		if( (mob.num = mob.num * db->spawn_rate / 100) < 1 )
+			mob.num = 1;
+	}
+	//Total Spawn Count
+	db->spawn_count += mob.num;
 	for(i = 0; i < ARRAYLENGTH(db->spawn); ++i) {
 		if(map[mob.m].index == db->spawn[i].mapindex) {
 			//Update total
@@ -3105,12 +3359,95 @@
 			}
 		}
 		map[m].flag.nosave = state;
-	} else if(!strcmpi(w3,"autotrade"))
+	}
+	else if (!strcmpi(w3,"pvp_event"))
+	{
+		int x1, y1, x2, y2;
+		if( state == 0 )
+			;
+		if( sscanf(w4, "%d,%d,%d,%d", &x1, &y1, &x2, &y2) == 4 )
+		{
+			if( x1 > x2 ) swap(x1, x2);
+			if( y1 > y2 ) swap(y1, y2);
+
+			map[m].pvpe_x1 = x1;
+			map[m].pvpe_y1 = y1;
+			map[m].pvpe_x2 = x2;
+			map[m].pvpe_y2 = y2;
+			map[m].pvpe_area = true;
+		}
+		map[m].flag.pvp_event = state;
+	}
+	else if (!strcmpi(w3,"woe_set"))
+	{
+		if( state )
+		{
+			if( sscanf(w4, "%d", &state) == 1 )
+				map[m].flag.woe_set = state;
+			else
+				ShowWarning("npc_parse_mapflag: Missing value for woe_set mapflag (file '%s', line '%d').\n", filepath, strline(buffer,start-buffer));
+		}
+		else
+			map[m].flag.woe_set = 0;
+	}
+	else if (!strcmpi(w3,"ancient"))
+	{
+		map[m].flag.ancient = state;
+		if( state )
+		{
+			map[m].guild_max = 36; // Ep 9 Max Guild Members value
+			map[m].flag.guildlock = 1;
+		}
+		else
+		{
+			map[m].guild_max = 0;
+			map[m].flag.guildlock = 0;
+		}
+	}
+	else if (!strcmpi(w3,"blocked"))
+		map[m].flag.blocked = state;
+	else if (!strcmpi(w3,"guild_max"))
+	{
+		if( map[m].flag.ancient )
+		{
+			ShowWarning("npc_parse_mapflag: Cannot change guild_max limit on ancient woe maps. (file '%s', line '%d').\n", filepath, strline(buffer,start-buffer));
+		}
+		else if( state && sscanf(w4, "%d", &state) == 1 )
+		{
+			map[m].guild_max = state;
+			map[m].flag.guildlock = 1;
+		}
+		else
+		{
+			map[m].guild_max = 0;
+			map[m].flag.guildlock = 0;
+		}
+	}
+	else if (!strcmpi(w3,"party_max"))
+	{
+		if( state && sscanf(w4, "%d", &state) == 1 )
+		{
+			map[m].party_max = state;
+			map[m].flag.partylock = 1;
+		}
+		else
+		{
+			map[m].party_max = 0;
+			map[m].flag.partylock = 0;
+		}
+	}
+	else if (!strcmpi(w3,"nopvpmode"))
+		map[m].flag.nopvpmode=state;
+	else if(!strcmpi(w3,"autotrade"))
 		map[m].flag.autotrade=state;
+	else if (!strcmpi(w3,"noemergencycall"))
+		map[m].flag.noemergencycall=state;
 	else if(!strcmpi(w3,"allowks"))
 		map[m].flag.allowks=state; // [Kill Steal Protection]
 	else if(!strcmpi(w3,"town"))
 		map[m].flag.town=state;
+	else if (!strcmpi(w3,"noguildwar"))
+		map[m].flag.noguildwar=state;
 	else if(!strcmpi(w3,"nomemo"))
 		map[m].flag.nomemo=state;
 	else if(!strcmpi(w3,"noteleport"))
@@ -3168,8 +3505,13 @@
 						map[m].drop_list[i].drop_type = drop_type;
 						map[m].drop_list[i].drop_per = drop_per;
 						break;
-					}
-				}
+		}
+		if( state && map[m].flag.fvf )
+		{
+			map[m].flag.fvf = 0;
+			ShowWarning("npc_parse_mapflag: You can't set PvP and FvF flags for the same map! Removing FvF flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+		}
+	}
 				map[m].flag.pvp_nightmaredrop = 1;
 			}
 		} else if(!state)  //Disable
@@ -3180,14 +3522,41 @@
 		map[m].flag.gvg = state;
 		if(state && map[m].flag.pvp) {
 			map[m].flag.pvp = 0;
-			ShowWarning("npc_parse_mapflag: You can't set PvP and GvG flags for the same map! Removing PvP flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+			ShowWarning("npc_parse_mapflag: You can't set GvG and PvP flags for the same map! Removing PvP flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
 		}
+		if( state && map[m].flag.fvf )
+		{
+			map[m].flag.fvf = 0;
+			ShowWarning("npc_parse_mapflag: You can't set GvG and FvF flags for the same map! Removing FvF flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+		}
 		if(state && map[m].flag.battleground) {
 			map[m].flag.battleground = 0;
 			ShowWarning("npc_parse_mapflag: You can't set GvG and BattleGround flags for the same map! Removing BattleGround flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
 		}
+		else if (!strcmpi(w3,"fvf")) {
+			map[m].flag.fvf = state;
+			if( state && map[m].flag.pvp )
+			{
+				map[m].flag.pvp = 0;
+				ShowWarning("npc_parse_mapflag: You can't set FvF and PvP flags for the same map! Removing PvP flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+			}
+			if( state && map[m].flag.battleground )
+			{
+				map[m].flag.battleground = 0;
+				ShowWarning("npc_parse_mapflag: You can't set FvF and BattleGround flags for the same map! Removing BattleGround flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+			}
+			if( state && (map[m].flag.gvg || map[m].flag.gvg_dungeon || map[m].flag.gvg_castle) )
+			{
+				map[m].flag.gvg = 0;
+				map[m].flag.gvg_dungeon = 0;
+				map[m].flag.gvg_castle = 0;
+				ShowWarning("npc_parse_mapflag: You can't set FvF and GvG flags for the same map! Removing GvG flags from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+			}
+		}
 	} else if(!strcmpi(w3,"gvg_noparty"))
 		map[m].flag.gvg_noparty=state;
+	else if (!strcmpi(w3,"gvg_noalliance"))
+		map[m].flag.gvg_noalliance=state;
 	else if(!strcmpi(w3,"gvg_dungeon")) {
 		map[m].flag.gvg_dungeon=state;
 		if(state) map[m].flag.pvp=0;
@@ -3213,17 +3582,30 @@
 			map[m].flag.gvg_castle = 0;
 			ShowWarning("npc_parse_mapflag: You can't set GvG and BattleGround flags for the same map! Removing GvG flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
 		}
+		if( map[m].flag.battleground && map[m].flag.fvf )
+		{
+			map[m].flag.fvf = 0;
+			ShowWarning("npc_parse_mapflag: You can't set FvF and Battleground flags for the same map! Removing FvF flag from %s (file '%s', line '%d').\n", map[m].name, filepath, strline(buffer,start-buffer));
+		}
+ 	}
+	else if (!strcmpi(w3,"bg_topscore")) {
+		if( state && sscanf(w4, "%d", &state) == 1 )
+			map[m].bgscore_top = state;
+		else
+			map[m].bgscore_top = 0; // Default value
 	} else if(!strcmpi(w3,"noexppenalty"))
 		map[m].flag.noexppenalty=state;
 	else if(!strcmpi(w3,"nozenypenalty"))
 		map[m].flag.nozenypenalty=state;
 	else if(!strcmpi(w3,"notrade"))
-		map[m].flag.notrade=state;
-	else if(!strcmpi(w3,"novending"))
-		map[m].flag.novending=state;
-	else if(!strcmpi(w3,"nodrop"))
-		map[m].flag.nodrop=state;
-	else if(!strcmpi(w3,"noskill"))
+		map[m].flag.notrade=state;
+	else if (!strcmpi(w3,"novending"))
+		map[m].flag.novending=state;
+	else if (!strcmpi(w3,"vending_cell"))
+		map[m].flag.vending_cell=state;
+	else if (!strcmpi(w3,"nodrop"))
+		map[m].flag.nodrop=state;
+	else if (!strcmpi(w3,"noskill"))
 		map[m].flag.noskill=state;
 	else if(!strcmpi(w3,"noicewall"))
 		map[m].flag.noicewall=state;
@@ -3299,6 +3681,15 @@
 		map[m].flag.guildlock=state;
 	else if(!strcmpi(w3,"reset"))
 		map[m].flag.reset=state;
+	else if (!strcmpi(w3,"nostorage"))
+		map[m].flag.nostorage=state;
+	else if (!strcmpi(w3,"noguildstorage"))
+		map[m].flag.noguildstorage=state;
+
+	else if (!strcmpi(w3,"allow_woe_items"))
+		map[m].flag.allow_woe_items=state;
+	else if (!strcmpi(w3,"allow_bg_items"))
+		map[m].flag.allow_bg_items=state;
 	else if(!strcmpi(w3,"set_castle"))
 		map[m].set_castle = atoi(w4);
 	else if (!strcmpi(w3,"adjust_unit_duration")) {
@@ -3469,9 +3860,9 @@
 			#endif
 			p = npc_parse_warp(w1,w2,w3,w4, p, buffer, filepath);
 			#ifdef RENEWAL
-		} else if((strcasecmp(w2,"shop") == 0 || strcasecmp(w2,"cashshop") == 0 || strcasecmp(w2,"shop#re") == 0 || strcasecmp(w2,"cashshop#re") == 0) && count > 3) {
+		} else if((!strcasecmp(w2,"shop") || !strcasecmp(w2,"sshop") || !strcasecmp(w2,"cashshop") || (i = 0, sscanf(w2,"cashshop%n",&i), (i > 0 && w2[i] == '('))) && count > 3) {
 			#else
-		} else if((strcasecmp(w2,"shop") == 0 || strcasecmp(w2,"cashshop") == 0 || strcasecmp(w2,"shop#pre") == 0 || strcasecmp(w2,"cashshop#pre") == 0) && count > 3) {
+		} else if((!strcasecmp(w2,"shop") || !strcasecmp(w2,"sshop") || !strcasecmp(w2,"cashshop") || (i = 0, sscanf(w2,"cashshop%n",&i), (i > 0 && w2[i] == '('))) && count > 3) {
 			#endif
 			p = npc_parse_shop(w1,w2,w3,w4, p, buffer, filepath);
 			#ifdef RENEWAL
@@ -3653,12 +4044,14 @@
 
 	npc_warp = npc_shop = npc_script = 0;
 	npc_mob = npc_cache_mob = npc_delay_mob = 0;
-
-	// reset mapflags
-	map_flags_init();
-
-	//TODO: the following code is copy-pasted from do_init_npc(); clean it up
-	// Reloading npcs now
+
+	// reset mapflags
+	map_flags_init();
+	// reset battleground teams and queues
+	bg_reload();
+
+	//TODO: the following code is copy-pasted from do_init_npc(); clean it up
+	// Reloading npcs now
 	for(nsl = npc_src_files; nsl; nsl = nsl->next) {
 		ShowStatus("Carregando arquivo de NPC: %s"CL_CLL"\r", nsl->name);
 		npc_parsesrcfile(nsl->name,false);
Index: src/map/npc.h
===================================================================
--- src/map/npc.h	(revision 1953)
+++ src/map/npc.h	(working copy)
@@ -33,12 +33,18 @@
 	int pos;
 };
 struct npc_item_list {
-	unsigned int nameid,value;
-};
-
-struct npc_data {
-	struct block_list bl;
-	struct unit_data  ud; //Because they need to be able to move....
+	unsigned int nameid,value;
+};
+
+struct graveyard_info {
+	char name[NAME_LENGTH]; // Name of the Victim
+	char killed_by[NAME_LENGTH];
+	time_t killed_time;
+};
+
+struct npc_data {
+	struct block_list bl;
+	struct unit_data  ud; //Because they need to be able to move....
 	struct view_data *vd;
 	struct status_change sc; //They can't have status changes, but.. they want the visual opt values.
 	struct npc_data *master_nd;
@@ -47,36 +53,41 @@
 	char name[NPC_NAME_LENGTH+1];// display name
 	char exname[NPC_NAME_LENGTH+1];// unique npc name
 	int chat_id;
-	int touching_id;
-	unsigned int next_walktime;
-
-	unsigned size : 2;
-
-	struct status_data status;
-	unsigned int level;
-	unsigned int stat_point;
-
-	void* chatdb; // pointer to a npc_parse struct (see npc_chat.c)
-	char* path;/* path dir */
-	enum npc_subtype subtype;
+	int touching_id;
+	unsigned int next_walktime;
+
+	short cashitem; // PShop
+	unsigned size : 2;
+
+	struct status_data status;
+	unsigned int level;
+	unsigned int stat_point;
+
+	struct graveyard_info graveyard; // Graveyard System
+
+	void* chatdb; // pointer to a npc_parse struct (see npc_chat.c)
+	char* path;/* path dir */
+	enum npc_subtype subtype;
 	int src_id;
 	union {
-		struct {
-			struct script_code *script;
-			short xs,ys; // OnTouch area radius
-			int guild_id;
-			int timer,timerid,timeramount,rid;
-			unsigned int timertick;
-			struct npc_timerevent_list *timer_event;
+		struct {
+			struct script_code *script;
+			short xs,ys; // OnTouch area radius
+			int guild_id, bg_id, faction_id;
+			int timer,timerid,timeramount,rid;
+			unsigned int timertick;
+			struct npc_timerevent_list *timer_event;
 			int label_list_num;
 			struct npc_label_list *label_list;
 		} scr;
-		struct {
-			struct npc_item_list* shop_item;
-			int count;
-		} shop;
-		struct {
-			short xs,ys; // OnTouch area radius
+		struct {
+			struct npc_item_list* shop_item;
+			int count;
+			char *cash_var, *point_var;
+			short cash_vartype, point_vartype; //1 = ##, 2 = #, 3 = Character
+		} shop;
+		struct {
+			short xs,ys; // OnTouch area radius
 			short x,y; // destination coords
 			unsigned short mapindex; // destination map
 		} warp;
@@ -173,16 +184,19 @@
 void npc_unload_duplicates (struct npc_data* nd);
 int npc_unload(struct npc_data* nd, bool single);
 int npc_reload(void);
-void npc_read_event_script(void);
-int npc_script_event(struct map_session_data* sd, enum npce_event type);
+void npc_read_event_script(void);
+int npc_script_event(struct map_session_data* sd, enum npce_event type);
+
+void npc_duplicate4graveyard(struct block_list* bl, struct block_list* sbl);
+int npc_duplicate4instance(struct npc_data *snd, int16 m);
+int npc_cashshop_buy(struct map_session_data *sd, int nameid, int amount, int points);
+
+int npc_do_atcmd_event(struct map_session_data* sd, const char* command, const char* message, const char* eventname);
+
+extern struct npc_data* fake_nd;
+
+int npc_cashshop_buylist(struct map_session_data *sd, int points, int count, unsigned short* item_list);
 
-int npc_duplicate4instance(struct npc_data *snd, int16 m);
-int npc_cashshop_buy(struct map_session_data *sd, int nameid, int amount, int points);
-
-extern struct npc_data* fake_nd;
-
-int npc_cashshop_buylist(struct map_session_data *sd, int points, int count, unsigned short* item_list);
-
 /**
  * For the Secure NPC Timeout option (check config/Secure.h) [RR]
  **/
Index: src/map/party.c
===================================================================
--- src/map/party.c	(revision 1953)
+++ src/map/party.c	(working copy)
@@ -22,12 +22,13 @@
 #include "../common/random.h"
 #include "../common/showmsg.h"
 #include "../common/utils.h"
-#include "../common/strlib.h"
-
-#include "party.h"
-#include "atcommand.h"  //msg_txt()
-#include "pc.h"
-#include "map.h"
+#include "../common/strlib.h"
+
+#include "party.h"
+#include "battleground.h"
+#include "atcommand.h"	//msg_txt()
+#include "pc.h"
+#include "map.h"
 #include "instance.h"
 #include "battle.h"
 #include "intif.h"
@@ -383,6 +384,12 @@
 		clif_party_inviteack(sd,tsd->status.name,1);
 		return 0;
 	}
+	
+	if( !battle_config.faction_allow_party && sd->status.faction_id != tsd->status.faction_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot invite to party with other faction's members.");
+		return 0;
+	}
 
 	if(tsd->status.party_id > 0 || tsd->party_invite > 0) {
 		// already associated with a party
@@ -1041,34 +1048,52 @@
 /// Executes 'func' for each party member on the same map and in range (0:whole map)
 int party_foreachsamemap(int (*func)(struct block_list *,va_list),struct map_session_data *sd,int range,...)
 {
-	struct party_data *p;
-	int i;
-	int x0,y0,x1,y1;
-	struct block_list *list[MAX_PARTY];
+	struct party_data *p = NULL;
+	struct battleground_data *bg = NULL;
+	struct map_session_data *psd;
+	int i,x0,y0,x1,y1;
+	struct block_list *list[MAX_BG_MEMBERS];
 	int blockcount=0;
 	int total = 0; //Return value.
 
 	nullpo_ret(sd);
 
-	if((p=party_search(sd->status.party_id))==NULL)
+	if( map[sd->bl.m].flag.battleground && (bg = bg_team_search(sd->bg_id)) == NULL )
 		return 0;
+	else if( !map[sd->bl.m].flag.battleground && (p = party_search(sd->status.party_id)) == NULL )
+		return 0;
 
 	x0=sd->bl.x-range;
 	y0=sd->bl.y-range;
 	x1=sd->bl.x+range;
 	y1=sd->bl.y+range;
 
-	for(i=0; i<MAX_PARTY; i++) {
-		struct map_session_data *psd = p->data[i].sd;
-		if(!psd) continue;
-		if(psd->bl.m!=sd->bl.m || !psd->bl.prev)
-			continue;
-		if(range &&
-		   (psd->bl.x<x0 || psd->bl.y<y0 ||
-		    psd->bl.x>x1 || psd->bl.y>y1))
-			continue;
-		list[blockcount++]=&psd->bl;
+	if( bg ) {
+		for( i = 0; i < MAX_BG_MEMBERS; i++ )
+		{
+			if( (psd = bg->members[i].sd) == NULL )
+				continue;
+			if( psd->bl.m != sd->bl.m || !psd->bl.prev )
+				continue;
+			if( range && (psd->bl.x < x0 || psd->bl.y < y0 || psd->bl.x > x1 || psd->bl.y > y1) )
+				continue;
+			list[blockcount++] = &psd->bl;
+		}
 	}
+	else if( p )
+	{
+		for( i = 0; i < MAX_PARTY; i++ )
+		{
+			if( (psd = p->data[i].sd) == NULL )
+				continue;
+			if( psd->bl.m != sd->bl.m || !psd->bl.prev )
+				continue;
+			if( range && (psd->bl.x < x0 || psd->bl.y < y0 || psd->bl.x > x1 || psd->bl.y > y1) )
+				continue;
+			list[blockcount++] = &psd->bl;
+		}
+	}
+	else return 0;
 
 	map_freeblock_lock();
 
Index: src/map/pc.c
===================================================================
--- src/map/pc.c	(revision 1953)
+++ src/map/pc.c	(working copy)
@@ -25,12 +25,13 @@
 #include "../common/utils.h"
 #include "../common/mmo.h" //NAME_LENGTH
 
-#include "atcommand.h" // get_atcommand_level()
-#include "battle.h" // battle_config
-#include "battleground.h"
-#include "chrif.h"
-#include "clif.h"
-#include "date.h" // is_day_of_*()
+#include "atcommand.h" // get_atcommand_level()
+#include "battle.h" // battle_config
+#include "battleground.h"
+#include "channel.h"
+#include "chrif.h"
+#include "clif.h"
+#include "date.h" // is_day_of_*()
 #include "duel.h"
 #include "intif.h"
 #include "itemdb.h"
@@ -52,17 +53,21 @@
 #include "pc.h"
 #include "pc_groups.h"
 #include "quest.h"
+#include "achievement.h"
+#include "region.h"
+#include "storage.h"
+#include "mapreg.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#include <math.h>
 
-
-#define PVP_CALCRANK_INTERVAL 1000  // PVP calculation interval
+#define PVP_CALCRANK_INTERVAL 1000	// PVP calculation interval
 static unsigned int exp_table[CLASS_COUNT][2][MAX_LEVEL];
 static unsigned int max_level[CLASS_COUNT][2];
-static unsigned int statp[MAX_LEVEL+1];
+unsigned int stats_point_table[MAX_LEVEL+1];
 #if defined(RENEWAL_DROP) || defined(RENEWAL_EXP)
 static unsigned int level_penalty[3][RC_MAX][MAX_LEVEL*2+1];
 #endif
@@ -76,15 +81,21 @@
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list pvprank_fame_list[MAX_FAME_LIST];
+struct fame_list pvpevent_fame_list[MAX_FAME_LIST];
+struct fame_list bgrank_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
 
-static unsigned short equip_pos[EQI_MAX]= {EQP_ACC_L,EQP_ACC_R,EQP_SHOES,EQP_GARMENT,EQP_HEAD_LOW,EQP_HEAD_MID,EQP_HEAD_TOP,EQP_ARMOR,EQP_HAND_L,EQP_HAND_R,EQP_COSTUME_HEAD_TOP,EQP_COSTUME_HEAD_MID,EQP_COSTUME_HEAD_LOW,EQP_COSTUME_GARMENT,EQP_AMMO};
+static unsigned short equip_pos[EQI_MAX]={EQP_ACC_L,EQP_ACC_R,EQP_SHOES,EQP_GARMENT,EQP_HEAD_LOW,EQP_HEAD_MID,EQP_HEAD_TOP,EQP_ARMOR,EQP_HAND_L,EQP_HAND_R,EQP_AMMO,EQP_COS_HEAD_TOP,EQP_COS_HEAD_MID,EQP_COS_HEAD_LOW};
 
 #define MOTD_LINE_SIZE 128
 static char motd_text[MOTD_LINE_SIZE][CHAT_SIZE_MAX]; // Message of the day buffer [Valaris]
 
+int global_size = 0;
+
 //Links related info to the sd->hate_mob[]/sd->feel_map[] entries
 const struct sg_data sg_info[MAX_PC_FEELHATE] = {
-	{ SG_SUN_ANGER, SG_SUN_BLESS, SG_SUN_COMFORT, "PC_FEEL_SUN", "PC_HATE_MOB_SUN", is_day_of_sun },
+		{ SG_SUN_ANGER, SG_SUN_BLESS, SG_SUN_COMFORT, "PC_FEEL_SUN", "PC_HATE_MOB_SUN", is_day_of_sun },
 	{ SG_MOON_ANGER, SG_MOON_BLESS, SG_MOON_COMFORT, "PC_FEEL_MOON", "PC_HATE_MOB_MOON", is_day_of_moon },
 	{ SG_STAR_ANGER, SG_STAR_BLESS, SG_STAR_COMFORT, "PC_FEEL_STAR", "PC_HATE_MOB_STAR", is_day_of_star }
 };
@@ -111,9 +122,172 @@
 	return class_;
 }
 
+// Removes invalid Cards on Items on authok
+// Send this Cards via eMail to the user
+void pc_fix_items_sub(struct item *it, struct item_data *inventory_data, struct mail_message *msg)
+{
+	struct item_data *card, *item = inventory_data;
+	int j;
+
+	if( it == NULL || it->nameid == 0 )
+		return;
+	if( item == NULL && (item = itemdb_exists(it->nameid)) == NULL )
+		return;
+
+	// Check Refine
+	if( item->flag.no_refine && it->refine > 0 )
+		it->refine = 0;
+	if( it->refine > MAX_REFINE )
+		it->refine = MAX_REFINE;
+
+#ifdef NSI_UNIQUE_ID
+	if( !itemdb_isstackable2(item) && !it->unique_id )
+		it->unique_id = itemdb_unique_id(0,0);
+#endif
+
+	if( (item->type != IT_ARMOR && item->type != IT_WEAPON) || itemdb_isspecial(it->card[0]) )
+		return;
+
+	for( j = 0; j < MAX_SLOTS; j++ )
+	{
+		if( it->card[j] == 0 || (card = itemdb_exists(it->card[j])) == NULL || card->type != IT_CARD )
+			continue;
+
+		if( j < item->slot )
+		{ // Equip Slots
+			if( (item->equip&card->equip) == 0 || (item->type == IT_WEAPON && card->equip == EQP_SHIELD) )
+				; // This card don't belong here
+			else continue;
+		}
+		else if( itemdb_isenchant(it->card[j]) )
+			continue;
+
+		if( msg )
+		{
+			msg->item.nameid = it->card[j];
+			intif_Mail_send(0, msg);
+		}
+		it->card[j] = 0;
+	}
+
+	return;
+}
+
+void pc_fix_items(struct map_session_data *sd)
+{
+	struct mail_message msg;
+	int i;
+	nullpo_retv(sd);
+
+	// Prepare Base Message
+	msg.id = 0;
+	msg.send_id = 0;
+	safestrncpy(msg.send_name, "Server", NAME_LENGTH);
+	msg.dest_id = sd->status.char_id;
+	safestrncpy(msg.dest_name, sd->status.name, NAME_LENGTH);
+	safestrncpy(msg.title, "Item check system", MAIL_TITLE_LENGTH);
+	safestrncpy(msg.body, "An item had its number of slots changed. This mail contains a card removed from one of the excessive slots.", MAIL_BODY_LENGTH);
+	msg.status = 0;
+	msg.zeny = 0;
+	msg.timestamp = time(NULL);
+	memset(&msg.item, 0, sizeof(struct item));
+	msg.item.amount = 1;
+	msg.item.identify = 1;
+	
+	for( i = 0; i < MAX_INVENTORY; i++ )
+		pc_fix_items_sub(&sd->status.inventory[i], sd->inventory_data[i], &msg);
+	for( i = 0; i < MAX_CART; i++ )
+		pc_fix_items_sub(&sd->status.cart[i], NULL, &msg);
+	for( i = 0; i < MAX_STORAGE; i++ )
+		pc_fix_items_sub(&sd->status.storage.items[i], NULL, &msg);
+	for( i = 0; i < MAX_EXTRA_STORAGE; i++ )
+		pc_fix_items_sub(&sd->status.ext_storage.items[i], NULL, &msg);
+}
+
+int pc_need_status_point2(int stat)
+{
+		if( stat >= 115 ) return 28;
+		if( stat >= 110 ) return 24;
+		if( stat >= 105 ) return 20;
+		if( stat >= 100 ) return 16;
+		return ( 1 + (stat + 9) / 10 );
+}
+
+bool pc_isPremium(struct map_session_data *sd)
+{
+	return ( battle_config.premium_group_id && sd->Premium_Tick > (int)time(NULL) );
+}
+
+void pc_calc_playtime(struct map_session_data* sd)
+{
+	if( !sd->state.autotrade && sd->state.active )
+	{
+		sd->status.playtime += DIFF_TICK(last_tick, sd->status.last_tick);
+		sd->status.last_tick = last_tick;
+	}
+	
+	return;
+}
+
+/***********************************************************
+* Update Idle PC Timer
+* Type
+* 0 = Send By Server
+* 1 = KeyBoard Action
+* 2 = Mouse Click
+* 3 = Both Hands
+***********************************************************/
+int pc_update_last_action(struct map_session_data *sd, int type)
+{
+	struct battleground_data *bg;
+	unsigned int tick = gettick();
+
+	sd->idletime = last_tick;
+
+	if( sd->bg_id && sd->state.bg_afk && (bg = bg_team_search(sd->bg_id)) != NULL && bg->g )
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, "%s : %s is no longer away...", bg->g->name, sd->status.name);
+		clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	switch( type )
+	{
+	case 1: // Keyboard Possible Actions (Skill Single, Potion)
+		if( battle_config.action_keyboard_limit )
+		{
+			if( DIFF_TICK(tick, sd->keyboard_action_tick) < battle_config.action_keyboard_limit )
+				return 0;
+			sd->keyboard_action_tick = tick;
+		}
+		break;
+	case 2:
+		if( battle_config.action_mouse_limit )
+		{
+			if( DIFF_TICK(tick, sd->mouse_action_tick) < battle_config.action_mouse_limit )
+				return 0;
+			sd->mouse_action_tick = tick;
+		}
+		break;
+	case 3:
+		if( battle_config.action_dual_limit )
+		{
+			unsigned int mtick = max(sd->keyboard_action_tick,sd->mouse_action_tick);
+			if( DIFF_TICK(tick,mtick) < battle_config.action_dual_limit )
+				return 0;
+			sd->keyboard_action_tick = tick;
+			sd->mouse_action_tick = tick;
+		}
+		break;
+	}
+
+	return 1;
+}
+
 inline int pc_get_group_id(struct map_session_data *sd)
 {
-	return sd->group_id;
+	return pc_isPremium(sd) ? battle_config.premium_group_id : sd->group_id;
 }
 
 inline int pc_get_group_level(struct map_session_data *sd)
@@ -121,6 +295,18 @@
 	return sd->group_level;
 }
 
+unsigned char pc_pvpfamerank(int char_id)
+{
+	int i;
+
+	for (i = 0; i < MAX_FAME_LIST; i++){
+		if(pvprank_fame_list[i].id == char_id)
+			return i + 1;
+	}
+
+	return 0;
+}
+
 static int pc_invincible_timer(int tid, unsigned int tick, int id, intptr_t data)
 {
 	struct map_session_data *sd;
@@ -350,32 +536,159 @@
 	}
 
 	return c;
-}
-
-// Increases a player's fame points and displays a notice to him
-void pc_addfame(struct map_session_data *sd,int count)
-{
-	nullpo_retv(sd);
-	sd->status.fame += count;
-	if(sd->status.fame > MAX_FAME)
-		sd->status.fame = MAX_FAME;
+}
+
+// Increases a player's fame points and displays a notice to him
+void pc_addfame(struct map_session_data *sd,int count,short flag)
+{
+	nullpo_retv(sd);
+	switch( flag )
+	{
+	case 1: // Pk Rank
+		sd->status.pk.score += count;
+		if( sd->status.pk.score > MAX_FAME )
+			sd->status.pk.score = MAX_FAME;
+
+		clif_rank_info(sd,count,sd->status.pk.score,0);
+		chrif_updatefamelist(sd,1);
+		return;
+	case 2: // Bg Ranked Matchs
+		sd->status.bgstats.rank_points += count;
+		if( sd->status.bgstats.rank_points > MAX_FAME )
+			sd->status.bgstats.rank_points = MAX_FAME;
+
+		clif_rank_info(sd,count,sd->status.bgstats.rank_points,1);
+		chrif_updatefamelist(sd,2);
+		return;
+	case 3: // Bg Normal Matchs
+		sd->status.bgstats.points += count;
+		if( sd->status.bgstats.points > MAX_FAME )
+			sd->status.bgstats.points = MAX_FAME;
+
+		clif_rank_info(sd,count,sd->status.bgstats.points,1);
+		chrif_updatefamelist(sd,3);
+		return;
+	}
+
+	// Normal Rankings
+	sd->status.fame += count;
+	if(sd->status.fame > MAX_FAME)
+		sd->status.fame = MAX_FAME;
 	switch(sd->class_&MAPID_UPPERMASK) {
 		case MAPID_BLACKSMITH: // Blacksmith
 			clif_fame_blacksmith(sd,count);
 			break;
 		case MAPID_ALCHEMIST: // Alchemist
 			clif_fame_alchemist(sd,count);
-			break;
-		case MAPID_TAEKWON: // Taekwon
-			clif_fame_taekwon(sd,count);
-			break;
-	}
-	chrif_updatefamelist(sd);
-}
-
-// Check whether a player ID is in the fame rankers' list of its job, returns his/her position if so, 0 else
-unsigned char pc_famerank(int char_id, int job)
-{
+			break;
+		case MAPID_TAEKWON: // Taekwon
+			clif_fame_taekwon(sd,count);
+			break;	
+	}
+	chrif_updatefamelist(sd,0);
+}
+
+// PVP Event Fame
+void pc_pvpevent_addfame(struct map_session_data *sd, bool single)
+{
+	struct map_session_data *p_sd;
+	int player_pos, fame_pos, i;
+	char output[256];
+	bool updatereg = false;
+	nullpo_retv(sd);
+
+	ARR_FIND(0, MAX_FAME_LIST, player_pos, pvpevent_fame_list[player_pos].id == sd->status.char_id); // Search if the player is on the List
+	ARR_FIND(0, MAX_FAME_LIST, fame_pos, pvpevent_fame_list[fame_pos].fame <= sd->pvpevent_fame); // Search if the player should be in the List
+
+	if( fame_pos == MAX_FAME_LIST )
+		; // Nothing to do, not enough points to rank this time...
+
+	// ===========================================
+	// From here, player have fame_pos           =
+	// ===========================================
+	else if( player_pos == fame_pos )
+	{ // Same Potion
+		if( pvpevent_fame_list[fame_pos].fame < sd->pvpevent_fame )
+		{ // Need to update own score
+			pvpevent_fame_list[fame_pos].fame = sd->pvpevent_fame;
+			updatereg = single;
+		}
+	}
+	else if( player_pos == MAX_FAME_LIST )
+	{ // New Player Entering Ranking
+		for( i = MAX_FAME_LIST - 1; i > fame_pos; i-- )
+			memcpy(&pvpevent_fame_list[i], &pvpevent_fame_list[i - 1], sizeof(struct fame_list));
+
+		pvpevent_fame_list[fame_pos].id = sd->status.char_id;
+		pvpevent_fame_list[fame_pos].fame = sd->pvpevent_fame;
+		safestrncpy(pvpevent_fame_list[fame_pos].name, sd->status.name, NAME_LENGTH);
+
+		if( single )
+		{
+			updatereg = true;
+			sprintf(output, "-- Entering Top %d PVP Event Fame List at position %d --", MAX_FAME_LIST, fame_pos + 1);
+			clif_disp_onlyself(sd, output, strlen(output));
+
+			for( i = fame_pos + 1; i < MAX_FAME_LIST; i++ )
+			{
+				if( pvpevent_fame_list[i].id == 0 || (p_sd = map_charid2sd(pvpevent_fame_list[i].id)) == NULL )
+					continue;
+
+				sprintf(output, "-- Going Down to Position %d on Top %d PVP Event Fame List --", i + 1, MAX_FAME_LIST);
+				clif_disp_onlyself(p_sd, output, strlen(output));
+			}
+		}
+	}
+
+	// ===========================================
+	// From here, player have player_pos         =
+	// ===========================================
+	else if( fame_pos > player_pos )
+		; // Player need to increase own score to rank...
+	else if( fame_pos < player_pos )
+	{ // Already on the List and going UP
+		for( i = player_pos; i > fame_pos; i-- )
+			memcpy(&pvpevent_fame_list[i], &pvpevent_fame_list[i - 1], sizeof(struct fame_list));
+
+		pvpevent_fame_list[fame_pos].id = sd->status.char_id;
+		pvpevent_fame_list[fame_pos].fame = sd->pvpevent_fame;
+		safestrncpy(pvpevent_fame_list[fame_pos].name, sd->status.name, NAME_LENGTH);
+
+		if( single )
+		{
+			updatereg = true;
+			sprintf(output, "-- Going UP to Position %d on Top %d PVP Event Fame List --", fame_pos + 1, MAX_FAME_LIST);
+			clif_disp_onlyself(sd, output, strlen(output));
+
+			for( i = fame_pos + 1; i < player_pos + 1; i++ )
+			{
+				if( pvpevent_fame_list[i].id == 0 || (p_sd = map_charid2sd(pvpevent_fame_list[i].id)) == NULL )
+					continue;
+
+				sprintf(output, "-- Going Down to Position %d on Top %d PVP Event Fame List --", i + 1, MAX_FAME_LIST);
+				clif_disp_onlyself(p_sd, output, strlen(output));
+			}
+		}
+	}
+
+	if( updatereg )
+	{
+		i = 0;
+		while( i < MAX_FAME_LIST && pvpevent_fame_list[i].id )
+		{
+			mapreg_setregstr(add_str("$pvpevent_name$")+(i<<24), pvpevent_fame_list[i].name);
+			mapreg_setreg(add_str("$pvpevent_id")+(i<<24), pvpevent_fame_list[i].id);
+			mapreg_setreg(add_str("$pvpevent_fame")+(i<<24), pvpevent_fame_list[i].fame);
+			i++;
+		}
+
+		mapreg_setreg(add_str("$pvpevent_count"),i);
+	}
+}
+
+// Check whether a player ID is in the fame rankers' list of its job, returns his/her position if so, 0 else
+unsigned char pc_famerank(int char_id, int job)
+{
 	int i;
 
 	switch(job) {
@@ -473,12 +786,75 @@
 			clif_rental_time(sd->fd, sd->status.inventory[i].nameid, (int)(expire_tick / 1000));
 			next_tick = min(expire_tick, next_tick);
 			c++;
-		}
-	}
-
-	if(c > 0)   // min(next_tick,3600000) 1 hour each timer to keep announcing to the owner, and to avoid a but with rental time > 15 days
-		sd->rental_timer = add_timer(gettick() + min(next_tick,3600000), pc_inventory_rental_end, sd->bl.id, 0);
-	else
+		}
+	}
+
+	for( i = 0; i < MAX_CART; i++ )
+	{ // Check for Rentals on Cart
+		if( sd->status.cart[i].nameid == 0 )
+			continue; // Nothing here
+		if( sd->status.cart[i].expire_time == 0 )
+			continue;
+
+		if( sd->status.cart[i].expire_time <= time(NULL) )
+		{
+			clif_rental_expired(sd->fd, -1, sd->status.cart[i].nameid);
+			pc_cart_delitem(sd, i, 1, 0, LOG_TYPE_OTHER);
+		}
+		else
+		{
+			expire_tick = (unsigned int)(sd->status.cart[i].expire_time - time(NULL)) * 1000;
+			clif_rental_time(sd->fd, sd->status.cart[i].nameid, (int)(expire_tick / 1000));
+			next_tick = min(expire_tick, next_tick);
+			c++;
+		}
+	}
+
+	for( i = 0; i < MAX_STORAGE; i++ )
+	{ // Check for Rentals on Storage
+		if( sd->status.storage.items[i].nameid == 0 )
+			continue;
+		if( sd->status.storage.items[i].expire_time == 0 )
+			continue;
+
+		if( sd->status.storage.items[i].expire_time <= time(NULL) )
+		{
+			clif_rental_expired(sd->fd, -1, sd->status.storage.items[i].nameid);
+			storage_delitem(sd, i, 1);
+		}
+		else
+		{
+			expire_tick = (unsigned int)(sd->status.storage.items[i].expire_time - time(NULL)) * 1000;
+			clif_rental_time(sd->fd, sd->status.storage.items[i].nameid, (int)(expire_tick / 1000));
+			next_tick = min(expire_tick, next_tick);
+			c++;
+		}
+	}
+
+	for( i = 0; i < MAX_EXTRA_STORAGE; i++ )
+	{ // Check for Rentals on Extra Storage
+		if( sd->status.ext_storage.items[i].nameid == 0 )
+			continue;
+		if( sd->status.ext_storage.items[i].expire_time == 0 )
+			continue;
+
+		if( sd->status.ext_storage.items[i].expire_time <= time(NULL) )
+		{
+			clif_rental_expired(sd->fd, -1, sd->status.ext_storage.items[i].nameid);
+			ext_storage_delitem(sd, i, 1);
+		}
+		else
+		{
+			expire_tick = (unsigned int)(sd->status.ext_storage.items[i].expire_time - time(NULL)) * 1000;
+			clif_rental_time(sd->fd, sd->status.ext_storage.items[i].nameid, (int)(expire_tick / 1000));
+			next_tick = min(expire_tick, next_tick);
+			c++;
+		}
+	}
+
+	if( c > 0 ) // min(next_tick,3600000) 1 hour each timer to keep announcing to the owner, and to avoid a but with rental time > 15 days
+		sd->rental_timer = add_timer(gettick() + min(next_tick,3600000), pc_inventory_rental_end, sd->bl.id, 0);
+	else
 		sd->rental_timer = INVALID_TIMER;
 }
 
@@ -498,12 +874,94 @@
 			sd->rental_timer = add_timer(gettick() + tick, pc_inventory_rental_end, sd->bl.id, 0);
 		}
 	} else
-		sd->rental_timer = add_timer(gettick() + min(tick,3600000), pc_inventory_rental_end, sd->bl.id, 0);
-}
-
-/**
- * Determines if player can give / drop / trade / vend items
- */
+		sd->rental_timer = add_timer(gettick() + min(tick,3600000), pc_inventory_rental_end, sd->bl.id, 0);
+}
+
+/*==========================================
+	Ranking Reset
+ *------------------------------------------*/
+void pc_ranking_reset(int type, bool char_server)
+{
+	struct map_session_data *sd;
+	struct s_mapiterator* iter;
+
+	iter = mapit_getallusers();
+	for( sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter) )
+	{
+		switch( type )
+		{
+		case 0: // WoE Ranking Reset
+			memset(&sd->status.wstats, 0, sizeof(struct s_woestats));
+			memset(&sd->status.skillcount, 0, sizeof(struct s_skillcount));
+			sd->status.wstats.score = 2000;
+			break;
+		case 1: // Battleground Stats
+			memset(&sd->status.bgstats, 0, sizeof(struct s_battleground_stats));
+			memset(&sd->status.bg_skillcount, 0, sizeof(struct s_skillcount));
+			sd->status.bgstats.score = 2000;
+			break;
+		case 2: // PVP Event Ranking
+			memset(&sd->status.pvp, 0, sizeof(struct s_killrank));
+			sd->status.pvp.score = 2000;
+			break;
+		}
+	}
+	mapit_free(iter);
+
+	if( char_server ) chrif_ranking_reset(type);
+}
+
+/*==========================================
+	Item Removal
+ *------------------------------------------*/
+void pc_item_remove4all(int nameid, bool char_server)
+{
+	if( char_server )
+		chrif_item_remove4all(nameid);
+	else
+	{
+		struct map_session_data *sd;
+		struct s_mapiterator* iter;
+		int index;
+
+		iter = mapit_getallusers();
+		for( sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter) )
+		{
+			for( index = 0; index < MAX_INVENTORY; index++ )
+			{ // Inventory Removal
+				if( sd->status.inventory[index].nameid != nameid )
+					continue;
+				pc_delitem(sd, index, sd->status.inventory[index].amount, 0, 0, LOG_TYPE_COMMAND);
+			}
+
+			for( index = 0; index < MAX_CART; index++ )
+			{ // Cart Removal
+				if( sd->status.cart[index].nameid != nameid )
+					continue;
+				pc_cart_delitem(sd, index, sd->status.cart[index].amount, 0, LOG_TYPE_COMMAND);
+			}
+
+			for( index = 0; index < MAX_STORAGE; index++ )
+			{ // Storage Removal
+				if( sd->status.storage.items[index].nameid != nameid )
+					continue;
+				storage_delitem(sd, index, sd->status.storage.items[index].amount);
+			}
+
+			for( index = 0; index < MAX_EXTRA_STORAGE; index++ )
+			{ // Extra Storage
+				if( sd->status.ext_storage.items[index].nameid != nameid )
+					continue;
+				ext_storage_delitem(sd, index, sd->status.ext_storage.items[index].amount);
+			}
+		}
+		mapit_free(iter);
+	}
+}
+
+/**
+ * Determines if player can give / drop / trade / vend items
+ */
 bool pc_can_give_items(struct map_session_data *sd)
 {
 	return pc_has_permission(sd, PC_PERM_TRADE);
@@ -575,21 +1033,21 @@
 	sd->status.sex   = sex;
 	sd->login_id1    = login_id1;
 	sd->login_id2    = 0; // at this point, we can not know the value :(
-	sd->client_tick  = client_tick;
-	sd->state.active = 0; //to be set to 1 after player is fully authed and loaded.
-	sd->bl.type      = BL_PC;
-	sd->canlog_tick  = gettick();
-	//Required to prevent homunculus copuing a base speed of 0.
-	sd->battle_status.speed = sd->base_status.speed = DEFAULT_WALK_SPEED;
-	return 0;
+	sd->client_tick  = client_tick;
+	sd->state.active = 0; //to be set to 1 after player is fully authed and loaded.
+	sd->bl.type      = BL_PC;
+	sd->canlog_tick  = sd->canescape_tick = gettick();
+	//Required to prevent homunculus copuing a base speed of 0.
+	sd->battle_status.speed = sd->base_status.speed = DEFAULT_WALK_SPEED;
+	return 0;
 }
-
-int pc_equippoint(struct map_session_data *sd,int n)
-{
-	int ep = 0;
-
-	nullpo_ret(sd);
-
+
+int pc_equippoint(struct map_session_data *sd,int n)
+{
+	int ep = 0, char_id = 0;
+
+	nullpo_ret(sd);
+
 	if(!sd->inventory_data[n])
 		return 0;
 
@@ -601,12 +1059,21 @@
 	   sd->inventory_data[n]->look == W_1HSWORD ||
 	   sd->inventory_data[n]->look == W_1HAXE) {
 		if(ep == EQP_HAND_R && (pc_checkskill(sd,AS_LEFT) > 0 || (sd->class_&MAPID_UPPERMASK) == MAPID_ASSASSIN ||
-		                        (sd->class_&MAPID_UPPERMASK) == MAPID_KAGEROUOBORO))//Kagerou and Oboro can dual wield daggers. [Rytech]
-			return EQP_ARMS;
-	}
-	return ep;
-}
-
+			(sd->class_&MAPID_UPPERMASK) == MAPID_KAGEROUOBORO))//Kagerou and Oboro can dual wield daggers. [Rytech]
+			return EQP_ARMS;
+	}
+
+	if( battle_config.costume_reserved_char_id &&
+		sd->status.inventory[n].card[0] == CARD0_CREATE &&
+		(char_id = MakeDWord(sd->status.inventory[n].card[2],sd->status.inventory[n].card[3])) == battle_config.costume_reserved_char_id )
+	{ // Costume Item - Converted
+		if( ep&EQP_HEAD_TOP ) { ep &= ~EQP_HEAD_TOP; ep |= EQP_COS_HEAD_TOP; }
+		if( ep&EQP_HEAD_LOW ) { ep &= ~EQP_HEAD_LOW; ep |= EQP_COS_HEAD_LOW; }
+		if( ep&EQP_HEAD_MID ) { ep &= ~EQP_HEAD_MID; ep |= EQP_COS_HEAD_MID; }
+	}
+	return ep;
+}
+
 int pc_setinventorydata(struct map_session_data *sd)
 {
 	int i,id;
@@ -716,13 +1183,31 @@
 //		s = MAX_SLOTS - 1;
 //
 //	ARR_FIND(0, s, i, item->card[i] && (data = itemdb_exists(item->card[i])) != NULL && data->flag.no_equip&flag);
-//	return(i < s) ? 0 : 1;
-//}
+//	return( i < s ) ? 0 : 1;
+//}
+
+static int pc_isAllowedCardOn_Ancient(struct map_session_data *sd,int s,int eqindex)
+{
+	int i;
+	struct item *item = &sd->status.inventory[eqindex];
+	struct item_data *data;
+	
+	//Crafted/made/hatched items.
+	if (itemdb_isspecial(item->card[0]))
+		return 1;
+
+	/* scan for enchant armor gems */
+	if( item->card[MAX_SLOTS - 1] && s < MAX_SLOTS - 1 )
+		s = MAX_SLOTS - 1;
+	
+	ARR_FIND( 0, s, i, item->card[i] && (data = itemdb_exists(item->card[i])) != NULL && !data->ancient );
+	return( i < s ) ? 0 : 1;
+}
+
+bool pc_isequipped(struct map_session_data *sd, int nameid)
+{
+	int i, j, index;
 
-bool pc_isequipped(struct map_session_data *sd, int nameid)
-{
-	int i, j, index;
-
 	for(i = 0; i < EQI_MAX; i++) {
 		index = sd->equip_index[i];
 		if(index < 0) continue;
@@ -903,12 +1388,39 @@
 		return 0;
 	}
 
-	return 1;
-}
-
-/*==========================================
- * No problem with the session id
- * set the status that has been sent from char server
+	return 1;
+}
+
+int pc_isequip2(struct map_session_data *sd, int nameid)
+{
+	struct item_data *item;
+	nullpo_ret(sd);
+
+	if( (item = itemdb_exists(nameid)) == NULL )
+		return 0;
+	if( pc_has_permission(sd, PC_PERM_USE_ALL_EQUIPMENT) )
+		return 1;
+	if( item->elv && sd->status.base_level < (unsigned int)item->elv )
+		return 0; // Level Restriction
+	if( item->sex != 2 && sd->status.sex != item->sex )
+		return 0; // Sex Restriction
+	if( !(1<<(sd->class_&MAPID_BASEMASK)&item->class_base[(sd->class_&JOBL_2_1)?1:((sd->class_&JOBL_2_2)?2:0)]) )
+		return 0; // Not equipable by Class
+	//Not usable by upper class. [Inkfish]
+	while( 1 ) {
+		if( item->class_upper&1 && !(sd->class_&(JOBL_UPPER|JOBL_THIRD|JOBL_BABY)) ) break;
+		if( item->class_upper&2 && sd->class_&(JOBL_UPPER|JOBL_THIRD) ) break;
+		if( item->class_upper&4 && sd->class_&JOBL_BABY ) break;
+		if( item->class_upper&8 && sd->class_&JOBL_THIRD ) break;
+		return 0;
+	}
+
+	return 1;
+}
+
+/*==========================================
+ * No problem with the session id
+ * set the status that has been sent from char server
  *------------------------------------------*/
 bool pc_authok(struct map_session_data *sd, int login_id2, time_t expiration_time, int group_id, struct mmo_charstatus *st, bool changing_mapservers)
 {
@@ -951,17 +1463,20 @@
 		sd->status.clothes_color = MIN_CLOTH_COLOR;
 	}
 
-	//Initializations to null/0 unneeded since map_session_data was filled with 0 upon allocation.
-	if(!sd->status.hp) pc_setdead(sd);
-	sd->state.connect_new = 1;
-
-	sd->followtimer = INVALID_TIMER; // [MouseJstr]
-	sd->invincible_timer = INVALID_TIMER;
-	sd->npc_timer_id = INVALID_TIMER;
-	sd->pvp_timer = INVALID_TIMER;
-	/**
-	 * For the Secure NPC Timeout option (check config/Secure.h) [RR]
-	 **/
+	//Initializations to null/0 unneeded since map_session_data was filled with 0 upon allocation.
+	if(!sd->status.hp) pc_setdead(sd);
+	sd->state.connect_new = 1;
+	sd->state.size = global_size;
+	sd->vend_coin = battle_config.vending_zeny_id;
+
+	sd->followtimer = INVALID_TIMER; // [MouseJstr]
+	sd->invincible_timer = INVALID_TIMER;
+	sd->npc_timer_id = INVALID_TIMER;
+	sd->pvp_timer = INVALID_TIMER;
+	sd->achievement_cutin_timer = INVALID_TIMER;
+	/**
+	 * For the Secure NPC Timeout option (check config/Secure.h) [RR]
+	 **/
 #if SECURE_NPCTIMEOUT
 	/**
 	 * Initialize to defaults/expected
@@ -972,25 +1487,32 @@
 
 	sd->canuseitem_tick = tick;
 	sd->canusecashfood_tick = tick;
-	sd->canequip_tick = tick;
-	sd->cantalk_tick = tick;
-	sd->canskill_tick = tick;
-	sd->cansendmail_tick = tick;
-
-	for(i = 0; i < MAX_SKILL_LEVEL; i++)
-		sd->spirit_timer[i] = INVALID_TIMER;
-	for(i = 0; i < ARRAYLENGTH(sd->autobonus); i++)
+	sd->canequip_tick = tick;
+	sd->cantalk_tick = tick;
+	sd->canskill_tick = tick;
+	sd->channel_cantalk_tick = tick;
+	sd->canjoinchn_tick = tick;
+	sd->cansendmail_tick = tick;
+	sd->keyboard_action_tick = tick;
+	sd->mouse_action_tick = tick;
+
+	sd->custom_data.session_start = last_tick;
+	sd->status.last_tick = last_tick;
+
+	for(i = 0; i < MAX_SKILL_LEVEL; i++)
+		sd->spirit_timer[i] = INVALID_TIMER;
+	for(i = 0; i < ARRAYLENGTH(sd->autobonus); i++)
 		sd->autobonus[i].active = INVALID_TIMER;
 	for(i = 0; i < ARRAYLENGTH(sd->autobonus2); i++)
 		sd->autobonus2[i].active = INVALID_TIMER;
 	for(i = 0; i < ARRAYLENGTH(sd->autobonus3); i++)
-		sd->autobonus3[i].active = INVALID_TIMER;
-
-	if(battle_config.item_auto_get)
-		sd->state.autoloot = 10000;
-
-	if(battle_config.disp_experience)
-		sd->state.showexp = 1;
+		sd->autobonus3[i].active = INVALID_TIMER;
+
+	if (battle_config.item_auto_get)
+		sd->aloot.rate = 10000;
+
+	if (battle_config.disp_experience)
+		sd->state.showexp = 1;
 	if(battle_config.disp_zeny)
 		sd->state.showzeny = 1;
 
@@ -1017,13 +1539,14 @@
 
 	// Event Timers
 	for(i = 0; i < MAX_EVENTTIMER; i++)
-		sd->eventtimer[i] = INVALID_TIMER;
-	// Rental Timer
-	sd->rental_timer = INVALID_TIMER;
+		sd->eventtimer[i] = INVALID_TIMER;
+	// Rental Timer
+	sd->rental_timer = INVALID_TIMER;
+	sd->channel_invite_timer = INVALID_TIMER;
+
+	for( i = 0; i < 3; i++ )
+		sd->hate_mob[i] = -1;
 
-	for(i = 0; i < 3; i++)
-		sd->hate_mob[i] = -1;
-
 	//warp player
 	if((i=pc_setpos(sd,sd->status.last_point.map, sd->status.last_point.x, sd->status.last_point.y, CLR_OUTSIGHT)) != 0) {
 		ShowError("Last_point_map %s - id %d not found (error code %d)\n", mapindex_id2name(sd->status.last_point.map), sd->status.last_point.map, i);
@@ -1077,17 +1600,14 @@
 		/**
 		 * Fixes login-without-aura glitch (the screen won't blink at this point, don't worry :P)
 		 **/
-		clif_changemap(sd,sd->mapindex,sd->bl.x,sd->bl.y);
-	}
-
-	/**
-	 * Check if player have any cool downs on
+		clif_changemap(sd,sd->mapindex,sd->bl.x,sd->bl.y);
+	}
+
+	// Cooldown removed by eAmod
+
+	/**
+	 * Check if player have any item cooldowns on
 	 **/
-	skill_cooldown_load(sd);
-
-	/**
-	 * Check if player have any item cooldowns on
-	 **/
 	pc_itemcd_do(sd,true);
 
 	// Request all registries (auth is considered completed whence they arrive)
@@ -1136,11 +1656,12 @@
 int pc_reg_received(struct map_session_data *sd)
 {
 	int i,j;
+	char output[256], varname[32];
 
 	sd->change_level_2nd = pc_readglobalreg(sd,"jobchange_level");
 	sd->change_level_3rd = pc_readglobalreg(sd,"jobchange_level_3rd");
 	sd->die_counter = pc_readglobalreg(sd,"PC_DIE_COUNTER");
-
+	sd->user_aura = pc_readglobalreg(sd,"USERAURA");
 	// Cash shop
 	sd->cashPoints = pc_readaccountreg(sd,"#CASHPOINTS");
 	sd->kafraPoints = pc_readaccountreg(sd,"#KAFRAPOINTS");
@@ -1148,15 +1669,32 @@
 	// Cooking Exp
 	sd->cook_mastery = pc_readglobalreg(sd,"COOK_MASTERY");
 
-	if((sd->class_&MAPID_BASEMASK) == MAPID_TAEKWON) {
-		// Better check for class rather than skill to prevent "skill resets" from unsetting this
+	// eAmod
+	sd->custom_data.MVPKiller = pc_readglobalreg(sd,"MVPRank");
+	sd->lang_mastery = pc_readglobalreg(sd,"eAmod_Languages");
+	sd->bg_team = pc_readglobalreg(sd,"Bat_Team");
+	sd->Premium_Tick = pc_readaccountreg(sd,"#Premium_Tick"); // Premium Account System
+
+	if( (sd->class_&MAPID_BASEMASK) == MAPID_TAEKWON )
+	{ // Better check for class rather than skill to prevent "skill resets" from unsetting this
 		sd->mission_mobid = pc_readglobalreg(sd,"TK_MISSION_ID");
 		sd->mission_count = pc_readglobalreg(sd,"TK_MISSION_COUNT");
 	}
 
+	// Hunting Missions [Zephyrus]
+	sd->hunting_time = pc_readglobalreg(sd,"Mission_Tick");
+	for( i = 0; i < 5; i++ )
+	{
+		sprintf(varname, "Mission_ID%d", i + 1);
+		sd->hunting[i].mob_id = pc_readglobalreg(sd,varname);
+		sprintf(varname, "Mission_Count%d", i + 1);
+		sd->hunting[i].count = pc_readglobalreg(sd,varname);
+	}
+
 	//SG map and mob read [Komurka]
-	for(i=0; i<MAX_PC_FEELHATE; i++) { //for now - someone need to make reading from txt/sql
-		if((j = pc_readglobalreg(sd,sg_info[i].feel_var))!=0) {
+	for(i=0;i<MAX_PC_FEELHATE;i++) //for now - someone need to make reading from txt/sql
+	{
+		if ((j = pc_readglobalreg(sd,sg_info[i].feel_var))!=0) {
 			sd->feel_map[i].index = j;
 			sd->feel_map[i].m = map_mapindex2mapid(j);
 		} else {
@@ -1166,51 +1704,87 @@
 		sd->hate_mob[i] = pc_readglobalreg(sd,sg_info[i].hate_var)-1;
 	}
 
-	if((i = pc_checkskill(sd,RG_PLAGIARISM)) > 0) {
+	if ((i = pc_checkskill(sd,RG_PLAGIARISM)) > 0) {
 		sd->cloneskill_id = pc_readglobalreg(sd,"CLONE_SKILL");
-		if(sd->cloneskill_id > 0) {
+		if (sd->cloneskill_id > 0) {
 			sd->status.skill[sd->cloneskill_id].id = sd->cloneskill_id;
 			sd->status.skill[sd->cloneskill_id].lv = pc_readglobalreg(sd,"CLONE_SKILL_LV");
-			if(sd->status.skill[sd->cloneskill_id].lv > i)
+			if (sd->status.skill[sd->cloneskill_id].lv > i)
 				sd->status.skill[sd->cloneskill_id].lv = i;
 			sd->status.skill[sd->cloneskill_id].flag = SKILL_FLAG_PLAGIARIZED;
 		}
 	}
-	if((i = pc_checkskill(sd,SC_REPRODUCE)) > 0) {
+	if ((i = pc_checkskill(sd,SC_REPRODUCE)) > 0) {
 		sd->reproduceskill_id = pc_readglobalreg(sd,"REPRODUCE_SKILL");
-		if(sd->reproduceskill_id > 0) {
+		if( sd->reproduceskill_id > 0) {
 			sd->status.skill[sd->reproduceskill_id].id = sd->reproduceskill_id;
 			sd->status.skill[sd->reproduceskill_id].lv = pc_readglobalreg(sd,"REPRODUCE_SKILL_LV");
-			if(i < sd->status.skill[sd->reproduceskill_id].lv)
+			if( i < sd->status.skill[sd->reproduceskill_id].lv)
 				sd->status.skill[sd->reproduceskill_id].lv = i;
 			sd->status.skill[sd->reproduceskill_id].flag = SKILL_FLAG_PLAGIARIZED;
 		}
 	}
 	//Weird... maybe registries were reloaded?
-	if(sd->state.active)
+	if (sd->state.active)
 		return 0;
 	sd->state.active = 1;
+	if( battle_config.pc_validate_items ) pc_fix_items(sd);
 
-	if(sd->status.party_id)
+	// Stats Check ------
+	if( battle_config.pc_validate_stats )
+	{
+		int b_stats = stats_point_table[sd->status.base_level] + (sd->class_&JOBL_UPPER ? 52 : 0),
+			u_stats = 0;
+		// Stats Used Calc
+		for( i = 1; i <= sd->status.str - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		for( i = 1; i <= sd->status.int_ - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		for( i = 1; i <= sd->status.vit - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		for( i = 1; i <= sd->status.dex - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		for( i = 1; i <= sd->status.agi - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		for( i = 1; i <= sd->status.luk - 1; i++ )
+			u_stats += pc_need_status_point2(i);
+		// Free Stats Points
+		u_stats += sd->status.status_point;
+		if( u_stats != b_stats )
+		{
+			sd->status.status_point = b_stats;
+			sd->status.str = 1;
+			sd->status.agi = 1;
+			sd->status.vit = 1;
+			sd->status.int_ = 1;
+			sd->status.dex = 1;
+			sd->status.luk = 1;
+			clif_displaymessage(sd->fd, "Abnormal Stats Points found. Your Build have been reset.");
+			log_npc(sd,"Invalid Character Stats Points founds. Reseted.");
+		}
+	}
+	// ------------------
+
+	if (sd->status.party_id)
 		party_member_joined(sd);
-	if(sd->status.guild_id)
-		guild_member_joined(sd);
+	if (sd->status.guild_id)
+		guild_member_joined(sd, false);
 
 	// pet
-	if(sd->status.pet_id > 0)
+	if (sd->status.pet_id > 0)
 		intif_request_petdata(sd->status.account_id, sd->status.char_id, sd->status.pet_id);
 
 	// Homunculus [albator]
-	if(sd->status.hom_id > 0)
+	if( sd->status.hom_id > 0 )
 		intif_homunculus_requestload(sd->status.account_id, sd->status.hom_id);
-	if(sd->status.mer_id > 0)
+	if( sd->status.mer_id > 0 )
 		intif_mercenary_request(sd->status.mer_id, sd->status.char_id);
-	if(sd->status.ele_id > 0)
+	if( sd->status.ele_id > 0 )
 		intif_elemental_request(sd->status.ele_id, sd->status.char_id);
 
 	map_addiddb(&sd->bl);
 	map_delnickdb(sd->status.char_id, sd->status.name);
-	if(!chrif_auth_finished(sd))
+	if (!chrif_auth_finished(sd))
 		ShowError("pc_reg_received: Failed to properly remove player %d:%d from logging db!\n", sd->status.account_id, sd->status.char_id);
 
 	pc_load_combo(sd);
@@ -1218,11 +1792,56 @@
 	status_calc_pc(sd,1);
 	chrif_scdata_request(sd->status.account_id, sd->status.char_id);
 
+	chrif_skillcooldown_request(sd->status.account_id, sd->status.char_id);
 	intif_Mail_requestinbox(sd->status.char_id, 0); // MAIL SYSTEM - Request Mail Inbox
 	intif_request_questlog(sd);
+	intif_request_achievement(sd);
 
-	if(sd->state.connect_new == 0 && sd->fd) {
-		//Character already loaded map! Gotta trigger LoadEndAck manually.
+	if( sd->status.iprank > 0 )
+	{
+		sprintf(output, "Conectado desde NetCafe Asociado Rango %d. (+%d%% Exp Bono)", sd->status.iprank, sd->status.iprank * 2);
+		clif_disp_onlyself(sd, output, strlen(output));
+	}
+
+	// Security System
+	if( pc_readaccountreg(sd,"#SECURITYCODE") > 0 )
+	{
+		clif_displaymessage(sd->fd, "Item Security System ENABLE : Use @security for more options.");
+		sd->state.secure_items = 1;
+	}
+	else
+		clif_displaymessage(sd->fd, "Item Security System DISABLE : Use @security for more options.");
+
+	if( battle_config.channel_system_enable )
+	{
+		sd->channels = pc_readaccountreg(sd,"#CHANNEL_CONF");
+		if( sd->channels&1 && server_channel[CHN_MAIN] )
+			channel_join(sd, server_channel[CHN_MAIN]->name, "", false);
+		if( sd->channels&2 && server_channel[CHN_VENDING] )
+			channel_join(sd, server_channel[CHN_VENDING]->name, "", false);
+		if( sd->channels&4 && server_channel[CHN_BATTLEGROUND] )
+			channel_join(sd, server_channel[CHN_BATTLEGROUND]->name, "", false);
+		if( pc_has_permission(sd,PC_PERM_CHANNEL_OPERATOR) && (sd->channels&8) && server_channel[CHN_GAMEMASTER] )
+			channel_join(sd, server_channel[CHN_GAMEMASTER]->name, "", false);
+	}
+
+	if( pc_isPremium(sd) )
+	{
+		int tick = sd->Premium_Tick - (int)time(NULL), day, hour, minute, second;
+		atcommand_expinfo_sub(tick, &day, &hour, &minute, &second);
+		sprintf(output, "Premium Account expire at : %d days, %02d:%02d:%02d", day, hour, minute, second);
+		clif_disp_onlyself(sd, output, strlen(output));
+	}
+
+	if( battle_config.bg_reward_rates != 100 )
+	{
+		int erate = battle_config.bg_reward_rates - 100;
+		sprintf(output, "Battleground Happy Hour. Rates at + %d %%", erate);
+		clif_displaymessage(sd->fd, output);
+	}
+
+	if( !sd->state.connect_new && sd->fd )
+	{	//Character already loaded map! Gotta trigger LoadEndAck manually.
 		sd->state.connect_new = 1;
 		clif_parse_LoadEndAck(sd->fd, sd);
 	}
@@ -1230,12 +1849,12 @@
 	pc_inventory_rentals(sd);
 
 	return 1;
-}
-
-static int pc_calc_skillpoint(struct map_session_data *sd)
-{
-	int  i,skill,inf2,skill_point=0;
-
+}
+
+int pc_calc_skillpoint(struct map_session_data* sd)
+{
+	int  i,skill,inf2,skill_point=0;
+
 	nullpo_ret(sd);
 
 	for(i=1; i<MAX_SKILL; i++) {
@@ -1751,22 +2370,26 @@
 	return 1;
 }
 
-static int pc_bonus_item_drop(struct s_add_drop *drop, const short max, short id, short group, int race, int rate)
-{
-	int i;
-	//Apply config rate adjustment settings.
-	if(rate >= 0) {  //Absolute drop.
-		if(battle_config.item_rate_adddrop != 100)
-			rate = rate*battle_config.item_rate_adddrop/100;
-		if(rate < battle_config.item_drop_adddrop_min)
-			rate = battle_config.item_drop_adddrop_min;
-		else if(rate > battle_config.item_drop_adddrop_max)
-			rate = battle_config.item_drop_adddrop_max;
-	} else { //Relative drop, max/min limits are applied at drop time.
-		if(battle_config.item_rate_adddrop != 100)
-			rate = rate*battle_config.item_rate_adddrop/100;
-		if(rate > -1)
-			rate = -1;
+static int pc_bonus_item_drop(struct s_add_drop *drop, const short max, short id, short group, int race, int rate)
+{
+	int i;
+	struct item_data *it = id ? itemdb_search(id) : NULL;
+
+	//Apply config rate adjustment settings.
+	if (rate >= 0) { //Absolute drop.
+		if( it && it->add_dropRate )
+			rate = rate * it->add_dropRate / 100;
+		else if( battle_config.item_rate_adddrop != 100 )
+			rate = rate*battle_config.item_rate_adddrop/100;
+
+		rate = cap_value(rate,battle_config.item_drop_adddrop_min,battle_config.item_drop_adddrop_max);
+	} else { //Relative drop, max/min limits are applied at drop time.
+		if( it && it->add_dropRate )
+			rate = rate * it->add_dropRate / 100;
+		else if( battle_config.item_rate_adddrop != 100 )
+			rate = rate*battle_config.item_rate_adddrop/100;
+		if (rate > -1)
+			rate = -1;
 	}
 	for(i = 0; i < max && (drop[i].id || drop[i].group); i++) {
 		if(
@@ -1841,10 +2464,10 @@
 		if(autobonus[i].active != INVALID_TIMER) {
 			if(restore && sd->state.autobonus&autobonus[i].pos) {
 				if(autobonus[i].bonus_script) {
-					int j;
-					ARR_FIND(0, EQI_MAX-1, j, sd->equip_index[j] >= 0 && sd->status.inventory[sd->equip_index[j]].equip == autobonus[i].pos);
-					if(j < EQI_MAX-1)
-						script_run_autobonus(autobonus[i].bonus_script,sd->bl.id,sd->equip_index[j]);
+					int j;
+					ARR_FIND( 0, EQI_MAX_BONUS, j, sd->equip_index[j] >= 0 && sd->status.inventory[sd->equip_index[j]].equip == autobonus[i].pos );
+					if( j < EQI_MAX_BONUS )
+						script_run_autobonus(autobonus[i].bonus_script,sd->bl.id,sd->equip_index[j]);
 				}
 				continue;
 			} else {
@@ -1870,10 +2493,10 @@
 	nullpo_ret(autobonus);
 
 	if(autobonus->other_script) {
-		int j;
-		ARR_FIND(0, EQI_MAX-1, j, sd->equip_index[j] >= 0 && sd->status.inventory[sd->equip_index[j]].equip == autobonus->pos);
-		if(j < EQI_MAX-1)
-			script_run_autobonus(autobonus->other_script,sd->bl.id,sd->equip_index[j]);
+		int j;
+		ARR_FIND( 0, EQI_MAX_BONUS, j, sd->equip_index[j] >= 0 && sd->status.inventory[sd->equip_index[j]].equip == autobonus->pos );
+		if( j < EQI_MAX_BONUS )
+			script_run_autobonus(autobonus->other_script,sd->bl.id,sd->equip_index[j]);
 	}
 
 	autobonus->active = add_timer(gettick()+autobonus->duration, pc_endautobonus, sd->bl.id, (intptr_t)autobonus);
@@ -2361,12 +2984,13 @@
 				sd->special_state.no_gemstone = 1;
 			break;
 		case SP_INTRAVISION: // Maya Purple Card effect allowing to see Hiding/Cloaking people [DracoRPG]
-			if(sd->state.lr_flag != 2) {
-				sd->special_state.intravision = 1;
-				clif_status_load(&sd->bl, SI_INTRAVISION, 1);
-			}
-			break;
-		case SP_NO_KNOCKBACK:
+			if(sd->state.lr_flag != 2) {
+				sd->special_state.intravision = 1;
+				clif_status_load(&sd->bl, SI_INTRAVISION, 1);
+				if( battle_config.anti_mayapurple_hack ) map_foreachinrange(clif_insight_bl2tbl, &sd->bl, AREA_SIZE, BL_PC, &sd->bl);
+			}
+			break;
+		case SP_NO_KNOCKBACK:
 			if(sd->state.lr_flag != 2)
 				sd->special_state.no_knockback = 1;
 			break;
@@ -2561,8 +3185,12 @@
 			if(sd->state.lr_flag != 2)
 			sd->bonus.add_varcast += val;
 			break;
-#endif
-		default:
+	#endif
+		case SP_MAXWEIGHT:
+			if(sd->state.lr_flag != 2)
+				sd->max_weight += val;
+			break;
+		default:
 			ShowWarning("pc_bonus: Tipo desconhecido %d %d !\n",type,val);
 			break;
 	}
@@ -3440,17 +4068,30 @@
 		return 0; // card slots reserved for other purposes
 	if((sd->inventory_data[idx_equip]->equip & sd->inventory_data[idx_card]->equip) == 0)
 		return 0; // card cannot be compounded on this item type
+	if( itemdb_isenchant(sd->status.inventory[idx_card].nameid) && sd->inventory_data[idx_equip]->slot > 3 )
+		return 0; // Reserved slot for Enchant is a normal slot
 	if(sd->inventory_data[idx_equip]->type == IT_WEAPON && sd->inventory_data[idx_card]->equip == EQP_SHIELD)
 		return 0; // attempted to place shield card on left-hand weapon.
 	if(sd->status.inventory[idx_equip].equip != 0)
 		return 0; // item must be unequipped
 
-	ARR_FIND(0, sd->inventory_data[idx_equip]->slot, i, sd->status.inventory[idx_equip].card[i] == 0);
-	if(i == sd->inventory_data[idx_equip]->slot)
-		return 0; // no free slots
-
 	// remember the card id to insert
 	nameid = sd->status.inventory[idx_card].nameid;
+	
+	if( itemdb_isenchant(nameid) )
+	{
+		switch( sd->inventory_data[idx_equip]->nameid )
+		{ // Non Enchantable Equipment
+		case 2357: return 0;
+		}
+		i = 3; // Enchant Slot - Can overwrite current enchant
+	}
+	else
+	{
+		ARR_FIND( 0, sd->inventory_data[idx_equip]->slot, i, sd->status.inventory[idx_equip].card[i] == 0 );
+		if( i == sd->inventory_data[idx_equip]->slot )
+			return 0; // no free slots
+	}
 
 	if(pc_delitem(sd,idx_card,1,1,0,LOG_TYPE_OTHER) == 1) {
 		// failed
@@ -3458,12 +4099,17 @@
 	} else {
 		// success
 		log_pick_pc(sd, LOG_TYPE_OTHER, -1, &sd->status.inventory[idx_equip]);
-		sd->status.inventory[idx_equip].card[i] = nameid;
-		log_pick_pc(sd, LOG_TYPE_OTHER,  1, &sd->status.inventory[idx_equip]);
-		clif_insert_card(sd,idx_equip,idx_card,0);
-	}
-
-	return 0;
+		sd->status.inventory[idx_equip].card[i] = nameid;
+		log_pick_pc(sd, LOG_TYPE_OTHER,  1, &sd->status.inventory[idx_equip]);
+		clif_insert_card(sd,idx_equip,idx_card,0);
+		if( itemdb_isenchant(nameid) )
+		{
+			clif_delitem(sd,idx_equip,1,3);
+			clif_additem(sd,idx_equip,1,0);
+		}
+	}
+
+	return 0;
 }
 
 //
@@ -3473,16 +4119,19 @@
 /*==========================================
  * Update buying value by skills
  *------------------------------------------*/
-int pc_modifybuyvalue(struct map_session_data *sd,int orig_value)
-{
-	int skill,val = orig_value,rate1 = 0,rate2 = 0;
-	if((skill=pc_checkskill(sd,MC_DISCOUNT))>0) // merchant discount
-		rate1 = 5+skill*2-((skill==10)? 1:0);
-	if((skill=pc_checkskill(sd,RG_COMPULSION))>0)    // rogue discount
-		rate2 = 5+skill*4;
-	if(rate1 < rate2) rate1 = rate2;
-	if(rate1)
-		val = (int)((double)orig_value*(double)(100-rate1)/100.);
+int pc_modifybuyvalue(struct map_session_data *sd,int orig_value)
+{
+	int skill,val = orig_value,rate1 = 0,rate2 = 0;
+	if( !battle_config.super_woe_enable )
+	{ // Discount not usable on Super WoE / GvG Events
+		if( (skill = pc_checkskill(sd,MC_DISCOUNT)) > 0 )	// merchant discount
+			rate1 = 5 + skill * 2 - ((skill==10)? 1:0);
+		if( (skill = pc_checkskill(sd,RG_COMPULSION)) > 0 )	// rogue discount
+			rate2 = 5 + skill * 4;
+	}
+	if(rate1 < rate2) rate1 = rate2;
+	if(rate1)
+		val = (int)((double)orig_value*(double)(100-rate1)/100.);
 	if(val < 0) val = 0;
 	if(orig_value > 0 && val < 1) val = 1;
 
@@ -3685,12 +4334,13 @@
 
 	if(zeny > MAX_ZENY - sd->status.zeny)
 		zeny = MAX_ZENY - sd->status.zeny;
-
-	sd->status.zeny += zeny;
-	clif_updatestatus(sd,SP_ZENY);
-
-	if(!tsd) tsd = sd;
-	log_zeny(sd, type, tsd, zeny);
+
+	sd->status.zeny += zeny;
+	clif_updatestatus(sd,SP_ZENY);
+	achievement_validate_zeny(sd,ATZ_HAVE,sd->status.zeny);
+
+	if(!tsd) tsd = sd;
+	log_zeny(sd, type, tsd, zeny);
 	if(zeny > 0 && sd->state.showzeny) {
 		char output[255];
 		sprintf(output, "Gained %dz.", zeny);
@@ -3702,17 +4352,54 @@
 
 /*==========================================
  * Searching a specified itemid in inventory and return his stored index
- *------------------------------------------*/
-int pc_search_inventory(struct map_session_data *sd,int item_id)
-{
-	int i;
-	nullpo_retr(-1, sd);
-
-	ARR_FIND(0, MAX_INVENTORY, i, sd->status.inventory[i].nameid == item_id && (sd->status.inventory[i].amount > 0 || item_id == 0));
-	return (i < MAX_INVENTORY) ? i : -1;
-}
-
-/*==========================================
+ *------------------------------------------*/
+int pc_search_inventory(struct map_session_data *sd,int item_id)
+{
+	int i, char_id;
+	nullpo_retr(-1, sd);
+
+	if( item_id )
+	{
+		if( map_bg_items(sd->bl.m) && battle_config.bg_reserved_char_id )
+		{ // Battleground Items
+			ARR_FIND( 0, MAX_INVENTORY, i, sd->status.inventory[i].nameid == item_id && sd->status.inventory[i].amount > 0 && sd->status.inventory[i].card[0] == CARD0_CREATE && MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3]) == battle_config.bg_reserved_char_id );
+			if( i < MAX_INVENTORY ) return i;
+		}
+		else if( map[sd->bl.m].flag.ancient && battle_config.ancient_reserved_char_id )
+		{ // Ancient Items
+			ARR_FIND( 0, MAX_INVENTORY, i, sd->status.inventory[i].nameid == item_id && sd->status.inventory[i].amount > 0 && sd->status.inventory[i].card[0] == CARD0_CREATE && MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3]) == battle_config.ancient_reserved_char_id );
+			if( i < MAX_INVENTORY ) return i;
+		}
+		else if( map_gvg_items(sd->bl.m) && battle_config.woe_reserved_char_id )
+		{ // WoE Items
+			ARR_FIND( 0, MAX_INVENTORY, i, sd->status.inventory[i].nameid == item_id && sd->status.inventory[i].amount > 0 && sd->status.inventory[i].card[0] == CARD0_CREATE && MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3]) == battle_config.woe_reserved_char_id );
+			if( i < MAX_INVENTORY ) return i;
+		}
+	}
+
+	for( i = 0; i < MAX_INVENTORY; i++ )
+	{
+		if( sd->status.inventory[i].nameid != item_id )
+			continue;
+		if( item_id && sd->status.inventory[i].amount < 1 )
+			continue;
+		if( item_id && sd->status.inventory[i].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3])) > 0 )
+		{
+			if( !map_bg_items(sd->bl.m) && battle_config.bg_reserved_char_id && battle_config.bg_reserved_char_id == char_id )
+				continue;
+			if( !map[sd->bl.m].flag.ancient && battle_config.ancient_reserved_char_id && battle_config.ancient_reserved_char_id == char_id )
+				continue;
+			if( !map_gvg_items(sd->bl.m) && battle_config.woe_reserved_char_id && battle_config.woe_reserved_char_id == char_id )
+				continue;
+		}
+
+		return i;
+	}
+
+	return -1;
+}
+
+/*==========================================
  * Attempt to add a new item to inventory.
  * Return:
         0 = success
@@ -3751,10 +4438,10 @@
 
 	i = MAX_INVENTORY;
 
-	if(itemdb_isstackable2(data) && item_data->expire_time == 0) {
-		// Stackable | Non Rental
+	if( itemdb_isstackable2(data) && item_data->unique_id == 0 && item_data->expire_time == 0 )
+	{ // Stackable | Non Serialized (non unique) | Non Rental
 		for(i = 0; i < MAX_INVENTORY; i++) {
-			if(sd->status.inventory[i].nameid == item_data->nameid && memcmp(&sd->status.inventory[i].card, &item_data->card, sizeof(item_data->card)) == 0) {
+			if( sd->status.inventory[i].nameid == item_data->nameid && sd->status.inventory[i].bound == item_data->bound && memcmp(&sd->status.inventory[i].card, &item_data->card, sizeof(item_data->card)) == 0 ) {
 				if(amount > MAX_AMOUNT - sd->status.inventory[i].amount || (data->stack.inventory && amount > data->stack.amount - sd->status.inventory[i].amount))
 					return 5;
 				sd->status.inventory[i].amount += amount;
@@ -3775,12 +4462,15 @@
 			sd->status.inventory[i].equip = 0;
 
 		sd->status.inventory[i].amount = amount;
-		sd->inventory_data[i] = data;
-		clif_additem(sd,i,amount,0);
-	}
-#ifdef NSI_UNIQUE_ID
-	if(!itemdb_isstackable2(data) && !item_data->unique_id)
-		sd->status.inventory[i].unique_id = itemdb_unique_id(0,0);
+		sd->inventory_data[i] = data;
+		clif_additem(sd,i,amount,0);
+	}
+
+	if( i < MAX_INVENTORY ) achievement_validate_item(sd,AT_ITEM_HAVE,sd->status.inventory[i].nameid,sd->status.inventory[i].amount);
+
+#ifdef NSI_UNIQUE_ID
+	if( !itemdb_isstackable2(data) && !item_data->unique_id )
+		sd->status.inventory[i].unique_id = itemdb_unique_id(0,0);
 #endif
 	log_pick_pc(sd, log_type, amount, &sd->status.inventory[i]);
 
@@ -3845,12 +4535,13 @@
  * Return:
  *  0 = fail
  *  1 = success
- *------------------------------------------*/
-int pc_dropitem(struct map_session_data *sd,int n,int amount)
-{
-	nullpo_retr(1, sd);
-
-	if(n < 0 || n >= MAX_INVENTORY)
+ *------------------------------------------*/
+int pc_dropitem(struct map_session_data *sd,int n,int amount)
+{
+	struct item_data *item_data; // [Zephyrus] Mensaje al Drop
+	nullpo_retr(1, sd);
+
+	if(n < 0 || n >= MAX_INVENTORY)
 		return 0;
 
 	if(amount <= 0)
@@ -3868,14 +4559,27 @@
 		clif_displaymessage(sd->fd, msg_txt(271));
 		return 0; //Can't drop items in nodrop mapflag maps.
 	}
+	
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't drop. Blocked with @security");
+		return 0;
+	}
 
 	if(!pc_candrop(sd,&sd->status.inventory[n])) {
 		clif_displaymessage(sd->fd, msg_txt(263));
 		return 0;
 	}
 
-	if(!map_addflooritem(&sd->status.inventory[n], amount, sd->bl.m, sd->bl.x, sd->bl.y, 0, 0, 0, 2))
+	if (!map_addflooritem(&sd->status.inventory[n], amount, sd->bl.m, sd->bl.x, sd->bl.y, 0, 0, 0, sd->status.guild_id, 2))
 		return 0;
+		
+	if ((item_data= itemdb_exists(sd->status.inventory[n].nameid)) != NULL)
+		if (item_data->type == IT_WEAPON || item_data->type == IT_CARD || item_data->type == IT_ARMOR) {
+			char output[100];
+			sprintf(output, "[- You drop %s !!. Please be sure about this -]", item_data->jname);
+			clif_displaymessage (sd->fd, output);
+		}
 
 	pc_delitem(sd, n, amount, 1, 0, LOG_TYPE_PICKDROP_PLAYER);
 	clif_dropitem(sd, n, amount);
@@ -3898,12 +4602,15 @@
 	nullpo_ret(sd);
 	nullpo_ret(fitem);
 
-	if(!check_distance_bl(&fitem->bl, &sd->bl, 2) && sd->ud.skill_id!=BS_GREED)
-		return 0;   // Distance is too far
-
-	if(sd->status.party_id)
-		p = party_search(sd->status.party_id);
-
+	if(!check_distance_bl(&fitem->bl, &sd->bl, 2) && sd->ud.skill_id!=BS_GREED)
+		return 0;	// Distance is too far
+
+	if( battle_config.super_woe_enable && fitem->guild_id && sd->status.guild_id != fitem->guild_id )
+		return 0; // Cannot pickup items from other Guilds
+
+	if (sd->status.party_id)
+		p = party_search(sd->status.party_id);
+
 	if(fitem->first_get_charid > 0 && fitem->first_get_charid != sd->status.char_id) {
 		first_sd = map_charid2sd(fitem->first_get_charid);
 		if(DIFF_TICK(tick,fitem->first_get_tick) < 0) {
@@ -3971,16 +4678,16 @@
 		return 0;
 
 	switch(nameid) { //@TODO, lot oh harcoded nameid here
-		case 605: // Anodyne
-			if(map_flag_gvg(sd->bl.m))
-				return 0;
+		case 605: // Anodyne
+			if( map_flag_gvg3(sd->bl.m) )
+				return 0;
 		case 606:
 			if(pc_issit(sd))
 				return 0;
 			break;
 		case 601: // Fly Wing
 		case 12212: // Giant Fly Wing
-			if(map[sd->bl.m].flag.noteleport || map_flag_gvg(sd->bl.m)) {
+			if( map[sd->bl.m].flag.noteleport || map_flag_gvg3(sd->bl.m) || !guild_canescape(sd) ) {
 				clif_skill_teleportmessage(sd,0);
 				return 0;
 			}
@@ -3993,24 +4700,33 @@
 		case 14585: // Blue Butterfly Wing
 		case 14591: // Siege Teleport Scroll
 			if(sd->duel_group && !battle_config.duel_allow_teleport) {
-				clif_displaymessage(sd->fd, msg_txt(663));
-				return 0;
-			}
-			if(nameid != 601 && nameid != 12212 && map[sd->bl.m].flag.noreturn)
-				return 0;
-			break;
+				clif_displaymessage(sd->fd, msg_txt(663));
+				return 0;
+			}
+			if( !guild_canescape(sd) )
+			{ // Guild Wars
+				clif_displaymessage(sd->fd, "Guild Wars: Cannot escape in battle");
+				return 0;
+			}
+			if( nameid != 601 && nameid != 12212 && map[sd->bl.m].flag.noreturn )
+				return 0;
+			break;
 		case 604: // Dead Branch
-		case 12024: // Red Pouch
-		case 12103: // Bloody Branch
-		case 12109: // Poring Box
-			if(map[sd->bl.m].flag.nobranch || map_flag_gvg(sd->bl.m))
+		case 12024: // Red Pouch
+		case 12103: // Bloody Branch
+		case 12109: // Poring Box
+			if( map[sd->bl.m].flag.nobranch || map_flag_gvg3(sd->bl.m) )
+				return 0;
+			break;
+		case 12211: // Kafra Card
+			if( map_flag_gvg(sd->bl.m) )
+				return 0;
+			break;
+		case 12210: // Bubble Gum
+		case 12264: // Comp Bubble Gum
+			if( sd->sc.data[SC_ITEMBOOST] )
 				return 0;
 			break;
-		case 12210: // Bubble Gum
-		case 12264: // Comp Bubble Gum
-			if(sd->sc.data[SC_ITEMBOOST])
-				return 0;
-			break;
 		case 12208: // Battle Manual
 		case 12263: // Comp Battle Manual
 		case 12312: // Thick Battle Manual
@@ -4060,12 +4776,15 @@
 	/**
 	 * Only GCross may use poisons
 	 **/
-	else if(itemdb_is_poison(nameid) && (sd->class_&MAPID_THIRDMASK) != MAPID_GUILLOTINE_CROSS)
-		return 0;
-
-	//Gender check
-	if(item->sex != 2 && sd->status.sex != item->sex)
-		return 0;
+	else if( itemdb_is_poison(nameid) && (sd->class_&MAPID_THIRDMASK) != MAPID_GUILLOTINE_CROSS )
+		return 0;
+
+	if( map[sd->bl.m].flag.ancient && !item->ancient )
+		return 0; // Ancient WoE items
+
+	//Gender check
+	if(item->sex != 2 && sd->status.sex != item->sex)
+		return 0;
 	//Required level check
 	if(item->elv && sd->status.base_level < (unsigned int)item->elv)
 		return 0;
@@ -4104,14 +4823,14 @@
  *  0 = fail
  *  1 = success
  *------------------------------------------*/
-int pc_useitem(struct map_session_data *sd,int n)
-{
-	unsigned int tick = gettick();
-	int amount, nameid;
-	struct script_code *script;
+int pc_useitem(struct map_session_data *sd,int n)
+{
+	unsigned int tick = gettick();
+	int amount, nameid, char_id = 0;
+	struct script_code *script;
+
+	nullpo_ret(sd);
 
-	nullpo_ret(sd);
-
 	if(sd->npc_id){
 #ifdef RENEWAL
 		clif_msg(sd, 0x783); // TODO look for the client date that has this message.
@@ -4121,9 +4840,23 @@
 
 	if(sd->status.inventory[n].nameid <= 0 || sd->status.inventory[n].amount <= 0)
 		return 0;
+		
+	if( sd->state.only_walk )
+		return 0;
 
 	if(!pc_isUseitem(sd,n))
 		return 0;
+		
+	if( sd->status.inventory[n].card[0] == CARD0_CREATE )
+	{ // Do not allow use BG - Ancient Items on invalid maps
+		char_id = MakeDWord(sd->status.inventory[n].card[2],sd->status.inventory[n].card[3]);
+		if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id && !map_bg_items(sd->bl.m) )
+			return 0;
+		if( battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id && !map[sd->bl.m].flag.ancient )
+			return 0;
+		if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id && !map_gvg_items(sd->bl.m) )
+			return 0;
+	}
 
 	// Store information for later use before it is lost (via pc_delitem) [Paradox924X]
 	nameid = sd->inventory_data[n]->nameid;
@@ -4228,12 +4961,12 @@
 	else {
 		if(sd->status.inventory[n].expire_time == 0) {
 			clif_useitemack(sd,n,amount-1,true);
+			achievement_validate_item(sd,AT_ITEM_USE,sd->status.inventory[n].nameid,1);
 			pc_delitem(sd,n,1,1,0,LOG_TYPE_CONSUME); // Rental Usable Items are not deleted until expiration
 		} else
 			clif_useitemack(sd,n,0,false);
 	}
-	if(sd->status.inventory[n].card[0]==CARD0_CREATE &&
-	   pc_famerank(MakeDWord(sd->status.inventory[n].card[2],sd->status.inventory[n].card[3]), MAPID_ALCHEMIST)) {
+	if( !map[sd->bl.m].flag.ancient && sd->status.inventory[n].card[0] == CARD0_CREATE && char_id && (char_id == battle_config.bg_reserved_char_id || char_id == battle_config.woe_reserved_char_id || pc_famerank(char_id, MAPID_ALCHEMIST)) ) {
 		potion_flag = 2; // Famous player's potions have 50% more efficiency
 		if(sd->sc.data[SC_SPIRIT] && sd->sc.data[SC_SPIRIT]->val2 == SL_ROGUE)
 			potion_flag = 3; //Even more effective potions.
@@ -4283,10 +5016,11 @@
 
 	i = MAX_CART;
 	if(itemdb_isstackable2(data) && !item_data->expire_time) {
-		ARR_FIND(0, MAX_CART, i,
-		         sd->status.cart[i].nameid == item_data->nameid &&
-		         sd->status.cart[i].card[0] == item_data->card[0] && sd->status.cart[i].card[1] == item_data->card[1] &&
-		         sd->status.cart[i].card[2] == item_data->card[2] && sd->status.cart[i].card[3] == item_data->card[3]);
+		ARR_FIND( 0, MAX_CART, i,
+			sd->status.cart[i].nameid == item_data->nameid &&
+			sd->status.cart[i].bound == item_data->bound &&
+			sd->status.cart[i].card[0] == item_data->card[0] && sd->status.cart[i].card[1] == item_data->card[1] &&
+			sd->status.cart[i].card[2] == item_data->card[2] && sd->status.cart[i].card[3] == item_data->card[3] );
 	};
 
 	if(i < MAX_CART) {
@@ -4327,13 +5061,13 @@
 	nullpo_retr(1, sd);
 
 	if(sd->status.cart[n].nameid==0 ||
-	   sd->status.cart[n].amount<amount)
-		return 1;
-
-	log_pick_pc(sd, log_type, -amount, &sd->status.cart[n]);
-
-	sd->status.cart[n].amount -= amount;
-	sd->cart_weight -= itemdb_weight(sd->status.cart[n].nameid)*amount ;
+	   sd->status.cart[n].amount<amount)
+		return 1;
+
+	log_pick_pc(sd,log_type,-amount,&sd->status.cart[n]);
+
+	sd->status.cart[n].amount -= amount;
+	sd->cart_weight -= itemdb_weight(sd->status.cart[n].nameid)*amount ;
 	if(sd->status.cart[n].amount <= 0) {
 		memset(&sd->status.cart[n],0,sizeof(sd->status.cart[0]));
 		sd->cart_num--;
@@ -4456,13 +5190,13 @@
 
 	if(!sd || !bl || bl->type!=BL_MOB)
 		return 0;
-
-	md = (TBL_MOB *)bl;
-
-	if(md->state.steal_flag == UCHAR_MAX || (md->sc.opt1 && md->sc.opt1 != OPT1_BURNING && md->sc.opt1 != OPT1_CRYSTALIZE))    //already stolen from / status change check
-		return 0;
-
-	sd_status= status_get_status_data(&sd->bl);
+
+	md = (TBL_MOB *)bl;
+
+	if(md->state.steal_flag == UCHAR_MAX || ( md->sc.opt1 && md->sc.opt1 != OPT1_BURNING && md->sc.opt1 != OPT1_CRYSTALIZE ) || md->option.no_expdrop ) //already stolen from / status change check
+		return 0;
+
+	sd_status= status_get_status_data(&sd->bl);
 	md_status= status_get_status_data(bl);
 
 	if(md->master_id || md_status->mode&MD_BOSS || mob_is_treasure(md) ||
@@ -4507,13 +5241,13 @@
 	}
 
 	if(battle_config.show_steal_in_same_party)
-		party_foreachsamemap(pc_show_steal,sd,AREA_SIZE,sd,tmp_item.nameid);
-
-	//Logs items, Stolen from mobs [Lupus]
-	log_pick_mob(md, LOG_TYPE_STEAL, -1, &tmp_item);
-
-	//A Rare Steal Global Announce by Lupus
-	if(md->db->dropitem[i].p<=battle_config.rare_drop_announce) {
+		party_foreachsamemap(pc_show_steal,sd,AREA_SIZE,sd,tmp_item.nameid);
+
+	//Logs items, Stolen from mobs [Lupus]
+	log_pick_mob(md, LOG_TYPE_PICKDROP_MONSTER, -1, &tmp_item);
+
+	//A Rare Steal Global Announce by Lupus
+	if(md->db->dropitem[i].p<=battle_config.rare_drop_announce) {
 		struct item_data *i_data;
 		char message[128];
 		i_data = itemdb_search(itemid);
@@ -4563,14 +5297,17 @@
  * 0 - Success.
  * 1 - Invalid map index.
  * 2 - Map not in this map-server, and failed to locate alternate map-server.
- *------------------------------------------*/
-int pc_setpos(struct map_session_data *sd, unsigned short mapindex, int x, int y, clr_type clrtype)
-{
-	struct party_data *p;
-	int16 m;
-
-	nullpo_ret(sd);
-
+ *------------------------------------------*/
+int pc_setpos(struct map_session_data* sd, unsigned short mapindex, int x, int y, clr_type clrtype)
+{
+	struct guild *g;
+	struct party_data *p;
+	struct guild_castle *gc;
+	int16 m;
+	int i, c;
+
+	nullpo_ret(sd);
+
 	if(!mapindex || !mapindex_id2name(mapindex)) {
 		ShowDebug("pc_setpos: Passed mapindex(%d) is invalid!\n", mapindex);
 		return 1;
@@ -4592,17 +5329,63 @@
 			// Changes destiny to the instance map, not the source map
 			m = im;
 			mapindex = map_id2index(m);
-		}
-	}
-
-	sd->state.changemap = (sd->mapindex != mapindex);
-	sd->state.warping = 1;
-	if(sd->state.changemap) {   // Misc map-changing settings
-		int i;
-		sd->state.pmap = sd->bl.m;
-		if(sd->sc.count) {  // Cancel some map related stuff.
-			if(sd->sc.data[SC_JAILED])
-				return 1; //You may not get out!
+		}
+	}
+
+	if( (map[m].flag.blocked && !pc_has_permission(sd,PC_PERM_WARP_ANYWHERE)) || (map[m].flag.ancient && (sd->md || !pc_class2ancientwoe(sd->status.class_) || pc_checkskill(sd, ALL_INCCARRY))) )
+	{
+		mapindex = sd->status.save_point.map;
+		x = sd->status.save_point.x;
+		y = sd->status.save_point.y;
+		m = map_mapindex2mapid(mapindex);
+	}
+	else if( map_blocked_woe(m) && (gc = guild_mapindex2gc(map[m].index)) != NULL && (gc->guild_id == 0 || sd->status.guild_id != gc->guild_id) )
+	{ // Non Castle Owners on different WoE times
+		mapindex = sd->status.save_point.map;
+		x = sd->status.save_point.x;
+		y = sd->status.save_point.y;
+		m = map_mapindex2mapid(mapindex);
+	}
+	else if( map[m].guild_max && sd->bl.m != m && sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL )
+	{ // Guild Limit
+		for( i = c = 0; i < g->max_member && c < map[m].guild_max; i++ )
+			if( g->member[i].sd && g->member[i].sd->bl.m == m )
+				c++;
+		
+		if( c >= map[m].guild_max )
+		{ // No more guild members on this map
+			mapindex = sd->status.save_point.map;
+			x = sd->status.save_point.x;
+			y = sd->status.save_point.y;
+			m = map_mapindex2mapid(mapindex);
+		}
+	}
+	else if( map[m].party_max && sd->bl.m != m && sd->status.party_id && (p = party_search(sd->status.party_id)) != NULL )
+	{ // Party Limit
+		for( i = c = 0; i < MAX_PARTY && c < map[m].party_max; i++ )
+			if( p->data[i].sd && p->data[i].sd->bl.m == m )
+				c++;
+
+		if( c >= map[m].party_max )
+		{ // No more party members on this map
+			mapindex = sd->status.save_point.map;
+			x = sd->status.save_point.x;
+			y = sd->status.save_point.y;
+			m = map_mapindex2mapid(mapindex);
+		}
+	}
+
+	sd->state.changemap = (sd->mapindex != mapindex);
+	sd->state.warping = 1;
+	if( sd->state.changemap ) { // Misc map-changing settings
+		int i;
+		sd->state.pmap = sd->bl.m;
+		sd->state.only_walk = 0;
+		sd->pvpevent_fame = 0;
+
+		if (sd->sc.count) { // Cancel some map related stuff.
+			if (sd->sc.data[SC_JAILED])
+				return 1; //You may not get out!
 			status_change_end(&sd->bl, SC_BOSSMAPINFO, INVALID_TIMER);
 			status_change_end(&sd->bl, SC_WARM, INVALID_TIMER);
 			status_change_end(&sd->bl, SC_SUN_COMFORT, INVALID_TIMER);
@@ -4615,23 +5398,43 @@
 					delete_timer(sce->timer, status_change_timer);
 				sce->timer = add_timer(gettick() + skill_get_time(SG_KNOWLEDGE, sce->val1), status_change_timer, sd->bl.id, SC_KNOWLEDGE);
 			}
-			status_change_end(&sd->bl, SC_PROPERTYWALK, INVALID_TIMER);
-			status_change_end(&sd->bl, SC_CLOAKING, INVALID_TIMER);
-			status_change_end(&sd->bl, SC_CLOAKINGEXCEED, INVALID_TIMER);
-		}
-		for(i = 0; i < EQI_MAX; i++) {
-			if(sd->equip_index[ i ] >= 0)
+			status_change_end(&sd->bl, SC_PROPERTYWALK, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CLOAKING, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CLOAKINGEXCEED, INVALID_TIMER);
+			if( map[m].flag.ancient )
+			{ // Ancient WoE Deffus
+				int i;
+				const enum sc_type scs[] = { SC_SPREGEN, SC_GOSPEL, SC_MAGICPOWER, SC_ASSUMPTIO, SC_SPIRIT, SC_INTRAVISION, SC_INCALLSTATUS, SC_INCSTR, SC_INCAGI, SC_INCVIT, SC_INCINT, SC_INCDEX, SC_INCLUK, SC_INCHIT, SC_INCHITRATE, SC_INCFLEE, SC_INCFLEERATE, SC_INCMHPRATE, SC_INCMSPRATE, SC_INCATKRATE, SC_INCMATKRATE, SC_INCDEFRATE, SC_STRFOOD, SC_AGIFOOD, SC_VITFOOD, SC_INTFOOD, SC_DEXFOOD, SC_LUKFOOD, SC_HITFOOD, SC_FLEEFOOD, SC_BATKFOOD, SC_WATKFOOD, SC_MATKFOOD, SC_SCRESIST, SC_INCCRI, SC_MDEF_RATE, SC_INCHEALRATE, SC_ARMOR_RESIST, SC_SPCOST_RATE, SC_COMMONSC_RESIST, SC_DEF_RATE, SC_KAITE, SC_KAUPE, SC_ITEMSCRIPT, SC_S_LIFEPOTION, SC_L_LIFEPOTION };
+
+				for( i = 0; i < ARRAYLENGTH(scs); i++ )
+				{
+					if( sd->sc.data[scs[i]] )
+						status_change_end(&sd->bl, scs[i], -1);
+				}
+
+				// Full Chemical Protection
+				for( i = 0; i < 4; i++ )
+				{
+					if( sd->sc.data[SC_CP_WEAPON + i] && sd->sc.data[SC_CP_WEAPON + i]->val4 == CR_FULLPROTECTION )
+						status_change_end(&sd->bl, (sc_type)(SC_CP_WEAPON + i), -1);
+				}
+			}
+		}
+		for( i = 0; i < EQI_MAX; i++ ) {
+			if( sd->equip_index[ i ] >= 0 )
 				if(!pc_isequip(sd , sd->equip_index[ i ]))
 					pc_unequipitem(sd , sd->equip_index[ i ] , 2);
 		}
 		if(battle_config.clear_unit_onwarp&BL_PC)
 			skill_clear_unitgroup(&sd->bl);
-		party_send_dot_remove(sd); //minimap dot fix [Kevin]
-		guild_send_dot_remove(sd);
-		bg_send_dot_remove(sd);
-		if(sd->regen.state.gc)
-			sd->regen.state.gc = 0;
-		// make sure vending is allowed here
+		party_send_dot_remove(sd); //minimap dot fix [Kevin]
+		guild_send_dot_remove(sd);
+		bg_send_dot_remove(sd);
+		if( battle_config.bg_queue_onlytowns && sd->qd && map[sd->bl.m].flag.town && !map[m].flag.town )
+			queue_leaveall(sd);
+		if (sd->regen.state.gc)
+			sd->regen.state.gc = 0;
+		// make sure vending is allowed here
 		if(sd->state.vending && map[m].flag.novending) {
 			clif_displaymessage(sd->fd, msg_txt(276));  // "You can't open a shop on this map"
 			vending_closevending(sd);
@@ -4685,12 +5488,13 @@
 		unit_remove_map_pc(sd,clrtype);
 		clif_changemap(sd,map[m].index,x,y); // [MouseJstr]
 	} else if(sd->state.active)
-		//Tag player for rewarping after map-loading is done. [Skotlex]
-		sd->state.rewarp = 1;
-
-	sd->mapindex = mapindex;
-	sd->bl.m = m;
-	sd->bl.x = sd->ud.to_x = x;
+		//Tag player for rewarping after map-loading is done. [Skotlex]
+		sd->state.rewarp = 1;
+
+	sd->state.changeregion = (map[sd->bl.m].region_id != map[m].region_id);
+	sd->mapindex = mapindex;
+	sd->bl.m = m;
+	sd->bl.x = sd->ud.to_x = x;
 	sd->bl.y = sd->ud.to_y = y;
 
 	if(sd->status.guild_id > 0 && map[m].flag.gvg_castle) {
@@ -5568,38 +6372,62 @@
  * Alters experienced based on self bonuses that do not get even shared to the party.
  *------------------------------------------*/
 static void pc_calcexp(struct map_session_data *sd, unsigned int *base_exp, unsigned int *job_exp, struct block_list *src)
-{
-	int bonus = 0;
-	struct status_data *status = status_get_status_data(src);
-
-	if(sd->expaddrace[status->race])
-		bonus += sd->expaddrace[status->race];
+{
+	int bonus = 0;
+	struct status_data *status = status_get_status_data(src);
+	struct region_data* rd;
+	unsigned int ebonus = 0, jbonus = 0;
+
+	if (sd->expaddrace[status->race])
+		bonus += sd->expaddrace[status->race];
 	bonus += sd->expaddrace[status->mode&MD_BOSS?RC_BOSS:RC_NONBOSS];
 
 	if(battle_config.pk_mode &&
 	   (int)(status_get_lv(src) - sd->status.base_level) >= 20)
 		bonus += 15; // pk_mode additional exp if monster >20 levels [Valaris]
 
-	if(sd->sc.data[SC_EXPBOOST])
-		bonus += sd->sc.data[SC_EXPBOOST]->val1;
-
-	*base_exp = (unsigned int) cap_value(*base_exp + (double)*base_exp * bonus/100., 1, UINT_MAX);
-
-	if(sd->sc.data[SC_JEXPBOOST])
-		bonus += sd->sc.data[SC_JEXPBOOST]->val1;
-
-	*job_exp = (unsigned int) cap_value(*job_exp + (double)*job_exp * bonus/100., 1, UINT_MAX);
-
-	return;
-}
-/*==========================================
+	if (sd->sc.data[SC_EXPBOOST])
+		bonus += sd->sc.data[SC_EXPBOOST]->val1;
+
+	if( sd->status.iprank )
+		bonus += (sd->status.iprank * 2);
+
+	if( pc_isPremium(sd) && battle_config.premium_bonusexp )
+		bonus += battle_config.premium_bonusexp;
+
+	if( sd->state.pvpmode && battle_config.pvpmode_expbonus )
+	{
+		int rank;
+		if( (rank = pc_pvpfamerank(sd->status.char_id)) && rand()%100 < ((MAX_FAME_LIST + 1 - rank) * 4) )
+			bonus += battle_config.pvpmode_expbonus;
+	}
+
+	if (sd->sc.data[SC_JEXPBOOST])
+		jbonus += sd->sc.data[SC_JEXPBOOST]->val1;
+
+	if( sd->status.guild_id && (rd = region_search(map[sd->bl.m].region_id)) != NULL && sd->status.guild_id == rd->guild_id )
+	{
+		ebonus += rd->bonus_bexp;
+		jbonus += rd->bonus_jexp;
+	}
+
+	if( !bonus && !ebonus && !jbonus )
+	  	return;
+	
+	*base_exp = (unsigned int) cap_value(*base_exp + (double)*base_exp * (bonus + ebonus)/100., 1, UINT_MAX);
+	*job_exp = (unsigned int) cap_value(*job_exp + (double)*job_exp * (bonus + jbonus)/100., 1, UINT_MAX);
+
+	return;
+}
+/*==========================================
  * Give x exp at sd player and calculate remaining exp for next lvl
- *------------------------------------------*/
-int pc_gainexp(struct map_session_data *sd, struct block_list *src, unsigned int base_exp,unsigned int job_exp,bool quest)
-{
-	float nextbp=0, nextjp=0;
-	unsigned int nextb=0, nextj=0;
-	nullpo_ret(sd);
+ *------------------------------------------*/
+int pc_gainexp(struct map_session_data *sd, struct block_list *src, unsigned int base_exp,unsigned int job_exp,bool quest)
+{
+	char output[256];
+	float nextbp=0, nextjp=0;
+	unsigned int nextb=0, nextj=0;
+	nullpo_ret(sd);
 
 	if(sd->bl.prev == NULL || pc_isdead(sd))
 		return 0;
@@ -5609,13 +6437,14 @@
 
 	if(pc_has_permission(sd,PC_PERM_DISABLE_EXP))
 		return 0;
-
-	if(sd->status.guild_id>0)
-		base_exp-=guild_payexp(sd,base_exp);
-
-	if(src) pc_calcexp(sd, &base_exp, &job_exp, src);
-
-	nextb = pc_nextbaseexp(sd);
+
+	if( src )
+		pc_calcexp(sd, &base_exp, &job_exp, src);
+
+	if(sd->status.guild_id>0)
+		base_exp-=guild_payexp(sd,base_exp);
+
+	nextb = pc_nextbaseexp(sd);
 	nextj = pc_nextjobexp(sd);
 
 	if(sd->state.showexp || battle_config.max_exp_gain_rate) {
@@ -5665,13 +6494,62 @@
 		clif_displayexp(sd, base_exp, SP_BASEEXP, quest);
 	if(job_exp)
 		clif_displayexp(sd, job_exp,  SP_JOBEXP, quest);
+	sd->custom_data.session_base_exp += base_exp;
+	sd->custom_data.session_job_exp += job_exp;
 	if(sd->state.showexp) {
-		char output[256];
 		sprintf(output,
 		        "Experiência de Base:%u (%.2f%%) Job:%u (%.2f%%)",base_exp,nextbp*(float)100,job_exp,nextjp*(float)100);
 		clif_disp_onlyself(sd,output,strlen(output));
 	}
+	
+	if( sd->state.showgain )
+	{
+		unsigned int nextb, nextj, bexp_ps, jexp_ps, nextbt, nextjt;
+		int session_time, day = 0, hour = 0, minute = 0, second = 0;
 
+		if( (session_time = (int)(last_tick - sd->custom_data.session_start)) <= 0 )
+			return 1;
+
+		nextb = pc_nextbaseexp(sd);
+		nextj = pc_nextjobexp(sd);
+
+		if( nextb )
+		{ // Next Base lvl information
+			if( (bexp_ps = sd->custom_data.session_base_exp / session_time) < 1 )
+				sprintf(output, msg_txt(869), bexp_ps);
+			else if( (nextbt = (nextb - sd->status.base_exp) / bexp_ps) < 604800 )
+			{
+				atcommand_expinfo_sub(nextbt, &day, &hour, &minute, &second);
+				if( day )
+					sprintf(output, msg_txt(870), bexp_ps, day, hour, minute, second);
+				else
+					sprintf(output, msg_txt(871), bexp_ps, hour, minute, second);
+			}
+			else
+				sprintf(output, msg_txt(869), bexp_ps);
+
+			clif_disp_onlyself(sd, output, strlen(output));
+		}
+
+		if( nextj )
+		{ // Next Job lvl information
+			if( (jexp_ps = sd->custom_data.session_job_exp / session_time) < 1 )
+				sprintf(output, msg_txt(872), jexp_ps);
+			else if( (nextjt = (nextj - sd->status.job_exp) / jexp_ps) < 604800 )
+			{
+				atcommand_expinfo_sub(nextjt, &day, &hour, &minute, &second);
+				if( day )
+					sprintf(output, msg_txt(873), jexp_ps, day, hour, minute, second);
+				else
+					sprintf(output, msg_txt(874), jexp_ps, hour, minute, second);
+			}
+			else
+				sprintf(output, msg_txt(872), jexp_ps);
+
+			clif_disp_onlyself(sd, output, strlen(output));
+		}
+	}
+
 	return 1;
 }
 
@@ -5776,13 +6654,13 @@
 }
 
 // Calculates the number of status points PC gets when leveling up (from level to level+1)
-int pc_gets_status_point(int level)
-{
-	if(battle_config.use_statpoint_table)  //Use values from "db/statpoint.txt"
-		return (statp[level+1] - statp[level]);
-	else //Default increase
-		return ((level+15) / 5);
-}
+int pc_gets_status_point(int level)
+{
+	if (battle_config.use_statpoint_table) //Use values from "db/statpoint.txt"
+		return (stats_point_table[level+1] - stats_point_table[level]);
+	else //Default increase
+		return ((level+15) / 5);
+}
 
 /// Returns the number of stat points needed to change the specified stat by val.
 /// If val is negative, returns the number of stat points that would be needed to
@@ -6098,7 +6976,7 @@
 			return 0;
 		}
 
-		sd->status.status_point = statp[sd->status.base_level] + (sd->class_&JOBL_UPPER ? 52 : 0);   // extra 52+48=100 stat points
+		sd->status.status_point = stats_point_table[sd->status.base_level] + (sd->class_&JOBL_UPPER ? 52 : 0); // extra 52+48=100 stat points
 	} else {
 		int add=0;
 		add += pc_need_status_point(sd, SP_STR, 1-pc_getstat(sd, SP_STR));
@@ -6361,12 +7239,14 @@
 
 /*==========================================
  * Invoked when a player has received damage
- *------------------------------------------*/
-void pc_damage(struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp)
-{
-	if(sp) clif_updatestatus(sd,SP_SP);
-	if(hp) clif_updatestatus(sd,SP_HP);
-	else return;
+ *------------------------------------------*/
+void pc_damage(struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp)
+{
+	struct block_list *s_bl;
+
+	if (sp) clif_updatestatus(sd,SP_SP);
+	if (hp) clif_updatestatus(sd,SP_HP);
+	else return;
 
 	if(!src || src == &sd->bl)
 		return;
@@ -6378,23 +7258,574 @@
 
 	if(sd->progressbar.npc_id)
 		clif_progressbar_abort(sd);
+		
+	if( sd->state.pvpmode && src->type == BL_PC && ((TBL_PC*)src)->state.pvpmode )
+	{
+		// [Zephyrus] Actualizacion de Timer de daño PVP, en PK Mode
+		struct map_session_data *pk = (TBL_PC*)src;
+		sd->idlepvp = last_tick;
+		pk->idlepvp = last_tick;
+	}
 
 	if(sd->status.pet_id > 0 && sd->pd && battle_config.pet_damage_support)
 		pet_target_check(sd,src,1);
+		
+	if( !(src && (s_bl = battle_get_master(src)) != NULL) )
+		s_bl = src;
 
 	if(sd->status.ele_id > 0)
 		elemental_set_target(sd,src);
+		
+	if( s_bl && s_bl->type == BL_PC && guild_wardamage(sd) )
+		sd->canescape_tick = gettick();
 
 	sd->canlog_tick = gettick();
 }
 
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md)
+{
+	struct guild *g;
+	struct guild_castle *gc;
+	struct battleground_data *bg;
+	int type = 0;
+
+	if( !sd ) return;
+	if( map[sd->bl.m].flag.battleground && sd->bg_id )
+	{
+		int i;
+		if( (bg = bg_team_search(sd->bg_id)) == NULL )
+			return;
+		ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
+		if( i >= MAX_BG_MEMBERS )
+			return;
+		type = bg->members[i].ranked ? 2 : 3;
+	}
+
+	if( map_allowed_woe(sd->bl.m) )
+	{
+		switch( md->class_ )
+		{
+		case MOBID_EMPERIUM:
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			if( (g = guild_search(sd->status.guild_id)) && (gc = guild_mapindex2gc(map[sd->bl.m].index)) )
+			{
+				add2limit(g->castle[gc->castle_id].emperium, 1, USHRT_MAX);
+				g->castle[gc->castle_id].changed = true;
+			}
+			break;
+		case 1905:
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case MOBID_GUARIDAN_STONE1:
+		case MOBID_GUARIDAN_STONE2:
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	else if( map[sd->bl.m].flag.battleground )
+	{
+		switch( md->class_ )
+		{
+		case 2100:
+		case 2101:
+		case 2102:
+		case 2103:
+		case 2104:
+			add2limit(sd->status.bgstats.boss_killed, 1, USHRT_MAX);
+			achievement_validate_bg(sd,ATB_BOSS_KILLS,1);
+			pc_addfame(sd,25,type);
+			break;
+		case 2105:
+		case 2106:
+			add2limit(sd->status.bgstats.gstone_kill, 1, USHRT_MAX);
+			achievement_validate_bg(sd,ATB_CON_GSTONE,1);
+			pc_addfame(sd,10,type);
+			break;
+		case 2107:
+			if( map[sd->bl.m].flag.battleground == 2 )
+			{
+				add2limit(sd->status.bgstats.ru_captures, 1, USHRT_MAX);
+				achievement_validate_bg(sd,ATB_RU_CAPTURE,1);
+			}
+			else
+			{
+				add2limit(sd->status.bgstats.emperium_kill, 1, USHRT_MAX);
+				achievement_validate_bg(sd,ATB_CON_EMPERIUM,1);
+			}
+			pc_addfame(sd,30,type);
+			break;
+		case 1911:
+			if( !strcmpi(map[sd->bl.m].name,"bat_a03") )
+			{
+				add2limit(sd->status.bgstats.boss_flags, 1, USHRT_MAX);
+				achievement_validate_bg(sd,ATB_BOSS_FLAGS,1);
+				pc_addfame(sd,5,type);
+			}
+			break;
+		case 1906:
+			if( strcmpi(map[sd->bl.m].name,"bat_a01") )
+			{
+				add2limit(sd->status.bgstats.barricade_kill, 1, USHRT_MAX);
+				achievement_validate_bg(sd,ATB_CON_BARRICADE,1);
+				pc_addfame(sd,1,type);
+			}
+			break;
+		}
+	}
+
+	if( map[sd->bl.m].flag.gvg_castle && ((md->class_ >= 1324 && md->class_ <= 1363) || (md->class_ >= 1938 && md->class_ <= 1946)) && (g = guild_search(sd->status.guild_id)) && (gc = guild_mapindex2gc(map[sd->bl.m].index)) )
+	{
+		add2limit(g->castle[gc->castle_id].treasure, 1, USHRT_MAX); // Treasure opened on Castle
+		g->castle[gc->castle_id].changed = true;
+		if( !(agit_flag || agit2_flag) )
+		{
+			intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+			g->castle[gc->castle_id].changed = false;
+		}
+	}
+}
+
+void pc_record_maxdamage(struct block_list *src, struct block_list *dst, int damage)
+{
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+
+	if( !src || !dst || src == dst || dst->type != BL_PC || damage <= 0 )
+		return;
+
+	if( (s_bl = battle_get_master(src)) == NULL )
+		s_bl = src;
+
+	if( s_bl->type != BL_PC )
+		return;
+
+	if( (sd = BL_CAST(BL_PC, s_bl)) != NULL )
+	{
+		if( map[src->m].flag.battleground && sd->bg_id && sd->status.bgstats.top_damage < damage )
+			sd->status.bgstats.top_damage = damage;
+		else if( map_allowed_woe(src->m) && sd->status.wstats.top_damage < damage )
+			sd->status.wstats.top_damage = damage;
+	}
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *dst, int damage)
+{
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+
+	if( !src || !dst || src == dst || damage <= 0 )
+		return;
+
+	if( (s_bl = battle_get_master(src)) == NULL )
+		s_bl = src;
+
+	if( s_bl->type != BL_PC )
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch( dst->type )
+	{
+		case BL_PC:
+			achievement_validate_damage(sd,damage);
+			if( map[src->m].flag.battleground && sd->bg_id )
+			{
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)dst)->status.bgstats.damage_received, damage, UINT_MAX);
+			}
+			else if( map_allowed_woe(src->m) )
+			{
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)dst)->status.wstats.damage_received, damage, UINT_MAX);
+			}
+			break;
+		case BL_MOB:
+		{
+			struct mob_data *md = BL_CAST(BL_MOB, dst);
+			if( map[src->m].flag.battleground && sd->bg_id && md->class_ >= 2100 && md->class_ <= 2104 )
+				add2limit(sd->status.bgstats.boss_damage, damage, UINT_MAX);
+			else if( map_allowed_woe(src->m) && md->guardian_data )
+			{
+				switch( md->class_ )
+				{
+					case MOBID_EMPERIUM:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case MOBID_GUARIDAN_STONE1:
+					case MOBID_GUARIDAN_STONE2:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_calc_ranking(struct map_session_data *tsd, struct map_session_data *ssd, uint16 skill_id)
+{
+	int m, i, Elo;
+	char output[256];
+
+	if( !tsd || !ssd || tsd == ssd )
+		return;
+
+	m = ssd->bl.m;
+	achievement_validate_killer(ssd);
+
+	if( map_allowed_woe(m) )
+	{
+		/*==========================================
+		 * Guild Ranking - War of Emperium
+		 *------------------------------------------*/
+		struct guild *tg, *sg;
+		struct guild_castle *gc = guild_mapindex2gc(map[m].index);
+
+		if( gc == NULL || gc->guild_id <= 0 )
+			return;
+
+		if( (tg = guild_search(tsd->status.guild_id)) == NULL || (sg = guild_search(ssd->status.guild_id)) == NULL )
+			return;
+
+		i = gc->castle_id;
+		Elo = (int)(10. / (1 + pow(10., (int)(sg->castle[i].offensive_score - tg->castle[i].offensive_score) / 2000.)));
+		add2limit(sg->castle[i].offensive_score, Elo, 4000);
+		sub2limit(tg->castle[i].offensive_score, Elo, 0);
+
+		// Single Player Ranking WoE
+		Elo = (int)(50. / (1 + pow(10., (int)(ssd->status.wstats.score - tsd->status.wstats.score) / 2000.)));
+		add2limit(ssd->status.wstats.score, Elo, 4000);
+		sub2limit(tsd->status.wstats.score, Elo, 0);
+		add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.wstats.death_count, 1, USHRT_MAX);
+
+		log_woe_kill(ssd,tsd,skill_id);
+
+		if( tsd->status.guild_id == gc->guild_id )
+		{ // Offensive Ranking - Killing Castle Owners
+			add2limit(sg->castle[i].off.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].def.death_count, 1, UINT_MAX);
+		}
+		else if( guild_isallied(gc->guild_id, tsd->status.guild_id) )
+		{ // Offensive Ranking - Killing Castle Allied
+			add2limit(sg->castle[i].off.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].ali.death_count, 1, UINT_MAX);
+		}
+		else if( ssd->status.guild_id == gc->guild_id )
+		{ // Defensive Ranking - Killing Castle Invaders
+			add2limit(sg->castle[i].def.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].off.death_count, 1, UINT_MAX);
+		}
+		else if( guild_isallied(gc->guild_id, ssd->status.guild_id) )
+		{ // Defensive Ranking - Allied killing Invaders
+			add2limit(sg->castle[i].ali.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].off.death_count, 1, UINT_MAX);
+		}
+		else
+		{ // Killing other guilds invaders
+			add2limit(sg->castle[i].ext.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].ext.death_count, 1, UINT_MAX);
+		}
+
+		tg->castle[i].changed = true;
+		sg->castle[i].changed = true;
+	}
+	else if( map_pvpevent(m) )
+	{
+		/*==========================================
+		 * PVP Event Ranking
+		 *------------------------------------------*/
+		struct party_data *p;
+		struct map_session_data *s_pl[MAX_PARTY], *t_pl[MAX_PARTY], *p_sd;
+		struct fame_list b_fame_list[MAX_FAME_LIST];
+		int j;
+
+		unsigned int s_rate = 0, t_rate = 0;
+		int sc = 1, tc = 1, s_Elo, t_Elo, diff_lv, cash = 0;
+
+		// Validate Kill Area
+		if( map[m].pvpe_area )
+		{
+			if( ssd->bl.x < map[m].pvpe_x1 || ssd->bl.x > map[m].pvpe_x2 || ssd->bl.y < map[m].pvpe_y1 || ssd->bl.y > map[m].pvpe_y2 )
+				return; // Killer not on Area
+			if( tsd->bl.x < map[m].pvpe_x1 || tsd->bl.x > map[m].pvpe_x2 || tsd->bl.y < map[m].pvpe_y1 || tsd->bl.y > map[m].pvpe_y2 )
+				return; // Killed not on Area
+		}
+
+		diff_lv = ssd->status.base_level - tsd->status.base_level;
+		if( diff_lv < 0 ) diff_lv = -1 * diff_lv;
+		if( diff_lv > 15 ) return;
+
+		// Source
+		if( ssd->status.party_id && (p = party_search(ssd->status.party_id)) != NULL )
+		{
+			for( i = sc = 0; i < MAX_PARTY; i++ )
+			{
+				if( (s_pl[sc] = p->data[i].sd) == NULL || s_pl[sc]->bl.m != m )
+					continue;
+				if( pc_isdead(s_pl[sc]) && s_pl[sc] != ssd )
+					continue;
+				if( map[m].pvpe_area && ( s_pl[sc]->bl.x < map[m].pvpe_x1 || s_pl[sc]->bl.x > map[m].pvpe_x2 || s_pl[sc]->bl.y < map[m].pvpe_y1 || s_pl[sc]->bl.y > map[m].pvpe_y2 ) )
+					continue; // Party member not on Area
+				
+				s_rate += s_pl[sc]->status.pvp.score;
+				sc++;
+			}
+			if( sc < 1 ) return;
+		}
+		else
+		{
+			s_pl[0] = ssd;
+			s_rate = s_pl[0]->status.pvp.score;
+		}
+
+		s_rate /= sc; // Average Source Rate
+
+		// Target
+		if( tsd->status.party_id && (p = party_search(tsd->status.party_id)) != NULL )
+		{
+			for( i = tc = 0; i < MAX_PARTY; i++ )
+			{
+				if( (t_pl[tc] = p->data[i].sd) == NULL || t_pl[tc]->bl.m != m )
+					continue;
+				if( pc_isdead(t_pl[tc]) && t_pl[tc] != tsd )
+					continue;
+				if( map[m].pvpe_area && ( t_pl[tc]->bl.x < map[m].pvpe_x1 || t_pl[tc]->bl.x > map[m].pvpe_x2 || t_pl[tc]->bl.y < map[m].pvpe_y1 || t_pl[tc]->bl.y > map[m].pvpe_y2 ) )
+					continue; // Party member not on Area
+				t_rate += t_pl[tc]->status.pvp.score;
+				tc++;
+			}
+			if( tc < 1 ) return;
+		}
+		else
+		{
+			t_pl[0] = tsd;
+			t_rate = t_pl[0]->status.pvp.score;
+		}
+
+		memcpy(&b_fame_list, pvpevent_fame_list, sizeof(struct fame_list));
+		t_rate /= sc; // Average Target Rate
+
+		Elo = (int)(50. / (1 + pow(10., (int)(s_rate - t_rate) / 2000.)));
+		s_Elo = Elo / sc;
+
+		if( battle_config.pvpevent_cashperkill )
+			cash = 1 + ( (tsd->status.base_level * battle_config.pvpevent_cashperkill) / (10 * sc) );
+
+		for( i = 0; i < sc; i++ )
+		{
+			add2limit(s_pl[i]->status.pvp.score, s_Elo, 4000);
+			add2limit(s_pl[i]->pvpevent_fame, s_Elo, UINT_MAX);
+
+			sprintf(output, "[%s] Killed by [%s] - Received %d / %d = %d Points. Stats PvP-Elo %d | Score %d.", tsd->status.name, ssd->status.name, Elo, sc, s_Elo, s_pl[i]->status.pvp.score, s_pl[i]->pvpevent_fame);
+			clif_disp_onlyself(s_pl[i], output, strlen(output));
+
+			pc_pvpevent_addfame(s_pl[i], false);
+			if( cash )
+			{ // Receiving Cash per Kill
+				pc_getcash(s_pl[i], 0, cash); // Kafra Points
+				clif_emotion(&s_pl[i]->bl, 8); // e_cash
+			}
+		}
+
+		for( i = 0; i < MAX_FAME_LIST; i++ )
+		{ // Announces Fame List
+			if( b_fame_list[i].id != 0 && (p_sd = map_charid2sd(b_fame_list[i].id)) != NULL )
+			{
+				ARR_FIND(0, MAX_FAME_LIST, j, pvpevent_fame_list[j].id == b_fame_list[i].id); // Search Previous Position
+				if( j != i )
+				{
+					if( j == MAX_FAME_LIST )
+						sprintf(output, "-- You have been removed from Top %d PVP Event Fame List --", MAX_FAME_LIST);
+					else if( j < i )
+						sprintf(output, "-- Going UP to Position %d on Top %d PVP Event Fame List --", j + 1, MAX_FAME_LIST);
+					else
+						sprintf(output, "-- Going Down to Position %d on Top %d PVP Event Fame List --", j + 1, MAX_FAME_LIST);
+
+					clif_disp_onlyself(p_sd, output, strlen(output));
+				}
+			}
+
+			if( pvpevent_fame_list[i].id != 0 && (p_sd = map_charid2sd(pvpevent_fame_list[i].id)) != NULL )
+			{
+				ARR_FIND(0, MAX_FAME_LIST, j, pvpevent_fame_list[i].id == b_fame_list[j].id);
+				if( j == MAX_FAME_LIST )
+				{
+					sprintf(output, "-- Entering Top %d PVP Event Fame List at position %d --", MAX_FAME_LIST, i + 1);
+					clif_disp_onlyself(p_sd, output, strlen(output));
+				}
+			}
+		}
+
+		if( memcmp(&pvpevent_fame_list, &b_fame_list, sizeof(pvpevent_fame_list)) )
+		{
+			i = 0;
+			while( i < MAX_FAME_LIST && pvpevent_fame_list[i].id )
+			{
+				mapreg_setregstr(add_str("$pvpevent_name$")+(i<<24), pvpevent_fame_list[i].name);
+				mapreg_setreg(add_str("$pvpevent_id")+(i<<24), pvpevent_fame_list[i].id);
+				mapreg_setreg(add_str("$pvpevent_fame")+(i<<24), pvpevent_fame_list[i].fame);
+				i++;
+			}
+
+			mapreg_setreg(add_str("$pvpevent_count"),i);
+		}
+
+		t_Elo = Elo / tc;
+		for( i = 0; i < tc; i++ )
+			sub2limit(t_pl[i]->status.pvp.score, t_Elo, 0);
+
+		add2limit(ssd->status.pvp.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.pvp.death_count, 1, USHRT_MAX);
+	}
+	else if( ssd->bg_id && map[m].flag.battleground && tsd->bg_id )
+	{
+		/*==========================================
+		 * BattleGround Ranking
+		 *------------------------------------------*/
+		struct battleground_data *s_bg, *t_bg;
+		struct map_session_data *s_pl[MAX_BG_MEMBERS], *t_pl[MAX_BG_MEMBERS];
+		unsigned int s_rate = 0, t_rate = 0;
+		int sc, tc, s_Elo, t_Elo;
+
+		if( (s_bg = bg_team_search(ssd->bg_id)) == NULL || (t_bg = bg_team_search(tsd->bg_id)) == NULL )
+			return;
+
+		// Source
+		for( i = sc = 0; i < MAX_BG_MEMBERS; i++ )
+		{
+			if( (s_pl[sc] = s_bg->members[i].sd) == NULL || s_pl[sc]->bl.m != m )
+				continue;
+			s_rate += s_pl[sc]->status.bgstats.score;
+			sc++;
+		}
+		if( sc < 1 ) return;
+		else s_rate /= sc; // Avergate Source Rate
+
+		// Target
+		for( i = tc = 0; i < MAX_BG_MEMBERS; i++ )
+		{
+			if( (t_pl[tc] = t_bg->members[i].sd) == NULL || t_pl[tc]->bl.m != m )
+				continue;
+			t_rate += t_pl[tc]->status.bgstats.score;
+			tc++;
+		}
+		if( tc < 1 ) return;
+		else t_rate /= tc; // Avergate Target Rate
+
+		Elo = (int)(50. / (1 + pow(10., (int)(s_rate - t_rate) / 2000.)));
+		s_Elo = Elo / sc;
+		for( i = 0; i < sc; i++ )
+			add2limit(s_pl[i]->status.bgstats.score, s_Elo, 4000);
+
+		t_Elo = Elo / tc;
+		for( i = 0; i < tc; i++ )
+			sub2limit(t_pl[i]->status.bgstats.score, t_Elo, 0);
+
+		log_bg_kill(ssd,tsd,skill_id);
+
+		add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.bgstats.death_count, 1, USHRT_MAX);
+		ssd->bg_kills++; // This BG Kills
+	}
+	else if( ssd->state.pvpmode && tsd->state.pvpmode )
+	{
+		/*==========================================
+		 * PVP Mode Ranking
+		 *------------------------------------------*/
+		struct party_data *p;
+		struct map_session_data *s_pl[MAX_PARTY];
+		unsigned int s_rate = 0, t_rate = 0;
+		int sc = 1, tc = 1;
+		int s_Elo;
+
+		// Source
+		if( ssd->status.party_id && (p = party_search(ssd->status.party_id)) != NULL )
+		{
+			for( i = sc = 0; i < MAX_PARTY; i++ )
+			{
+				if( (s_pl[sc] = p->data[i].sd) == NULL || s_pl[sc]->bl.m != m )
+					continue;
+				if( pc_isdead(s_pl[sc]) && s_pl[sc] != ssd )
+					continue;
+				
+				s_rate += s_pl[sc]->status.pk.score;
+				sc++;
+			}
+			if( sc < 1 ) return;
+		}
+		else
+		{
+			s_pl[0] = ssd;
+			s_rate = s_pl[0]->status.pk.score;
+		}
+
+		s_rate /= sc; // Average Source Rate
+
+		// Target
+		if( tsd->status.party_id && (p = party_search(tsd->status.party_id)) != NULL )
+		{
+			for( i = tc = 0; i < MAX_PARTY; i++ )
+			{
+				if( p->data[i].sd == NULL || p->data[i].sd->bl.m != m )
+					continue;
+				if( pc_isdead(p->data[i].sd) && p->data[i].sd != tsd )
+					continue;
+				t_rate += p->data[i].sd->status.pk.score;
+				tc++;
+			}
+			if( tc < 1 ) return;
+		}
+		else
+			t_rate = tsd->status.pk.score;
+
+		t_rate /= sc; // Average Target Rate
+		Elo = (int)(50. / (1 + pow(10., (int)(s_rate - t_rate) / 1000.)));
+		s_Elo = Elo / sc;
+
+		for( i = 0; i < sc; i++ )
+			pc_addfame(s_pl[i], s_Elo, 1);
+
+		add2limit(ssd->status.pk.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.pk.death_count, 1, USHRT_MAX);
+	}
+
+	if( ssd->state.battleinfo )
+	{
+		sprintf(output,"( You Kill the %s [%s] using <%s> )", job_name(tsd->status.class_), tsd->status.name, ( skill_id ? skill_get_desc(skill_id) : "Melee/Reflect/Effect" ));
+		clif_disp_onlyself(ssd,output,strlen(output));
+	}
+	if( tsd->state.battleinfo )
+	{
+		sprintf(output,"( The %s [%s] kill you using <%s> )", job_name(ssd->status.class_), ssd->status.name, ( skill_id ? skill_get_desc(skill_id) : "Melee/Reflect/Effect" ));
+		clif_disp_onlyself(tsd,output,strlen(output));
+	}
+}
+
 /*==========================================
  * Invoked when a player has negative current hp
  *------------------------------------------*/
-int pc_dead(struct map_session_data *sd,struct block_list *src)
+int pc_dead(struct map_session_data *sd,struct block_list *src,uint16 skill_id)
 {
 	int i=0,j=0,k=0,l=0;
 	unsigned int tick = gettick();
+	short flag = 0;
+ 
+	struct map_session_data *ssd;
+	int drop_skull_rate = sd->status.base_level; // Declaracion para sistema de porcentaje de drop trofeo [Tab]
 
 	for(k = 0; k < 5; k++)
 		if(sd->devotion[k]) {
@@ -6403,13 +7834,14 @@
 				status_change_end(&devsd->bl, SC_DEVOTION, INVALID_TIMER);
 			sd->devotion[k] = 0;
 		}
-
-	if(sd->status.pet_id > 0 && sd->pd) {
-		struct pet_data *pd = sd->pd;
-		if(!map[sd->bl.m].flag.noexppenalty) {
-			pet_set_intimate(pd, pd->pet.intimate - pd->petDB->die);
-			if(pd->pet.intimate < 0)
-				pd->pet.intimate = 0;
+
+	if(sd->status.pet_id > 0 && sd->pd) {
+		struct pet_data *pd = sd->pd;
+		if( !map[sd->bl.m].flag.noexppenalty && !flag )
+		{
+			pet_set_intimate(pd, pd->pet.intimate - pd->petDB->die);
+			if( pd->pet.intimate < 0 )
+				pd->pet.intimate = 0;
 			clif_send_petdata(sd,sd->pd,1,pd->pet.intimate);
 		}
 		if(sd->pd->target_id)   // Unlock all targets...
@@ -6432,19 +7864,27 @@
 		if(sd->duel_group > 0)
 			duel_leave(sd->duel_group, sd);
 		if(sd->duel_invite > 0)
-			duel_reject(sd->duel_invite, sd);
-	}
-
-	pc_setglobalreg(sd,"PC_DIE_COUNTER",sd->die_counter+1);
-	pc_setparam(sd, SP_KILLERRID, src?src->id:0);
-
-	if(sd->bg_id) {
-		struct battleground_data *bg;
-		if((bg = bg_team_search(sd->bg_id)) != NULL && bg->die_event[0])
-			npc_event(sd, bg->die_event, 0);
-	}
-
-	// Clear anything NPC-related when you die and was interacting with one.
+			duel_reject(sd->duel_invite, sd);
+	}
+
+	if( map[sd->bl.m].flag.diecounter )
+	{
+		if( --map[sd->bl.m].pjmuertos < 1 )
+		{
+			clif_broadcast(&sd->bl, "Ganan las fuerzas invasoras", strlen("Ganan las fuerzas invasoras") + 1, 0, ALL_SAMEMAP);
+			map[sd->bl.m].flag.diecounter = 0;
+		}
+	}
+
+	if( map[sd->bl.m].flag.residentevil )
+	{
+		int zombiernd[4] = { 1297, 1041, 1015, 1036 };
+		char tmp_name[NAME_LENGTH];
+		snprintf(tmp_name, NAME_LENGTH, "Zombie %s", sd->status.name);
+		mob_once_spawn_especial(sd, "this", sd->bl.x, sd->bl.y, tmp_name, zombiernd[rand()%4], 1, "", 0, 0, 0, false, 1, 0, false, false, !(map[sd->bl.m].flag.residentevil == 2), 0, 0, 0, false, 0, 0);
+	}
+
+	// Clear anything NPC-related when you die and was interacting with one.
 	if(sd->npc_id) {
 		if(sd->state.using_fake_npc) {
 			clif_clearunit_single(sd->npc_id, CLR_OUTSIGHT, sd->fd);
@@ -6468,10 +7908,8 @@
 		}
 	}
 #endif
-
-	npc_script_event(sd,NPCE_DIE);
-
-	/* e.g. not killed thru pc_damage */
+
+	/* e.g. not killed thru pc_damage */
 	if(pc_issit(sd)) {
 		clif_status_load(&sd->bl,SI_SIT,0);
 	}
@@ -6498,37 +7936,66 @@
 					if(md->target_id==sd->bl.id)
 						mob_unlocktarget(md,tick);
 					if(battle_config.mobs_level_up && md->status.hp &&
-					   (unsigned int)md->level < pc_maxbaselv(sd) &&
+					   (unsigned int)md->level < pc_maxbaselv(sd) && !md->option.is_event &&
 					   !md->guardian_data && !md->special_state.ai// Guardians/summons should not level. [Skotlex]
 					  ) {     // monster level up [Valaris]
 						clif_misceffect(&md->bl,0);
 						md->level++;
 						status_calc_mob(md, 0);
 						status_percent_heal(src,10,0);
+					}
 
-						if(battle_config.show_mob_info&4) {
-							// update name with new level
-							clif_charnameack(0, &md->bl);
-						}
-					}
+					if( md->option.is_event )
+						flag = 1;
+						
 					src = battle_get_master(src); // Maybe Player Summon
 				}
 				break;
 			case BL_PET: //Pass on to master...
-				src = &((TBL_PET *)src)->msd->bl;
-				break;
 			case BL_HOM:
-				src = &((TBL_HOM *)src)->master->bl;
-				break;
 			case BL_MER:
-				src = &((TBL_MER *)src)->master->bl;
-				break;
+			case BL_SKILL:
+				src = battle_get_master(src);
 		}
 
-	if(src && src->type == BL_PC) {
-		struct map_session_data *ssd = (struct map_session_data *)src;
+	ssd = BL_CAST(BL_PC,src);
+	pc_setglobalreg(sd,"PC_DIE_COUNTER",sd->die_counter+1);
+	pc_setparam(sd, SP_KILLERRID, src?src->id:0);
+	npc_script_event(sd,NPCE_DIE);
+
+	if( sd->bg_id ) {
+		struct battleground_data *bg;
+		if( map[sd->bl.m].flag.battleground && (bg = bg_team_search(sd->bg_id)) != NULL && bg->die_event[0] )
+		{
+			pc_setreg(sd,add_str("@killer_bg_id"),bg_team_get_id(src)); // Killer's Team
+			pc_setreg(sd,add_str("@killer_bg_src"),ssd && ssd->bg_id ? ssd->bl.id : 0);
+
+			npc_event(sd, bg->die_event, 0);
+			if( ssd && ssd->bg_id != sd->bg_id && !strcmpi(map[sd->bl.m].name,"bat_b03") )
+			{ // Team DeathMatch
+				add2limit(sd->status.bgstats.td_deaths, 1, USHRT_MAX);
+				achievement_validate_bg(sd,ATB_TDM_DEATHS,1);
+				if( ssd->bg_id && (bg = bg_team_search(ssd->bg_id)) != NULL )
+				{
+					add2limit(ssd->status.bgstats.td_kills, 1, USHRT_MAX);
+					achievement_validate_bg(ssd,ATB_TDM_KILLS,1);
+
+					ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == ssd);
+					if( i < MAX_BG_MEMBERS )
+						pc_addfame(ssd,1,(bg->members[i].ranked ? 2 : 3));
+				}
+			}
+		}
+	}
+
+	if( ssd )
+	{
+		pc_calc_ranking(sd, ssd, skill_id); // Ranking System
 		pc_setparam(ssd, SP_KILLEDRID, sd->bl.id);
 		npc_script_event(ssd, NPCE_KILLPC);
+		
+		if( ssd->status.guild_id && guild_wardamage(sd) )
+			flag = 2;
 
 		if(battle_config.pk_mode&2) {
 			ssd->status.manner -= 5;
@@ -6568,11 +8035,24 @@
 		item_tmp.card[0]=CARD0_CREATE;
 		item_tmp.card[1]=0;
 		item_tmp.card[2]=GetWord(sd->status.char_id,0); // CharId
-		item_tmp.card[3]=GetWord(sd->status.char_id,1);
-		map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-	}
-
-	// activate Steel body if a super novice dies at 99+% exp [celest]
+		item_tmp.card[3]=GetWord(sd->status.char_id,1);
+		map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+	}
+
+	// Graveyard System
+	if( battle_config.pc_graveyard && src && (src->type == BL_PC || src->type == BL_MOB) && !map_flag_vs(src->m) )
+	{
+		struct npc_data* nd;
+		if( sd->graveyard_npc_id && (nd = map_id2nd(sd->graveyard_npc_id)) != NULL )
+			npc_unload(nd,true);
+		sd->graveyard_npc_id = 0;
+		npc_duplicate4graveyard(&sd->bl,src);
+	}
+
+	// PVPMode OFF
+	if( sd->state.pvpmode ) pc_pvpmodeoff(sd, 1, 1);
+
+	// activate Steel body if a super novice dies at 99+% exp [celest]
 	if((sd->class_&MAPID_UPPERMASK) == MAPID_SUPER_NOVICE && !sd->state.snovice_dead_flag) {
 		unsigned int next = pc_nextbaseexp(sd);
 		if(next == 0) next = pc_thisbaseexp(sd);
@@ -6593,7 +8073,8 @@
 	// changed penalty options, added death by player if pk_mode [Valaris]
 	if(battle_config.death_penalty_type
 	   && (sd->class_&MAPID_UPPERMASK) != MAPID_NOVICE // only novices will receive no penalty
-	   && !map[sd->bl.m].flag.noexppenalty && !map_flag_gvg(sd->bl.m)
+	   && !map[sd->bl.m].flag.noexppenalty && !map_flag_gvg3(sd->bl.m)
+	   && flag != 1 // No Exp penalty if killed by noexp mob.
 	   && !sd->sc.data[SC_BABY] && !sd->sc.data[SC_LIFEINSURANCE]) {
 		unsigned int base_penalty =0;
 		if(bra_config.enable_system_vip && pc_isvip(sd)) {
@@ -6692,8 +8173,7 @@
 	if(map[sd->bl.m].flag.pvp && !battle_config.pk_mode && !map[sd->bl.m].flag.pvp_nocalcrank) {
 		sd->pvp_point -= 5;
 		sd->pvp_lost++;
-		if(src && src->type == BL_PC) {
-			struct map_session_data *ssd = (struct map_session_data *)src;
+		if( ssd ) {
 			ssd->pvp_point++;
 			ssd->pvp_won++;
 		}
@@ -6703,7 +8183,7 @@
 		}
 	}
 	//GvG
-	if(map_flag_gvg(sd->bl.m)) {
+	if( map_flag_gvg(sd->bl.m) || map_pvpevent(sd->bl.m) ) {
 		add_timer(tick+1000, pc_respawn_timer, sd->bl.id, 0);
 		return 1|8;
 	} else if(sd->bg_id) {
@@ -6712,12 +8192,13 @@
 			// Respawn by BG
 			add_timer(tick+1000, pc_respawn_timer, sd->bl.id, 0);
 			return 1|8;
-		}
-	}
-
-
-	//Reset "can log out" tick.
-	if(battle_config.prevent_logout)
+		}
+	}
+
+	sd->canescape_tick = gettick() - 10000;
+
+	//Reset "can log out" tick.
+	if( battle_config.prevent_logout )
 		sd->canlog_tick = gettick() - battle_config.prevent_logout;
 	return 1;
 }
@@ -7083,21 +8564,31 @@
 		if(bonus!=100)
 			hp = hp * bonus / 100;
 
-		// Recovery Potion
-		if(sd->sc.data[SC_INCHEALRATE])
-			hp += (int)(hp * sd->sc.data[SC_INCHEALRATE]->val1/100.);
-	}
-	if(sp) {
-		bonus = 100 + (sd->battle_status.int_<<1)
+		// Recovery Potion
+		if( sd->sc.data[SC_INCHEALRATE] )
+			hp += (int)(hp * sd->sc.data[SC_INCHEALRATE]->val1/100.);
+
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.hp_heal_potions, 1, UINT_MAX);
+		else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
+	}
+	if(sp) {
+		bonus = 100 + (sd->battle_status.int_<<1)
 		        + pc_checkskill(sd,MG_SRECOVERY)*10
 		        + pc_checkskill(sd,AM_LEARNINGPOTION)*5;
 		if(potion_flag > 1)
-			bonus += bonus*(potion_flag-1)*50/100;
-		if(bonus != 100)
-			sp = sp * bonus / 100;
-	}
-	if(sd->sc.count) {
-		if(sd->sc.data[SC_CRITICALWOUND]) {
+			bonus += bonus*(potion_flag-1)*50/100;
+		if(bonus != 100)
+			sp = sp * bonus / 100;
+
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.sp_heal_potions, 1, UINT_MAX);
+		else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
+	}
+	if( sd->sc.count ) {
+		if ( sd->sc.data[SC_CRITICALWOUND] ) {
 			hp -= hp * sd->sc.data[SC_CRITICALWOUND]->val2 / 100;
 			sp -= sp * sd->sc.data[SC_CRITICALWOUND]->val2 / 100;
 		}
@@ -7669,13 +9160,13 @@
 
 /*==========================================
  * Check if player can drop an item
- *------------------------------------------*/
-int pc_candrop(struct map_session_data *sd, struct item *item)
-{
-	if(item && item->expire_time)
-		return 0;
-	if(!pc_can_give_items(sd))   //check if this GM level can drop items
-		return 0;
+ *------------------------------------------*/
+int pc_candrop(struct map_session_data *sd, struct item *item)
+{
+	if( item && (item->expire_time || item->bound) )
+		return 0;
+	if( !pc_can_give_items(sd) ) //check if this GM level can drop items
+		return 0;
 	return (itemdb_isdropable(item, pc_get_group_level(sd)));
 }
 
@@ -7860,24 +9351,33 @@
 				if(i)
 					status_calc_pc(sd,0); // Lost the bonus.
 			} else if(!strcmp(reg,"COOK_MASTERY") && sd->cook_mastery != val) {
-				val = cap_value(val, 0, 1999);
-				sd->cook_mastery = val;
-			}
-			sd_reg = sd->save_reg.global;
-			max = &sd->save_reg.global_num;
-			regmax = GLOBAL_REG_NUM;
+			val = cap_value(val, 0, 1999);
+			sd->cook_mastery = val;
+		}
+		else if( !strcmp(reg,"Bat_Team") && sd->bg_team != val )
+		{
+			val = cap_value(val, 0, 2);
+			sd->bg_team = val;
+		}
+
+		sd_reg = sd->save_reg.global;
+		max = &sd->save_reg.global_num;
+		regmax = GLOBAL_REG_NUM;
 			break;
 		case 2: //Account reg
 			if(!strcmp(reg,"#CASHPOINTS") && sd->cashPoints != val) {
 				val = cap_value(val, 0, MAX_ZENY);
 				sd->cashPoints = val;
 			} else if(!strcmp(reg,"#KAFRAPOINTS") && sd->kafraPoints != val) {
-				val = cap_value(val, 0, MAX_ZENY);
-				sd->kafraPoints = val;
-			}
-			sd_reg = sd->save_reg.account;
-			max = &sd->save_reg.account_num;
-			regmax = ACCOUNT_REG_NUM;
+			val = cap_value(val, 0, MAX_ZENY);
+			sd->kafraPoints = val;
+		}
+		else if( !strcmp(reg,"#Premium_Tick") && sd->Premium_Tick != val )
+			sd->Premium_Tick = val; // Premium Account System
+
+		sd_reg = sd->save_reg.account;
+		max = &sd->save_reg.account_num;
+		regmax = ACCOUNT_REG_NUM;
 			break;
 		case 1: //Account2 reg
 			sd_reg = sd->save_reg.account2;
@@ -8342,12 +9842,13 @@
 		clif_arrowequip(sd,n);
 		clif_arrow_fail(sd,3);
 	} else
-		clif_equipitemack(sd,n,pos,1);
-
-	sd->status.inventory[n].equip=pos;
-
-	if(pos & EQP_HAND_R) {
-		if(id)
+		clif_equipitemack(sd,n,pos,1);
+
+	sd->status.inventory[n].equip=pos;
+	achievement_validate_item(sd,AT_ITEM_EQUIP,sd->status.inventory[n].nameid,1);
+
+	if(pos & EQP_HAND_R) {
+		if(id)
 			sd->weapontype1 = id->look;
 		else
 			sd->weapontype1 = 0;
@@ -8368,52 +9869,34 @@
 		pc_calcweapontype(sd);
 		clif_changelook(&sd->bl,LOOK_SHIELD,sd->status.shield);
 	}
-	//Added check to prevent sending the same look on multiple slots ->
-	//causes client to redraw item on top of itself. (suggested by Lupus)
-	if(pos & EQP_HEAD_LOW && pc_checkequip(sd,EQP_COSTUME_HEAD_LOW) == -1) {
-		if(id && !(pos&(EQP_HEAD_TOP|EQP_HEAD_MID)))
-			sd->status.head_bottom = id->look;
-		else
-			sd->status.head_bottom = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
-	}
-	if(pos & EQP_HEAD_TOP && pc_checkequip(sd,EQP_COSTUME_HEAD_TOP) == -1) {
-		if(id)
-			sd->status.head_top = id->look;
-		else
-			sd->status.head_top = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_TOP,sd->status.head_top);
-	}
-	if(pos & EQP_HEAD_MID && pc_checkequip(sd,EQP_COSTUME_HEAD_MID) == -1) {
-		if(id && !(pos&EQP_HEAD_TOP))
-			sd->status.head_mid = id->look;
-		else
-			sd->status.head_mid = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
-	}
-	if(pos & EQP_COSTUME_HEAD_TOP) {
-		if(id) {
-			sd->status.head_top = id->look;
-		} else
-			sd->status.head_top = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_TOP,sd->status.head_top);
-	}
-	if(pos & EQP_COSTUME_HEAD_MID) {
-		if(id && !(pos&EQP_HEAD_TOP)) {
-			sd->status.head_mid = id->look;
-		} else
-			sd->status.head_mid = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
-	}
-	if(pos & EQP_COSTUME_HEAD_LOW) {
-		if(id && !(pos&(EQP_HEAD_TOP|EQP_HEAD_MID))) {
-			sd->status.head_bottom = id->look;
-		} else
-			sd->status.head_bottom = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
-	}
-	if(pos & EQP_SHOES)
-		clif_changelook(&sd->bl,LOOK_SHOES,0);
+	//Added check to prevent sending the same look on multiple slots ->
+	//causes client to redraw item on top of itself. (suggested by Lupus)
+	if(pos&(EQP_HEAD_LOW|EQP_COS_HEAD_LOW)) {
+		if(id && !(pos&(EQP_HEAD_TOP|EQP_HEAD_MID|EQP_COS_HEAD_MID|EQP_COS_HEAD_TOP)))
+			sd->status.head_bottom = id->look;
+		else
+			sd->status.head_bottom = 0;
+		if((pos&EQP_HEAD_LOW && (pc_checkequip(sd,EQP_COS_HEAD_LOW)) < 0) || pos&EQP_COS_HEAD_LOW)
+			clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
+	}
+	if(pos&(EQP_HEAD_TOP|EQP_COS_HEAD_TOP)) {
+		if(id)
+			sd->status.head_top = id->look;
+		else
+			sd->status.head_top = 0;
+		if((pos&EQP_HEAD_TOP && (pc_checkequip(sd,EQP_COS_HEAD_TOP)) < 0) || pos&EQP_COS_HEAD_TOP)
+			clif_changelook(&sd->bl,LOOK_HEAD_TOP,sd->status.head_top);
+	}
+	if(pos&(EQP_HEAD_MID|EQP_COS_HEAD_MID)) {
+		if(id && !(pos&(EQP_HEAD_TOP|EQP_COS_HEAD_TOP)))
+			sd->status.head_mid = id->look;
+		else
+			sd->status.head_mid = 0;
+		if((pos&EQP_HEAD_MID && (pc_checkequip(sd,EQP_COS_HEAD_MID)) < 0) || pos&EQP_COS_HEAD_MID)
+			clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
+	}
+	if(pos & EQP_SHOES)
+		clif_changelook(&sd->bl,LOOK_SHOES,0);
 	if(pos&EQP_GARMENT) {
 		sd->status.robe = id ? id->look : 0;
 		clif_changelook(&sd->bl, LOOK_ROBE, sd->status.robe);
@@ -8528,34 +10011,30 @@
 		pc_calcweapontype(sd);
 		clif_changelook(&sd->bl,LOOK_SHIELD,sd->status.shield);
 	}
-	if(sd->status.inventory[n].equip & EQP_HEAD_LOW && pc_checkequip(sd,EQP_COSTUME_HEAD_LOW) == -1) {
-		sd->status.head_bottom = 0;
+	if(sd->status.inventory[n].equip & EQP_HEAD_LOW) {
+		sd->status.head_bottom = ( pc_checkequip(sd,EQP_COS_HEAD_LOW) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_COS_HEAD_LOW)]->look : 0;
 		clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
 	}
-	if(sd->status.inventory[n].equip & EQP_HEAD_TOP && pc_checkequip(sd,EQP_COSTUME_HEAD_TOP) == -1) {
-		sd->status.head_top = 0;
+	if(sd->status.inventory[n].equip & EQP_COS_HEAD_LOW) {
+		sd->status.head_bottom = ( pc_checkequip(sd,EQP_HEAD_LOW) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_LOW)]->look : 0;
+		clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
+	}
+	if(sd->status.inventory[n].equip & EQP_HEAD_TOP) {
+		sd->status.head_top = ( pc_checkequip(sd,EQP_COS_HEAD_TOP) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_COS_HEAD_TOP)]->look : 0;
 		clif_changelook(&sd->bl,LOOK_HEAD_TOP,sd->status.head_top);
 	}
-	if(sd->status.inventory[n].equip & EQP_HEAD_MID && pc_checkequip(sd,EQP_COSTUME_HEAD_MID) == -1) {
-		sd->status.head_mid = 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
-	}
-
-	if(sd->status.inventory[n].equip & EQP_COSTUME_HEAD_TOP) {
-		sd->status.head_top = (pc_checkequip(sd,EQP_HEAD_TOP) >= 0) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_TOP)]->look : 0;
+	if(sd->status.inventory[n].equip & EQP_COS_HEAD_TOP) {
+		sd->status.head_top = ( pc_checkequip(sd,EQP_HEAD_TOP) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_TOP)]->look : 0;
 		clif_changelook(&sd->bl,LOOK_HEAD_TOP,sd->status.head_top);
 	}
-
-	if(sd->status.inventory[n].equip & EQP_COSTUME_HEAD_MID) {
-		sd->status.head_mid = (pc_checkequip(sd,EQP_HEAD_MID) >= 0) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_MID)]->look : 0;
+	if(sd->status.inventory[n].equip & EQP_HEAD_MID) {
+		sd->status.head_mid = ( pc_checkequip(sd,EQP_COS_HEAD_MID) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_COS_HEAD_MID)]->look : 0;
 		clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
 	}
-
-	if(sd->status.inventory[n].equip & EQP_COSTUME_HEAD_LOW) {
-		sd->status.head_bottom = (pc_checkequip(sd,EQP_HEAD_LOW) >= 0) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_LOW)]->look : 0;
-		clif_changelook(&sd->bl,LOOK_HEAD_BOTTOM,sd->status.head_bottom);
+	if(sd->status.inventory[n].equip & EQP_COS_HEAD_MID) {
+		sd->status.head_mid = ( pc_checkequip(sd,EQP_HEAD_MID) >= 0 ) ? sd->inventory_data[pc_checkequip(sd,EQP_HEAD_MID)]->look : 0;
+		clif_changelook(&sd->bl,LOOK_HEAD_MID,sd->status.head_mid);
 	}
-
 	if(sd->status.inventory[n].equip & EQP_SHOES)
 		clif_changelook(&sd->bl,LOOK_SHOES,0);
 	if(sd->status.inventory[n].equip&EQP_GARMENT && pc_checkequip(sd,EQP_COSTUME_GARMENT) == -1) {
@@ -9052,13 +10531,109 @@
 	status_change_end(&sd->bl, SC_TENSIONRELAX, INVALID_TIMER);
 	clif_status_load(&sd->bl,SI_SIT,0);
 	//Reset sitting tick.
-	sd->ssregen.tick.hp = sd->ssregen.tick.sp = 0;
-	sd->state.dead_sit = sd->vd.dead_sit = 0;
-}
-
-/**
- * Mechanic (MADO GEAR)
- **/
+	sd->ssregen.tick.hp = sd->ssregen.tick.sp = 0;
+	sd->state.dead_sit = sd->vd.dead_sit = 0;
+}
+/*==========================================
+ * Aura
+ *------------------------------------------*/
+int pc_get_aura(struct map_session_data *sd)
+{
+	int i;
+	// Battleground Ranking
+	if( map_flag_vs(sd->bl.m) )
+		return 0;
+
+	if( sd->state.pvpmode )
+		return 15;
+	if( sd->user_aura != 0 )
+		return sd->user_aura; // Priority Custom Aura
+
+	ARR_FIND(0, MAX_FAME_LIST, i, bgrank_fame_list[i].id == sd->status.char_id);
+	if( i < MAX_FAME_LIST )
+		return 5;
+	ARR_FIND(0, MAX_FAME_LIST, i, bg_fame_list[i].id == sd->status.char_id);
+	if( i < MAX_FAME_LIST )
+		return 4;
+	ARR_FIND(0, MAX_FAME_LIST, i, pvprank_fame_list[i].id == sd->status.char_id);
+	if( i < MAX_FAME_LIST )
+		return 2;
+
+	return 0;
+}
+
+void pc_pvpmode(struct map_session_data* sd)
+{
+	if( sd->state.pvpmode || map_flag_nopvpmode(sd->bl.m) )
+		return; // Mapas de No PK
+
+	if( sd->duel_group > 0 )
+		return; // No PK en Duelo
+
+	if( sd->disguise )
+		return; // No PK si esta Disguise
+
+	if( sd->status.guild_id && guild_isatwar(sd->status.guild_id) )
+		return; // No PK on GuildWars
+	
+	if( !map[sd->bl.m].flag.nopvpmode && sd->idlepvp >= last_tick - battle_config.pvpmode_enable_delay )
+	{
+		char pkinfo[100];
+		unsigned int tick = (unsigned int)(sd->idlepvp - last_tick + battle_config.pvpmode_enable_delay);
+		sprintf(pkinfo, "[PK disable - wait %d seconds to enter again in PK Mode.]", tick);
+		clif_disp_onlyself(sd ,(const char*)pkinfo,(int)strlen((const char*)pkinfo));
+
+		return;
+	}
+
+	sd->state.pvpmode = 1;
+	sd->view_aura = pc_get_aura(sd);
+	sd->idlepvp = last_tick; // Inicio de Modo PK
+
+	clif_clearunit_area(&sd->bl,0);
+	clif_refresh(sd);
+	map_foreachinrange(clif_insight_tbl2bl,&sd->bl,AREA_SIZE,BL_PC,&sd->bl);
+	clif_map_property(sd, MAPPROPERTY_FREEPVPZONE);
+
+	clif_displaymessage(sd->fd, "[Entering PK Mode - You can kill/be killed by others in PK Mode]");
+	return;
+}
+
+void pc_pvpmodeoff(struct map_session_data* sd, short force, short flag)
+{
+	char pkinfo[100];
+
+	if( !sd || !sd->state.pvpmode )
+		return;
+
+	if( !force && sd->idlepvp >= last_tick - battle_config.pvpmode_disable_delay )
+	{
+		unsigned int tick = (unsigned int)(sd->idlepvp - last_tick + battle_config.pvpmode_disable_delay);
+		sprintf(pkinfo, "[PK Enabled - %d seconds to disable it]", tick);
+		clif_disp_onlyself(sd,pkinfo,(int)strlen(pkinfo));
+		return;
+	}
+
+	sd->state.pvpmode = 0;
+	sd->view_aura = pc_get_aura(sd);
+
+	if( flag )
+	{ // Manual Change - else it's a off from change map
+		clif_clearunit_area(&sd->bl,0);
+		clif_refresh(sd);
+		map_foreachinrange(clif_insight_tbl2bl,&sd->bl,AREA_SIZE,BL_PC,&sd->bl);
+	}
+
+	sprintf(pkinfo, "[PK Mode Disabled]");
+	clif_disp_onlyself(sd,pkinfo,(int)strlen(pkinfo));
+	sd->idlepvp = last_tick; // PK Last Action
+
+	return;
+}
+
+/**
+ * Mechanic (MADO GEAR)
+ **/
 void pc_overheat(struct map_session_data *sd, int val)
 {
 	int heat = val, skill,
@@ -9080,24 +10655,12 @@
 		sc_start(&sd->bl,&sd->bl,SC_OVERHEAT_LIMITPOINT,100,heat,30000);
 
 	return;
-}
-
-/**
- * Check if player is autolooting given itemID.
- */
-bool pc_isautolooting(struct map_session_data *sd, int nameid)
-{
-	int i;
-	if(!sd->state.autolooting)
-		return false;
-	ARR_FIND(0, AUTOLOOTITEM_SIZE, i, sd->state.autolootid[i] == nameid);
-	return (i != AUTOLOOTITEM_SIZE);
-}
-
-/**
- * Checks if player can use @/#command
- * @param sd Player map session data
- * @param command Command name without @/# and params
+}
+
+/**
+ * Checks if player can use @/#command
+ * @param sd Player map session data
+ * @param command Command name without @/# and params
  * @param type is it atcommand or charcommand
  */
 bool pc_can_use_command(struct map_session_data *sd, const char *command, AtCommandType type)
@@ -9548,11 +11111,11 @@
 	}
 	fclose(fp);
 	ShowStatus("Leitura de '"CL_WHITE"%s"CL_RESET"' completa.\n","attr_fix"DBPATH"");
-
-	// reset then read statspoint
-	memset(statp,0,sizeof(statp));
-	i=1;
-
+
+    // reset then read statspoint
+	memset(stats_point_table,0,sizeof(stats_point_table));
+	i=1;
+
 	if(SQL_ERROR == Sql_Query(dbmysql_handle, "SELECT * FROM `%s`", get_database_name(53)))
 		Sql_ShowDebug(dbmysql_handle);
 
@@ -9566,21 +11129,21 @@
 		if(i > MAX_LEVEL)
 			break;
 
-		statp[i] = stat;
+		stats_point_table[i]=stat;
 		i++;
 	}
 	ShowSQL("Leitura de '"CL_WHITE"%lu"CL_RESET"' entradas na tabela '"CL_WHITE"%s"CL_RESET"'.\n", (i > 1 ? i-1 : 0), get_database_name(53));
 	Sql_FreeResult(dbmysql_handle);
 
-	// generate the remaining parts of the db if necessary
-	k = battle_config.use_statpoint_table; //save setting
-	battle_config.use_statpoint_table = 0; //temporarily disable to force pc_gets_status_point use default values
-	statp[0] = 45; // seed value
-	for(; i <= MAX_LEVEL; i++)
-		statp[i] = statp[i-1] + pc_gets_status_point(i-1);
-	battle_config.use_statpoint_table = k; //restore setting
-
-	return 0;
+	// generate the remaining parts of the db if necessary
+	k = battle_config.use_statpoint_table; //save setting
+	battle_config.use_statpoint_table = 0; //temporarily disable to force pc_gets_status_point use default values
+	stats_point_table[0] = 45; // seed value
+	for (; i <= MAX_LEVEL; i++)
+		stats_point_table[i] = stats_point_table[i-1] + pc_gets_status_point(i-1);
+	battle_config.use_statpoint_table = k; //restore setting
+
+	return 0;
 }
 
 // Read MOTD on startup. [Valaris]
@@ -9687,12 +11250,14 @@
 
 	itemcd_db = idb_alloc(DB_OPT_RELEASE_DATA);
 
-	pc_readdb();
-	pc_read_motd(); // Read MOTD [Valaris]
-
-	add_timer_func_list(pc_invincible_timer, "pc_invincible_timer");
-	add_timer_func_list(pc_eventtimer, "pc_eventtimer");
-	add_timer_func_list(pc_inventory_rental_end, "pc_inventory_rental_end");
+	pc_readdb();
+	pc_read_motd(); // Read MOTD [Valaris]
+
+	memset(pvpevent_fame_list, 0, sizeof(pvpevent_fame_list));
+
+	add_timer_func_list(pc_invincible_timer, "pc_invincible_timer");
+	add_timer_func_list(pc_eventtimer, "pc_eventtimer");
+	add_timer_func_list(pc_inventory_rental_end, "pc_inventory_rental_end");
 	add_timer_func_list(pc_calc_pvprank_timer, "pc_calc_pvprank_timer");
 	add_timer_func_list(pc_autosave, "pc_autosave");
 	add_timer_func_list(pc_spiritball_timer, "pc_spiritball_timer");
Index: src/map/pc.h
===================================================================
--- src/map/pc.h	(revision 1953)
+++ src/map/pc.h	(working copy)
@@ -19,12 +19,14 @@
 
 #include "../common/mmo.h" // JOB_*, MAX_FAME_LIST, struct fame_list, struct mmo_charstatus
 #include "../common/timer.h" // INVALID_TIMER
-#include "atcommand.h" // AtCommandType
-#include "battle.h" // battle_config
-#include "buyingstore.h"  // struct s_buyingstore
-#include "itemdb.h" // MAX_ITEMGROUP
-#include "map.h" // RC_MAX
-#include "script.h" // struct script_reg, struct script_regstr
+#include "atcommand.h" // AtCommandType
+#include "battle.h" // battle_config
+#include "buyingstore.h"  // struct s_buyingstore
+#include "channel.h" // channel_data
+#include "battleground.h" // battleground_queue
+#include "itemdb.h" // MAX_ITEMGROUP
+#include "map.h" // RC_MAX
+#include "script.h" // struct script_reg, struct script_regstr
 #include "searchstore.h"  // struct s_search_store_info
 #include "status.h" // OPTION_*, struct weapon_atk
 #include "unit.h" // unit_stop_attack(), unit_stop_walking()
@@ -33,12 +35,13 @@
 #include "log.h"
 #include "pc_groups.h"
 
-#define MAX_PC_BONUS 10
-#define MAX_PC_SKILL_REQUIRE 5
-#define MAX_PC_FEELHATE 3
-
-struct weapon_data {
-	int atkmods[3];
+#define MAX_PC_BONUS 10
+#define MAX_PC_SKILL_REQUIRE 5
+#define MAX_PC_FEELHATE 3
+#define MAX_AUTOLOOTID 20
+
+struct weapon_data {
+	int atkmods[3];
 	// all the variables except atkmods get zero'ed in each call of status_calc_pc
 	// NOTE: if you want to add a non-zeroed variable, you need to update the memset call
 	//  in status_calc_pc as well! All the following are automatically zero'ed. [Skotlex]
@@ -97,12 +100,17 @@
 	unsigned int duration;
 	char *bonus_script, *other_script;
 	int active;
-	unsigned short pos;
-};
-
-struct map_session_data {
-	struct block_list bl;
-	struct unit_data ud;
+	unsigned short pos;
+};
+
+struct skill_cooldown_entry {
+	unsigned short skill_id;
+	int timer;
+};
+
+struct map_session_data {
+	struct block_list bl;
+	struct unit_data ud;
 	struct view_data vd;
 	struct status_data base_status, battle_status;
 	struct status_change sc;
@@ -116,22 +124,24 @@
 		unsigned int dead_sit : 2;
 		unsigned int lr_flag : 3;//1: left h. weapon; 2: arrow; 3: shield
 		unsigned int connect_new : 1;
-		unsigned int arrow_atk : 1;
-		unsigned int gangsterparadise : 1;
-		unsigned int rest : 1;
-		unsigned int storage_flag : 2; //0: closed, 1: Normal Storage open, 2: guild storage open [Skotlex]
-		unsigned int snovice_dead_flag : 1; //Explosion spirits on death: 0 off, 1 used.
-		unsigned int abra_flag : 2; // Abracadabra bugfix by Aru
-		unsigned int autocast : 1; // Autospell flag [Inkfish]
-		unsigned int autotrade : 1; //By Fantik
-		unsigned int reg_dirty : 4; //By Skotlex (marks whether registry variables have been saved or not yet)
-		unsigned int showdelay :1;
-		unsigned int showexp :1;
-		unsigned int showzeny :1;
-		unsigned int mainchat :1; //[LuzZza]
-		unsigned int noask :1; // [LuzZza]
-		unsigned int trading :1; //[Skotlex] is 1 only after a trade has started.
-		unsigned int deal_locked :2; //1: Clicked on OK. 2: Clicked on TRADE
+		unsigned int arrow_atk : 1;
+		unsigned int gangsterparadise : 1;
+		unsigned int rest : 1;
+		unsigned int storage_flag : 3; //0: closed, 1: Normal Storage open, 2: guild storage open [Skotlex] 3: Rent Storage [ZephStorage]
+		unsigned int snovice_dead_flag : 1; //Explosion spirits on death: 0 off, 1 used.
+		unsigned int abra_flag : 2; // Abracadabra bugfix by Aru
+		unsigned int autocast : 1; // Autospell flag [Inkfish]
+		unsigned int autotrade : 1;	//By Fantik
+		unsigned int reg_dirty : 4; //By Skotlex (marks whether registry variables have been saved or not yet)
+		unsigned int showdelay :1;
+		unsigned int showcast :1; // [Zephyrus] Display casting time to user
+		unsigned int showcastdelay :1; // [Zephyrus] Display casting delay time to user
+		unsigned int showexp :1;
+		unsigned int showgain :1;
+		unsigned int showzeny :1;
+		unsigned int noask :1; // [LuzZza]
+		unsigned int trading :1; //[Skotlex] is 1 only after a trade has started.
+		unsigned int deal_locked :2; //1: Clicked on OK. 2: Clicked on TRADE
 		unsigned int monster_ignore :1; // for monsters to ignore a character [Valaris] [zzo]
 		unsigned int size :2; // for tiny/large types
 		unsigned int night :1; //Holds whether or not the player currently has the SI_NIGHT effect on. [Skotlex]
@@ -143,23 +153,30 @@
 		unsigned int doridori : 1;
 		unsigned int ignoreAll : 1;
 		unsigned int debug_remove_map : 1; // temporary state to track double remove_map's [FlavioJS]
-		unsigned int buyingstore : 1;
-		unsigned int lesseffect : 1;
-		unsigned int vending : 1;
-		unsigned int noks : 3; // [Zeph Kill Steal Protection]
-		unsigned int changemap : 1;
-		unsigned int callshop : 1; // flag to indicate that a script used callshop; on a shop
-		short pmap; // Previous map on Map Change
-		unsigned short autoloot;
-		unsigned short autolootid[AUTOLOOTITEM_SIZE]; // [Zephyrus]
-		unsigned int autolooting : 1; //performance-saver, autolooting state for @alootid
-		unsigned short autobonus; //flag to indicate if an autobonus is activated. [Inkfish]
-		struct guild *gmaster_flag;
-		unsigned int prevend : 1;//used to flag wheather you've spent 40sp to open the vending or not.
-		unsigned int warping : 1;//states whether you're in the middle of a warp processing
-	} state;
-	struct {
-		unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
+		unsigned int buyingstore : 1;
+		unsigned int lesseffect : 1;
+		unsigned int vending : 1;
+		short packet_filter; // [Zephyrus] Packet Filter
+		unsigned int battleinfo : 1;
+		unsigned short displaydrop;
+		unsigned int pvpmode : 1; // PK Mode [Zephyrus]
+		unsigned int noks : 3; // [Zeph Kill Steal Protection]
+		unsigned int secure_items : 1; // [Zephyrus] Item Security
+		bool changemap, changeregion;
+		unsigned int callshop : 1; // flag to indicate that a script used callshop; on a shop
+		short pmap; // Previous map on Map Change
+		unsigned short autobonus; //flag to indicate if an autobonus is activated. [Inkfish]
+		struct guild *gmaster_flag;
+		unsigned int prevend : 1;//used to flag wheather you've spent 40sp to open the vending or not.
+		unsigned int warping : 1;//states whether you're in the middle of a warp processing
+		unsigned int only_walk : 1; // [Zephyrus] Block Skills and Item usage to a player
+		unsigned int view_mob_info : 1;
+		unsigned int evade_antiwpefilter : 1; // Required sometimes to show the user previous to use the skill
+		unsigned int bg_afk : 1; // Moved here to reduce searchs
+		unsigned int bg_listen : 1;
+	} state;
+	struct {
+		unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
 		unsigned int restart_full_recover : 1;
 		unsigned int no_castcancel : 1;
 		unsigned int no_castcancel2 : 1;
@@ -170,8 +187,13 @@
 		unsigned int no_knockback : 1;
 		unsigned int bonus_coma : 1;
 		unsigned int double_attack : 1; // [ brAthena ]
-	} special_state;
-	int login_id1, login_id2;
+	} special_state;
+	struct {
+		unsigned short rate;
+		int nameid[MAX_AUTOLOOTID];
+	} aloot;
+
+	int login_id1, login_id2;
 	unsigned short class_;  //This is the internal job ID used by the map server to simplify comparisons/queries/etc. [Skotlex]
 	int group_id, group_pos, group_level;
 	unsigned int permissions;/* group permissions */
@@ -181,7 +203,7 @@
 	struct registry save_reg;
 
 	struct item_data *inventory_data[MAX_INVENTORY]; // direct pointers to itemdb entries (faster than doing item_id lookups)
-	short equip_index[15];
+	short equip_index[14];
 	unsigned int weight,max_weight;
 	int cart_weight,cart_num,cart_weight_max;
 	int fd;
@@ -194,12 +216,15 @@
 	int npc_amount;
 	struct script_state *st;
 	char npc_str[CHATBOX_SIZE]; // for passing npc input box text to script engine
-	int npc_timer_id; //For player attached npc timers. [Skotlex]
-	unsigned int chatID;
-	time_t idletime;
-
-	struct {
-		int npc_id;
+	int npc_timer_id; //For player attached npc timers. [Skotlex]
+	unsigned int chatID;
+	time_t idletime;
+	unsigned int keyboard_action_tick;
+	unsigned int mouse_action_tick;
+	time_t idlepvp; // [Zephyrus] Ultimo Tick de daño PVP
+
+	struct{
+		int npc_id;
 		unsigned int timeout;
 	} progressbar; //Progress Bar [Inkfish]
 
@@ -213,32 +238,39 @@
 	time_t emotionlasttime; // to limit flood with emotion packets
 
 	short skillitem,skillitemlv;
-	uint16 skill_id_old,skill_lv_old;
-	uint16 skill_id_dance,skill_lv_dance;
-	short cook_mastery; // range: [0,1999] [Inkfish]
-	unsigned char blockskill[MAX_SKILL];
-	int cloneskill_id, reproduceskill_id;
-	int menuskill_id, menuskill_val, menuskill_val2;
+	uint16 skill_id_old,skill_lv_old;
+	uint16 skill_id_dance,skill_lv_dance;
+	short cook_mastery; // range: [0,1999] [Inkfish]
+	struct skill_cooldown_entry *scd[MAX_SKILLCOOLDOWN]; // Skill Cooldown
+	int cloneskill_id, reproduceskill_id;
+	int menuskill_id, menuskill_val, menuskill_val2;
+
+	int invincible_timer;
+	unsigned int canlog_tick;
+	unsigned int canescape_tick;
+	unsigned int canuseitem_tick;	// [Skotlex]
+	unsigned int canusecashfood_tick;
+	unsigned int canequip_tick;	// [Inkfish]
+	unsigned int cantalk_tick;
+	unsigned int canskill_tick; // used to prevent abuse from no-delay ACT files
+	unsigned int channel_cantalk_tick; // [Channel Flood Protection]
+	unsigned int canjoinchn_tick;
+	unsigned int cansendmail_tick; // [Mail System Flood Protection]
+	unsigned int ks_floodprotect_tick; // [Kill Steal Protection]
+    unsigned int bloodylust_tick; // bloodylust player timer [out/in re full-heal protection]
 
-	int invincible_timer;
-	unsigned int canlog_tick;
-	unsigned int canuseitem_tick;   // [Skotlex]
-	unsigned int canusecashfood_tick;
-	unsigned int canequip_tick; // [Inkfish]
-	unsigned int cantalk_tick;
-	unsigned int canskill_tick; // used to prevent abuse from no-delay ACT files
-	unsigned int cansendmail_tick; // [Mail System Flood Protection]
-	unsigned int ks_floodprotect_tick; // [Kill Steal Protection]
-	unsigned int bloodylust_tick; // bloodylust player timer [out/in re full-heal protection]
-
 	struct {
 		short nameid;
-		unsigned int tick;
-	} item_delay[MAX_ITEMDELAYS]; // [Paradox924X]
-
-	short weapontype1,weapontype2;
-	short disguise; // [Valaris]
-
+		unsigned int tick;
+	} item_delay[MAX_ITEMDELAYS]; // [Paradox924X]
+
+	// [Flood Protection - Automute]
+	unsigned int last_talk_message;
+	short message_count;
+
+	short weapontype1,weapontype2;
+	short disguise; // [Valaris]
+
 	struct weapon_data right_weapon, left_weapon;
 
 	// here start arrays to be globally zeroed at the beginning of status_calc_pc()
@@ -387,23 +419,28 @@
 
 	int vended_id;
 	int vender_id;
-	int vend_num;
-	char message[MESSAGE_SIZE];
-	struct s_vending vending[MAX_VENDING];
+	int vend_num;
+	char message[MESSAGE_SIZE];
+	struct s_vending vending[MAX_VENDING];
+	int vend_coin;
+
+	unsigned int buyer_id;  // uid of open buying store
+	struct s_buyingstore buyingstore;
 
-	unsigned int buyer_id;  // uid of open buying store
-	struct s_buyingstore buyingstore;
-
 	struct s_search_store_info searchstore;
 
 	struct pet_data *pd;
 	struct homun_data *hd;  // [blackhole89]
-	struct mercenary_data *md;
-	struct elemental_data *ed;
-
-	struct {
-		int  m; //-1 - none, other: map index corresponding to map name.
-		unsigned short index; //map index
+	struct mercenary_data *md;
+	struct elemental_data *ed;
+
+	int channels;
+	struct channel_data *cd[MAX_USER_CHANNELS];
+	int channel_invite_timer;
+
+	struct{
+		int  m; //-1 - none, other: map index corresponding to map name.
+		unsigned short index; //map index
 	} feel_map[3]; // 0 - Sun; 1 - Moon; 2 - Stars
 	short hate_mob[3];
 
@@ -415,23 +452,44 @@
 	char eventqueue[MAX_EVENTQUEUE][EVENT_NAME_LENGTH];
 	int eventtimer[MAX_EVENTTIMER];
 	unsigned short eventcount; // [celest]
-
-	unsigned char change_level_2nd; // job level when changing from 1st to 2nd class [jobchange_level in global_reg_value]
-	unsigned char change_level_3rd; // job level when changing from 2nd to 3rd class [jobchange_level_3rd in global_reg_value]
-
-	char fakename[NAME_LENGTH]; // fake names [Valaris]
-
-	int duel_group; // duel vars [LuzZza]
+
+	unsigned char change_level_2nd; // job level when changing from 1st to 2nd class [jobchange_level in global_reg_value]
+	unsigned char change_level_3rd; // job level when changing from 2nd to 3rd class [jobchange_level_3rd in global_reg_value]
+	unsigned gm_power : 1; // Flag para comando maspower [Tab]
+	int gm_stats[6];
+
+	struct {
+		int MVPKiller;
+		time_t session_start;
+		unsigned int session_base_exp, session_job_exp;
+	} custom_data;
+
+	unsigned int pvpevent_fame;
+
+	char fakename[NAME_LENGTH]; // fake names [Valaris]
+
+	int duel_group; // duel vars [LuzZza]
 	int duel_invite;
-
-	int killerrid, killedrid;
-
-	int cashPoints, kafraPoints;
-	int rental_timer;
-
-	// Auction System [Zephyrus]
-	struct {
-		int index, amount;
+
+	int killerrid, killedrid;
+
+	char away_message[128]; // [LuzZza]
+
+	int cashPoints, kafraPoints;
+	int Premium_Tick; // Premium Account System
+
+	int rental_timer;
+
+	// Hunting Missions [Zephyrus]
+	int hunting_time;
+	struct {
+		int mob_id;
+		short count;
+	} hunting[5];
+
+	// Auction System [Zephyrus]
+	struct {
+		int index, amount;
 	} auction;
 
 	// Mail System [Zephyrus]
@@ -451,15 +509,35 @@
 
 	// temporary debug [flaviojs]
 	const char *debug_file;
-	int debug_line;
-	const char *debug_func;
-
-	unsigned int bg_id;
-	unsigned short user_font;
-
-	/**
-	 * For the Secure NPC Timeout option (check config/Secure.h) [RR]
-	 **/
+	int debug_line;
+	const char* debug_func;
+
+	// Achievement System
+	struct s_achievement achievement[ACHIEVEMENT_MAX];
+	int achievement_count;
+	int achievement_cutin_timer;
+	bool save_achievement;
+
+	// Graveyard System
+	int graveyard_npc_id;
+
+	// Battleground and Queue System
+	unsigned int bg_id;
+	struct battleground_data *bmaster_flag;
+	unsigned short bg_kills; 
+	struct queue_data *qd;
+	unsigned short bg_team;
+
+	unsigned short user_font;
+	short view_aura, user_aura;
+
+	// Language System
+	int lang_id;
+	unsigned int lang_mastery;
+
+	/**
+	 * For the Secure NPC Timeout option (check config/Secure.h) [RR]
+	 **/
 #if SECURE_NPCTIMEOUT
 	/**
 	 * ID of the timer
@@ -492,15 +570,12 @@
 	// temporary debugging of bug #3504
 	const char *delunit_prevfile;
 	int delunit_prevline;
-
-};
-
-//Update this max as necessary. 55 is the value needed for Super Baby currently
-//Raised to 84 since Expanded Super Novice needs it.
-#define MAX_SKILL_TREE 84
-//Total number of classes (for data storage)
-#define CLASS_COUNT (JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)
-
+
+};
+
+//Total number of classes (for data storage)
+#define CLASS_COUNT (JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)
+
 enum weapon_type {
     W_FIST, //Bare hands
     W_DAGGER,   //1
@@ -560,9 +635,9 @@
 	EQP_GARMENT          = 0x0004, //4
 	EQP_ACC_L            = 0x0008, //8
 	EQP_ACC_R            = 0x0080, //128
-	EQP_COSTUME_HEAD_TOP = 0x0400, //1024
-	EQP_COSTUME_HEAD_MID = 0x0800, //2048
-	EQP_COSTUME_HEAD_LOW = 0x1000, //4096
+	EQP_COS_HEAD_TOP = 0x0400, //1024
+	EQP_COS_HEAD_MID = 0x0800, //2048
+	EQP_COS_HEAD_LOW = 0x1000, //4096
 	EQP_COSTUME_GARMENT	 = 0x2000, //8192
 	EQP_AMMO             = 0x8000, //32768
 	//EQP_COSTUME_FLOOR  = 0x4000,
@@ -577,9 +652,9 @@
 #define EQP_WEAPON EQP_HAND_R
 #define EQP_SHIELD EQP_HAND_L
 #define EQP_ARMS (EQP_HAND_R|EQP_HAND_L)
-#define EQP_HELM (EQP_HEAD_LOW|EQP_HEAD_MID|EQP_HEAD_TOP)
+#define EQP_HELM (EQP_HEAD_LOW|EQP_HEAD_MID|EQP_HEAD_TOP|EQP_COS_HEAD_TOP|EQP_COS_HEAD_MID|EQP_COS_HEAD_LOW)
 #define EQP_ACC (EQP_ACC_L|EQP_ACC_R)
-#define EQP_COSTUME (EQP_COSTUME_HEAD_TOP|EQP_COSTUME_HEAD_MID|EQP_COSTUME_HEAD_LOW|EQP_COSTUME_GARMENT)
+#define EQP_COSTUME (EQP_COS_HEAD_TOP|EQP_COS_HEAD_MID|EQP_COS_HEAD_LOW|EQP_COSTUME_GARMENT)
 //#define EQP_SHADOW_GEAR (EQP_SHADOW_ARMOR|EQP_SHADOW_WEAPON|EQP_SHADOW_SHIELD|EQP_SHADOW_SHOES|EQP_SHADOW_ACC_R|EQP_SHADOW_ACC_L)
 
 /// Equip positions that use a visible sprite
@@ -602,14 +677,17 @@
     EQI_ARMOR,
     EQI_HAND_L,
     EQI_HAND_R,
-    EQI_COSTUME_TOP,
-    EQI_COSTUME_MID,
-    EQI_COSTUME_LOW,
+	EQI_MAX_BONUS = 10,
+	EQI_COS_HEAD_TOP,
+	EQI_COS_MID_TOP,
+	EQI_COS_LOW_TOP,
     EQI_COSTUME_GARMENT,
     EQI_AMMO,
     EQI_MAX
 };
 
+extern int global_size;
+
 #define pc_setdead(sd)        ( (sd)->state.dead_sit = (sd)->vd.dead_sit = 1 )
 #define pc_setsit(sd)         ( (sd)->state.dead_sit = (sd)->vd.dead_sit = 2 )
 #define pc_isdead(sd)         ( (sd)->state.dead_sit == 1 )
@@ -665,12 +743,17 @@
 	  ||  ( (class_) >= JOB_BABY_RUNE      && (class_) <= JOB_BABY_MECHANIC2 ) \
 	  ||  ( (class_) >= JOB_SUPER_NOVICE_E && (class_) <= JOB_SUPER_BABY_E   ) \
 	  ||  ( (class_) >= JOB_KAGEROU        && (class_) <  JOB_MAX            ) \
-	)
-#define pcdb_checkid(class_) pcdb_checkid_sub((unsigned int)class_)
-
-// clientside display macros (values to the left/right of the "+")
-#ifdef RENEWAL
-#define pc_leftside_atk(sd) ((sd)->battle_status.batk)
+)
+#define pcdb_checkid(class_) pcdb_checkid_sub((unsigned int)class_)
+
+//Ancient WoE Check
+#define pc_class2ancientwoe(class_) ( (class_ >= JOB_NOVICE && class_ <= JOB_SUPER_NOVICE && class_ != JOB_WEDDING) )
+//#define pc_class2ancientwoe(class_) ( (class_ >= JOB_NOVICE && class_ <= JOB_SUPER_NOVICE && class_ != JOB_WEDDING) || (class_ >= JOB_BABY && class_ <= JOB_SUPER_BABY) )
+// Note : Switch to allow Baby Class to enter Ancient WoE.
+
+// clientside display macros (values to the left/right of the "+")
+#ifdef RENEWAL
+	#define pc_leftside_atk(sd) ((sd)->battle_status.batk)
 #define pc_rightside_atk(sd) ((sd)->battle_status.rhw.atk + (sd)->battle_status.lhw.atk + (sd)->battle_status.rhw.atk2 + (sd)->battle_status.lhw.atk2)
 #define pc_leftside_def(sd) ((sd)->battle_status.def2)
 #define pc_rightside_def(sd) ((sd)->battle_status.def)
@@ -701,12 +784,13 @@
 
 int pc_class2idx(int class_);
 int pc_get_group_level(struct map_session_data *sd);
-int pc_get_group_id(struct map_session_data *sd);
-int pc_getrefinebonus(int lv,int type);
-bool pc_can_give_items(struct map_session_data *sd);
-
-bool pc_can_use_command(struct map_session_data *sd, const char *command, AtCommandType type);
-#define pc_has_permission(sd, permission) ( ((sd)->permissions&permission) != 0 )
+int pc_get_group_id(struct map_session_data *sd);
+int pc_getrefinebonus(int lv,int type);
+bool pc_can_give_items(struct map_session_data *sd);
+bool pc_isPremium(struct map_session_data *sd);
+
+bool pc_can_use_command(struct map_session_data *sd, const char *command, AtCommandType type);
+#define pc_has_permission(sd, permission) ( ((sd)->permissions&permission) != 0 )
 bool pc_should_log_commands(struct map_session_data *sd);
 
 int pc_setrestartvalue(struct map_session_data *sd,int type);
@@ -715,12 +799,13 @@
 int pc_setnewpc(struct map_session_data *,int,int,int,unsigned int,int,int);
 bool pc_authok(struct map_session_data *sd, int login_id2, time_t expiration_time, int group_id, struct mmo_charstatus *st, bool changing_mapservers);
 void pc_authfail(struct map_session_data *);
-int pc_reg_received(struct map_session_data *sd);
-
-int pc_isequip(struct map_session_data *sd,int n);
-int pc_equippoint(struct map_session_data *sd,int n);
-int pc_setinventorydata(struct map_session_data *sd);
-
+int pc_reg_received(struct map_session_data *sd);
+
+int pc_isequip(struct map_session_data *sd,int n);
+int pc_isequip2(struct map_session_data *sd, int nameid);
+int pc_equippoint(struct map_session_data *sd,int n);
+int pc_setinventorydata(struct map_session_data *sd);
+
 int pc_checkskill(struct map_session_data *sd,uint16 skill_id);
 int pc_checkallowskill(struct map_session_data *sd);
 int pc_checkequip(struct map_session_data *sd,int pos);
@@ -814,13 +899,13 @@
 
 int pc_skillatk_bonus(struct map_session_data *sd, uint16 skill_id);
 int pc_skillheal_bonus(struct map_session_data *sd, uint16 skill_id);
-int pc_skillheal2_bonus(struct map_session_data *sd, uint16 skill_id);
-
-void pc_damage(struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp);
-int pc_dead(struct map_session_data *sd,struct block_list *src);
-void pc_revive(struct map_session_data *sd,unsigned int hp, unsigned int sp);
-void pc_heal(struct map_session_data *sd,unsigned int hp,unsigned int sp, int type);
-int pc_itemheal(struct map_session_data *sd,int itemid, int hp,int sp);
+int pc_skillheal2_bonus(struct map_session_data *sd, uint16 skill_id);
+
+void pc_damage(struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp);
+int pc_dead(struct map_session_data *sd,struct block_list *src,uint16 skill_id);
+void pc_revive(struct map_session_data *sd,unsigned int hp, unsigned int sp);
+void pc_heal(struct map_session_data *sd,unsigned int hp,unsigned int sp, int type);
+int pc_itemheal(struct map_session_data *sd,int itemid, int hp,int sp);
 int pc_percentheal(struct map_session_data *sd,int,int);
 int pc_jobchange(struct map_session_data *,int, int);
 int pc_setoption(struct map_session_data *,int);
@@ -860,12 +945,13 @@
 int pc_cleareventtimer(struct map_session_data *sd);
 int pc_addeventtimercount(struct map_session_data *sd,const char *name,int tick);
 
-int pc_calc_pvprank(struct map_session_data *sd);
-int pc_calc_pvprank_timer(int tid, unsigned int tick, int id, intptr_t data);
-
-int pc_ismarried(struct map_session_data *sd);
-int pc_marriage(struct map_session_data *sd,struct map_session_data *dstsd);
-int pc_divorce(struct map_session_data *sd);
+int pc_calc_pvprank(struct map_session_data *sd);
+int pc_calc_pvprank_timer(int tid, unsigned int tick, int id, intptr_t data);
+
+int pc_calc_skillpoint(struct map_session_data* sd);
+int pc_ismarried(struct map_session_data *sd);
+int pc_marriage(struct map_session_data *sd,struct map_session_data *dstsd);
+int pc_divorce(struct map_session_data *sd);
 struct map_session_data *pc_get_partner(struct map_session_data *sd);
 struct map_session_data *pc_get_father(struct map_session_data *sd);
 struct map_session_data *pc_get_mother(struct map_session_data *sd);
@@ -905,19 +991,25 @@
 
 void pc_setinvincibletimer(struct map_session_data *sd, int val);
 void pc_delinvincibletimer(struct map_session_data *sd);
-
-int pc_addspiritball(struct map_session_data *sd,int,int);
-int pc_delspiritball(struct map_session_data *sd,int,int);
-void pc_addfame(struct map_session_data *sd,int count);
-unsigned char pc_famerank(int char_id, int job);
-int pc_set_hate_mob(struct map_session_data *sd, int pos, struct block_list *bl);
-
-extern struct fame_list smith_fame_list[MAX_FAME_LIST];
-extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
-extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
-
-int pc_readdb(void);
-int do_init_pc(void);
+
+int pc_addspiritball(struct map_session_data *sd,int,int);
+int pc_delspiritball(struct map_session_data *sd,int,int);
+void pc_addfame(struct map_session_data *sd,int count,short flag);
+unsigned char pc_famerank(int char_id, int job);
+int pc_set_hate_mob(struct map_session_data *sd, int pos, struct block_list *bl);
+
+extern unsigned int stats_point_table[MAX_LEVEL+1];
+
+extern struct fame_list smith_fame_list[MAX_FAME_LIST];
+extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
+extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list pvprank_fame_list[MAX_FAME_LIST];
+extern struct fame_list pvpevent_fame_list[MAX_FAME_LIST];
+extern struct fame_list bgrank_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
+
+int pc_readdb(void);
+int do_init_pc(void);
 void do_final_pc(void);
 
 enum {ADDITEM_EXIST,ADDITEM_NEW,ADDITEM_OVERAMOUNT};
@@ -925,18 +1017,33 @@
 // timer for night.day
 extern int day_timer_tid;
 extern int night_timer_tid;
-int map_day_timer(int tid, unsigned int tick, int id, intptr_t data); // by [yor]
-int map_night_timer(int tid, unsigned int tick, int id, intptr_t data); // by [yor]
+int map_day_timer(int tid, unsigned int tick, int id, intptr_t data); // by [yor]
+int map_night_timer(int tid, unsigned int tick, int id, intptr_t data); // by [yor]
+
+// PVP Mode [Zephyrus]
+int pc_get_aura(struct map_session_data *sd);
+void pc_pvpmode(struct map_session_data* sd);
+void pc_pvpmodeoff(struct map_session_data* sd, short force, short flag);
+void pc_calc_playtime(struct map_session_data* sd);
+int pc_update_last_action(struct map_session_data *sd, int type);
+void pc_pvpevent_addfame(struct map_session_data *sd, bool single);
+
+// Rental System
+void pc_inventory_rentals(struct map_session_data *sd);
+int pc_inventory_rental_clear(struct map_session_data *sd);
+void pc_inventory_rental_add(struct map_session_data *sd, int seconds);
+
+// WoE Ranking Stats
+void pc_record_damage(struct block_list *src, struct block_list *dst, int damage);
+void pc_record_maxdamage(struct block_list *src, struct block_list *dst, int damage);
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md);
+void pc_ranking_reset(int type, bool char_server);
+void pc_item_remove4all(int nameid, bool char_server);
+
+int pc_read_motd(void); // [Valaris]
+int pc_disguise(struct map_session_data *sd, int class_);
+bool pc_isautolooting(struct map_session_data *sd, int nameid);
 
-// Rental System
-void pc_inventory_rentals(struct map_session_data *sd);
-int pc_inventory_rental_clear(struct map_session_data *sd);
-void pc_inventory_rental_add(struct map_session_data *sd, int seconds);
-
-int pc_read_motd(void); // [Valaris]
-int pc_disguise(struct map_session_data *sd, int class_);
-bool pc_isautolooting(struct map_session_data *sd, int nameid);
-
 void pc_overheat(struct map_session_data *sd, int val);
 
 int pc_banding(struct map_session_data *sd, uint16 skill_lv);
Index: src/map/pc_groups.c
===================================================================
--- src/map/pc_groups.c	(revision 1953)
+++ src/map/pc_groups.c	(working copy)
@@ -444,12 +444,18 @@
  */
 void do_init_pc_groups(void)
 {
-	pc_group_db = idb_alloc(DB_OPT_RELEASE_DATA);
-	pc_groupname_db = stridb_alloc(DB_OPT_DUP_KEY, 0);
-	read_config();
-}
-
-/**
+	pc_group_db = idb_alloc(DB_OPT_RELEASE_DATA);
+	pc_groupname_db = stridb_alloc(DB_OPT_DUP_KEY, 0);
+	read_config();
+
+	if( battle_config.premium_group_id && !pc_group_exists(battle_config.premium_group_id) )
+	{
+		battle_config.premium_group_id = 0;
+		ShowWarning("conf/battle/eAmod.conf premium_group_id is enabled but group dont exist, disabling...\n");
+	}
+}
+
+/**
  * Finalize PC Groups: free DBMaps and config.
  * @public
  */
Index: src/map/pc_groups.h
===================================================================
--- src/map/pc_groups.h	(revision 1953)
+++ src/map/pc_groups.h	(working copy)
@@ -63,6 +63,8 @@
 	PC_PERM_NOT_ATTACK    		= 0x2000000,   // [Holy]
 	PC_PERM_NO_CREATE_GUILD     = 0x4000000,   // [Holy]
 	PC_PERM_NOT_USE_SKILL       = 0x8000000,   // [Holy]
+	// eAmod Permissions
+	PC_PERM_CHANNEL_OPERATOR	= 0x100000,
 };
 
 static const struct {
Index: src/map/pet.c
===================================================================
--- src/map/pet.c	(revision 1953)
+++ src/map/pet.c	(working copy)
@@ -310,13 +310,13 @@
 	tmp_item.card[0] = CARD0_PET;
 	tmp_item.card[1] = GetWord(pd->pet.pet_id,0);
 	tmp_item.card[2] = GetWord(pd->pet.pet_id,1);
-	tmp_item.card[3] = pd->pet.rename_flag;
-	if((flag = pc_additem(sd,&tmp_item,1,LOG_TYPE_OTHER))) {
-		clif_additem(sd,0,0,flag);
-		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-	}
-	pd->pet.incuvate = 1;
-	unit_free(&pd->bl,CLR_OUTSIGHT);
+	tmp_item.card[3] = pd->pet.rename_flag;
+	if((flag = pc_additem(sd,&tmp_item,1,LOG_TYPE_OTHER))) {
+		clif_additem(sd,0,0,flag);
+		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+	}
+	pd->pet.incuvate = 1;
+	unit_free(&pd->bl,CLR_OUTSIGHT);
 
 	status_calc_pc(sd,0);
 	sd->status.pet_id = 0;
@@ -504,7 +504,7 @@
 	nullpo_retr(1, sd);
 
 	md = (struct mob_data *)map_id2bl(target_id);
-	if(!md || md->bl.type != BL_MOB || md->bl.prev == NULL) {
+	if(!md || md->bl.type != BL_MOB || md->bl.prev == NULL || md->option.is_event) {
 		// Invalid inputs/state, abort capture.
 		clif_pet_roulette(sd,0);
 		sd->catch_target_class = -1;
@@ -574,13 +574,13 @@
 	tmp_item.card[0] = CARD0_PET;
 	tmp_item.card[1] = GetWord(pet_id,0);
 	tmp_item.card[2] = GetWord(pet_id,1);
-	tmp_item.card[3] = 0; //New pets are not named.
-	if((ret = pc_additem(sd,&tmp_item,1,LOG_TYPE_PICKDROP_PLAYER))) {
-		clif_additem(sd,0,0,ret);
-		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-	}
-
-	return 1;
+	tmp_item.card[3] = 0; //New pets are not named.
+	if((ret = pc_additem(sd,&tmp_item,1,LOG_TYPE_PICKDROP_PLAYER))) {
+		clif_additem(sd,0,0,ret);
+		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+	}
+
+	return 1;
 }
 
 static int pet_unequipitem(struct map_session_data *sd, struct pet_data *pd);
@@ -645,13 +645,13 @@
 	if(!flag || !strlen(name)) {
 		clif_displaymessage(sd->fd, msg_txt(280)); // You cannot use this name for your pet.
 		clif_send_petstatus(sd); //Send status so client knows oet name change got rejected.
-		return 0;
-	}
-	memcpy(pd->pet.name, name, NAME_LENGTH);
-	clif_charnameack(0,&pd->bl);
-	pd->pet.rename_flag = 1;
-	clif_pet_equip_area(pd);
-	clif_send_petstatus(sd);
+		return 0;
+	}
+	memcpy(pd->pet.name, name, NAME_LENGTH);
+	clif_charnameack (NULL,&pd->bl);
+	pd->pet.rename_flag = 1;
+	clif_pet_equip_area(pd);
+	clif_send_petstatus(sd);
 	return 1;
 }
 
@@ -707,9 +707,9 @@
 	tmp_item.nameid = nameid;
 	tmp_item.identify = 1;
 	if((flag = pc_additem(sd,&tmp_item,1,LOG_TYPE_OTHER))) {
-		clif_additem(sd,0,0,flag);
-		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-	}
+		clif_additem(sd,0,0,flag);
+		map_addflooritem(&tmp_item,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+	}
 	if(battle_config.pet_equip_required) {
 		// Skotlex: halt support timers if needed
 		if(pd->state.skillbonus) {
@@ -955,12 +955,14 @@
 	target=va_arg(ap,struct block_list **);
 
 	sd_charid = fitem->first_get_charid;
-
-	if(sd_charid && sd_charid != pd->msd->status.char_id)
-		return 0;
-
-	if(unit_can_reach_bl(&pd->bl,bl, pd->db->range2, 1, NULL, NULL) &&
-	   ((*target) == NULL || //New target closer than previous one.
+
+	if(sd_charid && sd_charid != pd->msd->status.char_id)
+		return 0;
+	if( battle_config.super_woe_enable && fitem->guild_id && fitem->guild_id != pd->msd->status.guild_id )
+		return 0; // Pets cannot loot on Super WoE servers
+	
+	if(unit_can_reach_bl(&pd->bl,bl, pd->db->range2, 1, NULL, NULL) &&
+		((*target) == NULL || //New target closer than previous one.
 	    !check_distance_bl(&pd->bl, *target, distance_bl(&pd->bl, bl)))) {
 		(*target) = bl;
 		pd->target_id = bl->id;
@@ -976,13 +978,13 @@
 	struct item_drop *ditem, *ditem_prev;
 	list=(struct item_drop_list *)data;
 	ditem = list->item;
-	while(ditem) {
-		map_addflooritem(&ditem->item_data,ditem->item_data.amount,
-		                 list->m,list->x,list->y,
-		                 list->first_charid,list->second_charid,list->third_charid,0);
-		ditem_prev = ditem;
-		ditem = ditem->next;
-		ers_free(item_drop_ers, ditem_prev);
+	while (ditem) {
+		map_addflooritem(&ditem->item_data,ditem->item_data.amount,
+			list->m,list->x,list->y,
+			list->first_charid,list->second_charid,list->third_charid,0,0);
+		ditem_prev = ditem;
+		ditem = ditem->next;
+		ers_free(item_drop_ers, ditem_prev);
 	}
 	ers_free(item_drop_list_ers, list);
 	return 0;
Index: src/map/quest.c
===================================================================
--- src/map/quest.c	(revision 1953)
+++ src/map/quest.c	(working copy)
@@ -35,12 +35,13 @@
 #include "unit.h"
 #include "log.h"
 #include "clif.h"
-#include "quest.h"
-#include "intif.h"
-#include "chrif.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "quest.h"
+#include "intif.h"
+#include "chrif.h"
+#include "achievement.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <time.h>
@@ -243,12 +244,14 @@
 
 	if(status < Q_COMPLETE) {
 		clif_quest_update_status(sd, quest_id, (bool)status);
-		return 0;
-	}
-
-	if(i != (--sd->avail_quests)) {
-		struct quest tmp_quest;
-		memcpy(&tmp_quest, &sd->quest_log[i],sizeof(struct quest));
+		return 0;
+	}
+
+	achievement_validate_quest(sd,quest_id);	
+	
+	if( i != (--sd->avail_quests) ) {
+		struct quest tmp_quest;
+		memcpy(&tmp_quest, &sd->quest_log[i],sizeof(struct quest));
 		memcpy(&sd->quest_log[i], &sd->quest_log[sd->avail_quests],sizeof(struct quest));
 		memcpy(&sd->quest_log[sd->avail_quests], &tmp_quest,sizeof(struct quest));
 	}
Index: src/map/script.c
===================================================================
--- src/map/script.c	(revision 1953)
+++ src/map/script.c	(working copy)
@@ -18,12 +18,13 @@
 //#define DEBUG_DISASM
 //#define DEBUG_RUN
 //#define DEBUG_HASH
-//#define DEBUG_DUMP_STACK
-
-#include "../common/cbasetypes.h"
-#include "../common/malloc.h"
-#include "../common/md5calc.h"
-#include "../common/nullpo.h"
+//#define DEBUG_DUMP_STACK
+
+#include "../common/cbasetypes.h"
+#include "../common/socket.h"
+#include "../common/malloc.h"
+#include "../common/md5calc.h"
+#include "../common/nullpo.h"
 #include "../common/random.h"
 #include "../common/showmsg.h"
 #include "../common/socket.h"   // usage: getcharip
@@ -47,23 +48,26 @@
 #include "instance.h"
 #include "mercenary.h"
 #include "intif.h"
-#include "skill.h"
-#include "status.h"
-#include "chat.h"
-#include "battle.h"
-#include "battleground.h"
-#include "party.h"
+#include "skill.h"
+#include "status.h"
+#include "chat.h"
+#include "channel.h"
+#include "battle.h"
+#include "battleground.h"
+#include "party.h"
 #include "guild.h"
 #include "atcommand.h"
 #include "log.h"
 #include "unit.h"
 #include "pet.h"
-#include "mail.h"
-#include "script.h"
-#include "quest.h"
-#include "elemental.h"
-
-#include <stdio.h>
+#include "mail.h"
+#include "script.h"
+#include "quest.h"
+#include "achievement.h"
+#include "faction.h"
+#include "elemental.h"
+
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
@@ -182,9 +186,6 @@
 	if( script_hasdata(st,n) ) \
 		(t)=script_getnum(st,n);
 
-/// Maximum amount of elements in script arrays
-#define SCRIPT_MAX_ARRAYSIZE 128+50
-
 #define SCRIPT_BLOCK_SIZE 512
 enum { LABEL_NEXTLINE=1,LABEL_START };
 
@@ -417,8 +418,14 @@
     MF_MONSTER_NOTELEPORT,
     MF_PVP_NOCALCRANK,  //50
     MF_BATTLEGROUND,
-    MF_RESET,
-    MF_SET_CASTLE
+    MF_SET_CASTLE,
+	MF_RESET,
+	MF_NOPVPMODE = 70,
+	MF_PVPMODE,
+	MF_WOE_SET,
+	MF_BLOCKED,
+	MF_NOSTORAGE,
+	MF_NOGUILDSTORAGE
 };
 
 const char *script_op2name(int op)
@@ -5808,19 +5815,53 @@
 
 	clif_viewpoint(sd,st->oid,type,x,y,id,color);
 
-	return 0;
-}
-
-/*==========================================
- *
- *------------------------------------------*/
-BUILDIN_FUNC(countitem)
-{
-	int nameid, i;
-	int count = 0;
-	struct item_data *id = NULL;
-	struct script_data *data;
-
+	return 0;
+}
+
+int viewpointmap_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd;
+	int npc_id, type, x, y, id, color;
+	npc_id = va_arg(ap,int);
+	type = va_arg(ap,int);
+	x = va_arg(ap,int);
+	y = va_arg(ap,int);
+	id = va_arg(ap,int);
+	color = va_arg(ap,int);
+	sd = (struct map_session_data *)bl;
+	clif_viewpoint(sd,npc_id,type,x,y,id,color);
+	return 0;
+}
+
+BUILDIN_FUNC(viewpointmap)
+{
+	int type,x,y,id,color,m;
+	const char *map_name;
+
+	map_name = script_getstr(st,2);
+	if( (m = map_mapname2mapid(map_name)) < 0 )
+		return 0; // Invalid Map
+
+	type=script_getnum(st,3);
+	x=script_getnum(st,4);
+	y=script_getnum(st,5);
+	id=script_getnum(st,6);
+	color=script_getnum(st,7);
+
+	map_foreachinmap(viewpointmap_sub,m,BL_PC,st->oid,type,x,y,id,color);
+	return 0;
+}
+
+/*==========================================
+ *
+ *------------------------------------------*/
+BUILDIN_FUNC(countitem)
+{
+	int nameid, i;
+	int count = 0, char_id;
+	struct item_data* id = NULL;
+	struct script_data* data;
+
 	TBL_PC *sd = script_rid2sd(st);
 	if(!sd) {
 		script_pushint(st,0);
@@ -5844,16 +5885,31 @@
 		return 1;
 	}
 
-	nameid = id->nameid;
+	nameid = id->nameid;
+
+	for(i = 0; i < MAX_INVENTORY; i++)
+	{
+		if( sd->status.inventory[i].nameid != nameid )
+			continue;
+
+		if( sd->status.inventory[i].card[0] == CARD0_CREATE )
+		{
+			char_id = MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3]);
+			if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id && !map_bg_items(sd->bl.m) )
+				continue;
+			if( battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id && !map[sd->bl.m].flag.ancient )
+				continue;
+			if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id && !map_gvg_items(sd->bl.m) )
+				continue;
+		}
+
+		count += sd->status.inventory[i].amount;
+	}
+
+	script_pushint(st,count);
+	return 0;
+}
 
-	for(i = 0; i < MAX_INVENTORY; i++)
-		if(sd->status.inventory[i].nameid == nameid)
-			count += sd->status.inventory[i].amount;
-
-	script_pushint(st,count);
-	return 0;
-}
-
 /*==========================================
  * countitem2(nameID,Identified,Refine,Attribute,Card0,Card1,Card2,Card3)   [Lupus]
  *  returns number of items that meet the conditions
@@ -6162,11 +6218,11 @@
 		// if not pet egg
 		if(!pet_create_egg(sd, nameid)) {
 			if((flag = pc_additem(sd, &it, get_count, LOG_TYPE_SCRIPT))) {
-				clif_additem(sd, 0, 0, flag);
-				if(pc_candrop(sd,&it))
-					map_addflooritem(&it,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-			}
-		}
+				clif_additem(sd, 0, 0, flag);
+				if( pc_candrop(sd,&it) )
+					map_addflooritem(&it,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+		}
 	}
 
 	return 0;
@@ -6255,21 +6311,237 @@
 			// if not pet egg
 			if(!pet_create_egg(sd, nameid)) {
 				if((flag = pc_additem(sd, &item_tmp, get_count, LOG_TYPE_SCRIPT))) {
-					clif_additem(sd, 0, 0, flag);
-					if(pc_candrop(sd,&item_tmp))
-						map_addflooritem(&item_tmp,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-				}
-			}
+					clif_additem(sd, 0, 0, flag);
+					if( pc_candrop(sd,&item_tmp) )
+						map_addflooritem(&item_tmp,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+				}
+			}
 		}
 	}
 
 	return 0;
-}
-
-/*==========================================
- * rentitem <item id>,<seconds>
- * rentitem "<item name>",<seconds>
- *------------------------------------------*/
+}
+
+/*==========================================
+ * Items to Storage [Zephyrus]
+ *------------------------------------------*/
+BUILDIN_FUNC(checkspace)
+{
+	int nameid = 0, amount;
+	struct map_session_data *sd;
+	
+	if( (sd = script_rid2sd(st)) == NULL )
+		script_pushint(st,0);
+	else if( sd->status.storage.storage_amount > MAX_STORAGE )
+		script_pushint(st,0); // Storage at max
+	else
+	{
+		struct script_data *data = script_getdata(st,2);
+		struct item_data *id;
+		struct item it;
+		int i;
+
+		get_val(st,data);
+		if( data_isstring(data) )
+		{
+			const char *name = conv_str(st,data);
+			struct item_data *id = itemdb_searchname(name);
+			if( id )
+				nameid = id->nameid;
+		}
+		else
+			nameid = conv_num(st,data);
+
+		memset(&it,0,sizeof(it));
+		amount = script_getnum(st,3);
+		it.nameid = nameid;
+		it.identify = script_getnum(st,4);
+		it.refine = script_getnum(st,5);
+		it.attribute = script_getnum(st,6);
+		it.card[0] = (short)script_getnum(st,7);
+		it.card[1] = (short)script_getnum(st,8);
+		it.card[2] = (short)script_getnum(st,9);
+		it.card[3] = (short)script_getnum(st,10);
+
+		if( nameid < 500 || amount <= 0 || (id = itemdb_exists(nameid)) == NULL || !itemdb_canstore(&it, pc_get_group_level(sd)) || !itemdb_isstackable2(id) )
+		{
+			script_pushint(st,0);
+			return 0;
+		}
+
+		if( itemdb_isstackable2(id) )
+		{
+			ARR_FIND(0,MAX_STORAGE,i,compare_item(&sd->status.storage.items[i],&it));
+			if( i < MAX_STORAGE )
+			{ // Item on Storage
+				script_pushint(st,amount + sd->status.storage.items[i].amount > MAX_AMOUNT ? 0 : 1);
+				return 0;
+			}
+		}
+
+		ARR_FIND(0,MAX_STORAGE,i,sd->status.storage.items[i].nameid == 0);
+		if( i >= MAX_STORAGE )
+		{
+			script_pushint(st,0);
+			return 0;
+		}
+	
+		script_pushint(st,1); // Can be Stored
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(storeitem)
+{
+	int nameid = 0, amount;
+	struct item it;
+	struct map_session_data *sd;
+	struct script_data *data;
+	int result = 1;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{ // "<item name>"
+		const char *name = conv_str(st,data);
+		struct item_data *item_data = itemdb_searchname(name);
+		if( item_data == NULL )
+		{
+			ShowError("buildin_storeitem: Nonexistant item %s requested.\n", name);
+			result = 0; //No item created.
+		}
+		else
+			nameid = item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{ // <item id>
+		nameid = conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_storeitem: Nonexistant item %d requested.\n", nameid);
+			result = 0;
+		}
+	}
+	else
+	{
+		ShowError("buildin_storeitem: invalid data type for argument #1 (%d).", data->type);
+		result = 0;
+	}
+
+	if( !itemdb_isstackable(nameid) )
+		result = 0;
+	if( (amount = script_getnum(st,3)) <= 0 )
+		result = 0;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4)); // <Account ID>
+	else
+		sd = script_rid2sd(st); // Attached player
+
+	if( sd == NULL ) // no target
+		result = 0;
+
+	if( result )
+	{
+		memset(&it,0,sizeof(it));
+		it.nameid = nameid;
+		it.identify = 1;
+		result = storage_additem2(sd,&it,amount);
+
+		if( result )
+			log_pick_pc(sd, LOG_TYPE_SCRIPT, amount, &it);
+	}
+
+	script_pushint(st,result);
+	return 0;
+}
+
+BUILDIN_FUNC(storeitem2)
+{
+	int nameid = 0, amount = 0;
+	int iden = 0,ref = 0,attr = 0,c1 = 0,c2 = 0,c3 = 0,c4 = 0;
+	struct map_session_data *sd;
+	struct script_data *data;
+	struct item it;
+	int result = 1;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{
+		const char *name = conv_str(st,data);
+		struct item_data *item_data = itemdb_searchname(name);
+		if( item_data == NULL )
+		{
+			ShowError("buildin_storeitem2: Nonexistant item %s requested.\n", name);
+			result = 0;
+		}
+		else
+			nameid = item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{
+		nameid = conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_storeitem2: Nonexistant item %d requested.\n", nameid);
+			result = 0;
+		}
+	}
+	else
+	{
+		ShowError("buildin_storeitem2: invalid data type for argument #1 (%d).", data->type);
+		result = 0;
+	}
+
+	if( !itemdb_isstackable(nameid) )
+		result = 0;
+	else if( (amount = script_getnum(st,3)) <= 0 )
+		result = 0;
+	else
+	{
+		iden = script_getnum(st,4);
+		ref = script_getnum(st,5);
+		attr = script_getnum(st,6);
+		c1 = (short)script_getnum(st,7);
+		c2 = (short)script_getnum(st,8);
+		c3 = (short)script_getnum(st,9);
+		c4 = (short)script_getnum(st,10);
+	}
+
+	if( script_hasdata(st,11) )
+		sd = map_id2sd(script_getnum(st,11));
+	else
+		sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		result = 0;
+
+	if( result )
+	{
+		memset(&it,0,sizeof(it));
+		it.nameid = nameid;
+		it.identify = 1; // always Identify
+		it.refine = ref;
+		it.attribute = attr;
+		it.card[0] = (short)c1;
+		it.card[1] = (short)c2;
+		it.card[2] = (short)c3;
+		it.card[3] = (short)c4;
+		result = storage_additem2(sd,&it,amount);
+		if( result )
+			log_pick_pc(sd, LOG_TYPE_SCRIPT, amount, &it);
+	}
+
+	script_pushint(st,result);
+	return 0;
+}
+
+/*==========================================
+ * rentitem <item id>,<seconds>
+ * rentitem "<item name>",<seconds>
+ *------------------------------------------*/
 BUILDIN_FUNC(rentitem)
 {
 	struct map_session_data *sd;
@@ -6307,20 +6579,260 @@
 	memset(&it, 0, sizeof(it));
 	it.nameid = nameid;
 	it.identify = 1;
-	it.expire_time = (unsigned int)(time(NULL) + seconds);
-
+	it.expire_time = (unsigned int)(time(NULL) + seconds);
+	it.bound = 0;
+
 	if((flag = pc_additem(sd, &it, 1, LOG_TYPE_SCRIPT))) {
 		clif_additem(sd, 0, 0, flag);
 		return 1;
 	}
 
-	return 0;
-}
-
-/*==========================================
- * gets an item with someone's name inscribed [Skotlex]
- * getinscribeditem item_num, character_name
- * Returned Qty is always 1, only works on equip-able
+	return 0;
+}
+
+BUILDIN_FUNC(rentitem2)
+{
+	struct map_session_data *sd;
+	struct script_data *data;
+	struct item_data *itd;
+	struct item it;
+	int seconds;
+	int nameid = 0, iden, ref, attr, c1, c2, c3, c4, flag;
+	
+	data = script_getdata(st,2);
+	get_val(st,data);
+
+	if( (sd = script_rid2sd(st)) == NULL )
+		return 0;
+
+	if( data_isstring(data) )
+	{
+		const char *name = conv_str(st,data);
+		itd = itemdb_searchname(name);
+		if( itd == NULL )
+		{
+			ShowError("buildin_rentitem2: Nonexistant item %s requested.\n", name);
+			return 1;
+		}
+		nameid = itd->nameid;
+	}
+	else if( data_isint(data) )
+	{
+		nameid = conv_num(st,data);
+		if( nameid <= 0 || (itd = itemdb_exists(nameid)) == NULL )
+		{
+			ShowError("buildin_rentitem2: Nonexistant item %d requested.\n", nameid);
+			return 1;
+		}
+	}
+	else
+	{
+		ShowError("buildin_rentitem2: invalid data type for argument #1 (%d).\n", data->type);
+		return 1;
+	}
+
+	iden = script_getnum(st,3);
+	ref = script_getnum(st,4);
+	attr = script_getnum(st,5);
+	c1 = (short)script_getnum(st,6);
+	c2 = (short)script_getnum(st,7);
+	c3 = (short)script_getnum(st,8);
+	c4 = (short)script_getnum(st,9);
+	seconds = script_getnum(st,10);
+
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	if( itd->type == IT_WEAPON || itd->type == IT_ARMOR )
+		ref = cap_value(ref,0,MAX_REFINE);
+	else if( itd->type == IT_PETEGG )
+	{
+		ShowError("buildin_rentitem2: invalid item type. Pet Egg cannot be set as rental items.\n");
+		return 1;
+	}
+	else
+	{
+		iden = 1;
+		ref = attr = 0;
+	}
+
+	it.identify = iden;
+	it.refine=ref;
+	it.attribute=attr;
+	it.card[0]=(short)c1;
+	it.card[1]=(short)c2;
+	it.card[2]=(short)c3;
+	it.card[3]=(short)c4;
+	it.expire_time = (unsigned int)(time(NULL) + seconds);
+
+	if( (flag = pc_additem(sd, &it, 1, LOG_TYPE_SCRIPT)) )
+	{
+		clif_additem(sd, 0, 0, flag);
+		return 1;
+	}
+
+	clif_rental_time(sd->fd, nameid, seconds);
+	pc_inventory_rental_add(sd, seconds);
+	return 0;
+}
+
+/*==========================================
+ * itembound <item id>,<amount>{,<character ID>};
+ * itembound "<item name>",<amount>{,<character ID>};
+ *------------------------------------------*/
+BUILDIN_FUNC(itembound)
+{
+	int nameid,amount,i,flag;
+	struct item it;
+	TBL_PC *sd;
+	struct script_data *data;
+
+	data=script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{ // "<item name>"
+		const char *name=conv_str(st,data);
+		struct item_data *item_data = itemdb_searchname(name);
+		if( item_data == NULL ){
+			ShowError("buildin_itembound: Nonexistant item %s requested.\n", name);
+			return 1; //No item created.
+		}
+		nameid=item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{ // <item id>
+		nameid=conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_getitem: Nonexistant item %d requested.\n", nameid);
+			return 1; //No item created.
+		}
+	}
+	else
+	{
+		ShowError("buildin_itembound: invalid data type for argument #1 (%d).", data->type);
+		return 1;
+	}
+
+	if( itemdb_isstackable(nameid) || itemdb_type(nameid) == IT_PETEGG )
+	{
+		ShowError("buildin_itembound: invalid item type. Bound only work for non stackeable items (Item %d).", nameid);
+		return 1;
+	}
+
+	// <amount>
+	if( (amount=script_getnum(st,3)) <= 0)
+		return 0; //return if amount <=0, skip the useles iteration
+
+	memset(&it,0,sizeof(it));
+	it.nameid = nameid;
+	it.bound = 1;
+	it.identify = 1;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4)); // <Account ID>
+	else
+		sd = script_rid2sd(st); // Attached player
+
+	if( sd == NULL ) // no target
+		return 0;
+
+	for( i = 0; i < amount; i++ )
+	{
+		if( (flag = pc_additem(sd, &it, 1, LOG_TYPE_SCRIPT)) )
+		{
+			clif_additem(sd, 0, 0, flag);
+			if( pc_candrop(sd,&it) )
+				map_addflooritem(&it,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(itembound2)
+{
+	int nameid,amount,i,flag;
+	int iden,ref,attr,c1,c2,c3,c4;
+	struct item_data *item_data;
+	struct item item_tmp;
+	TBL_PC *sd;
+	struct script_data *data;
+
+	if( script_hasdata(st,11) )
+		sd = map_id2sd(script_getnum(st,11)); // <Account ID>
+	else
+		sd = script_rid2sd(st); // Attached player
+
+	if( sd == NULL ) // no target
+		return 0;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{
+		const char *name = conv_str(st,data);
+		struct item_data *item_data = itemdb_searchname(name);
+		if( item_data )
+			nameid = item_data->nameid;
+		else
+			nameid = UNKNOWN_ITEM_ID;
+	}
+	else
+		nameid = conv_num(st,data);
+
+	amount = script_getnum(st,3);
+	iden = script_getnum(st,4);
+	ref = script_getnum(st,5);
+	attr = script_getnum(st,6);
+	c1 = (short)script_getnum(st,7);
+	c2 = (short)script_getnum(st,8);
+	c3 = (short)script_getnum(st,9);
+	c4 = (short)script_getnum(st,10);
+	
+	if( nameid < 0 || (item_data = itemdb_exists(nameid)) == NULL || itemdb_isstackable2(item_data) )
+		return 0;
+
+	memset(&item_tmp,0,sizeof(item_tmp));
+	item_tmp.nameid = nameid;
+	if( item_data->type == IT_WEAPON || item_data->type == IT_ARMOR )
+		ref = cap_value(ref,0,MAX_REFINE);
+	else if( item_data->type == IT_PETEGG )
+	{
+		ShowError("buildin_itembound2: invalid item type. Pet Egg cannot be set as rental items.\n");
+		return 1;
+	}
+	else
+	{ // Should not happen
+		iden = 1;
+		ref = attr = 0;
+	}
+
+	item_tmp.identify = iden;
+	item_tmp.refine = ref;
+	item_tmp.attribute = attr;
+	item_tmp.card[0] = (short)c1;
+	item_tmp.card[1] = (short)c2;
+	item_tmp.card[2] = (short)c3;
+	item_tmp.card[3] = (short)c4;
+	item_tmp.bound = 1;
+
+	for( i = 0; i < amount; i++ )
+	{
+		if ((flag = pc_additem(sd, &item_tmp, 1, LOG_TYPE_SCRIPT)))
+		{
+			clif_additem(sd, 0, 0, flag);
+			if( pc_candrop(sd,&item_tmp) )
+				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * gets an item with someone's name inscribed [Skotlex]
+ * getinscribeditem item_num, character_name
+ * Returned Qty is always 1, only works on equip-able
  * equipment
  *------------------------------------------*/
 BUILDIN_FUNC(getnameditem)
@@ -6445,13 +6957,13 @@
 		item_tmp.nameid=nameid;
 		if(!flag)
 			item_tmp.identify=1;
-		else
-			item_tmp.identify=itemdb_isidentified(nameid);
-
-		map_addflooritem(&item_tmp,amount,m,x,y,0,0,0,0);
-	}
-
-	return 0;
+		else
+			item_tmp.identify=itemdb_isidentified(nameid);
+
+		map_addflooritem(&item_tmp,amount,m,x,y,0,0,0,0,0);
+	}
+
+	return 0;
 }
 
 
@@ -6560,12 +7072,22 @@
 				if(exact_match) {
 					if(inv->refine != it->refine || inv->identify != it->identify || inv->attribute != it->attribute || memcmp(inv->card, it->card, sizeof(inv->card))) {
 						// not matching attributes
-						continue;
-					}
-				}
-
-				// count / delete item
-				buildin_delitem_delete(sd, i, &amount, delete_items);
+					continue;
+				}
+			}
+			else if( inv->card[0] == CARD0_CREATE )
+			{
+				int char_id = MakeDWord(inv->card[2],inv->card[3]);
+				if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id && !map_bg_items(sd->bl.m) )
+					continue;
+				if( battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id && !map[sd->bl.m].flag.ancient )
+					continue;
+				if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id && !map_gvg_items(sd->bl.m) )
+					continue;
+			}
+
+			// count / delete item
+			buildin_delitem_delete(sd, i, &amount, delete_items);
 			}
 
 		if(amount) {
@@ -6784,12 +7306,13 @@
 	switch(num) {
 		case 0: script_pushint(st,sd->status.char_id); break;
 		case 1: script_pushint(st,sd->status.party_id); break;
-		case 2: script_pushint(st,sd->status.guild_id); break;
-		case 3: script_pushint(st,sd->status.account_id); break;
-		case 4: script_pushint(st,sd->bg_id); break;
-		default:
-			ShowError("buildin_getcharid: invalid parameter (%d).\n", num);
-			script_pushint(st,0);
+	case 2: script_pushint(st,sd->status.guild_id); break;
+	case 3: script_pushint(st,sd->status.account_id); break;
+	case 4: script_pushint(st,sd->bg_id); break;
+	case 5: script_pushint(st,sd->status.faction_id); break;
+	default:
+		ShowError("buildin_getcharid: invalid parameter (%d).\n", num);
+		script_pushint(st,0);
 			break;
 	}
 
@@ -7080,7 +7603,7 @@
 
 
 // aegis->athena slot position conversion table
-static unsigned int equip[] = {EQP_HEAD_TOP,EQP_ARMOR,EQP_HAND_L,EQP_HAND_R,EQP_GARMENT,EQP_SHOES,EQP_ACC_L,EQP_ACC_R,EQP_HEAD_MID,EQP_HEAD_LOW,EQP_COSTUME_HEAD_LOW,EQP_COSTUME_HEAD_MID,EQP_COSTUME_HEAD_TOP,EQP_COSTUME_GARMENT};
+static unsigned int equip[] = {EQP_HEAD_TOP,EQP_ARMOR,EQP_HAND_L,EQP_HAND_R,EQP_GARMENT,EQP_SHOES,EQP_ACC_L,EQP_ACC_R,EQP_HEAD_MID,EQP_HEAD_LOW,EQP_COS_HEAD_LOW,EQP_COS_HEAD_MID,EQP_COS_HEAD_TOP,EQP_COSTUME_GARMENT};
 
 /*==========================================
  * GetEquipID(Pos);     Pos: 1-13
@@ -7365,12 +7888,54 @@
 	else
 		script_pushint(st,0);
 
-	return 0;
-}
-
-/*==========================================
- * Get the item refine chance (from refine.txt) for item at pos
- * return (npc)
+	return 0;
+}
+
+BUILDIN_FUNC(getequipisrental)
+{
+	int i=-1,num;
+	TBL_PC *sd;
+
+	num=script_getnum(st,2);
+	sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+
+	if (num > 0 && num <= ARRAYLENGTH(equip))
+		i=pc_checkequip(sd,equip[num-1]);
+
+	if(i >= 0 && sd->status.inventory[i].expire_time)
+		script_pushint(st,1);
+	else
+		script_pushint(st,0);
+
+	return 0;
+}
+
+BUILDIN_FUNC(getequipisbounded)
+{
+	int i=-1,num;
+	TBL_PC *sd;
+
+	num=script_getnum(st,2);
+	sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+
+	if (num > 0 && num <= ARRAYLENGTH(equip))
+		i=pc_checkequip(sd,equip[num-1]);
+
+	if(i >= 0 && sd->status.inventory[i].bound)
+		script_pushint(st,1);
+	else
+		script_pushint(st,0);
+
+	return 0;
+}
+
+/*==========================================
+ * Get the item refine chance (from refine.txt) for item at pos
+ * return (npc)
  *  x : refine chance
  *  0 : false (max refine level or unequip..)
  *------------------------------------------*/
@@ -7394,8 +7959,122 @@
 	return 0;
 }
 
+/*==========================================
+ * Refine +1 item at pos and log and display refine
+ *------------------------------------------*/
+BUILDIN_FUNC(costume)
+{
+	int i = -1, num, ep;
+	TBL_PC *sd;
+
+	num = script_getnum(st,2); // Equip Slot
+	sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		return 0;
+	if( num > 0 && num <= ARRAYLENGTH(equip) )
+		i = pc_checkequip(sd, equip[num - 1]);
+	if( i < 0 )
+		return 0;
+
+	ep = sd->status.inventory[i].equip;
+	if( !(ep&EQP_HEAD_LOW) && !(ep&EQP_HEAD_MID) && !(ep&EQP_HEAD_TOP) )
+		return 0;
+
+	log_pick_pc(sd, LOG_TYPE_SCRIPT, -1, &sd->status.inventory[i]);
+	pc_unequipitem(sd,i,2);
+	clif_delitem(sd,i,1,3);
+	// --------------------------------------------------------------------
+	sd->status.inventory[i].refine = 0;
+	sd->status.inventory[i].card[0] = CARD0_CREATE;
+	sd->status.inventory[i].card[1] = 0;
+	sd->status.inventory[i].card[2] = GetWord(battle_config.costume_reserved_char_id, 0);
+	sd->status.inventory[i].card[3] = GetWord(battle_config.costume_reserved_char_id, 1);
+
+	if( ep&EQP_HEAD_TOP ) { ep &= ~EQP_HEAD_TOP; ep |= EQP_COS_HEAD_TOP; }
+	if( ep&EQP_HEAD_LOW ) { ep &= ~EQP_HEAD_LOW; ep |= EQP_COS_HEAD_LOW; }
+	if( ep&EQP_HEAD_MID ) { ep &= ~EQP_HEAD_MID; ep |= EQP_COS_HEAD_MID; }
+	// --------------------------------------------------------------------
+	log_pick_pc(sd, LOG_TYPE_SCRIPT, 1, &sd->status.inventory[i]);
+
+	clif_additem(sd,i,1,0);
+	pc_equipitem(sd,i,ep);
+	clif_misceffect(&sd->bl,3);
+
+	return 0;
+}
+
+/*==========================================
+ * Armor Enchanting
+ *------------------------------------------*/
+BUILDIN_FUNC(successenchant)
+{
+	int i = -1, j, num, enchant, ep;
+	char chat_announce[256];
+	TBL_PC *sd;
+
+	num = script_getnum(st,2); // Equip Slot
+	enchant = script_getnum(st,3); // Equip Enchant
+	sd = script_rid2sd(st);
+	if( sd == NULL || !itemdb_isenchant(enchant) )
+		return 0;
+	if( num > 0 && num <= ARRAYLENGTH(equip) )
+		i = pc_checkequip(sd, equip[num - 1]);
+	if( i < 0 )
+		return 0;
+	if( !sd->inventory_data[i] || sd->inventory_data[i]->slot >= MAX_SLOTS )
+		return 0; // Cannot enchant an item with 4 slots. Enchant uses last slot.
+
+	ep = sd->status.inventory[i].equip;
+	log_pick_pc(sd, LOG_TYPE_SCRIPT, -1, &sd->status.inventory[i]);
+	
+	// By Official Info: Item will lose cards, refine and previus enchants.
+	for( j = 0; j < MAX_SLOTS; j++ )
+		sd->status.inventory[i].card[j] = 0;
+	sd->status.inventory[i].refine = 0;
+	// --------------------------------------------------------------------
+
+	pc_unequipitem(sd,i,2);
+	clif_delitem(sd,i,1,3);
+	sd->status.inventory[i].card[MAX_SLOTS - 1] = enchant;
+	log_pick_pc(sd, LOG_TYPE_SCRIPT, 1, &sd->status.inventory[i]);
+
+	clif_additem(sd,i,1,0);
+	pc_equipitem(sd,i,ep);
+	clif_misceffect(&sd->bl,3);
+
+	if( battle_config.channel_announces&8 && server_channel[CHN_VENDING] )
+	{
+		sprintf(chat_announce, msg_txt(892), server_channel[CHN_VENDING]->name, sd->status.name, sd->inventory_data[i]->jname, sd->inventory_data[i]->slot, itemdb_search(enchant)->jname);
+		clif_channel_message(server_channel[CHN_VENDING], chat_announce, 26);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(failedenchant)
+{
+	int i = -1, num;
+	TBL_PC *sd;
+
+	num = script_getnum(st,2);
+	sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+	if( num > 0 && num <= ARRAYLENGTH(equip) )
+		i = pc_checkequip(sd, equip[num - 1]);
+	if( i >= 0 )
+	{
+		pc_unequipitem(sd,i,3);
+		pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
+		clif_misceffect(&sd->bl,2);
+	}
+
+	return 0;
+}
+
 /*==========================================
- * Refine +1 item at pos and log and display refine
+
  *------------------------------------------*/
 BUILDIN_FUNC(successrefitem)
 {
@@ -7404,12 +8083,14 @@
 
 	num = script_getnum(st,2);
 	sd = script_rid2sd(st);
-	if(sd == NULL)
+	if( sd == NULL )
 		return 0;
 
-	if(num > 0 && num <= ARRAYLENGTH(equip))
+	if (num > 0 && num <= ARRAYLENGTH(equip))
 		i=pc_checkequip(sd,equip[num-1]);
 	if(i >= 0) {
+		short announce_refine[] = { 7, 9, 8, 7, 5 };
+
 		ep=sd->status.inventory[i].equip;
 
 		//Logs items, got from (N)PC scripts [Lupus]
@@ -7427,21 +8108,29 @@
 		clif_additem(sd,i,1,0);
 		pc_equipitem(sd,i,ep);
 		clif_misceffect(&sd->bl,3);
+
+		if( battle_config.channel_announces&4 && server_channel[CHN_VENDING] && sd->inventory_data[i]->wlv >= 0 && sd->inventory_data[i]->wlv <= 4 && sd->status.inventory[i].refine >= announce_refine[sd->inventory_data[i]->wlv] )
+		{ // Announces Refines to Chat
+			char chat_announce[256];
+			sprintf(chat_announce, msg_txt(821), server_channel[CHN_VENDING]->name, sd->status.name, sd->status.inventory[i].refine, sd->inventory_data[i]->jname, sd->inventory_data[i]->slot);
+			clif_channel_message(server_channel[CHN_VENDING], chat_announce, 26);
+		}
+
 		if(sd->status.inventory[i].refine == MAX_REFINE &&
-		   sd->status.inventory[i].card[0] == CARD0_FORGE &&
-		   sd->status.char_id == (int)MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3])
-		  ) { // Fame point system [DracoRPG]
-			switch(sd->inventory_data[i]->wlv) {
+			sd->status.inventory[i].card[0] == CARD0_FORGE &&
+		  	sd->status.char_id == (int)MakeDWord(sd->status.inventory[i].card[2],sd->status.inventory[i].card[3])
+		){ // Fame point system [DracoRPG]
+	 		switch (sd->inventory_data[i]->wlv){
 				case 1:
-					pc_addfame(sd,1); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
+					pc_addfame(sd,1,0); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
 					break;
 				case 2:
-					pc_addfame(sd,25); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
+					pc_addfame(sd,25,0); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
 					break;
 				case 3:
-					pc_addfame(sd,1000); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
+					pc_addfame(sd,1000,0); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
 					break;
-			}
+	 	 	 }
 		}
 	}
 
@@ -7458,24 +8147,78 @@
 
 	num = script_getnum(st,2);
 	sd = script_rid2sd(st);
-	if(sd == NULL)
+	if( sd == NULL )
 		return 0;
 
-	if(num > 0 && num <= ARRAYLENGTH(equip))
+	if (num > 0 && num <= ARRAYLENGTH(equip))
 		i=pc_checkequip(sd,equip[num-1]);
 	if(i >= 0) {
+		short announce_refine[] = { 7, 9, 8, 7, 5 };
+
+		if( battle_config.channel_announces&4 && server_channel[CHN_VENDING] && sd->inventory_data[i]->wlv >= 0 && sd->inventory_data[i]->wlv <= 4 && sd->status.inventory[i].refine >= announce_refine[sd->inventory_data[i]->wlv] )
+		{ // Announces Refines to Chat
+			char chat_announce[256];
+			sprintf(chat_announce, msg_txt(822), server_channel[CHN_VENDING]->name, sd->status.name, sd->status.inventory[i].refine, sd->inventory_data[i]->jname, sd->inventory_data[i]->slot);
+			clif_channel_message(server_channel[CHN_VENDING], chat_announce, 1);
+		}
+
 		sd->status.inventory[i].refine = 0;
 		pc_unequipitem(sd,i,3); //recalculate bonus
 		clif_refine(sd->fd,1,i,sd->status.inventory[i].refine); //notify client of failure
 
 		pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
 
-		clif_misceffect(&sd->bl,2);     // display failure effect
+		clif_misceffect(&sd->bl,2); 	// display failure effect
 	}
 
 	return 0;
 }
 
+BUILDIN_FUNC(failedrefitemR) // by jakeRed
+{
+	int i=-1,num,ep,ref;
+	TBL_PC *sd;
+
+	num = script_getnum(st,2); // Equip Slot
+	ref = script_getnum(st,3); // Refine Points Lost
+	sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		return 0;
+
+	if( num > 0 && num <= ARRAYLENGTH(equip) )
+		i = pc_checkequip(sd,equip[num-1]);
+	if( i >= 0 )
+	{
+		short announce_refine[] = { 7, 9, 8, 7, 5 };
+		ep = sd->status.inventory[i].equip;
+
+		//Logs items, got from (N)PC scripts [Lupus]
+		log_pick_pc(sd, LOG_TYPE_SCRIPT, -1, &sd->status.inventory[i]);
+
+		if( battle_config.channel_announces&4 && server_channel[CHN_VENDING] && sd->inventory_data[i]->wlv >= 0 && sd->inventory_data[i]->wlv <= 4 && sd->status.inventory[i].refine >= announce_refine[sd->inventory_data[i]->wlv] )
+		{ // Announces Refines to Chat
+			char chat_announce[256];
+			sprintf(chat_announce, msg_txt(704), server_channel[CHN_VENDING]->name, sd->status.name, sd->status.inventory[i].refine, sd->inventory_data[i]->jname, sd->inventory_data[i]->slot,(sd->status.inventory[i].refine - ref));
+			clif_channel_message(server_channel[CHN_VENDING], chat_announce, 1);
+		}
+
+		ref = min(ref,sd->status.inventory[i].refine); // To avoid negative Refine
+		sd->status.inventory[i].refine = sd->status.inventory[i].refine - ref;
+
+		pc_unequipitem(sd,i,2); // status calc will happen in pc_equipitem() below
+		clif_refine(sd->fd,0,i,sd->status.inventory[i].refine);
+		clif_delitem(sd,i,1,3);
+		log_pick_pc(sd, LOG_TYPE_SCRIPT, 1, &sd->status.inventory[i]);
+
+		clif_additem(sd,i,1,0);
+		pc_equipitem(sd,i,ep);
+		clif_misceffect(&sd->bl,2);
+	}
+
+	return 0;
+}
+
 /*==========================================
  * Downgrades an Equipment Part by -1 . [Masao]
  *------------------------------------------*/
@@ -7486,10 +8229,10 @@
 
 	num = script_getnum(st,2);
 	sd = script_rid2sd(st);
-	if(sd == NULL)
+	if( sd == NULL )
 		return 0;
 
-	if(num > 0 && num <= ARRAYLENGTH(equip))
+	if (num > 0 && num <= ARRAYLENGTH(equip))
 		i = pc_checkequip(sd,equip[num-1]);
 	if(i >= 0) {
 		ep = sd->status.inventory[i].equip;
@@ -7524,7 +8267,7 @@
 
 	type=script_getnum(st,2);
 	sd = script_rid2sd(st);
-	if(sd == NULL)
+	if( sd == NULL )
 		return 0;
 
 	pc_statusup(sd,type);
@@ -8366,12 +9109,23 @@
 
 	ret = storage_guild_storageopen(sd);
 	script_pushint(st,ret);
-	return 0;
-}
-
-/*==========================================
- * Make player use a skill trought item usage
- *------------------------------------------*/
+	return 0;
+}
+
+BUILDIN_FUNC(openrentstorage) // [ZephStorage]
+{
+	TBL_PC* sd;
+
+	sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+
+	ext_storage_open(sd);
+	return 0;
+}
+/*==========================================
+ * Make player use a skill trought item usage
+ *------------------------------------------*/
 /// itemskill <skill id>,<level>
 /// itemskill "<skill name>",<level>
 BUILDIN_FUNC(itemskill)
@@ -8468,13 +9222,13 @@
 	base=script_getnum(st,2);
 	job =script_getnum(st,3);
 	if(base<0 || job<0)
-		return 0;
-
-	// bonus for npc-given exp
-	bonus = battle_config.quest_exp_rate / 100.;
-	base = (int) cap_value(base * bonus, 0, INT_MAX);
-	job = (int) cap_value(job * bonus, 0, INT_MAX);
-
+		return 0;
+
+	// bonus for npc-given exp
+	bonus = (script_hasdata(st,4) ? script_getnum(st,4) : battle_config.quest_exp_rate) / 100.;
+	base = (int) cap_value(base * bonus, 0, INT_MAX);
+	job = (int) cap_value(job * bonus, 0, INT_MAX);
+
 	pc_gainexp(sd, NULL, base, job, true);
 
 	return 0;
@@ -8587,12 +9341,131 @@
 	}
 
 	mob_once_spawn(sd, m, x, y, str, class_, amount, event, size, ai);
-	return 0;
-}
-/*==========================================
- * Request List of Monster Drops
- *------------------------------------------*/
-BUILDIN_FUNC(getmobdrops)
+	return 0;
+}
+/*==========================================
+ * Creacin de Mobs Aliados - Invocacin por Item
+ *------------------------------------------*/
+BUILDIN_FUNC(invocar)
+{
+	TBL_PC *sd;
+	struct mob_data *md;
+	int timeout, class_, k, tick = gettick();
+
+	sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+
+	class_ = script_getnum(st,2);
+	timeout = script_getnum(st,3);
+
+	if( map_flag_vs(sd->bl.m) )
+		return 0;
+
+	if( class_ >= 0 && !mobdb_checkid(class_) )
+	{
+		ShowWarning("buildin_monster: Attempted to spawn non-existing monster class %d\n", class_);
+		return 1;
+	}
+
+	k = mob_once_spawn_especial((struct map_session_data*)sd, "this", sd->bl.x, sd->bl.y, "--ja--", class_, 1, "", 0, 0, 1, false, 0, 1, false, false, true, 0, 0, 0, false, 0, 0);
+
+	if( (md = (struct mob_data *)map_id2bl(k)) )
+	{
+		md->deletetimer = add_timer(tick + (timeout > 0 ? timeout * 1000 : 60000), mob_timer_delete, md->bl.id, 0);
+		clif_misceffect(&md->bl,344);
+	}
+
+	return 0;
+}
+
+/*==========================================
+ * Cdigo Zephyrus para mob con IDdeParty para Map Dominacion
+ *------------------------------------------*/
+BUILDIN_FUNC(mobdemolition)
+{
+	short x,y,ratio;
+	const char *map;
+	int type,power,amount,m;
+
+	map    = script_getstr(st,2);
+	x      = script_getnum(st,3);
+	y      = script_getnum(st,4);
+	ratio  = script_getnum(st,5);
+	type   = script_getnum(st,6);
+	amount = script_getnum(st,7);
+	power  = script_getnum(st,8);
+
+	m = map_mapname2mapid(map);
+
+	if (m < 0)
+		return 1; // mapa no encontrado
+
+	mob_demolition(m,x,y,ratio,type,amount,power);
+
+	return 0;			
+}
+
+/*==========================================
+ * Cdigo Zephyrus para mob con IDdeParty para Map Dominacion
+ *------------------------------------------*/
+BUILDIN_FUNC(mobevent)
+{
+	int class_,size,amount,x,y,partyid,mostrarhp,hpmas,allied,noslaves,noexpnodrop,k,iswar,exp_boost,drop_boost;
+	int item_drop, item_amount;
+	const char *str,*map,*event="";
+
+	map	        = script_getstr(st,2);
+	x	        = script_getnum(st,3);
+	y	        = script_getnum(st,4);
+	str	        = script_getstr(st,5);
+	class_      = script_getnum(st,6);
+	size        = script_getnum(st,7);
+	amount      = script_getnum(st,8);
+	partyid     = script_getnum(st,9);
+	mostrarhp   = script_getnum(st,10);
+	hpmas       = script_getnum(st,11);
+	allied      = script_getnum(st,12);
+	noslaves    = script_getnum(st,13);
+	noexpnodrop = script_getnum(st,14);
+	item_drop   = script_getnum(st,15);
+	item_amount = script_getnum(st,16);
+	iswar       = script_getnum(st,17);
+	exp_boost   = script_getnum(st,18);
+	drop_boost  = script_getnum(st,19);
+
+	if( script_hasdata(st,20) )
+	{
+		event = script_getstr(st,20);
+		check_event(st, event);
+	}
+
+	if( class_ >= 0 && !mobdb_checkid(class_) )
+	{
+		ShowWarning("buildin_monster: Attempted to spawn non-existing monster class %d\n", class_);
+		return 1;
+	}
+
+	k = mob_once_spawn_especial(map_id2sd(st->rid),map,x,y,str,class_,amount,event,hpmas,size,allied,noslaves,0,mostrarhp,0,0,noexpnodrop,partyid,item_drop,item_amount,iswar,exp_boost,drop_boost);
+	script_pushint(st,1); // Confirmando creacion
+
+	return 0;
+}
+/*==========================================
+ * Get a Random mob ID
+ *------------------------------------------*/
+BUILDIN_FUNC(getmobrandid)
+{
+	int level = script_getnum(st,2);
+	int range = script_getnum(st,3);
+
+	script_pushint(st, mob_get_random_id_lv(level, range));
+	return 0;
+}
+/*==========================================
+ * Request List of Monster Drops
+ *------------------------------------------*/
+BUILDIN_FUNC(getmobdrops)
 {
 	int class_ = script_getnum(st,2);
 	int i, j = 0;
@@ -9212,14 +10085,31 @@
 			intif_broadcast2(mes, (int)strlen(mes)+1, strtol(fontColor, (char **)NULL, 0), fontType, fontSize, fontAlign, fontY);
 		else
 			intif_broadcast(mes, (int)strlen(mes)+1, flag&0xf0);
-	}
-	return 0;
-}
-/*==========================================
- *------------------------------------------*/
-static int buildin_announce_sub(struct block_list *bl, va_list ap)
-{
-	char *mes       = va_arg(ap, char *);
+	}
+	return 0;
+}
+
+/*==========================================
+ *------------------------------------------*/
+BUILDIN_FUNC(bgannounce)
+{
+	const char *mes       = script_getstr(st,2);
+	const char *fontColor = script_hasdata(st,3) ? script_getstr(st,3) : "0xFFFFFF";
+	int         fontType  = script_hasdata(st,4) ? script_getnum(st,4) : 0x190; // default fontType (FW_NORMAL)
+	int         fontSize  = script_hasdata(st,5) ? script_getnum(st,5) : 12;    // default fontSize
+	int         fontAlign = script_hasdata(st,6) ? script_getnum(st,6) : 0;     // default fontAlign
+	int         fontY     = script_hasdata(st,7) ? script_getnum(st,7) : 0;     // default fontY
+
+	clif_broadcast2(NULL, mes, (int)strlen(mes)+1, strtol(fontColor, (char **)NULL, 0), fontType, fontSize, fontAlign, fontY, BG_LISTEN);
+	return 0;
+}
+
+/*==========================================
+
+ *------------------------------------------*/
+static int buildin_announce_sub(struct block_list *bl, va_list ap)
+{
+	char *mes       = va_arg(ap, char *);
 	int   len       = va_arg(ap, int);
 	int   type      = va_arg(ap, int);
 	char *fontColor = va_arg(ap, char *);
@@ -10142,12 +11032,26 @@
 		case 0:  script_pushint(st, cd->users); break;
 		case 1:  script_pushint(st, cd->limit); break;
 		case 2:  script_pushint(st, cd->trigger&0x7f); break;
-		case 3:  script_pushint(st, ((cd->trigger&0x80)!=0)); break;
-		case 4:  script_pushstrcopy(st, cd->title); break;
-		case 5:  script_pushstrcopy(st, cd->pass); break;
-		case 16: script_pushstrcopy(st, cd->npc_event); break;
-		case 32: script_pushint(st, (cd->users >= cd->limit)); break;
-		case 33: script_pushint(st, (cd->users >= cd->trigger)); break;
+	case 3:  script_pushint(st, ((cd->trigger&0x80)!=0)); break;
+	case 4:  script_pushstrcopy(st, cd->title); break;
+	case 5:  script_pushstrcopy(st, cd->pass); break;
+	case 6: // Users and List
+		{
+			int i, j = 0;
+			struct map_session_data *sd;
+			for( i = 0; i < cd->users; i++ )
+			{
+				if( (sd = cd->usersd[i]) == NULL )
+					continue; // Should be a bug
+				mapreg_setregstr(reference_uid(add_str("$@waitingroommembers$"),j),sd->status.name);
+				j++;
+			}
+			script_pushint(st, j);
+		}
+		break;
+	case 16: script_pushstrcopy(st, cd->npc_event);break;
+	case 32: script_pushint(st, (cd->users >= cd->limit)); break;
+	case 33: script_pushint(st, (cd->users >= cd->trigger)); break;
 		default: script_pushint(st, -1); break;
 	}
 	return 0;
@@ -10365,6 +11269,11 @@
 			case MF_BATTLEGROUND:       script_pushint(st,map[m].flag.battleground); break;
 			case MF_RESET:              script_pushint(st,map[m].flag.reset); break;
 			case MF_SET_CASTLE:         script_pushint(st,map[m].set_castle); break;
+			case MF_NOPVPMODE:			script_pushint(st,map[m].flag.nopvpmode); break;
+			case MF_WOE_SET:			script_pushint(st,map[m].flag.woe_set); break;
+			case MF_BLOCKED:			script_pushint(st,map[m].flag.blocked); break;
+			case MF_NOSTORAGE:			script_pushint(st,map[m].flag.nostorage); break;
+			case MF_NOGUILDSTORAGE:		script_pushint(st,map[m].flag.noguildstorage); break;
 		}
 	}
 
@@ -10462,12 +11371,17 @@
 			case MF_AUTOTRADE:          map[m].flag.autotrade = 1; break;
 			case MF_ALLOWKS:            map[m].flag.allowks = 1; break;
 			case MF_MONSTER_NOTELEPORT: map[m].flag.monster_noteleport = 1; break;
-			case MF_PVP_NOCALCRANK:     map[m].flag.pvp_nocalcrank = 1; break;
-			case MF_BATTLEGROUND:       map[m].flag.battleground = (val <= 0 || val > 2) ? 1 : val; break;
-			case MF_RESET:              map[m].flag.reset = 1; break;
-		}
-	}
-
+			case MF_PVP_NOCALCRANK:		map[m].flag.pvp_nocalcrank = 1; break;
+			case MF_BATTLEGROUND:		map[m].flag.battleground = (val <= 0 || val > 2) ? 1 : val; break;
+			case MF_RESET:				map[m].flag.reset = 1; break;
+			case MF_NOPVPMODE:     map[m].flag.nopvpmode=1; break;
+			case MF_WOE_SET:       if( val > 0 ) map[m].flag.woe_set = val; break;
+			case MF_BLOCKED:       map[m].flag.blocked=1; break;
+			case MF_NOSTORAGE:			map[m].flag.nostorage=1; break;
+			case MF_NOGUILDSTORAGE:		map[m].flag.noguildstorage=1; break;
+		}
+	}
+
 	return 0;
 }
 
@@ -10548,12 +11462,17 @@
 			case MF_AUTOTRADE:          map[m].flag.autotrade = 0; break;
 			case MF_ALLOWKS:            map[m].flag.allowks = 0; break;
 			case MF_MONSTER_NOTELEPORT: map[m].flag.monster_noteleport = 0; break;
-			case MF_PVP_NOCALCRANK:     map[m].flag.pvp_nocalcrank = 0; break;
-			case MF_BATTLEGROUND:       map[m].flag.battleground = 0; break;
-			case MF_RESET:              map[m].flag.reset = 0; break;
-		}
-	}
-
+			case MF_PVP_NOCALCRANK:		map[m].flag.pvp_nocalcrank = 0; break;
+			case MF_BATTLEGROUND:		map[m].flag.battleground = 0; break;
+			case MF_RESET:				map[m].flag.reset = 0; break;
+			case MF_NOPVPMODE:     map[m].flag.nopvpmode=0; break;
+			case MF_WOE_SET:       map[m].flag.woe_set=0; break;
+			case MF_BLOCKED:       map[m].flag.blocked=0; break;
+			case MF_NOSTORAGE:			map[m].flag.nostorage=0; break;
+			case MF_NOGUILDSTORAGE:		map[m].flag.noguildstorage=0; break;
+		}
+	}
+
 	return 0;
 }
 
@@ -10577,12 +11496,15 @@
 
 	iter = mapit_getallusers();
 	for(sd = (TBL_PC *)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC *)mapit_next(iter)) {
-		if(sd->bl.m != m || sd->pvp_timer != INVALID_TIMER)
-			continue; // not applicable
-
-		sd->pvp_timer = add_timer(gettick()+200,pc_calc_pvprank_timer,sd->bl.id,0);
-		sd->pvp_rank = 0;
-		sd->pvp_lastusers = 0;
+		if( sd->bl.m != m || sd->pvp_timer != INVALID_TIMER )
+			continue; // not applicable
+
+		if( sd->state.pvpmode )
+			pc_pvpmodeoff(sd, 1, 1);
+
+		sd->pvp_timer = add_timer(gettick()+200,pc_calc_pvprank_timer,sd->bl.id,0);
+		sd->pvp_rank = 0;
+		sd->pvp_lastusers = 0;
 		sd->pvp_point = 5;
 		sd->pvp_won = 0;
 		sd->pvp_lost = 0;
@@ -10690,18 +11612,31 @@
 	int16 m=va_arg(ap,int);
 	int g_id=va_arg(ap,int);
 	int flag=va_arg(ap,int);
-
-	if(!sd || sd->bl.m != m)
-		return 0;
-	if(
-	    (sd->status.guild_id == g_id && flag&1) || //Warp out owners
-	    (sd->status.guild_id != g_id && flag&2) || //Warp out outsiders
-	    (sd->status.guild_id == 0)  // Warp out players not in guild [Valaris]
-	)
-		pc_setpos(sd,sd->status.save_point.map,sd->status.save_point.x,sd->status.save_point.y,CLR_TELEPORT);
-	return 1;
-}
-
+
+	if(!sd || sd->bl.m != m)
+		return 0;
+
+	while( 1 )
+	{
+		if( sd->status.guild_id == 0 )
+			break; // Warp out players not in guild
+		if( sd->status.guild_id == g_id && flag&1 )
+			break; // Warp out owners
+		if( map[m].flag.ancient && !pc_class2ancientwoe(sd->status.class_) )
+			break; // Not ancient woe users
+		if( map_blocked_woe(m) )
+			break; // Blocked map on this WoE
+		if( g_id && (flag&4) && guild_isallied(g_id, sd->status.guild_id) )
+			return 0; // Do not kick allies
+		if( sd->status.guild_id != g_id && flag&2 )
+			break; // Warp out outsiders except for allied on Super WoE
+		return 0;
+	}
+
+	pc_setpos(sd,sd->status.save_point.map,sd->status.save_point.x,sd->status.save_point.y,CLR_TELEPORT);
+	return 1;
+}
+
 static int buildin_maprespawnguildid_sub_mob(struct block_list *bl,va_list ap)
 {
 	struct mob_data *md=(struct mob_data *)bl;
@@ -10731,37 +11666,51 @@
 }
 
 BUILDIN_FUNC(agitstart)
-{
-	if(agit_flag==1) return 0;      // Agit already Start.
-	agit_flag=1;
-	guild_agit_start();
-	return 0;
-}
+{
+	if(agit_flag==1) return 0;      // Agit already Start.
+	agit_flag=1;
+	if( script_hasdata(st,2) )
+	{
+		int i = script_getnum(st,2);
+		if( i > 0 ) woe_set = i;
+	}
+
+	guild_agit_start();
+	return 0;
+}
 
-BUILDIN_FUNC(agitend)
-{
-	if(agit_flag==0) return 0;      // Agit already End.
-	agit_flag=0;
-	guild_agit_end();
-	return 0;
-}
-
+BUILDIN_FUNC(agitend)
+{
+	if(agit_flag==0) return 0;      // Agit already End.
+	guild_agit_end();
+	agit_flag = 0;
+	woe_set = 0;
+	return 0;
+}
+
 BUILDIN_FUNC(agitstart2)
-{
-	if(agit2_flag==1) return 0;      // Agit2 already Start.
-	agit2_flag=1;
-	guild_agit2_start();
-	return 0;
-}
+{
+	if(agit2_flag==1) return 0;      // Agit2 already Start.
+	agit2_flag=1;
+	if( script_hasdata(st,2) )
+	{
+		int i = script_getnum(st,2);
+		if( i > 0 ) woe_set = i;
+	}
+
+	guild_agit2_start();
+	return 0;
+}
 
-BUILDIN_FUNC(agitend2)
-{
-	if(agit2_flag==0) return 0;      // Agit2 already End.
-	agit2_flag=0;
-	guild_agit2_end();
-	return 0;
-}
-
+BUILDIN_FUNC(agitend2)
+{
+	if(agit2_flag==0) return 0;      // Agit2 already End.
+	guild_agit2_end();
+	agit2_flag=0;
+	woe_set = 0;
+	return 0;
+}
+
 /*==========================================
  * Returns whether woe is on or off.    // choice script
  *------------------------------------------*/
@@ -10785,22 +11734,30 @@
 /// flagemblem <guild_id>;
 BUILDIN_FUNC(flagemblem)
 {
-	TBL_NPC *nd;
-	int g_id = script_getnum(st,2);
-
-	if(g_id < 0) return 0;
-
-	nd = (TBL_NPC *)map_id2nd(st->oid);
-	if(nd == NULL) {
-		ShowError("script:flagemblem: npc %d not found\n", st->oid);
-	} else if(nd->subtype != SCRIPT) {
-		ShowError("script:flagemblem: unexpected subtype %d for npc %d '%s'\n", nd->subtype, st->oid, nd->exname);
-	} else {
-		bool changed = (nd->u.scr.guild_id != g_id)?true:false;
-		nd->u.scr.guild_id = g_id;
-		clif_guild_emblem_area(&nd->bl);
-		/* guild flag caching */
-		if(g_id)   /* adding a id */
+	TBL_NPC* nd;
+	int g_id = script_getnum(st,2);
+
+	if( script_hasdata(st,3) )
+		nd = npc_name2id(script_getstr(st,3));
+	else
+		nd = map_id2nd(st->oid);
+
+	if(g_id < 0) return 0;
+
+	if( nd == NULL ) {
+		ShowError("script:flagemblem: npc %d not found\n", st->oid);
+	} else if( nd->subtype != SCRIPT ) {
+		ShowError("script:flagemblem: unexpected subtype %d for npc %d '%s'\n", nd->subtype, st->oid, nd->exname);
+	} else {
+		bool changed = ( nd->u.scr.guild_id != g_id )?true:false;
+		if( !map[nd->bl.m].flag.battleground )
+			nd->u.scr.guild_id = g_id;
+		else
+			nd->u.scr.bg_id = g_id;
+
+		clif_guild_emblem_area(&nd->bl);
+		/* guild flag caching */
+		if( g_id ) /* adding a id */
 			guild_flag_add(nd);
 		else if(changed)   /* removing a flag */
 			guild_flag_remove(nd);
@@ -10933,25 +11890,24 @@
 /// Removes all cards from the item found in the specified equipment slot of the invoking character,
 /// and give them to the character. If any cards were removed in this manner, it will also show a success effect.
 /// successremovecards <slot>;
-BUILDIN_FUNC(successremovecards)
-{
+BUILDIN_FUNC(successremovecards) {
 	int i=-1,j,c,cardflag=0;
 
-	TBL_PC *sd = script_rid2sd(st);
+	TBL_PC* sd = script_rid2sd(st);
 	int num = script_getnum(st,2);
 
-	if(num > 0 && num <= ARRAYLENGTH(equip))
+	if (num > 0 && num <= ARRAYLENGTH(equip))
 		i=pc_checkequip(sd,equip[num-1]);
 
-	if(i < 0 || !sd->inventory_data[i]) {
+	if (i < 0 || !sd->inventory_data[i]) {
 		return 0;
 	}
 
 	if(itemdb_isspecial(sd->status.inventory[i].card[0]))
 		return 0;
 
-	for(c = sd->inventory_data[i]->slot - 1; c >= 0; --c) {
-		if(sd->status.inventory[i].card[c] && itemdb_type(sd->status.inventory[i].card[c]) == IT_CARD) {  // extract this card from the item
+	for( c = sd->inventory_data[i]->slot - 1; c >= 0; --c ) {
+		if( sd->status.inventory[i].card[c] && itemdb_type(sd->status.inventory[i].card[c]) == IT_CARD ) {// extract this card from the item
 			int flag;
 			struct item item_tmp;
 			memset(&item_tmp,0,sizeof(item_tmp));
@@ -10959,9 +11915,9 @@
 			item_tmp.nameid   = sd->status.inventory[i].card[c];
 			item_tmp.identify = 1;
 
-			if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))) { // get back the cart in inventory
+			if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))){	// get back the cart in inventory
 				clif_additem(sd,0,0,flag);
-				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
+				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
 			}
 		}
 	}
@@ -10976,14 +11932,16 @@
 		item_tmp.refine      = sd->status.inventory[i].refine;
 		item_tmp.attribute   = sd->status.inventory[i].attribute;
 		item_tmp.expire_time = sd->status.inventory[i].expire_time;
+		item_tmp.unique_id   = sd->status.inventory[i].unique_id;
+		item_tmp.bound       = sd->status.inventory[i].bound;
 
-		for(j = sd->inventory_data[i]->slot; j < MAX_SLOTS; j++)
+		for (j = sd->inventory_data[i]->slot; j < MAX_SLOTS; j++)
 			item_tmp.card[j]=sd->status.inventory[i].card[j];
 
 		pc_delitem(sd,i,1,0,3,LOG_TYPE_SCRIPT);
-		if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))) { // ???A??????h???b?v
+		if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))){	//chk if can be spawn in inventory otherwise put on floor
 			clif_additem(sd,0,0,flag);
-			map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
+			map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
 		}
 
 		clif_misceffect(&sd->bl,3);
@@ -10997,133 +11955,136 @@
 /// <type>=1 : will keep the item, but destroy the cards.
 /// <type>=2 : will keep the cards, but destroy the item.
 /// <type>=? : will just display the failure effect.
-BUILDIN_FUNC(failedremovecards)
-{
-	int i=-1,j,c,cardflag=0;
-
-	TBL_PC *sd = script_rid2sd(st);
-	int num = script_getnum(st,2);
-	int typefail = script_getnum(st,3);
-
-	if(num > 0 && num <= ARRAYLENGTH(equip))
-		i=pc_checkequip(sd,equip[num-1]);
-
-	if(i < 0 || !sd->inventory_data[i])
-		return 0;
-
-	if(itemdb_isspecial(sd->status.inventory[i].card[0]))
-		return 0;
-
-	for(c = sd->inventory_data[i]->slot - 1; c >= 0; --c) {
-		if(sd->status.inventory[i].card[c] && itemdb_type(sd->status.inventory[i].card[c]) == IT_CARD) {
-			cardflag = 1;
-
-			if(typefail == 2) {// add cards to inventory, clear
-				int flag;
-				struct item item_tmp;
-
-				memset(&item_tmp,0,sizeof(item_tmp));
-
-				item_tmp.nameid   = sd->status.inventory[i].card[c];
-				item_tmp.identify = 1;
-
-				if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))) {
-					clif_additem(sd,0,0,flag);
-					map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-				}
-			}
-		}
-	}
-
-	if(cardflag == 1) {
-		if(typefail == 0 || typefail == 2) { // ??????
-			pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
-		}
-		if(typefail == 1) { // ?J?[?h?^?????i??????????j
-			int flag;
-			struct item item_tmp;
-
-			memset(&item_tmp,0,sizeof(item_tmp));
-
-			item_tmp.nameid      = sd->status.inventory[i].nameid;
-			item_tmp.identify    = 1;
-			item_tmp.refine      = sd->status.inventory[i].refine;
-			item_tmp.attribute   = sd->status.inventory[i].attribute;
-			item_tmp.expire_time = sd->status.inventory[i].expire_time;
-
-			for(j = sd->inventory_data[i]->slot; j < MAX_SLOTS; j++)
-				item_tmp.card[j]=sd->status.inventory[i].card[j];
-
-			pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
-
-			if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))) {
-				clif_additem(sd,0,0,flag);
-				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-			}
-		}
-		clif_misceffect(&sd->bl,2);
-	}
-
-	return 0;
+BUILDIN_FUNC(failedremovecards) {
+	int i=-1,j,c,cardflag=0;
+
+	TBL_PC* sd = script_rid2sd(st);
+	int num = script_getnum(st,2);
+	int typefail = script_getnum(st,3);
+
+	if (num > 0 && num <= ARRAYLENGTH(equip))
+		i=pc_checkequip(sd,equip[num-1]);
+
+	if (i < 0 || !sd->inventory_data[i])
+		return 0;
+
+	if(itemdb_isspecial(sd->status.inventory[i].card[0]))
+		return 0;
+
+	for( c = sd->inventory_data[i]->slot - 1; c >= 0; --c ) {
+		if( sd->status.inventory[i].card[c] && itemdb_type(sd->status.inventory[i].card[c]) == IT_CARD ) {
+			cardflag = 1;
+
+			if(typefail == 2) {// add cards to inventory, clear
+				int flag;
+				struct item item_tmp;
+
+				memset(&item_tmp,0,sizeof(item_tmp));
+
+				item_tmp.nameid   = sd->status.inventory[i].card[c];
+				item_tmp.identify = 1;
+
+				if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))){
+					clif_additem(sd,0,0,flag);
+					map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+				}
+			}
+		}
+	}
+
+	if(cardflag == 1) {
+		if(typefail == 0 || typefail == 2){	// destroy the item
+			pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
+		}
+		if(typefail == 1){	// destroy the card
+			int flag;
+			struct item item_tmp;
+
+			memset(&item_tmp,0,sizeof(item_tmp));
+
+			item_tmp.nameid      = sd->status.inventory[i].nameid;
+			item_tmp.identify    = 1;
+			item_tmp.refine      = sd->status.inventory[i].refine;
+			item_tmp.attribute   = sd->status.inventory[i].attribute;
+			item_tmp.expire_time = sd->status.inventory[i].expire_time;
+			item_tmp.unique_id = sd->status.inventory[i].unique_id;
+			item_tmp.bound = sd->status.inventory[i].bound;
+			item_tmp.favorite = sd->status.inventory[i].favorite;
+
+			for (j = sd->inventory_data[i]->slot; j < MAX_SLOTS; j++)
+				item_tmp.card[j]=sd->status.inventory[i].card[j];
+
+			pc_delitem(sd,i,1,0,2,LOG_TYPE_SCRIPT);
+
+			if((flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_SCRIPT))){
+				clif_additem(sd,0,0,flag);
+				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+		}
+		clif_misceffect(&sd->bl,2);
+	}
+
+	return 0;
+}
+
+/* ================================================================
+ * mapwarp "<from map>","<to map>",<x>,<y>,<type>,<ID for Type>;
+ * type: 0=everyone, 1=guild, 2=party;	[Reddozen]
+ * improved by [Lance]
+ * ================================================================*/
+BUILDIN_FUNC(mapwarp)	// Added by RoVeRT
+{
+	int x,y,m,check_val=0,check_ID=0,i=0;
+	struct guild *g = NULL;
+	struct party_data *p = NULL;
+	const char *str;
+	const char *mapname;
+	unsigned int index;
+	mapname=script_getstr(st,2);
+	str=script_getstr(st,3);
+	x=script_getnum(st,4);
+	y=script_getnum(st,5);
+	if(script_hasdata(st,7)){
+		check_val=script_getnum(st,6);
+		check_ID=script_getnum(st,7);
+	}
+
+	if((m=map_mapname2mapid(mapname))< 0)
+		return 0;
+
+	if(!(index=mapindex_name2id(str)))
+		return 0;
+
+	switch(check_val){
+		case 1:
+			g = guild_search(check_ID);
+			if (g){
+				for( i=0; i < g->max_member; i++)
+				{
+					if(g->member[i].sd && g->member[i].sd->bl.m==m){
+						pc_setpos(g->member[i].sd,index,x,y,CLR_TELEPORT);
+					}
+				}
+			}
+			break;
+		case 2:
+			p = party_search(check_ID);
+			if(p){
+				for(i=0;i<MAX_PARTY; i++){
+					if(p->data[i].sd && p->data[i].sd->bl.m == m){
+						pc_setpos(p->data[i].sd,index,x,y,CLR_TELEPORT);
+					}
+				}
+			}
+			break;
+		default:
+			map_foreachinmap(buildin_areawarp_sub,m,BL_PC,index,x,y,0,0);
+			break;
+	}
+
+	return 0;
 }
 
-/* ================================================================
- * mapwarp "<from map>","<to map>",<x>,<y>,<type>,<ID for Type>;
- * type: 0=everyone, 1=guild, 2=party;  [Reddozen]
- * improved by [Lance]
- * ================================================================*/
-BUILDIN_FUNC(mapwarp)   // Added by RoVeRT
-{
-	int x,y,m,check_val=0,check_ID=0,i=0;
-	struct guild *g = NULL;
-	struct party_data *p = NULL;
-	const char *str;
-	const char *mapname;
-	unsigned int index;
-	mapname=script_getstr(st,2);
-	str=script_getstr(st,3);
-	x=script_getnum(st,4);
-	y=script_getnum(st,5);
-	if(script_hasdata(st,7)) {
-		check_val=script_getnum(st,6);
-		check_ID=script_getnum(st,7);
-	}
-
-	if((m=map_mapname2mapid(mapname))< 0)
-		return 0;
-
-	if(!(index=mapindex_name2id(str)))
-		return 0;
-
-	switch(check_val) {
-		case 1:
-			g = guild_search(check_ID);
-			if(g) {
-				for(i=0; i < g->max_member; i++) {
-					if(g->member[i].sd && g->member[i].sd->bl.m==m) {
-						pc_setpos(g->member[i].sd,index,x,y,CLR_TELEPORT);
-					}
-				}
-			}
-			break;
-		case 2:
-			p = party_search(check_ID);
-			if(p) {
-				for(i=0; i<MAX_PARTY; i++) {
-					if(p->data[i].sd && p->data[i].sd->bl.m == m) {
-						pc_setpos(p->data[i].sd,index,x,y,CLR_TELEPORT);
-					}
-				}
-			}
-			break;
-		default:
-			map_foreachinmap(buildin_areawarp_sub,m,BL_PC,index,x,y,0,0);
-			break;
-	}
-
-	return 0;
-}
-
 static int buildin_mobcount_sub(struct block_list *bl,va_list ap)   // Added by RoVeRT
 {
 	char *event=va_arg(ap,char *);
@@ -11527,12 +12488,37 @@
 		script_pushint(st,item_arr[n]);
 	} else
 		script_pushint(st,-1);
-	return 0;
-}
-
-/*==========================================
- * Set some values of an item [Lupus]
- * Price, Weight, etc...
+	return 0;
+}
+
+BUILDIN_FUNC(getitemisrefinable)
+{
+	int item_id;
+	struct item_data *i_data;
+
+	item_id = script_getnum(st,2);
+	i_data = itemdb_exists(item_id);
+
+	if( i_data != NULL && !i_data->flag.no_refine )
+		script_pushint(st,1);
+	else
+		script_pushint(st,0);
+	return 0;
+}
+
+BUILDIN_FUNC(getitemisequipable)
+{
+	struct map_session_data *sd;
+	int item_id = script_getnum(st,2);
+	sd = script_rid2sd(st);
+
+	script_pushint(st,pc_isequip2(sd, item_id));
+	return 0;
+}
+
+/*==========================================
+ * Set some values of an item [Lupus]
+ * Price, Weight, etc...
     setiteminfo(itemID,n,Value), where n
         0 value_buy;
         1 value_sell;
@@ -11773,12 +12759,22 @@
 	} else {
 		script_pushint(st,1);
 	}
-	return 0;
-}
-
-/*==========================================
- * Transform a bl to another _class,
- * @type unused
+	return 0;
+}
+
+BUILDIN_FUNC(isdisguised)
+{
+	TBL_PC* sd = script_rid2sd(st);
+	if (sd == NULL) return 0;
+
+	script_pushint(st,sd->disguise);
+
+	return 0;
+}
+
+/*==========================================
+ * Transform a bl to another _class,
+ * @type unused
  *------------------------------------------*/
 BUILDIN_FUNC(classchange)
 {
@@ -12786,12 +13782,95 @@
 
 	str = script_getstr(st,2);
 	log_npc(sd,str);
-	return 0;
-}
-
-BUILDIN_FUNC(summon)
-{
-	int _class, timeout=0;
+	return 0;
+}
+
+BUILDIN_FUNC(summongroup)
+{
+	int _class, timeout=0;
+	int mostrarhp = 0, i;
+	TBL_PC *sd;
+	struct mob_data *md;
+	int tick = gettick();
+
+	sd=script_rid2sd(st);
+	if (!sd) return 0;
+
+	timeout = script_getnum(st,2);
+	mostrarhp = script_getnum(st,3);
+	// Correccion a lmites
+	timeout = cap_value(timeout, 5000, 600000);
+	mostrarhp = cap_value(mostrarhp, 0, 3);
+
+	clif_skill_poseffect(&sd->bl,AM_CALLHOMUN,1,sd->bl.x,sd->bl.y,tick);
+
+	for (i = st->start + 4; i < st->end; i++) {
+		_class = script_getnum(st,i);
+		md = mob_once_spawn_sub(&sd->bl, sd->bl.m, sd->bl.x, sd->bl.y, "--ja--", _class, "", SZ_SMALL, AI_NONE);
+		if (md) {
+			md->option.is_event = true;
+			md->option.hp_show = mostrarhp;
+			md->master_id = sd->bl.id;
+			// Opciones para Slave
+			md->special_state.ai = 1;
+			md->deletetimer = add_timer(tick+timeout,mob_timer_delete,md->bl.id,0); // El tiempo de vida del mob
+			mob_spawn (md); // Listo para mostrar el mob
+			clif_misceffect(&md->bl,344);
+			sc_start4(NULL, &md->bl, SC_MODECHANGE, 100, 1, 0, MD_AGGRESSIVE, 0, timeout);
+		}
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(summonspecial)
+{
+	int _class, timeout=0, hpmas=0, mostrarhp=0;
+	const char *str,*event="";
+	TBL_PC *sd;
+	struct mob_data *md;
+	int tick = gettick();
+
+	sd=script_rid2sd(st);
+	if (sd ==  NULL) return 0; // La sesion del Player al que va a pertenecer el mob
+
+	str	= script_getstr(st,2); // el Nombre del Mob Custom
+	_class = script_getnum(st,3); // La clase del Mob a Summonear
+	hpmas = script_getnum(st,4); // El aumento o disminucin de HP
+	hpmas = cap_value(hpmas, -5000000, 10000000);
+	timeout =  script_getnum(st,5); // El tiempo de Vida del Mob en Milisegundos
+	timeout = cap_value(timeout, 5000, 600000);
+	mostrarhp = script_getnum(st,6); // Variable para mostrar el HP del mob o no
+	mostrarhp = cap_value(mostrarhp, 0, 3);
+
+	if( script_hasdata(st,7) )
+	{ // El evento de cuando el Summon Muera
+		event=script_getstr(st,7);
+		check_event(st, event);
+	}
+
+	md = mob_once_spawn_sub(&sd->bl, sd->bl.m, sd->bl.x, sd->bl.y, str, _class, event, SZ_SMALL, AI_NONE);
+	if (md) {
+		md->master_id = sd->bl.id;
+		md->special_state.ai = 1;
+		md->deletetimer = add_timer(tick+timeout,mob_timer_delete,md->bl.id,0);
+
+		md->option.is_event = true;
+		md->option.no_expdrop = true;
+		md->status.hp += hpmas;
+		md->status.max_hp += hpmas; // Aumenta el Lmite del Maximo de HP [Zephyrus]
+		if (md->status.hp <= 0) md->status.hp = 10; // No permite mob con HP 0 o negativo
+		md->option.hp_show = mostrarhp;
+		// *******************
+		mob_spawn (md); //Now it is ready for spawning.
+		clif_misceffect(&md->bl,344);
+		sc_start4(NULL, &md->bl, SC_MODECHANGE, 100, 1, 0, MD_AGGRESSIVE, 0, timeout);
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(summon)
+{
+	int _class, timeout=0;
 	const char *str,*event="";
 	TBL_PC *sd;
 	struct mob_data *md;
@@ -14276,7 +15355,7 @@
 	if(script_hasdata(st,3))
 		flag = script_getnum(st,3);
 	nd = npc_name2id(shopname);
-	if(!nd || nd->bl.type != BL_NPC || (nd->subtype != SHOP && nd->subtype != CASHSHOP)) {
+	if( !nd || nd->bl.type != BL_NPC || (nd->subtype != SHOP && nd->subtype != CASHSHOP && nd->subtype != SPSHOP) ) {
 		ShowError("buildin_callshop: Shop [%s] not found (or NPC is not shop type)\n", shopname);
 		script_pushint(st,0);
 		return 1;
@@ -14718,28 +15797,36 @@
 		ShowError("buildin_rid2name: invalid RID\n");
 		script_pushconststr(st,"(null)");
 	}
-	return 0;
-}
-
-BUILDIN_FUNC(pcblockmove)
-{
-	int id, flag;
-	TBL_PC *sd = NULL;
-
-	id = script_getnum(st,2);
-	flag = script_getnum(st,3);
-
-	if(id)
-		sd = map_id2sd(id);
-	else
-		sd = script_rid2sd(st);
-
-	if(sd)
-		sd->state.blockedmove = flag > 0;
-
-	return 0;
-}
-
+	return 0;
+}
+
+BUILDIN_FUNC(pcblock)
+{
+	int id = 0, flag, type;
+	TBL_PC *sd = NULL;
+
+	type = script_getnum(st,2);
+	flag = script_getnum(st,3);
+	if( script_hasdata(st,4) )
+		id = script_getnum(st,4);
+
+	if( id && (sd = map_id2sd(id)) == NULL )
+		return 0;
+	else
+		sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		return 0;
+
+	switch( type )
+	{
+		case 0: sd->state.blockedmove = flag > 0; break;
+		case 1: sd->state.only_walk = flag > 0; break;
+	}
+
+	return 0;
+}
+
 BUILDIN_FUNC(pcfollow)
 {
 	int id, targetid;
@@ -15466,13 +16553,186 @@
 	page = script_getnum(st,3);
 
 	clif_readbook(sd->fd, book_id, page);
-	return 0;
-}
+	return 0;
+}
+
+// Addons from Terra
+BUILDIN_FUNC(strcmpi)
+{
+	const char *str1, *str2;
+
+	str1 = script_getstr(st,2);
+	str2 = script_getstr(st,3);
+
+	script_pushint(st,strcmpi(str1, str2));
+	
+	return 0;
+}
+
+BUILDIN_FUNC(chatmessage)
+{
+	const char *str;
+	int color, channel;
+
+	if( !battle_config.channel_system_enable )
+		return 0;
+
+	str = script_getstr(st,2); // Mensaje
+	channel = script_getnum(st,3); // Canal
+	color = script_getnum(st,4); // Color
+
+	switch( channel )
+	{
+		case CHN_MAIN: clif_channel_message(server_channel[CHN_MAIN], str, color); break;
+		case CHN_VENDING: clif_channel_message(server_channel[CHN_VENDING], str, color); break;
+		case CHN_BATTLEGROUND: clif_channel_message(server_channel[CHN_BATTLEGROUND], str, color); break;
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(flooritem)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	struct item_data *item_data;
+	int nameid, amount;
+
+	if( sd == NULL ) return 0;
+
+	nameid = script_getnum(st,2);
+	if( (item_data = itemdb_search(nameid)) == NULL )
+		return 0;
+
+	amount = script_getnum(st,3);
+	if( amount <= 0 )
+		return 0;
+
+	map_addflooritem_area(&sd->bl, 0, 0, 0, nameid, amount);
+	return 0;
+}
+
+BUILDIN_FUNC(flooritem2xy)
+{
+	struct item_data *item_data;
+	int nameid, amount, m, x, y;
+	const char *mapname;
+
+	mapname = script_getstr(st,2);
+	if( (m = map_mapname2mapid(mapname)) < 0 )
+		return 0;
+
+	x = script_getnum(st,3);
+	y = script_getnum(st,4);
+	nameid = script_getnum(st,5);
+	if( (item_data = itemdb_search(nameid)) == NULL )
+		return 0;
+
+	amount = script_getnum(st,6);
+	if( amount < 1 )
+		return 0;
+
+	map_addflooritem_area(NULL, m, x, y, nameid, amount);
+	return 0;
+}
+
+/*==========================================
+ * killslaves [Zephyrus]
+ *------------------------------------------*/
+int script_deleteslave_sub(struct block_list *bl, va_list ap)
+{
+	struct mob_data *md;
+	int id;
+
+	nullpo_ret(bl);
+	nullpo_ret(ap);
+	nullpo_ret(md = (struct mob_data *)bl);
+
+	id = va_arg(ap,int);
+	if( md->master_id > 0 && md->master_id == id )
+		status_kill(bl);
+
+	return 0;
+}
+
+BUILDIN_FUNC(killslaves)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	if( sd == NULL ) return 0;
+
+	map_foreachinmap(script_deleteslave_sub, sd->bl.m, BL_MOB, sd->bl.id);
+
+	return 0;
+}
+
+BUILDIN_FUNC(class2ancientwoe)
+{
+	struct map_session_data *sd;
+	
+	sd = script_rid2sd(st);
+
+	if( sd && pc_class2ancientwoe(sd->status.class_) && !sd->md )
+		script_pushint(st,1); // Cannot Access Ancient WoE with Mercenaries
+	else
+		script_pushint(st,0);
+
+	return 0;
+}
+
+/*==========================================
+ * partyitem <item id>,<amount>;
+ *------------------------------------------*/
+BUILDIN_FUNC(partyitem)
+{
+	int nameid,amount,i,flag;
+	struct item_data *item_data;
+	struct item item_tmp;
+	struct map_session_data *sd = script_rid2sd(st);
+	struct party_data *p;
+	
+	if( sd == NULL ) return 0;
+
+	nameid = script_getnum(st,2);
+	if( (item_data = itemdb_search(nameid)) == NULL )
+		return 0;
+
+	amount = script_getnum(st,3);
+	if( amount <= 0 )
+		return 0;
+
+	memset(&item_tmp,0,sizeof(item_tmp));
+	item_tmp.nameid = nameid;
+	item_tmp.identify = 1;
+	item_tmp.amount = 1;
+
+	if( (p = party_search(sd->status.party_id)) == NULL )
+	{ // No party
+		if( (flag = pc_additem(sd,&item_tmp,amount,LOG_TYPE_SCRIPT)) )
+		{
+			clif_additem(sd,0,0,flag);
+			if( pc_candrop(sd,&item_tmp) )
+				map_addflooritem(&item_tmp,amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+
+		return 0;
+	}
+
+	// Party Share
+	for( i = 0; i < amount; i++ )
+	{
+		if( (flag = party_share_loot(p,sd,&item_tmp,sd->status.char_id)) )
+		{
+			clif_additem(sd,0,0,flag);
+			if( pc_candrop(sd,&item_tmp) )
+				map_addflooritem(&item_tmp,amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+	
+	return 0;
+}
+
+/******************
+Questlog script commands
+*******************/
 
-/******************
-Questlog script commands
-*******************/
-
 BUILDIN_FUNC(setquest)
 {
 	struct map_session_data *sd = script_rid2sd(st);
@@ -15546,18 +16806,823 @@
 /*==========================================
  * BattleGround System
  *------------------------------------------*/
+BUILDIN_FUNC(map_logincount)
+{
+	const char *var = script_getstr(st,2);
+	struct map_session_data *sd = script_rid2sd(st);
+	int i = 0, m;
+
+	if( sd && (m = map_mapname2mapid(var)) >= 0 )
+	{
+		struct map_session_data* pl_sd;
+		struct s_mapiterator* iter;
+
+		iter = mapit_getallusers();
+		for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+		{
+			if( pl_sd->bl.m != m )
+				continue;
+			if( session[sd->fd]->client_addr == session[pl_sd->fd]->client_addr )
+				i++;
+		}
+		mapit_free(iter);
+	}
+
+	script_pushint(st,i);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_logincount)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	int i = 0;
+
+	if( sd )
+		i = battleground_countlogin(sd,true);
+
+	script_pushint(st,i);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_create)
+{
+	const char *map_name, *ev = "", *dev = "";
+	int x, y, mapindex = 0, guild_index, bg_id;
+
+	map_name = script_getstr(st,2);
+	if( strcmp(map_name,"-") != 0 && (mapindex = mapindex_name2id(map_name)) == 0 )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	x = script_getnum(st,3);
+	y = script_getnum(st,4);
+	guild_index = script_getnum(st,5);
+	ev = script_getstr(st,6); // Logout Event
+	dev = script_getstr(st,7); // Die Event
+
+	guild_index = cap_value(guild_index, 0, 12);
+	bg_id = bg_create(mapindex, x, y, guild_index, ev, dev);
+
+	script_pushint(st,bg_id);
+	return 0;
+}
+
+// Creates a Queue
+// bg_queue_create "Queue Name","On Join Event",min_level;
+
+BUILDIN_FUNC(bg_queue_create)
+{
+	const char *queue_name, *jev;
+	int q_id, min_level = 0;
+
+	queue_name = script_getstr(st,2);
+	jev = script_getstr(st,3);
+	if( script_hasdata(st,4) )
+		min_level = script_getnum(st,4);
+
+	q_id = queue_create(queue_name,jev,min_level);
+	script_pushint(st,q_id);
+	return 0;
+}
+
+// Changes the Queue's Join Event.
+// bg_queue_event queue_id,"On Join Event";
+
+BUILDIN_FUNC(bg_queue_event)
+{
+	struct queue_data *qd;
+	const char *jev;
+	int q_id;
+
+	q_id = script_getnum(st,2);
+	if( (qd = queue_search(q_id)) == NULL )
+		return 0;
+
+	jev = script_getstr(st,3);
+	safestrncpy(qd->join_event, jev, sizeof(qd->join_event));
+	return 0;
+}
+
+// Joins a Queue
+// bg_queue_join queue_id;
+
+BUILDIN_FUNC(bg_queue_join)
+{
+	int q_id;
+	struct map_session_data *sd = script_rid2sd(st);
+	if( !sd ) return 0;
+
+	q_id = script_getnum(st,2);
+	queue_join(sd,q_id);
+	return 0;
+}
+
+// Party Joins a Queue
+// bg_queue_partyjoin party_id,queue_id;
+
+BUILDIN_FUNC(bg_queue_partyjoin)
+{
+	int q_id, i, party_id;
+	struct map_session_data *sd;
+	struct party_data *p;
+
+	party_id = script_getnum(st,2);
+	if( !party_id || (p = party_search(party_id)) == NULL ) return 0;
+
+	q_id = script_getnum(st,3);
+	if( !queue_search(q_id) ) return 0;
+
+	for( i = 0; i < MAX_PARTY; i++ )
+	{
+		if( (sd = p->data[i].sd) == NULL )
+			continue;
+		queue_join(sd,q_id);
+	}
+
+	return 0;
+}
+
+// Leaves a Queue
+// bg_queue_leave queue_id;
+
+BUILDIN_FUNC(bg_queue_leave)
+{
+	int q_id;
+	struct map_session_data *sd = script_rid2sd(st);
+	if( !sd ) return 0;
+
+	q_id = script_getnum(st,2);
+	queue_leave(sd,q_id);
+	return 0;
+}
+
+// Request Information from a Queue
+// bg_queue_data queue_id,type;
+
+BUILDIN_FUNC(bg_queue_data)
+{
+	struct queue_data *qd;
+	int q_id = script_getnum(st,2),
+		type = script_getnum(st,3);
+
+	if( (qd = queue_search(q_id)) == NULL )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	switch( type )
+	{
+	case 0: script_pushint(st,qd->users); break;
+	case 1: // User List
+		{
+			int j = 0;
+			struct map_session_data *sd;
+			struct queue_member *head;
+			head = qd->first;
+			while( head )
+			{
+				if( (sd = head->sd) != NULL )
+				{
+					mapreg_setregstr(reference_uid(add_str("$@qmembers$"),j),sd->status.name);
+					j++;
+				}
+				head = head->next;
+			}
+			script_pushint(st,j);
+		}
+		break;
+	default:
+		ShowError("script:bg_queue_data: unknown data identifier %d\n", type);
+		break;
+	}
+
+	return 0;
+}
+
+// Creates a Team from a BG Queue
+// bg_queue2team queue_id,max2join,"mapname",x,y,guild_index,"Logout Event","Die Event";
+
+BUILDIN_FUNC(bg_queue2team)
+{
+	struct queue_data *qd;
+	struct queue_member *qm;
+	const char *map_name, *ev = "", *dev = "";
+	int q_id, max, x, y, i, mapindex = 0, guild_index, bg_id;
+
+	q_id = script_getnum(st,2);
+	if( (qd = queue_search(q_id)) == NULL )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	max = script_getnum(st,3);
+	map_name = script_getstr(st,4);
+
+	if( strcmp(map_name,"-") != 0 && (mapindex = mapindex_name2id(map_name)) == 0 )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	x = script_getnum(st,5);
+	y = script_getnum(st,6);
+	guild_index = script_getnum(st,7);
+	ev = script_getstr(st,8); // Logout Event
+	dev = script_getstr(st,9); // Die Event
+
+	guild_index = cap_value(guild_index, 0, 12);
+	if( (bg_id = bg_create(mapindex, x, y, guild_index, ev, dev)) == 0 )
+	{ // Creation failed
+		script_pushint(st,0);
+		return 0;
+	}
+
+	i = 0; // Counter
+	while( (qm = qd->first) != NULL && i < max && i < MAX_BG_MEMBERS )
+	{
+		if( qm->sd && bg_team_join(bg_id, qm->sd) )
+		{
+			mapreg_setreg(reference_uid(add_str("$@arenamembers"), i), qm->sd->bl.id);
+			queue_member_remove(qd,qm->sd->bl.id);
+			i++;
+		}
+		else break; // Failed? Should not. Anyway, to avoid a infinite loop
+	}
+
+	mapreg_setreg(add_str("$@arenamembersnum"), i);
+	script_pushint(st,bg_id);
+	return 0;
+}
+
+// Joins the first player from the queue to the given team and warp him.
+// bg_queue2team_single queue_id,bg_id,"mapname",x,y;
+
+BUILDIN_FUNC(bg_queue2team_single)
+{
+	const char* map_name;
+	struct queue_data *qd;
+	struct map_session_data *sd;
+	int x, y, mapindex, bg_id, q_id;
+
+	q_id = script_getnum(st,2);
+	if( (qd = queue_search(q_id)) == NULL || !qd->first || !qd->first->sd )
+		return 0;
+
+	bg_id = script_getnum(st,3);
+	map_name = script_getstr(st,4);
+	if( (mapindex = mapindex_name2id(map_name)) == 0 )
+		return 0; // Invalid Map
+	x = script_getnum(st,5);
+	y = script_getnum(st,6);
+	sd = qd->first->sd;
+
+	if( bg_team_join(bg_id,sd) )
+	{
+		queue_member_remove(qd,sd->bl.id);
+		pc_setpos(sd,mapindex,x,y,CLR_TELEPORT);
+	}
+
+	return 0;
+}
+
+// Check if the given BG queue can start a BG in the given Mode
+// bg_queue_checkstart queue_id,type,teams,required min players;
+
+BUILDIN_FUNC(bg_queue_checkstart)
+{
+	int q_id, result = 0;
+	struct queue_data *qd;
+
+	q_id = script_getnum(st,2);
+	if( (qd = queue_search(q_id)) != NULL )
+	{
+		int type, req_min, teams;
+
+		type = script_getnum(st,3);
+		teams = script_getnum(st,4);
+		req_min = script_getnum(st,5);
+
+		switch( type )
+		{
+		case 0: // Lineal, as they Join
+		case 1: // Random
+		case 2: // Class Balance
+			if( qd->users >= (req_min * teams) )
+				result = 1;
+			break;
+		case 3: // Faction
+			{
+				int count[FACTION_MAX+1], factions = 0;
+				struct queue_member *qm = qd->first;
+				struct map_session_data *sd;
+
+				memset(count,0,sizeof(count));
+				while( qm && (sd = qm->sd) != NULL && factions < teams )
+				{ // Faction Count
+					count[sd->status.faction_id]++;
+					if( count[sd->status.faction_id] == req_min )
+						factions++;
+					qm = qm->next;
+				}
+
+				if( factions >= teams ) result = 1;
+			}
+			break;
+		case 4: // BG Team Selected by Script
+			{
+				int count[3], teamcount = 0;
+				struct queue_member *qm = qd->first;
+				struct map_session_data *sd;
+
+				memset(count,0,sizeof(count));
+				while( qm && (sd = qm->sd) != NULL && teamcount < teams )
+				{ // Faction Count
+					count[sd->bg_team]++;
+					// 0 - Traitors | 1 - Guillaume | 2 - Croix
+					if( count[sd->bg_team] == req_min )
+						teamcount++;
+					qm = qm->next;
+				}
+
+				if( teamcount >= teams ) result = 1;
+			}
+			break;
+		default:
+			result = 0;
+			break;
+		}
+	}
+
+	script_pushint(st,result);
+	return 0;
+}
+
+// Build BG Teams from one Queue
+// bg_queue2teams queue_id,maxplayersperteam,type,teamID1,teamID2...;
+
+BUILDIN_FUNC(bg_queue2teams)
+{ // Send Users from Queue to Teams. Requires previously created teams.
+	struct queue_data *qd;
+	int i, j = 0, bg_id = 0, c = 0, q_id, min, max, type, limit = 0;
+	struct map_session_data *sd;
+
+	q_id = script_getnum(st,2); // Queue ID
+	if( (qd = queue_search(q_id)) == NULL )
+	{
+		ShowError("script:bg_queue2teams: Non existant queue id received %d.\n", q_id);
+		return 0;
+	}
+
+	min = script_getnum(st,3); // Min Members per Team
+	max = script_getnum(st,4); // Max Members per Team
+	type = script_getnum(st,5); // Team Building Method
+
+	i = 6; // Team ID's to build
+	while( script_hasdata(st,i) )
+	{
+		bg_id = script_getnum(st,i);
+		if( bg_team_search(bg_id) == NULL )
+		{
+			ShowError("script:bg_queue2teams: Non existant team id received %d.\n", bg_id);
+			return 0;
+		}
+		i++;
+	}
+	c = i - 6;
+
+	if( c < 2 )
+	{
+		ShowError("script:bg_queue2teams: Less than 2 teams received to build members.\n");
+		return 0;
+	}
+
+	if( type < 3 )
+	{
+		limit = min(max * c,qd->users); // How many players are we going to take from the Queue
+		if( battle_config.bg_queue2team_balanced )
+		{
+			limit -= limit % c; // Remove the remaining difference to balance teams
+			max = limit / c;
+		}
+		else
+		{
+			max = (limit - (limit % c)) / c;
+			if( limit % c > 0 ) max++; // Extra slot per team to add the remaining members
+		}
+	}
+
+	switch( type )
+	{
+	case 0: // Lineal - Maybe to keep party together
+		for( i = 0; i < limit; i++ )
+		{
+			if( i % max == 0 )
+			{ // Switch Team
+				bg_id = script_getnum(st,j+6);
+				if( ++j >= c ) j = 0;
+			}
+
+			if( !qd->first || (sd = qd->first->sd) == NULL )
+				break; // No more people to join Teams
+
+			bg_team_join(bg_id,sd);
+			queue_member_remove(qd,sd->bl.id);
+		}
+		break;
+	case 1: // Random
+		{
+			int pos;
+			struct queue_member *qm;
+
+			for( i = 0; i < limit; i++ )
+			{
+				if( i % max == 0 )
+				{ // Switch Team
+					bg_id = script_getnum(st,j+6);
+					if( ++j >= c ) j = 0;
+				}
+
+				pos = 1 + rand() % (limit - i);
+				if( (qm = queue_member_get(qd,pos)) == NULL || (sd = qm->sd) == NULL )
+					break;
+
+				bg_team_join(bg_id,sd);
+				queue_member_remove(qd,sd->bl.id);
+			}
+		}
+		break;
+	case 2: // Job Balance
+		{
+			struct queue_member *qm, *head, *previous, *first = NULL;
+			int s_class, t_class;
+
+			// Building a Temporal Sorted by Class Queue
+			i = 0;
+			while( i < limit && (qm = qd->first) != NULL && (sd = qm->sd) != NULL )
+			{
+				qd->first = qd->first->next; // Move the queue head to the next pos
+				qd->users--; // Reduces the amount of members on queue
+				if( qm->next == NULL ) qd->last = NULL;
+				qm->next = NULL;
+				sd->qd = NULL;
+
+				// Plug qm into the temporal Queue
+				head = first;
+				previous = NULL;
+				s_class = sd->class_&MAPID_UPPERMASK; // Current Member's Upper Class
+
+				while( head && head->sd && (s_class > (t_class = (head->sd->class_&MAPID_UPPERMASK)) || (s_class == t_class && sd->class_ > head->sd->class_)) )
+				{ // Search for Insert Position
+					previous = head;
+					head = head->next;
+				}
+
+				qm->next = head;
+				if( previous )
+					previous->next = qm;
+				else
+					first = qm;
+			}
+
+			// Update the Queue new positions
+			i = 0;
+			head = qd->first;
+			while( head )
+			{
+				head->position = ++i;
+				head = head->next;
+			}
+
+			// Player distribution into Teams
+			while( (head = first) != NULL && (sd = head->sd) != NULL )
+			{
+				bg_id = script_getnum(st,j+6);
+				if( ++j >= c ) j = 0;
+				bg_team_join(bg_id,sd);
+
+				first = first->next;
+				aFree(head);
+			}
+		}
+		break;
+	case 3: // Faction Mode
+		{
+			bool faction[FACTION_MAX+1];
+			int count[FACTION_MAX+1], factions = 0, k;
+			struct queue_member *qm = qd->first;
+			struct battleground_data *bg;
+
+			memset(count,0,sizeof(count));
+			memset(faction,0,sizeof(faction));
+
+			while( qm && (sd = qm->sd) != NULL )
+			{ // Search the First Factions to Build Teams
+				i = sd->status.faction_id;
+				count[i]++;
+
+				if( count[i] == min && !faction[i] && factions < c )
+				{
+					faction[i] = true; // Tag this Faction
+					factions++;
+				}
+
+				qm = qm->next;
+			}
+
+			if( factions < c ) break; // Should not happen if you use first bg_queue_checkstart
+
+			if( battle_config.bg_queue2team_balanced )
+			{
+				for( i = 0; i < FACTION_MAX+1; i++ )
+				{ // Set the Max per Team to be taken from the Queue
+					if( !faction[i] ) continue; // Ignore this Faction.
+					max = min(count[i],max);
+				}
+			}
+
+			for( i = 0; i < FACTION_MAX+1; i++ )
+			{
+				if( !faction[i] ) continue; // Ignore this Faction.
+
+				k = 0;
+				bg_id = script_getnum(st,j+6);
+				if( (bg = bg_team_search(bg_id)) != NULL ) bg->pf_id = i; // Faction ID stored for Balancing
+				j++;
+
+				qm = qd->first;
+				while( qm && (sd = qm->sd) != NULL && k < max )
+				{
+					qm = qm->next;
+					if( sd->status.faction_id != i ) continue; // Not from this faction
+					queue_member_remove(qd,sd->bl.id);
+					bg_team_join(bg_id,sd);
+					k++;
+				}
+			}
+		}
+		break;
+	case 4: // BG Team Mode
+		{
+			bool team[3];
+			int count[3], teams = 0, k;
+			struct queue_member *qm = qd->first;
+			struct battleground_data *bg;
+
+			memset(count,0,sizeof(count));
+			memset(team,0,sizeof(team));
+
+			while( qm && (sd = qm->sd) != NULL )
+			{ // Search the First Teams to Build Teams
+				i = sd->bg_team;
+				count[i]++;
+
+				if( count[i] == min && !team[i] && teams < c )
+				{
+					team[i] = true; // Tag this Team.
+					teams++;
+				}
+
+				qm = qm->next;
+			}
+
+			if( teams < c ) break; // Should not happen if you use first bg_queue_checkstart
+
+			if( battle_config.bg_queue2team_balanced )
+			{
+				for( i = 0; i < 3; i++ )
+				{ // Set the Max per Team to be taken from the Queue
+					if( !team[i] ) continue; // Ignore this Team.
+					max = min(count[i],max);
+				}
+			}
+
+			for( i = 0; i < 3; i++ )
+			{
+				if( !team[i] ) continue; // Ignore this Team.
+
+				k = 0;
+				bg_id = script_getnum(st,j+6);
+				if( (bg = bg_team_search(bg_id)) != NULL )
+				{
+					bg->pf_id = i; // Team ID stored for Balancing
+					bg->g = &bg_guild[( !i ? 2 : i-1 )];
+					bg->color = bg_colors[( !i ? 2 : i-1 )];
+				}
+				j++;
+
+				qm = qd->first;
+				while( qm && (sd = qm->sd) != NULL && k < max )
+				{
+					qm = qm->next;
+					if( sd->bg_team != i ) continue; // Not from this Team
+					queue_member_remove(qd,sd->bl.id);
+					bg_team_join(bg_id,sd);
+					k++;
+				}
+			}
+		}
+		break;
+	}
+
+	return 0;
+}
+
+// Fill teams with members from the given Queue
+// bg_balance_teams queue_id,maxplayersperteam,TeamID1,TeamID2,...;
+
+BUILDIN_FUNC(bg_balance_teams)
+{
+	struct queue_data *qd;
+	struct queue_member *head;
+	struct battleground_data *bg, *p_bg;
+	int i, c, q_id, bg_id, m_bg_id = 0, max, min, type, bg_count[FACTION_MAX+1];
+	struct map_session_data *sd;
+	bool balanced, bg_faction[FACTION_MAX+1];
+
+	q_id = script_getnum(st,2);
+	if( (qd = queue_search(q_id)) == NULL || qd->users <= 0 )
+		return 0;
+
+	max = script_getnum(st,3);
+	if( max > MAX_BG_MEMBERS ) max = MAX_BG_MEMBERS;
+	min = MAX_BG_MEMBERS + 1;
+	type = script_getnum(st,4);
+
+	i = 5; // Team ID's to build
+	memset(bg_count,0,sizeof(bg_count));
+	memset(bg_faction,0,sizeof(bg_faction));
+
+	while( script_hasdata(st,i) )
+	{
+		bg_id = script_getnum(st,i);
+		if( (bg = bg_team_search(bg_id)) == NULL )
+		{
+			ShowError("script:bg_balance_teams: Non existant team id received %d.\n", bg_id);
+			return 0;
+		}
+
+		if( bg->count < min ) min = bg->count;
+		if( type > 2 )
+		{
+			bg_count[bg->pf_id] = bg->count;
+			bg_faction[bg->pf_id] = true;
+		}
+		i++;
+	}
+
+	c = i - 5; // Teams Found
+	if( c < 2 || min >= max ) return 0; // No Balance Required
+
+	if( type < 3 )
+	{
+		while( (head = qd->first) != NULL && (sd = head->sd) != NULL )
+		{
+			p_bg = NULL;
+			balanced = true;
+			min = MAX_BG_MEMBERS + 1;
+
+			// Search the Current Minimum and Balance status
+			for( i = 0; i < c; i++ )
+			{
+				bg_id = script_getnum(st,i+5);
+				if( (bg = bg_team_search(bg_id)) == NULL )
+					break; // Should not happen. Teams already check
+				if( p_bg && p_bg->count != bg->count )
+					balanced = false; // Teams still with different member count
+				if( bg->count < min )
+				{
+					m_bg_id = bg_id;
+					min = bg->count;
+				}
+				p_bg = bg;
+			}
+
+			if( min >= max ) break; // Balance completed
+
+			if( battle_config.bg_queue2team_balanced && balanced && qd->users < c )
+				break; // No required users on queue to keep balance
+
+			bg_team_join(m_bg_id,sd);
+			queue_member_remove(qd,sd->bl.id);
+			if( (bg = bg_team_search(m_bg_id)) != NULL && bg->mapindex )
+				pc_setpos(sd,bg->mapindex,bg->x,bg->y,CLR_OUTSIGHT); // Joins and Warps
+		}	
+	}
+	else if( type == 3 )
+	{
+		int fd_count[FACTION_MAX+1], j;
+		memset(fd_count,0,sizeof(fd_count));
+
+		head = qd->first;
+		while( head && (sd = head->sd) != NULL )
+		{
+			fd_count[sd->status.faction_id]++;
+			head = head->next;
+		}
+
+		min = MAX_BG_MEMBERS + 1;
+		for( i = 0; i < FACTION_MAX+1; i++ )
+		{
+			if( !bg_faction[i] ) continue; // Faction not present on the BG teams.
+			if( (fd_count[i] + bg_count[i]) > max ) fd_count[i] = max - bg_count[i];
+			if( battle_config.bg_queue2team_balanced && min < (fd_count[i] + bg_count[i]) ) min = fd_count[i] + bg_count[i];
+		}
+
+		// Balancing - Limit to the minimum possible
+		if( battle_config.bg_queue2team_balanced )
+		{
+			for( i = 0; i < FACTION_MAX+1; i++ )
+			{
+				if( !bg_faction[i] ) continue; // Faction not present on the BG teams.
+				if( (fd_count[i] + bg_count[i]) > min ) fd_count[i] = min - bg_count[i];
+			}
+		}
+
+		// Fill Teams
+		for( i = 0; i < c; i++ )
+		{
+			bg_id = script_getnum(st,i+5);
+			if( (bg = bg_team_search(bg_id)) == NULL || fd_count[bg->pf_id] <= 0 )
+				continue; // Nothing to Add here
+
+			j = 0;
+			head = qd->first;
+			while( head && (sd = head->sd) != NULL && j < fd_count[bg->pf_id] )
+			{
+				head = head->next;
+				if( sd->status.faction_id != bg->pf_id ) continue;
+				queue_member_remove(qd,sd->bl.id);
+				bg_team_join(bg_id,sd);
+				j++;
+			}
+		}
+	}
+	else if( type == 4 )
+	{
+		int td_count[3], j;
+		memset(td_count,0,sizeof(td_count));
+
+		head = qd->first;
+		while( head && (sd = head->sd) != NULL )
+		{
+			td_count[sd->bg_team]++;
+			head = head->next;
+		}
+
+		min = MAX_BG_MEMBERS + 1;
+		for( i = 0; i < 3; i++ )
+		{
+			if( !bg_faction[i] ) continue; // Team not present on the BG teams.
+			if( (td_count[i] + bg_count[i]) > max ) td_count[i] = max - bg_count[i];
+			if( battle_config.bg_queue2team_balanced && min < (td_count[i] + bg_count[i]) ) min = td_count[i] + bg_count[i];
+		}
+
+		// Balancing - Limit to the minimum possible
+		if( battle_config.bg_queue2team_balanced )
+		{
+			for( i = 0; i < 3; i++ )
+			{
+				if( !bg_faction[i] ) continue; // Team not present on the BG teams.
+				if( (td_count[i] + bg_count[i]) > min ) td_count[i] = min - bg_count[i];
+			}
+		}
+
+		// Fill Teams
+		for( i = 0; i < c; i++ )
+		{
+			bg_id = script_getnum(st,i+5);
+			if( (bg = bg_team_search(bg_id)) == NULL || td_count[bg->pf_id] <= 0 )
+				continue; // Nothing to Add here
+
+			j = 0;
+			head = qd->first;
+			while( head && (sd = head->sd) != NULL && j < td_count[bg->pf_id] )
+			{
+				head = head->next;
+				if( sd->bg_team != bg->pf_id ) continue;
+				queue_member_remove(qd,sd->bl.id);
+				bg_team_join(bg_id,sd);
+				j++;
+			}
+		}
+	}
+
+	return 0;
+}
+
 BUILDIN_FUNC(waitingroom2bg)
 {
 	struct npc_data *nd;
 	struct chat_data *cd;
 	const char *map_name, *ev = "", *dev = "";
-	int x, y, i, mapindex = 0, bg_id, n;
+	int x, y, i, mapindex = 0, guild_index, bg_id;
 	struct map_session_data *sd;
 
-	if(script_hasdata(st,7))
-		nd = npc_name2id(script_getstr(st,7));
-	else
-		nd = (struct npc_data *)map_id2bl(st->oid);
+	nd = (struct npc_data *)map_id2bl(st->oid);
 
 	if(nd == NULL || (cd = (struct chat_data *)map_id2bl(nd->chat_id)) == NULL) {
 		script_pushint(st,0);
@@ -15565,28 +17630,25 @@
 	}
 
 	map_name = script_getstr(st,2);
-	if(strcmp(map_name,"-") != 0) {
-		mapindex = mapindex_name2id(map_name);
-		if(mapindex == 0) {
-			// Invalid Map
-			script_pushint(st,0);
-			return 0;
-		}
+	if( strcmp(map_name,"-") != 0 && (mapindex = mapindex_name2id(map_name)) == 0 ) {
+		script_pushint(st,0);
+		return 0;
 	}
 
 	x = script_getnum(st,3);
 	y = script_getnum(st,4);
-	ev = script_getstr(st,5); // Logout Event
-	dev = script_getstr(st,6); // Die Event
+	guild_index = script_getnum(st,5);
+	ev = script_getstr(st,6); // Logout Event
+	dev = script_getstr(st,7); // Die Event
 
-	if((bg_id = bg_create(mapindex, x, y, ev, dev)) == 0) {
+	guild_index = cap_value(guild_index, 0, 12);
+	if( (bg_id = bg_create(mapindex, x, y, guild_index, ev, dev)) == 0 ) {
 		// Creation failed
 		script_pushint(st,0);
 		return 0;
 	}
 
-	n = cd->users;
-	for(i = 0; i < n && i < MAX_BG_MEMBERS; i++) {
+	for( i = 0; i < cd->users && i < MAX_BG_MEMBERS; i++ ) {
 		if((sd = cd->usersd[i]) != NULL && bg_team_join(bg_id, sd))
 			mapreg_setreg(reference_uid(add_str("$@arenamembers"), i), sd->bl.id);
 		else
@@ -15641,20 +17703,56 @@
 
 	bg->x = script_getnum(st,3);
 	bg->y = script_getnum(st,4);
-	return 0;
-}
-
-BUILDIN_FUNC(bg_warp)
-{
-	int x, y, mapindex, bg_id;
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_reveal)
+{
+	struct battleground_data *bg;
+	int bg_id;
+
+	bg_id = script_getnum(st,2);
+	if( (bg = bg_team_search(bg_id)) == NULL )
+		return 0;
+
+	bg->reveal_pos = true; // Reveal Position Mode
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_setquest)
+{
+	struct battleground_data *bg;
+	struct map_session_data *sd;
+	int i, bg_id, quest;
+
+	bg_id = script_getnum(st,2);
+	quest = script_getnum(st,3);
+
+	if( bg_id == 0 || (bg = bg_team_search(bg_id)) == NULL )
+		return 0;
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
+		quest_add(sd,quest);
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(bg_warp)
+{
+	int x, y, mapindex, bg_id;
 	const char *map_name;
-
-	bg_id = script_getnum(st,2);
-	map_name = script_getstr(st,3);
-	if((mapindex = mapindex_name2id(map_name)) == 0)
-		return 0; // Invalid Map
-	x = script_getnum(st,4);
-	y = script_getnum(st,5);
+
+	bg_id = script_getnum(st,2);
+	map_name = script_getstr(st,3);
+	if( !strcmp(map_name,"RespawnPoint") )
+		mapindex = 0;
+	else if( (mapindex = mapindex_name2id(map_name)) == 0 )
+		return 0; // Invalid Map
+	x = script_getnum(st,4);
+	y = script_getnum(st,5);
 	bg_team_warp(bg_id, mapindex, x, y);
 	return 0;
 }
@@ -15673,29 +17771,58 @@
 	if(script_hasdata(st,8)) evt = script_getstr(st,8);
 	check_event(st, evt);
 	script_pushint(st, mob_spawn_bg(map,x,y,str,class_,evt,bg_id));
-	return 0;
-}
-
-BUILDIN_FUNC(bg_monster_set_team)
-{
-	struct mob_data *md;
+	return 0;
+}
+
+BUILDIN_FUNC(bg_monster_reveal)
+{
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st,2),
+		flag = script_getnum(st,3),
+		color = script_getnum(st,4);
+	
+	if( id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB )
+		return 0;
+	md = (TBL_MOB *)mbl;
+	map_foreachinmap(viewpointmap_sub,mbl->m,BL_PC,st->oid,flag,mbl->x,mbl->y,mbl->id,color);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_monster_set_team)
+{
+	struct mob_data *md;
 	struct block_list *mbl;
-	int id = script_getnum(st,2),
-	    bg_id = script_getnum(st,3);
+	int id = script_getnum(st,2),
+		bg_id = script_getnum(st,3);
+
+	if( id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB )
+		return 0;
+	md = (TBL_MOB *)mbl;
+	md->bg_id = bg_id;
 
-	if((mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB)
-		return 0;
-	md = (TBL_MOB *)mbl;
-	md->bg_id = bg_id;
-
-	mob_stop_attack(md);
-	mob_stop_walking(md, 0);
-	md->target_id = md->attacked_id = 0;
-	clif_charnameack(0, &md->bl);
-
-	return 0;
-}
-
+	mob_stop_attack(md);
+	mob_stop_walking(md, 0);
+	md->target_id = md->attacked_id = 0;
+	clif_mobnameack(NULL, md, 0);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_monster_inmunity)
+{
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st,2),
+		flag = script_getnum(st,3);
+	
+	if( id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB )
+		return 0;
+
+	md = (TBL_MOB *)mbl;
+	md->state.inmunity = flag;
+	return 0;
+}
+
 BUILDIN_FUNC(bg_leave)
 {
 	struct map_session_data *sd = script_rid2sd(st);
@@ -15703,19 +17830,46 @@
 		return 0;
 
 	bg_team_leave(sd,0);
-	return 0;
-}
-
-BUILDIN_FUNC(bg_destroy)
-{
-	int bg_id = script_getnum(st,2);
-	bg_team_delete(bg_id);
-	return 0;
-}
-
-BUILDIN_FUNC(bg_getareausers)
-{
-	const char *str;
+	return 0;
+}
+
+static int bg_cleanmap_sub(struct block_list *bl, va_list ap)
+{
+	nullpo_ret(bl);
+	map_clearflooritem(bl);
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_cleanmap)
+{
+	const char* map_name;
+	int m;
+
+	map_name = script_getstr(st,3);
+	m = map_mapname2mapid(map_name);
+
+	map_foreachinmap(bg_cleanmap_sub,m,BL_ITEM);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_destroy)
+{
+	int bg_id = script_getnum(st,2);
+	bg_team_clean(bg_id, true);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_clean)
+{
+	int bg_id = script_getnum(st,2);
+	bg_team_clean(bg_id, false);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getareausers)
+{
+	const char *str;
 	int16 m, x0, y0, x1, y1;
 	int bg_id;
 	int i = 0, c = 0;
@@ -15760,12 +17914,40 @@
 	map[m].bgscore_eagle = script_getnum(st,4);
 
 	clif_bg_updatescore(m);
-	return 0;
-}
-
-BUILDIN_FUNC(bg_get_data)
-{
-	struct battleground_data *bg;
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_updatescore)
+{
+	struct battleground_data *bg;
+	int bg_id = script_getnum(st,2),
+		score = script_getnum(st,3);
+
+	if( (bg = bg_team_search(bg_id)) != NULL )
+	{
+		bg->team_score = score;
+		clif_bg_updatescore_team(bg);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_guildid)
+{
+	struct battleground_data *bg;
+	int bg_id = script_getnum(st,2),
+		guild_id = 0;
+
+	if( (bg = bg_team_search(bg_id)) != NULL && bg->g )
+		guild_id = bg->g->guild_id;
+
+	script_pushint(st,guild_id);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_get_data)
+{
+	struct battleground_data *bg;
 	int bg_id = script_getnum(st,2),
 	    type = script_getnum(st,3);
 
@@ -15775,19 +17957,231 @@
 	}
 
 	switch(type) {
-		case 0: script_pushint(st, bg->count); break;
-		default:
+		case 0: script_pushint(st, bg->count); break;
+		case 1: // Users and List
+			{
+				int i, j = 0;
+				struct map_session_data *sd;
+				for( i = 0; i < bg->count; i++ )
+				{
+					if( (sd = bg->members[i].sd) == NULL )
+						continue;
+					mapreg_setregstr(reference_uid(add_str("$@bgmembers$"),j),sd->status.name);
+					j++;
+				}
+				script_pushint(st, j);
+			}
+			break;
+		case 2:
+			script_pushconststr(st,bg->g ? bg->g->name : "null");
+			break;
+		case 3:
+			script_pushconststr(st,bg->g ? bg->g->master : "null");
+			break;
+		case 4:
+			script_pushint(st,bg->color);
+			break;
+
+		default:
 			ShowError("script:bg_get_data: unknown data identifier %d\n", type);
 			break;
 	}
 
-	return 0;
-}
+	return 0;
+}
+
+BUILDIN_FUNC(bg_rankpoints)
+{
+	struct map_session_data *sd;
+	struct battleground_data *bg;
+	const char *type;
+	int i, add_value, flag;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4));
+	else
+		sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		return 0;
+
+	if( !sd->bg_id || (bg = bg_team_search(sd->bg_id)) == NULL )
+		return 0;
+	ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
+	if( i >= MAX_BG_MEMBERS )
+		return 0;
+
+	flag = bg->members[i].ranked ? 2 : 3;
+	type = script_getstr(st,2);
+	add_value = script_getnum(st,3);
+
+	// Just +1 Fame Point
+	if( !strcmpi(type,"fame") )
+		pc_addfame(sd,add_value,flag);
+	// Normal Ranking actions
+	else if( !strcmpi(type,"skulls") )
+	{
+		add2limit(sd->status.bgstats.skulls,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_TI_SKULLS,add_value);
+		pc_addfame(sd,2 * add_value,flag);
+	}
+	else if( !strcmpi(type,"eos_flags") )
+	{
+		add2limit(sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_EOS_FLAGS,1);
+		pc_addfame(sd,5,flag);
+	}
+	else if( !strcmpi(type,"sc_stole") )
+	{
+		pc_addfame(sd,1,flag);
+		achievement_validate_bg(sd,ATB_SC_TAKE,1);
+		add2limit(sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"sc_captured") )
+	{
+		add2limit(sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_SC_CAPTURED,1);
+		pc_addfame(sd,5,flag);
+	}
+	else if( !strcmpi(type,"sc_droped") )
+	{
+		add2limit(sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_SC_DROP,1);
+	}
+	else if( !strcmpi(type,"ctf_taken") )
+	{
+		add2limit(sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_CTF_TAKE,1);
+		pc_addfame(sd,1,flag);
+	}
+	else if( !strcmpi(type,"ctf_captured") )
+	{
+		add2limit(sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_CTF_CAPTURED,1);
+		pc_addfame(sd,25,flag);
+	}
+	else if( !strcmpi(type,"ctf_droped") )
+	{
+		add2limit(sd->status.bgstats.ctf_droped,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_CTF_DROP,1);
+	}
+	else if( !strcmpi(type,"dom_off_kills") )
+	{
+		add2limit(sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_DOM_OFFKILLS,1);
+	}
+	else if( !strcmpi(type,"dom_def_kills") )
+	{
+		add2limit(sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+		achievement_validate_bg(sd,ATB_DOM_DEFKILLS,1);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_rankpoints_area)
+{
+	const char *str, *type;
+	int m, x0, y0, x1, y1, bg_id;
+	int i = 0, add_value;
+	int type_val;
+	struct battleground_data *bg = NULL;
+	struct map_session_data *sd;
+
+	bg_id = script_getnum(st,2);
+	str = script_getstr(st,3);
+
+	if( (bg = bg_team_search(bg_id)) == NULL || (m = map_mapname2mapid(str)) < 0 )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	x0 = script_getnum(st,4);
+	y0 = script_getnum(st,5);
+	x1 = script_getnum(st,6);
+	y1 = script_getnum(st,7);
+	type = script_getstr(st,8);
+
+	if( !strcmpi(type,"eos_bases") )
+		type_val = 1;
+	else if( !strcmpi(type,"dom_bases") )
+		type_val = 2;
+	else return 0; // Invalid Type
+
+	add_value = script_getnum(st,9);
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
+		if( sd->bl.m != m || sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1 )
+			continue;
+
+		switch( type_val )
+		{
+		case 1:
+			add2limit(sd->status.bgstats.eos_bases,add_value,USHRT_MAX);
+			achievement_validate_bg(sd,ATB_EOS_BASES,1);
+			pc_addfame(sd,10,(bg->members[i].ranked ? 2 : 3));
+			break;
+		case 2:
+			add2limit(sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+			achievement_validate_bg(sd,ATB_DOM_BASES,1);
+			pc_addfame(sd,10,(bg->members[i].ranked ? 2 : 3));
+			break;
+		}
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getitem)
+{
+	int bg_id, nameid, amount;
+
+	bg_id = script_getnum(st,2);
+	nameid = script_getnum(st,3);
+	amount = script_getnum(st,4);
+
+	bg_team_getitem(bg_id, nameid, amount);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getkafrapoints)
+{
+	int bg_id, amount;
+
+	bg_id = script_getnum(st,2);
+	amount = script_getnum(st,3);
+
+	bg_team_get_kafrapoints(bg_id, amount);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_reward)
+{
+	int bg_id, nameid, amount, kafrapoints, quest_id, add_value, bg_arena, bg_result;
+	const char *var;
+
+	bg_id = script_getnum(st,2);
+	nameid = script_getnum(st,3);
+	amount = script_getnum(st,4);
+	kafrapoints = script_getnum(st,5);
+	quest_id = script_getnum(st,6);
+	var = script_getstr(st,7);
+	add_value = script_getnum(st,8);
+	bg_arena = script_getnum(st,9);
+	bg_result = script_getnum(st,10);
+
+	bg_team_rewards(bg_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena, bg_result);
+	return 0;
+}
+
+/*==========================================
+ * Instancing Script Commands
+ *------------------------------------------*/
 
-/*==========================================
- * Instancing Script Commands
- *------------------------------------------*/
-
 BUILDIN_FUNC(instance_create)
 {
 	const char *name;
@@ -16079,12 +18473,79 @@
 		if((pl_sd = p->data[i].sd) && map[pl_sd->bl.m].instance_id == st->instance_id) pc_setpos(pl_sd,mapindex,x,y,CLR_TELEPORT);
 
 	return 0;
-}
-
-/*==========================================
- * instance_check_party [malufett]
- * Values:
- * party_id : Party ID of the invoking character. [Required Parameter]
+}
+
+/*==========================================
+ * PlayTime
+ *------------------------------------------*/
+BUILDIN_FUNC(get_playtime)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+	
+	pc_calc_playtime(sd);
+	script_pushint(st,sd->status.playtime);
+	return 0;
+}
+/*==========================================
+ * Premium account check
+ *------------------------------------------*/
+BUILDIN_FUNC(isPremium)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	if( sd == NULL || !pc_isPremium(sd) )
+		script_pushint(st,0);
+	else
+		script_pushint(st,1);
+	return 0;
+}
+/*==========================================
+ * Hunting Missions [Zephyrus]
+ *------------------------------------------*/
+BUILDIN_FUNC(mission_sethunting)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	int index, i;
+	char varname[32];
+
+	if( sd == NULL )
+		return 0;
+
+	index = script_getnum(st,2);
+	if( index < 1 || index > 5 )
+		return 0; // Invalid Index
+
+	i = index - 1;
+
+	sprintf(varname, "Mission_ID%d", index);
+	sd->hunting[i].mob_id = script_getnum(st,3);
+	pc_setglobalreg(sd, varname, sd->hunting[i].mob_id);
+
+	sprintf(varname, "Mission_Count%d", index);
+	sd->hunting[i].count = script_getnum(st,4);
+	pc_setglobalreg(sd, varname, sd->hunting[i].count);
+
+	return 0;
+}
+
+BUILDIN_FUNC(mission_settime)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+
+	if( sd == NULL )
+		return 0;
+
+	sd->hunting_time = script_getnum(st,2);
+	pc_setglobalreg(sd, "Mission_Tick", sd->hunting_time);
+
+	return 0;
+}
+
+/*==========================================
+ * instance_check_party [malufett]
+ * Values:
+ * party_id : Party ID of the invoking character. [Required Parameter]
  * amount : Amount of needed Partymembers for the Instance. [Optional Parameter]
  * min : Minimum Level needed to join the Instance. [Optional Parameter]
  * max : Maxium Level allowed to join the Instance. [Optional Parameter]
@@ -16787,13 +19248,13 @@
 	for(i = 0; i < qty; i += get_count) {
 		// if not pet egg
 		if(!pet_create_egg(sd, nameid)) {
-			if((flag = pc_additem(sd, &item_tmp, get_count, LOG_TYPE_SCRIPT))) {
-				clif_additem(sd, 0, 0, flag);
-				if(pc_candrop(sd,&item_tmp))
-					map_addflooritem(&item_tmp,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-			}
-		}
-	}
+			if ((flag = pc_additem(sd, &item_tmp, get_count, LOG_TYPE_SCRIPT))) {
+				clif_additem(sd, 0, 0, flag);
+				if( pc_candrop(sd,&item_tmp) )
+					map_addflooritem(&item_tmp,get_count,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+		}
+	}
 
 	return 0;
 }
@@ -16969,12 +19430,12 @@
 	if(pc_issit(sd)) {
 		pc_setstand(sd);
 		skill_sit(sd, 0);
-		clif_standing(&sd->bl);
+		clif_standing(&sd->bl,true);
 	} else {
 		unit_stop_walking(&sd->bl, 1|4);
 		pc_setsit(sd);
 		skill_sit(sd, 1);
-		clif_sitting(&sd->bl);
+		clif_sitting(&sd->bl,true);
 	}
 
 	return 0;
@@ -16995,8 +19456,323 @@
 	return 0;
 }
 
-
-// declarations that were supposed to be exported from npc_chat.c
+
+
+/*==========================================
+ * PvP Event Start/Stop Scripts
+ *------------------------------------------*/
+BUILDIN_FUNC(pvpeventstart)
+{
+	struct map_session_data *pl_sd;
+	struct s_mapiterator* iter;
+
+	iter = mapit_getallusers();
+	for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+		pl_sd->pvpevent_fame = 0;
+
+	mapit_free(iter);
+
+	memset(pvpevent_fame_list, 0, sizeof(pvpevent_fame_list));
+	pvpevent_flag = 1;
+	return 0;
+}
+
+BUILDIN_FUNC(pvpeventstop)
+{
+	memset(pvpevent_fame_list, 0, sizeof(pvpevent_fame_list));
+	pvpevent_flag = 0;
+	return 0;
+}
+
+BUILDIN_FUNC(pvpeventcheck)
+{
+	script_pushint(st,pvpevent_flag);
+	return 0;
+}
+
+BUILDIN_FUNC(pvpevent_addpoints)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	int value = script_getnum(st,2);
+	if( sd == NULL ) return 0;
+
+	sd->pvpevent_fame += value;
+	pc_pvpevent_addfame(sd, true);
+
+	return 0;
+}
+/*==========================================
+ * Ranking Reset
+ *------------------------------------------*/
+BUILDIN_FUNC(rankreset)
+{
+	int type = script_getnum(st,2);
+	if( type >= 0 && type <= 2 )
+		pc_ranking_reset(type,true);
+
+	return 0;
+}
+/*==========================================
+ * Item Destroy
+ *------------------------------------------*/
+BUILDIN_FUNC(item_remove4all)
+{
+	int nameid = script_getnum(st,2);
+	pc_item_remove4all(nameid,true);
+
+	return 0;
+}
+/*==========================================
+ * Guild Ranking - Zeny Investments
+ *------------------------------------------*/
+BUILDIN_FUNC(guild_addzenyeco)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	struct guild_castle *gc;
+	struct guild *g;
+
+	int value = script_getnum(st,2);
+	if( sd == NULL || sd->status.guild_id == 0 || (g = guild_search(sd->status.guild_id)) == NULL || (gc = guild_mapindex2gc(map[sd->bl.m].index)) == NULL )
+		return 0;
+
+	add2limit(g->castle[gc->castle_id].zeny_eco, value, UINT_MAX);
+	g->castle[gc->castle_id].changed = true;
+	if( !agit_flag )
+	{
+		intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+		g->castle[gc->castle_id].changed = false;
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(guild_addzenydef)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	struct guild_castle *gc;
+	struct guild *g;
+
+	int value = script_getnum(st,2);
+	if( sd == NULL || sd->status.guild_id == 0 || (g = guild_search(sd->status.guild_id)) == NULL || (gc = guild_mapindex2gc(map[sd->bl.m].index)) == NULL )
+		return 0;
+
+	add2limit(g->castle[gc->castle_id].zeny_def, value, UINT_MAX);
+	g->castle[gc->castle_id].changed = true;
+	if( !agit_flag )
+	{
+		intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+		g->castle[gc->castle_id].changed = false;
+	}
+	return 0;
+}
+
+/*==========================================
+ * Character PvP Mode
+ *------------------------------------------*/
+BUILDIN_FUNC(getpvpmode)
+{
+	int result = 0;
+	struct map_session_data *sd = script_rid2sd(st);
+	if( sd && sd->state.pvpmode )
+		result = 1;
+
+	script_pushint(st,result);
+	return 0;
+}
+
+/*==========================================
+ * Item Security System
+ *------------------------------------------*/
+BUILDIN_FUNC(setsecurity)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	int value = script_getnum(st,2);
+	if( sd == NULL )
+		return 0;
+
+	sd->state.secure_items = (value)?1:0;
+	return 0;
+}
+
+BUILDIN_FUNC(getsecurity)
+{
+	struct map_session_data *sd = script_rid2sd(st);
+	if( sd == NULL )
+		return 0;
+
+	script_pushint(st,sd->state.secure_items);
+	return 0;
+}
+
+// Graveyard System
+BUILDIN_FUNC(graveyard_info)
+{
+	struct tm *datetime;
+	char buf[128], *output = NULL;
+
+	struct npc_data* nd = map_id2nd(st->oid);
+	int type = script_getnum(st,2);
+
+	if( !nd ) return 0;
+
+	switch( type )
+	{
+	case 1: // Killer Name
+		output = aStrdup(nd->graveyard.killed_by);
+		break;
+	case 2: // Killed Time
+		datetime = localtime(&nd->graveyard.killed_time);
+		strftime(buf, sizeof(buf)-1, "%A, %B %d %Y %X.", datetime);
+		output = aStrdup(buf);
+		break;
+	default: // Victim Name
+		output = aStrdup(nd->graveyard.name);
+		break;
+	}
+
+	if( output )
+		script_pushstr(st,output);
+	else
+		script_pushconststr(st,"");
+
+	return 0;
+}
+
+// Achievement System
+BUILDIN_FUNC(achieve)
+{
+	struct map_session_data* sd = script_rid2sd(st);
+	int id = script_getnum(st,2);
+	struct achievement_data *ad;
+
+	if( (ad = achievement_search(id)) != NULL )
+		achievement_complete(sd,ad);
+
+	return 0;
+}
+
+BUILDIN_FUNC(achievement_info)
+{
+	struct achievement_data *ad;
+	int id, flag;
+
+	id = script_getnum(st,2);
+	flag = script_getnum(st,3);
+
+	if( (ad = achievement_search(id)) == NULL )
+	{
+		ShowError("buildin:achievement_info: No achievement found with id %d.\n",id);
+		return 0;
+	}
+
+	switch( flag )
+	{
+	case 0: // Status
+		{
+			struct map_session_data* sd = script_rid2sd(st);
+			int index;
+			if( !sd )
+			{
+				ShowError("buildin:achievement_info: No player attached.\n");
+				return 0;
+			}
+			index = achievement_index(sd,id);
+			script_pushint(st,(index >= 0 && sd->achievement[index].completed) ? 1 : 0);
+		}
+		break;
+	case 1: // Name
+		script_pushconststr(st,ad->name);
+		break;
+	case 2: // Cut-in
+		script_pushconststr(st,ad->cutin);
+		break;
+	case 3: // Reward Base Exp
+		script_pushint(st,ad->bexp);
+		break;
+	case 4: // Reward Base Exp
+		script_pushint(st,ad->jexp);
+		break;
+	case 5: // Reward Item ID
+		script_pushint(st,ad->nameid);
+		break;
+	}
+
+	return 0;
+}
+
+// Faction and Language System
+BUILDIN_FUNC(setfaction)
+{
+	struct faction_data* fd;
+	struct map_session_data* sd = script_rid2sd(st);
+	int id = script_getnum(st,2);
+
+	if( sd && (fd = faction_search(id)) != NULL )
+	{
+		char output[256];
+		sd->status.faction_id = id;
+		snprintf(output,sizeof(output),"- You have joined the faction [ %s ] -",fd->name);
+		clif_broadcast2(&sd->bl,output,strlen(output) + 1,0xFFA500,0x190,20,0,0,SELF);
+		status_calc_pc(sd,0);
+		sd->lang_id = fd->lang_id;
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(language)
+{
+	struct lang_data* ld;
+	struct map_session_data* sd = script_rid2sd(st);
+	int id = script_getnum(st,2);
+
+	if( sd && (ld = lang_search(id)) != NULL )
+	{
+		char output[256];
+		sd->lang_id = id;
+		snprintf(output,sizeof(output),"- Now you will speak and understand [ %s ] -",ld->name);
+		clif_broadcast2(&sd->bl,output,strlen(output) + 1,0xFFA500,0x190,20,0,0,SELF);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(learnlang)
+{
+	struct lang_data* ld;
+	struct map_session_data* sd = script_rid2sd(st);
+	int id = script_getnum(st,2);
+
+	if( sd && (ld = lang_search(id)) != NULL && !(sd->lang_mastery&lang_pow[id-1]) )
+	{
+		char output[256];
+		sd->lang_mastery |= lang_pow[id-1];
+		pc_setglobalreg(sd,"eAmod_Languages",sd->lang_mastery);
+		snprintf(output,sizeof(output),"- You learn to speak and understand [ %s ] -",ld->name);
+		clif_broadcast2(&sd->bl,output,strlen(output) + 1,0x00FF00,0x190,20,0,0,SELF);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(unlearnlang)
+{
+	struct lang_data* ld;
+	struct map_session_data* sd = script_rid2sd(st);
+	int id = script_getnum(st,2);
+
+	if( sd && (ld = lang_search(id)) != NULL && (sd->lang_mastery&lang_pow[id-1]) )
+	{
+		char output[256];
+		sd->lang_mastery &= ~lang_pow[id-1];
+		pc_setglobalreg(sd,"eAmod_Languages",sd->lang_mastery);
+		snprintf(output,sizeof(output),"- You can't speak and understand [ %s ] anymore -",ld->name);
+		clif_broadcast2(&sd->bl,output,strlen(output) + 1,0xC0C0C0,0x190,20,0,0,SELF);
+	}
+
+	return 0;
+}
+
+// declarations that were supposed to be exported from npc_chat.c
 #ifdef PCRE_SUPPORT
 BUILDIN_FUNC(defpattern);
 BUILDIN_FUNC(activatepset);
@@ -17036,23 +19812,30 @@
 	BUILDIN_DEF(cleararray,"rvi"),
 	BUILDIN_DEF(copyarray,"rri"),
 	BUILDIN_DEF(getarraysize,"r"),
-	BUILDIN_DEF(deletearray,"r?"),
-	BUILDIN_DEF(getelementofarray,"ri"),
-	BUILDIN_DEF(getitem,"vi?"),
-	BUILDIN_DEF(rentitem,"vi"),
-	BUILDIN_DEF(getitem2,"viiiiiiii?"),
-	BUILDIN_DEF(getnameditem,"vv"),
-	BUILDIN_DEF2(grouprandomitem,"groupranditem","i"),
-	BUILDIN_DEF(makeitem,"visii"),
+	BUILDIN_DEF(deletearray,"r?"),
+	BUILDIN_DEF(getelementofarray,"ri"),
+	BUILDIN_DEF(getitem,"vi?"),
+	BUILDIN_DEF(storeitem,"vi?"),
+	BUILDIN_DEF(rentitem,"vi"),
+	BUILDIN_DEF(itembound,"vi?"),
+	BUILDIN_DEF(getitem2,"viiiiiiii?"),
+	BUILDIN_DEF(storeitem2,"viiiiiiii?"),
+	BUILDIN_DEF(checkspace,"viiiiiiii"),
+	BUILDIN_DEF(rentitem2,"viiiiiiii"),
+	BUILDIN_DEF(itembound2,"viiiiiiii?"),
+	BUILDIN_DEF(getnameditem,"vv"),
+	BUILDIN_DEF2(grouprandomitem,"groupranditem","i"),
+	BUILDIN_DEF(makeitem,"visii"),
 	BUILDIN_DEF(delitem,"vi?"),
 	BUILDIN_DEF(delitem2,"viiiiiiii?"),
 	BUILDIN_DEF2(enableitemuse,"enable_items",""),
-	BUILDIN_DEF2(disableitemuse,"disable_items",""),
-	BUILDIN_DEF(cutin,"si"),
-	BUILDIN_DEF(viewpoint,"iiiii"),
-	BUILDIN_DEF(heal,"ii"),
-	BUILDIN_DEF(itemheal,"ii"),
-	BUILDIN_DEF(percentheal,"ii"),
+	BUILDIN_DEF2(disableitemuse,"disable_items",""),
+	BUILDIN_DEF(cutin,"si"),
+	BUILDIN_DEF(viewpoint,"iiiii"),
+	BUILDIN_DEF(viewpointmap,"siiiii"),
+	BUILDIN_DEF(heal,"ii"),
+	BUILDIN_DEF(itemheal,"ii"),
+	BUILDIN_DEF(percentheal,"ii"),
 	BUILDIN_DEF(rand,"i?"),
 	BUILDIN_DEF(countitem,"v"),
 	BUILDIN_DEF(countitem2,"viiiiiii"),
@@ -17077,15 +19860,17 @@
 	BUILDIN_DEF(getequipisequiped,"i"),
 	BUILDIN_DEF(getequipisenableref,"i"),
 	BUILDIN_DEF(getequipisidentify,"i"),
-	BUILDIN_DEF(getequiprefinerycnt,"i"),
-	BUILDIN_DEF(getequipweaponlv,"i"),
-	BUILDIN_DEF(getequippercentrefinery,"i"),
-	BUILDIN_DEF(successrefitem,"i"),
-	BUILDIN_DEF(failedrefitem,"i"),
-	BUILDIN_DEF(downrefitem,"i"),
-	BUILDIN_DEF(statusup,"i"),
-	BUILDIN_DEF(statusup2,"ii"),
-	BUILDIN_DEF(bonus,"iv"),
+	BUILDIN_DEF(getequiprefinerycnt,"i"),
+	BUILDIN_DEF(getequipweaponlv,"i"),
+	BUILDIN_DEF(getequippercentrefinery,"i"),
+	BUILDIN_DEF(getequipisrental,"i"),
+	BUILDIN_DEF(getequipisbounded,"i"),
+	BUILDIN_DEF(successrefitem,"i"),
+	BUILDIN_DEF(failedrefitem,"i"),
+	BUILDIN_DEF(downrefitem,"i"),	BUILDIN_DEF(failedrefitemR,"ii"),
+	BUILDIN_DEF(statusup,"i"),
+	BUILDIN_DEF(statusup2,"ii"),
+	BUILDIN_DEF(bonus,"iv"),
 	BUILDIN_DEF2(bonus,"bonus2","ivi"),
 	BUILDIN_DEF2(bonus,"bonus3","ivii"),
 	BUILDIN_DEF2(bonus,"bonus4","ivvii"),
@@ -17117,18 +19902,23 @@
 	BUILDIN_DEF(savepoint,"sii"),
 	BUILDIN_DEF(gettimetick,"i"),
 	BUILDIN_DEF(gettime,"i"),
-	BUILDIN_DEF(gettimestr,"si"),
-	BUILDIN_DEF(openstorage,""),
-	BUILDIN_DEF(guildopenstorage,""),
-	BUILDIN_DEF(itemskill,"vi"),
-	BUILDIN_DEF(produce,"i"),
-	BUILDIN_DEF(cooking,"i"),
-	BUILDIN_DEF(monster,"siisii???"),
-	BUILDIN_DEF(getmobdrops,"i"),
-	BUILDIN_DEF(areamonster,"siiiisii???"),
-	BUILDIN_DEF(killmonster,"ss?"),
-	BUILDIN_DEF(killmonsterall,"s?"),
-	BUILDIN_DEF(clone,"siisi????"),
+	BUILDIN_DEF(gettimestr,"si"),
+	BUILDIN_DEF(openstorage,""),
+	BUILDIN_DEF(guildopenstorage,""),
+	BUILDIN_DEF(openrentstorage,""),
+	BUILDIN_DEF(itemskill,"vi"),
+	BUILDIN_DEF(produce,"i"),
+	BUILDIN_DEF(cooking,"i"),
+	BUILDIN_DEF(monster,"siisii???"),
+	BUILDIN_DEF(mobdemolition,"siiiiii"),
+	BUILDIN_DEF2(mobevent,"mobevent","siisiiiiiiiiiiiiii?"),
+	BUILDIN_DEF(getmobrandid,"ii"),
+	BUILDIN_DEF(getmobdrops,"i"),
+	BUILDIN_DEF(areamonster,"siiiisii???"),
+	BUILDIN_DEF(invocar,"ii"),
+	BUILDIN_DEF(killmonster,"ss?"),
+	BUILDIN_DEF(killmonsterall,"s?"),
+	BUILDIN_DEF(clone,"siisi????"),
 	BUILDIN_DEF(doevent,"s"),
 	BUILDIN_DEF(donpcevent,"s"),
 	BUILDIN_DEF(cmdothernpc,"ss"),
@@ -17189,16 +19979,16 @@
 	BUILDIN_DEF(pvpon,"s"),
 	BUILDIN_DEF(pvpoff,"s"),
 	BUILDIN_DEF(gvgon,"s"),
-	BUILDIN_DEF(gvgoff,"s"),
-	BUILDIN_DEF(emotion,"i??"),
-	BUILDIN_DEF(maprespawnguildid,"sii"),
-	BUILDIN_DEF(agitstart,""),  // <Agit>
-	BUILDIN_DEF(agitend,""),
-	BUILDIN_DEF(agitcheck,""),   // <Agitcheck>
-	BUILDIN_DEF(flagemblem,"i"),    // Flag Emblem
-	BUILDIN_DEF(getcastlename,"s"),
-	BUILDIN_DEF(getcastledata,"si"),
-	BUILDIN_DEF(setcastledata,"sii"),
+	BUILDIN_DEF(gvgoff,"s"),
+	BUILDIN_DEF(emotion,"i??"),
+	BUILDIN_DEF(maprespawnguildid,"sii"),
+	BUILDIN_DEF(agitstart,"?"),	// <Agit>
+	BUILDIN_DEF(agitend,""),
+	BUILDIN_DEF(agitcheck,""),   // <Agitcheck>
+	BUILDIN_DEF(flagemblem,"i?"),	// Flag Emblem
+	BUILDIN_DEF(getcastlename,"s"),
+	BUILDIN_DEF(getcastledata,"si"),
+	BUILDIN_DEF(setcastledata,"sii"),
 	BUILDIN_DEF(requestguildinfo,"i?"),
 	BUILDIN_DEF(getequipcardcnt,"i"),
 	BUILDIN_DEF(successremovecards,"i"),
@@ -17212,13 +20002,13 @@
 	BUILDIN_DEF(getmotherid,""),
 	BUILDIN_DEF(getfatherid,""),
 	BUILDIN_DEF(warppartner,"sii"),
-	BUILDIN_DEF(getitemname,"v"),
-	BUILDIN_DEF(getitemslots,"i"),
-	BUILDIN_DEF(makepet,"i"),
-	BUILDIN_DEF(getexp,"ii"),
-	BUILDIN_DEF(getinventorylist,""),
-	BUILDIN_DEF(getskilllist,""),
-	BUILDIN_DEF(clearitem,""),
+	BUILDIN_DEF(getitemname,"v"),
+	BUILDIN_DEF(getitemslots,"i"),
+	BUILDIN_DEF(makepet,"i"),
+	BUILDIN_DEF(getexp,"ii?"), // [Zephyrus] Added Custom Exp Rates
+	BUILDIN_DEF(getinventorylist,""),
+	BUILDIN_DEF(getskilllist,""),
+	BUILDIN_DEF(clearitem,""),
 	BUILDIN_DEF(classchange,"ii"),
 	BUILDIN_DEF(misceffect,"i"),
 	BUILDIN_DEF(playBGM,"s"),
@@ -17256,12 +20046,14 @@
 	BUILDIN_DEF(checkoption1,"i"),
 	BUILDIN_DEF(checkoption2,"i"),
 	BUILDIN_DEF(guildgetexp,"i"),
-	BUILDIN_DEF(guildchangegm,"is"),
-	BUILDIN_DEF(logmes,"s"), //this command actls as MES but rints info into LOG file either SQL/TXT [Lupus]
-	BUILDIN_DEF(summon,"si??"), // summons a slave monster [Celest]
-	BUILDIN_DEF(isnight,""), // check whether it is night time [Celest]
-	BUILDIN_DEF(isday,""), // check whether it is day time [Celest]
-	BUILDIN_DEF(isequipped,"i*"), // check whether another item/card has been equipped [Celest]
+	BUILDIN_DEF(guildchangegm,"is"),
+	BUILDIN_DEF(logmes,"s"), //this command actls as MES but rints info into LOG file either SQL/TXT [Lupus]
+	BUILDIN_DEF(summon,"si??"), // summons a slave monster [Celest]
+	BUILDIN_DEF(summonspecial,"siiii?"), // Un Slave Monster del tipo evento [Zephyrus] - (nombre del mob, class, hp+, tiempo del mob, mostrarhp, evento)
+	BUILDIN_DEF(summongroup,"ii*"), // El anterior pero en grupos
+	BUILDIN_DEF(isnight,""), // check whether it is night time [Celest]
+	BUILDIN_DEF(isday,""), // check whether it is day time [Celest]
+	BUILDIN_DEF(isequipped,"i*"), // check whether another item/card has been equipped [Celest]
 	BUILDIN_DEF(isequippedcnt,"i*"), // check how many items/cards are being equipped [Celest]
 	BUILDIN_DEF(cardscnt,"i*"), // check how many items/cards are being equipped in the same arm [Lupus]
 	BUILDIN_DEF(getrefine,""), // returns the refined number of the current item, or an item with index specified [celest]
@@ -17301,12 +20093,14 @@
 	BUILDIN_DEF(strpos,"ss?"),
 	BUILDIN_DEF(replacestr,"sss??"),
 	BUILDIN_DEF(countstr,"ss?"),
-	BUILDIN_DEF(setnpcdisplay,"sv??"),
-	BUILDIN_DEF(compare,"ss"), // Lordalfa - To bring strstr to scripting Engine.
-	BUILDIN_DEF(getiteminfo,"ii"), //[Lupus] returns Items Buy / sell Price, etc info
-	BUILDIN_DEF(setiteminfo,"iii"), //[Lupus] set Items Buy / sell Price, etc info
-	BUILDIN_DEF(getequipcardid,"ii"), //[Lupus] returns CARD ID or other info from CARD slot N of equipped item
-	// [zBuffer] List of mathematics commands --->
+	BUILDIN_DEF(setnpcdisplay,"sv??"),
+	BUILDIN_DEF(compare,"ss"), // Lordalfa - To bring strstr to scripting Engine.
+	BUILDIN_DEF(getiteminfo,"ii"), //[Lupus] returns Items Buy / sell Price, etc info
+	BUILDIN_DEF(getitemisrefinable,"i"), // [Zephyrus] Report if the item is refinable
+	BUILDIN_DEF(getitemisequipable,"i"), // [Zephyrus] Reports if the item is equipable by sd
+	BUILDIN_DEF(setiteminfo,"iii"), //[Lupus] set Items Buy / sell Price, etc info
+	BUILDIN_DEF(getequipcardid,"ii"), //[Lupus] returns CARD ID or other info from CARD slot N of equipped item
+	// [zBuffer] List of mathematics commands --->
 	BUILDIN_DEF(sqrt,"i"),
 	BUILDIN_DEF(pow,"ii"),
 	BUILDIN_DEF(distance,"iiii"),
@@ -17326,23 +20120,24 @@
 	BUILDIN_DEF(autoequip,"ii"),
 	BUILDIN_DEF(setbattleflag,"si"),
 	BUILDIN_DEF(getbattleflag,"s"),
-	BUILDIN_DEF(setitemscript,"is?"), //Set NEW item bonus script. Lupus
-	BUILDIN_DEF(disguise,"i"), //disguise player. Lupus
-	BUILDIN_DEF(undisguise,""), //undisguise player. Lupus
-	BUILDIN_DEF(getmonsterinfo,"ii"), //Lupus
-	BUILDIN_DEF(axtoi,"s"),
-	BUILDIN_DEF(query_sql,"s*"),
+	BUILDIN_DEF(setitemscript,"is?"), //Set NEW item bonus script. Lupus
+	BUILDIN_DEF(disguise,"i"), //disguise player. Lupus
+	BUILDIN_DEF(undisguise,""), //undisguise player. Lupus
+	BUILDIN_DEF(isdisguised,""), // [Zephyrus]
+	BUILDIN_DEF(getmonsterinfo,"ii"), //Lupus
+	BUILDIN_DEF(axtoi,"s"),
+	BUILDIN_DEF(query_sql,"s*"),
 	BUILDIN_DEF(query_logsql,"s*"),
 	BUILDIN_DEF(escape_sql,"v"),
 	BUILDIN_DEF(atoi,"s"),
 	// [zBuffer] List of player cont commands --->
-	BUILDIN_DEF(rid2name,"i"),
-	BUILDIN_DEF(pcfollow,"ii"),
-	BUILDIN_DEF(pcstopfollow,"i"),
-	BUILDIN_DEF(pcblockmove,"ii"),
-	// <--- [zBuffer] List of player cont commands
-	// [zBuffer] List of mob control commands --->
-	BUILDIN_DEF(unitwalk,"ii?"),
+	BUILDIN_DEF(rid2name,"i"),
+	BUILDIN_DEF(pcfollow,"ii"),
+	BUILDIN_DEF(pcstopfollow,"i"),
+	BUILDIN_DEF(pcblock,"ii?"),
+	// <--- [zBuffer] List of player cont commands
+	// [zBuffer] List of mob control commands --->
+	BUILDIN_DEF(unitwalk,"ii?"),
 	BUILDIN_DEF(unitkill,"i"),
 	BUILDIN_DEF(unitwarp,"isii"),
 	BUILDIN_DEF(unitattack,"iv?"),
@@ -17366,12 +20161,25 @@
 	BUILDIN_DEF(checkchatting,"?"),
 	BUILDIN_DEF(checkidle,"?"),
 	BUILDIN_DEF(openmail,""),
-	BUILDIN_DEF(openauction,""),
-	BUILDIN_DEF(checkcell,"siii"),
-	BUILDIN_DEF(setcell,"siiiiii"),
-	BUILDIN_DEF(setwall,"siiiiis"),
-	BUILDIN_DEF(delwall,"s"),
-	BUILDIN_DEF(searchitem,"rs"),
+	BUILDIN_DEF(openauction,""),
+	BUILDIN_DEF(checkcell,"siii"),
+	BUILDIN_DEF(setcell,"siiiiii"),
+	BUILDIN_DEF(chatmessage,"sii"),
+	BUILDIN_DEF(strcmpi,"ss"),
+	BUILDIN_DEF(flooritem,"ii"),
+	BUILDIN_DEF(flooritem2xy,"siiii"),
+	BUILDIN_DEF(partyitem,"ii"),
+	BUILDIN_DEF(mission_sethunting,"iii"),
+	BUILDIN_DEF(mission_settime,"i"),
+	BUILDIN_DEF(killslaves,""),
+	BUILDIN_DEF(class2ancientwoe,""),
+	BUILDIN_DEF(pvpeventstart,""),
+	BUILDIN_DEF(pvpeventstop,""),
+	BUILDIN_DEF(pvpeventcheck,""),
+	BUILDIN_DEF(pvpevent_addpoints,"i"),
+	BUILDIN_DEF(setwall,"siiiiis"),
+	BUILDIN_DEF(delwall,"s"),
+	BUILDIN_DEF(searchitem,"rs"),
 	BUILDIN_DEF(mercenary_create,"ii"),
 	BUILDIN_DEF(mercenary_heal,"ii"),
 	BUILDIN_DEF(mercenary_sc_start,"iii"),
@@ -17385,28 +20193,58 @@
 	BUILDIN_DEF(progressbar,"si"),
 	BUILDIN_DEF(pushpc,"ii"),
 	BUILDIN_DEF(buyingstore,"i"),
-	BUILDIN_DEF(searchstores,"ii"),
-	BUILDIN_DEF(showdigit,"i?"),
-	// WoE SE
-	BUILDIN_DEF(agitstart2,""),
-	BUILDIN_DEF(agitend2,""),
-	BUILDIN_DEF(agitcheck2,""),
-	// BattleGround
-	BUILDIN_DEF(waitingroom2bg,"siiss?"),
-	BUILDIN_DEF(waitingroom2bg_single,"isiis"),
-	BUILDIN_DEF(bg_team_setxy,"iii"),
-	BUILDIN_DEF(bg_warp,"isii"),
-	BUILDIN_DEF(bg_monster,"isiisi?"),
-	BUILDIN_DEF(bg_monster_set_team,"ii"),
-	BUILDIN_DEF(bg_leave,""),
-	BUILDIN_DEF(bg_destroy,"i"),
-	BUILDIN_DEF(areapercentheal,"siiiiii"),
-	BUILDIN_DEF(bg_get_data,"ii"),
-	BUILDIN_DEF(bg_getareausers,"isiiii"),
-	BUILDIN_DEF(bg_updatescore,"sii"),
-
-	// Instancing
-	BUILDIN_DEF(instance_create,"si"),
+	BUILDIN_DEF(searchstores,"ii"),
+	BUILDIN_DEF(showdigit,"i?"),
+	// WoE SE
+	BUILDIN_DEF(agitstart2,"?"),
+	BUILDIN_DEF(agitend2,""),
+	BUILDIN_DEF(agitcheck2,""),
+	// BattleGround
+	BUILDIN_DEF(bg_logincount,""),
+	BUILDIN_DEF(map_logincount,"s"),
+	BUILDIN_DEF(bg_team_create,"siiiss"),
+
+	BUILDIN_DEF(bg_queue_create,"ss?"),
+	BUILDIN_DEF(bg_queue_event,"is"),
+	BUILDIN_DEF(bg_queue_join,"i"),
+	BUILDIN_DEF(bg_queue_partyjoin,"ii"),
+	BUILDIN_DEF(bg_queue_leave,"i"),
+	BUILDIN_DEF(bg_queue_data,"ii"),
+	BUILDIN_DEF(bg_queue2team,"iisiiiss"),
+	BUILDIN_DEF(bg_queue2team_single,"iisii"),
+	BUILDIN_DEF(bg_queue2teams,"iiiiii*"),
+	BUILDIN_DEF(bg_queue_checkstart,"iiii"),
+	BUILDIN_DEF(bg_balance_teams,"iiiii*"),
+
+	BUILDIN_DEF(waitingroom2bg,"siiiss"),
+	BUILDIN_DEF(waitingroom2bg_single,"isiis"),
+	BUILDIN_DEF(bg_team_setxy,"iii"),
+	BUILDIN_DEF(bg_team_reveal,"i"),
+	BUILDIN_DEF(bg_team_setquest,"ii"),
+	BUILDIN_DEF(bg_warp,"isii"),
+	BUILDIN_DEF(bg_monster,"isiisi?"),
+	BUILDIN_DEF(bg_monster_reveal,"iii"),
+	BUILDIN_DEF(bg_monster_set_team,"ii"),
+	BUILDIN_DEF(bg_monster_inmunity,"ii"),
+	BUILDIN_DEF(bg_leave,""),
+	BUILDIN_DEF(bg_cleanmap,"s"),
+	BUILDIN_DEF(bg_destroy,"i"),
+	BUILDIN_DEF(bg_clean,"i"),
+	BUILDIN_DEF(areapercentheal,"siiiiii"),
+	BUILDIN_DEF(bg_get_data,"ii"),
+	BUILDIN_DEF(bg_getareausers,"isiiii"),
+	BUILDIN_DEF(bg_rankpoints,"si?"),
+	BUILDIN_DEF(bg_rankpoints_area,"isiiiisi"),
+	BUILDIN_DEF(bg_updatescore,"sii"),
+	BUILDIN_DEF(bg_team_updatescore,"ii"),
+	BUILDIN_DEF(bg_team_guildid,"i"),
+	BUILDIN_DEF(bg_getitem,"iii"),
+	BUILDIN_DEF(bg_getkafrapoints,"ii"),
+	BUILDIN_DEF(bg_reward,"iiiiisiii"),
+	BUILDIN_DEF(bgannounce,"s?????"),
+
+	// Instancing
+	BUILDIN_DEF(instance_create,"si"),
 	BUILDIN_DEF(instance_destroy,"?"),
 	BUILDIN_DEF(instance_attachmap,"si?"),
 	BUILDIN_DEF(instance_detachmap,"s?"),
@@ -17458,7 +20296,30 @@
 	BUILDIN_DEF(checkquest, "i?"),
 	BUILDIN_DEF(changequest, "ii"),
 	BUILDIN_DEF(showevent, "ii"),
+	
+	// Enchanting - Costume
+	BUILDIN_DEF(costume,"i"),
+	BUILDIN_DEF(successenchant,"ii"),
+	BUILDIN_DEF(failedenchant,"i"),
 
+	BUILDIN_DEF(get_playtime,""),
+	BUILDIN_DEF(isPremium,""),
+	BUILDIN_DEF(rankreset,"i"),
+	BUILDIN_DEF(item_remove4all,"i"),
+	BUILDIN_DEF(guild_addzenyeco,"i"),
+	BUILDIN_DEF(guild_addzenydef,"i"),
+	BUILDIN_DEF(getpvpmode,""),
+	BUILDIN_DEF(setsecurity,"i"),
+	BUILDIN_DEF(getsecurity,""),
+
+	BUILDIN_DEF(graveyard_info,"i"),
+	BUILDIN_DEF(achieve,"i"),
+	BUILDIN_DEF(achievement_info,"ii"),
+	BUILDIN_DEF(setfaction,"i"),
+	BUILDIN_DEF(language,"i"),
+	BUILDIN_DEF(learnlang,"i"),
+	BUILDIN_DEF(unlearnlang,"i"),
+
 	// brAthena
 	BUILDIN_DEF(unloadnpc,"s"),  // [Holy]
 	{NULL,NULL,NULL},
Index: src/map/script.h
===================================================================
--- src/map/script.h	(revision 1953)
+++ src/map/script.h	(working copy)
@@ -86,12 +86,15 @@
     C_R_SHIFT, // a >> b
     C_L_SHIFT, // a << b
     C_ADD_PP, // ++a
-    C_SUB_PP, // --a
-} c_op;
-
-struct script_retinfo {
-	struct DBMap *var_function;// scope variables
-	struct script_code *script;// script code
+	C_SUB_PP, // --a
+} c_op;
+
+/// Maximum amount of elements in script arrays
+#define SCRIPT_MAX_ARRAYSIZE 128
+
+struct script_retinfo {
+	struct DBMap* var_function;// scope variables
+	struct script_code* script;// script code
 	int pos;// script location
 	int nargs;// argument count
 	int defsp;// default stack pointer
Index: src/map/skill.c
===================================================================
--- src/map/skill.c	(revision 1953)
+++ src/map/skill.c	(working copy)
@@ -21,12 +21,13 @@
 #include "../common/random.h"
 #include "../common/showmsg.h"
 #include "../common/strlib.h"
-#include "../common/utils.h"
-#include "../common/ers.h"
-
-#include "map.h"
-#include "path.h"
-#include "clif.h"
+#include "../common/utils.h"
+#include "../common/ers.h"
+
+#include "atcommand.h"
+#include "map.h"
+#include "path.h"
+#include "clif.h"
 #include "pc.h"
 #include "status.h"
 #include "skill.h"
@@ -44,12 +45,14 @@
 #include "intif.h"
 #include "log.h"
 #include "chrif.h"
-#include "guild.h"
-#include "date.h"
-#include "unit.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "guild.h"
+#include "date.h"
+#include "unit.h"
+#include "achievement.h"
+#include "faction.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <math.h>
@@ -72,34 +75,13 @@
 #endif
 static struct eri *skill_unit_ers = NULL; //For handling skill_unit's [Skotlex]
 static struct eri *skill_timer_ers = NULL; //For handling skill_timerskills [Skotlex]
-
-DBMap *skillunit_db = NULL; // int id -> struct skill_unit*
-
-/**
- * Skill Cool Down Delay Saving
- * Struct skill_cd is not a member of struct map_session_data
- * to keep cooldowns in memory between player log-ins.
- * All cooldowns are reset when server is restarted.
- **/
-DBMap *skillcd_db = NULL; // char_id -> struct skill_cd
-struct skill_cd {
-	int duration[MAX_SKILL_TREE];//milliseconds
-	short skidx[MAX_SKILL_TREE];//the skill index entries belong to
-	short nameid[MAX_SKILL_TREE];//skill id
-	unsigned char cursor;
-};
-
-/**
- * Skill Unit Persistency during endack routes (mostly for songs see bugreport:4574)
- **/
-DBMap *skillusave_db = NULL; // char_id -> struct skill_usave
-struct skill_usave {
-	uint16 skill_id, skill_lv;
-};
-
-struct s_skill_db skill_db[MAX_SKILL_DB];
-struct s_skill_produce_db skill_produce_db[MAX_SKILL_PRODUCE_DB];
-struct s_skill_arrow_db skill_arrow_db[MAX_SKILL_ARROW_DB];
+
+DBMap* skillunit_db = NULL; // int id -> struct skill_unit*
+
+
+struct s_skill_db skill_db[MAX_SKILL_DB];
+struct s_skill_produce_db skill_produce_db[MAX_SKILL_PRODUCE_DB];
+struct s_skill_arrow_db skill_arrow_db[MAX_SKILL_ARROW_DB];
 struct s_skill_abra_db skill_abra_db[MAX_SKILL_ABRA_DB];
 struct s_skill_improvise_db {
 	uint16 skill_id;
@@ -375,6 +357,10 @@
 {
 	skill_get(skill_db[skill_id].cooldown[skill_lv-1], skill_id, skill_lv);
 }
+int	skill_get_blocked(uint16 skill_id)
+{ 
+	skill_get(skill_db[skill_id].blocked, skill_id, 1); 
+}
 #ifdef RENEWAL_CAST
 int skill_get_fixed_cast(uint16 skill_id ,uint16 skill_lv)
 {
@@ -402,13 +388,42 @@
 static int skill_cell_overlap(struct block_list *bl, va_list ap);
 static int skill_trap_splash(struct block_list *bl, va_list ap);
 struct skill_unit_group_tickset *skill_unitgrouptickset_search(struct block_list *bl,struct skill_unit_group *sg,int tick);
-static int skill_unit_onplace(struct skill_unit *src,struct block_list *bl,unsigned int tick);
-static int skill_unit_onleft(uint16 skill_id, struct block_list *bl,unsigned int tick);
-static int skill_unit_effect(struct block_list *bl,va_list ap);
-
-int enchant_eff[5] = { 10, 14, 17, 19, 20 };
-int deluge_eff[5] = { 5, 9, 12, 14, 15 };
-
+static int skill_unit_onplace(struct skill_unit *src,struct block_list *bl,unsigned int tick);
+static int skill_unit_onleft(uint16 skill_id, struct block_list *bl,unsigned int tick);
+static int skill_unit_effect(struct block_list *bl,va_list ap);
+int skill_blockpc_get(struct map_session_data *sd, uint16 skillid);
+
+/*==========================================
+ * Party/Team Checks for Skills
+ *------------------------------------------*/
+bool skill_check_party(struct map_session_data *sd)
+{
+	if( sd )
+	{
+		if( !map[sd->bl.m].flag.battleground && sd->status.party_id )
+			return true;
+		else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+			return true;
+	}
+	return false;
+}
+
+bool skill_check_sameparty(struct map_session_data *sd1, struct map_session_data *sd2)
+{
+	if( sd1 && sd2 )
+	{
+		if( !map[sd1->bl.m].flag.battleground && sd1->status.party_id && sd1->status.party_id == sd2->status.party_id )
+			return true;
+		else if( map[sd1->bl.m].flag.battleground && sd1->bg_id && sd1->bg_id == sd2->bg_id )
+			return true;
+	}
+	return false;
+}
+
+
+int enchant_eff[5] = { 10, 14, 17, 19, 20 };
+int deluge_eff[5] = { 5, 9, 12, 14, 15 };
+
 int skill_get_casttype(uint16 skill_id)
 {
 	int inf = skill_get_inf(skill_id);
@@ -668,23 +683,25 @@
 	if(!sd->state.autocast && sd->skillitem != skill_id && sd->canskill_tick &&
 	   DIFF_TICK(gettick(), sd->canskill_tick) < (sd->battle_status.amotion * (battle_config.skill_amotion_leniency) / 100)) {
 		// attempted to cast a skill before the attack motion has finished
-		return 1;
-	}
-
-	if(sd->blockskill[idx] > 0) {
-		clif_skill_fail(sd, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
-		return 1;
-	}
+		return 1;
+	}
+
+	if( skill_blockpc_get(sd,skill_id) != -1 ){
+		clif_skill_fail(sd, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
+		return 1;
+	}
 	/**
 	 * It has been confirmed on a official server (thanks to Yommy) that item-cast skills bypass all the restrictions above
 	 * Also, without this check, an exploit where an item casting + healing (or any other kind buff) isn't deleted after used on a restricted map
 	 **/
-	if(sd->skillitem == skill_id)
-		return 0;
-	// Check skill restrictions [Celest]
-	if((!map_flag_vs(m) && skill_get_nocast(skill_id) & 1) ||
-	   (map[m].flag.pvp && skill_get_nocast(skill_id) & 2) ||
-	   (map_flag_gvg(m) && skill_get_nocast(skill_id) & 4) ||
+	if( sd->skillitem == skill_id )
+		return 0;
+	// Check skill restrictions [Celest]
+	if( skill_get_blocked(skill_id) || sd->state.only_walk )
+		return 1;
+	if( (!map_flag_vs(m) && skill_get_nocast (skill_id) & 1) ||
+		(map[m].flag.pvp && skill_get_nocast (skill_id) & 2) ||
+		(map_flag_gvg(m) && skill_get_nocast (skill_id) & 4) ||
 	   (map[m].flag.battleground && skill_get_nocast(skill_id) & 8) ||
 	   (map[m].flag.restricted && map[m].zone && skill_get_nocast(skill_id) & (8*map[m].zone))) {
 		clif_msg(sd, 0x536); // This skill cannot be used within this area
@@ -743,22 +760,31 @@
 			if(map_flag_gvg(m)) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return 1;
-			}
-			break;
-		case GD_EMERGENCYCALL:
-			if(
-			    !(battle_config.emergency_call&((agit_flag || agit2_flag)?2:1)) ||
-			    !(battle_config.emergency_call&(map[m].flag.gvg || map[m].flag.gvg_castle?8:4)) ||
-			    (battle_config.emergency_call&16 && map[m].flag.nowarpto && !map[m].flag.gvg_castle)
-			)   {
-				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
-				return 1;
-			}
-			break;
-		case BS_GREED:
-		case WS_CARTBOOST:
-		case BS_HAMMERFALL:
-		case BS_ADRENALINE:
+			}
+			break;
+		case GD_EMERGENCYCALL:
+			if( map[m].flag.noemergencycall )
+			{
+				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
+				return 1;
+			}
+			if( !map[m].flag.battleground && (!(battle_config.emergency_call&((agit_flag || agit2_flag)?2:1)) || !(battle_config.emergency_call&(map[m].flag.gvg || map[m].flag.gvg_castle?8:4)) || (battle_config.emergency_call&16 && map[m].flag.nowarpto && !map[m].flag.gvg_castle)) )
+			{
+				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
+				return 1;
+			}
+		case GD_BATTLEORDER:
+		case GD_REGENERATION:
+		case GD_RESTORE:
+			if( map[m].flag.ancient )
+				return 1;
+			break;
+		case BS_GREED:
+			if( map[m].flag.ancient )
+				return 1; // eAmod
+		case WS_CARTBOOST:
+		case BS_HAMMERFALL:
+		case BS_ADRENALINE:
 		case MC_CARTREVOLUTION:
 		case MC_MAMMONITE:
 		case WS_MELTDOWN:
@@ -1812,12 +1838,14 @@
 			//Set canact delay. [Skotlex]
 			ud = unit_bl2ud(src);
 			if(ud) {
-				rate = skill_delayfix(src, skill, skill_lv);
-				if(DIFF_TICK(ud->canact_tick, tick + rate) < 0) {
-					ud->canact_tick = tick+rate;
-					if(battle_config.display_status_timers && sd)
-						clif_status_change(src, SI_ACTIONDELAY, 1, rate, 0, 0, 0);
-				}
+				rate = skill_delayfix(src, skill, skill_lv);
+				if (DIFF_TICK(ud->canact_tick, tick + rate) < 0){
+					ud->canact_tick = tick+rate;
+					if( sd && skill_get_cooldown(skill,skill_lv) > 0 )
+						skill_blockpc_start(sd, skill, skill_get_cooldown(skill, skill_lv));
+					if ( battle_config.display_status_timers && sd )
+						clif_status_change(src, SI_ACTIONDELAY, 1, rate, 0, 0, 0);
+				}
 			}
 		}
 	}
@@ -2146,12 +2174,14 @@
 			//Set canact delay. [Skotlex]
 			ud = unit_bl2ud(bl);
 			if(ud) {
-				rate = skill_delayfix(bl, skill_id, skill_lv);
-				if(DIFF_TICK(ud->canact_tick, tick + rate) < 0) {
-					ud->canact_tick = tick+rate;
-					if(battle_config.display_status_timers && dstsd)
-						clif_status_change(bl, SI_ACTIONDELAY, 1, rate, 0, 0, 0);
-				}
+				rate = skill_delayfix(bl, skill_id, skill_lv);
+				if (DIFF_TICK(ud->canact_tick, tick + rate) < 0){
+					ud->canact_tick = tick+rate;
+					if( sd && skill_get_cooldown(skill_id,skill_lv) > 0 )
+						skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
+					if ( battle_config.display_status_timers && dstsd )
+						clif_status_change(bl, SI_ACTIONDELAY, 1, rate, 0, 0, 0);
+				}
 			}
 		}
 	}
@@ -2311,32 +2341,34 @@
 {
 	int dx = 0, dy = 0;
 	struct skill_unit *su = NULL;
+
+	nullpo_ret(src);
+
+	if (src != target && map_flag_gvg3(target->m))
+		return 0; //No knocking back in WoE
+	if (count == 0)
+		return 0; //Actual knockback distance is 0.
 
-	nullpo_ret(src);
-
-	if(src != target && (map_flag_gvg(target->m) || map[target->m].flag.battleground))
-		return 0; //No knocking back in WoE
-	if(count == 0)
-		return 0; //Actual knockback distance is 0.
-
-	switch(target->type) {
-		case BL_MOB: {
-				struct mob_data *md = BL_CAST(BL_MOB, target);
-				if(md->class_ == MOBID_EMPERIUM)
-					return 0;
-				if(src != target && is_boss(target)) //Bosses can't be knocked-back
-					return 0;
+	switch (target->type) {
+		case BL_MOB: {
+				struct mob_data* md = BL_CAST(BL_MOB, target);
+				if( md->class_ == MOBID_EMPERIUM || md->class_ == 1674 )
+					return 0;
+				if(src != target && is_boss(target)) //Bosses can't be knocked-back
+					return 0;
 			}
 			break;
 		case BL_PC: {
 				struct map_session_data *sd = BL_CAST(BL_PC, target);
 				if(sd->sc.data[SC_BASILICA] && sd->sc.data[SC_BASILICA]->val4 == sd->bl.id && !is_boss(src))
-					return 0; // Basilica caster can't be knocked-back by normal monsters.
-				if(!(flag&0x2) && src != target && sd->special_state.no_knockback)
-					return 0;
-			}
-			break;
-		case BL_SKILL:
+					return 0; // Basilica caster can't be knocked-back by normal monsters.
+				if( !(flag&0x2) && src != target && sd->special_state.no_knockback )
+					return 0;
+				if( (sd->state.vending || sd->state.buyingstore) && map[target->m].flag.vending_cell )
+					return 0;
+			}
+			break;
+		case BL_SKILL:
 			su = (struct skill_unit *)target;
 			if(su && su->group && su->group->unit_id == UNT_ANKLESNARE)
 				return 0; // ankle snare cannot be knocked back
@@ -2528,13 +2560,13 @@
 
 	if(damage && sc && sc->data[SC_GENSOU] && dmg.flag&BF_MAGIC) {
 		struct block_list *nbl;
-		nbl = battle_getenemyarea(bl,bl->x,bl->y,2,BL_CHAR,bl->id);
-		if(nbl) {  // Only one target is chosen.
-			damage = damage / 2; // Deflect half of the damage to a target nearby
-			clif_skill_damage(bl, nbl, tick, status_get_amotion(src), 0, status_fix_damage(bl,nbl,damage,0), dmg.div_, OB_OBOROGENSOU_TRANSITION_ATK, -1, 6);
-		}
-	}
-
+		nbl = battle_getenemyarea(bl,bl->x,bl->y,2,BL_CHAR,bl->id);
+		if( nbl ){ // Only one target is chosen.
+			damage = damage / 2; // Deflect half of the damage to a target nearby
+			clif_skill_damage(bl, nbl, tick, status_get_amotion(src), 0, status_fix_damage(bl,nbl,damage,0,0), dmg.div_, OB_OBOROGENSOU_TRANSITION_ATK, -1, 6);
+		}
+	}
+
 	//Skill hit type
 	type=(skill_id==0)?5:skill_get_hit(skill_id);
 
@@ -2727,21 +2759,33 @@
 		case WZ_SIGHTBLASTER:
 			dmg.dmotion = clif_skill_damage(src,bl,tick, dmg.amotion, dmg.dmotion, damage, dmg.div_, skill_id, flag&SD_LEVEL?-1:skill_lv, 5);
 			break;
-		case AB_DUPLELIGHT_MELEE:
-		case AB_DUPLELIGHT_MAGIC:
-			dmg.amotion = 300;/* makes the damage value not overlap with previous damage (when displayed by the client) */
-		default:
-			if(flag&SD_ANIMATION && dmg.div_ < 2)   //Disabling skill animation doesn't works on multi-hit.
-				type = 5;
+	case AB_DUPLELIGHT_MELEE:
+	case AB_DUPLELIGHT_MAGIC:
+		dmg.amotion = 300;/* makes the damage value not overlap with previous damage (when displayed by the client) */
+	case AS_GRIMTOOTH:
+		if( battle_config.anti_mayapurple_hack && sd )
+		{ // Show the user position (Anti WPE Filter)
+			sd->state.evade_antiwpefilter = 1;
+			map_foreachinrange(clif_insight_tbl2bl, src, AREA_SIZE, BL_PC, src);
+		}
+	default:
+		if( flag&SD_ANIMATION && dmg.div_ < 2 ) //Disabling skill animation doesn't works on multi-hit.
+			type = 5;
 			if(bl->type == BL_SKILL) {
 				TBL_SKILL *su = (TBL_SKILL *)bl;
 				if(su->group && skill_get_inf2(su->group->skill_id)&INF2_TRAP)  // show damage on trap targets
-					clif_skill_damage(src,bl,tick, dmg.amotion, dmg.dmotion, damage, dmg.div_, skill_id, flag&SD_LEVEL?-1:skill_lv, 5);
-			}
-			dmg.dmotion = clif_skill_damage(dsrc,bl,tick, dmg.amotion, dmg.dmotion, damage, dmg.div_, skill_id, flag&SD_LEVEL?-1:skill_lv, type);
-			break;
-	}
-
+				clif_skill_damage(src,bl,tick, dmg.amotion, dmg.dmotion, damage, dmg.div_, skill_id, flag&SD_LEVEL?-1:skill_lv, 5);
+		}
+		dmg.dmotion = clif_skill_damage(dsrc,bl,tick, dmg.amotion, dmg.dmotion, damage, dmg.div_, skill_id, flag&SD_LEVEL?-1:skill_lv, type);
+		if( battle_config.anti_mayapurple_hack && sd && skill_id == AS_GRIMTOOTH )
+		{ // Hide the user again (Anti WPE Filter)
+			sd->state.evade_antiwpefilter = 0;
+			if( sd->sc.option&(OPTION_HIDE|OPTION_CLOAK) )
+				clif_clearunit_invisible(src);
+		}
+		break;
+	}
+
 	map_freeblock_lock();
 
 	if(damage > 0 && dmg.flag&BF_SKILL && tsd
@@ -2835,9 +2879,9 @@
 
 	if(!dmg.amotion) {
 		//Instant damage
-		if(!sc || (!sc->data[SC_DEVOTION] && skill_id != CR_REFLECTSHIELD))
-			status_fix_damage(src,bl,damage,dmg.dmotion); //Deal damage before knockback to allow stuff like firewall+storm gust combo.
-		if(!status_isdead(bl) && additional_effects)
+		if( !sc || (!sc->data[SC_DEVOTION] && skill_id != CR_REFLECTSHIELD) )
+			status_fix_damage(src,bl,damage,dmg.dmotion,skill_id); //Deal damage before knockback to allow stuff like firewall+storm gust combo.
+		if( !status_isdead(bl) && additional_effects )
 			skill_additional_effect(src,bl,skill_id,skill_lv,dmg.flag,dmg.dmg_lv,tick);
 		if(damage > 0)   //Counter status effects [Skotlex]
 			skill_counter_additional_effect(src,bl,skill_id,skill_lv,dmg.flag,tick);
@@ -2923,17 +2967,17 @@
 		   ) && check_distance_bl(bl, d_bl, sce->val3)) {
 			if(!rmdamage) {
 				clif_damage(d_bl,d_bl, gettick(), 0, 0, damage, 0, 0, 0);
-				status_fix_damage(NULL,d_bl, damage, 0);
+				status_fix_damage(NULL,d_bl, damage, 0, 0);
 			} else { //Reflected magics are done directly on the target not on paladin
 				//This check is only for magical skill.
 				//For BF_WEAPON skills types track var rdamage and function battle_calc_return_damage
 				clif_damage(bl,bl, gettick(), 0, 0, damage, 0, 0, 0);
-				status_fix_damage(bl,bl, damage, 0);
+				status_fix_damage(bl,bl, damage, 0, 0);
 			}
 		} else {
 			status_change_end(bl, SC_DEVOTION, INVALID_TIMER);
 			if(!dmg.amotion)
-				status_fix_damage(src,bl,damage,dmg.dmotion);
+				status_fix_damage(src,bl,damage,dmg.dmotion, 0);
 		}
 	}
 
@@ -2963,13 +3007,13 @@
 			if(src != bl)  // Don't reflect your own damage (Grand Cross)
 				map_foreachinshootrange(battle_damage_area,bl,skill_get_splash(LG_REFLECTDAMAGE,1),BL_CHAR,tick,bl,dmg.amotion,sstatus->dmotion,rdamage,tstatus->race);
 		} else {
-			if(dmg.amotion)
-				battle_delay_damage(tick, dmg.amotion,bl,src,0,CR_REFLECTSHIELD,0,rdamage,ATK_DEF,0,additional_effects);
-			else
-				status_fix_damage(bl,src,rdamage,0);
-			clif_damage(src,src,tick, dmg.amotion,0,rdamage,1,4,0); // in aegis damage reflected is shown in single hit.
-			//Use Reflect Shield to signal this kind of skill trigger. [Skotlex]
-			if(tsd && src != bl)
+			if( dmg.amotion )
+				battle_delay_damage(tick, dmg.amotion,bl,src,0,CR_REFLECTSHIELD,0,rdamage,ATK_DEF,0,additional_effects);
+			else
+				status_fix_damage(bl,src,rdamage,0,0);
+			clif_damage(src,src,tick, dmg.amotion,0,rdamage,1,4,0); // in aegis damage reflected is shown in single hit.
+			//Use Reflect Shield to signal this kind of skill trigger. [Skotlex]
+			if( tsd && src != bl )
 				battle_drain(tsd, src, rdamage, rdamage, sstatus->race, is_boss(src));
 			skill_additional_effect(bl, src, CR_REFLECTSHIELD, 1, BF_WEAPON|BF_SHORT|BF_NORMAL,ATK_DEF,tick);
 		}
@@ -3459,13 +3503,13 @@
 				case SR_WINDMILL:
 					if(target->type == BL_PC) {
 						struct map_session_data *tsd = NULL;
-						if((tsd = ((TBL_PC *)target)) && !pc_issit(tsd)) {
-							pc_setsit(tsd);
-							skill_sit(tsd,1);
-							clif_sitting(&tsd->bl);
-						}
-					}
-					break;
+						if( (tsd = ((TBL_PC*)target)) && !pc_issit(tsd) ) {
+							pc_setsit(tsd);
+							skill_sit(tsd,1);
+							clif_sitting(&tsd->bl,true);
+						}
+					}
+					break;
 				case LG_OVERBRAND_BRANDISH:
 				case LG_OVERBRAND_PLUSATK:
 				case SR_KNUCKLEARROW:
@@ -4571,13 +4615,13 @@
 					if(!(sg->unit_id == UNT_USED_TRAPS || (sg->unit_id == UNT_ANKLESNARE && sg->val2 != 0))) {
 						struct item item_tmp;
 						memset(&item_tmp,0,sizeof(item_tmp));
-						item_tmp.nameid = sg->item_id?sg->item_id:ITEMID_TRAP;
-						item_tmp.identify = 1;
-						if(item_tmp.nameid)
-							map_addflooritem(&item_tmp,1,bl->m,bl->x,bl->y,0,0,0,0);
-					}
-					skill_delunit(su);
-				}
+					item_tmp.nameid = sg->item_id?sg->item_id:ITEMID_TRAP;
+					item_tmp.identify = 1;
+					if( item_tmp.nameid )
+						map_addflooritem(&item_tmp,1,bl->m,bl->x,bl->y,0,0,0,0,0);
+				}
+				skill_delunit(su);
+			}
 			}
 			break;
 		case NC_INFRAREDSCAN:
@@ -5011,16 +5055,18 @@
 				int heal_get_jobexp;
 				//Highness Heal: starts at 1.5 boost + 0.5 for each level
 				if(skill_id == AB_HIGHNESSHEAL) {
-					heal = heal * ( 17 + 3 * skill_lv ) / 10;
-				}
-				if(status_isimmune(bl) ||
-				   (dstmd && (dstmd->class_ == MOBID_EMPERIUM || mob_is_battleground(dstmd))) ||
-				   (dstsd && pc_ismadogear(dstsd))) //Mado is immune to heal
-					heal=0;
+				heal = heal * ( 17 + 3 * skill_lv ) / 10;
+			}
+			if( status_isimmune(bl) ||
+					(dstmd && dstmd->class_ == MOBID_EMPERIUM) ||
+					(dstsd && pc_ismadogear(dstsd)) )//Mado is immune to heal
+				heal=0;
+			if( dstmd && mob_is_battleground(dstmd) )
+				heal = 1;
+
+			if( sd && dstsd && sd->status.partner_id == dstsd->status.char_id && (sd->class_&MAPID_UPPERMASK) == MAPID_SUPER_NOVICE && sd->status.sex == 0 )
+				heal = heal*2;
 
-				if(sd && dstsd && sd->status.partner_id == dstsd->status.char_id && (sd->class_&MAPID_UPPERMASK) == MAPID_SUPER_NOVICE && sd->status.sex == 0)
-					heal = heal*2;
-
 				if(tsc && tsc->count) {
 					if(tsc->data[SC_KAITE] && !(sstatus->mode&MD_BOSS)) {
 						//Bounce back heal
@@ -5037,18 +5083,37 @@
 				}
 				clif_skill_nodamage(src, bl, skill_id, heal, 1);
 				if(tsc && tsc->data[SC_AKAITSUKI] && heal && skill_id != HLIF_HEAL)
-					heal = ~heal + 1;
-				heal_get_jobexp = status_heal(bl,heal,0,0);
+				heal = ~heal + 1;
+			heal_get_jobexp = status_heal(bl,heal,0,0);
+
+			if( sd && dstsd && heal > 0 && sd != dstsd )
+			{
+				if( sd->status.guild_id && map_allowed_woe(src->m) )
+				{
+					if( sd->status.guild_id == dstsd->status.guild_id || (!map[src->m].flag.gvg_noalliance && guild_isallied(sd->status.guild_id, dstsd->status.guild_id)) )
+						add2limit(sd->status.wstats.healing_done, heal_get_jobexp, UINT_MAX);
+					else
+						add2limit(sd->status.wstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+				else if( map[src->m].flag.battleground && sd->bg_id && dstsd->bg_id )
+				{
+					if( sd->bg_id == dstsd->bg_id )
+						add2limit(sd->status.bgstats.healing_done, heal_get_jobexp, UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+
+				if( battle_config.heal_exp > 0 )
+				{
+					heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
+					if( heal_get_jobexp <= 0 )
+						heal_get_jobexp = 1;
+					pc_gainexp(sd, bl, 0, heal_get_jobexp, false);
+				}
+			}
+		}
+		break;
 
-				if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0) {
-					heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
-					if(heal_get_jobexp <= 0)
-						heal_get_jobexp = 1;
-					pc_gainexp(sd, bl, 0, heal_get_jobexp, false);
-				}
-			}
-			break;
-
 		case PR_REDEMPTIO:
 			if(sd && !(flag&1)) {
 				if(sd->status.party_id == 0) {
@@ -5081,7 +5146,7 @@
 				break;
 
 		case ALL_RESURRECTION:
-			if(sd && (map_flag_gvg(bl->m) || map[bl->m].flag.battleground)) {
+			if( sd && map_flag_gvg3(bl->m) ) {
 				//No reviving in WoE grounds!
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				break;
@@ -5744,7 +5809,7 @@
 
 		case MO_ABSORBSPIRITS:
 			i = 0;
-			if(dstsd && dstsd->spiritball && (sd == dstsd || map_flag_vs(src->m)) && (dstsd->class_&MAPID_BASEMASK)!=MAPID_GUNSLINGER) {
+			if (dstsd && dstsd->spiritball && (sd == dstsd || map_flag_vs(src->m) || (sd && sd->state.pvpmode && dstsd->state.pvpmode)) && (dstsd->class_&MAPID_BASEMASK)!=MAPID_GUNSLINGER) {
 				// split the if for readability, and included gunslingers in the check so that their coins cannot be removed [Reddozen]
 				i = dstsd->spiritball * 7;
 				pc_delspiritball(dstsd,dstsd->spiritball,0);
@@ -6173,9 +6238,9 @@
 
 		case MER_SCAPEGOAT:
 			if(mer && mer->master) {
-				status_heal(&mer->master->bl, mer->battle_status.hp, 0, 2);
-				status_damage(src, src, mer->battle_status.max_hp, 0, 0, 1);
-			}
+			status_heal(&mer->master->bl, mer->battle_status.hp, 0, 2);
+			status_damage_(src, src, mer->battle_status.max_hp, 0, 0, 1, skill_id);
+		}
 			break;
 
 		case MER_ESTIMATION:
@@ -6216,20 +6281,23 @@
 			break;
 
 		case MC_VENDING:
-			if(sd) {
-				//Prevent vending of GMs with unnecessary Level to trade/drop. [Skotlex]
-				if(!pc_can_give_items(sd))
+			if( sd ) {
+				if( battle_config.vending_zeny_id )
+					clif_vend(sd,skill_lv); // Extended Vending System
+				else {
+				if ( !pc_can_give_items(sd) )
 					clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				else {
 					sd->state.prevend = 1;
 					clif_openvendingreq(sd,2+skill_lv);
+					}
 				}
 			}
 			break;
 
 		case AL_TELEPORT:
 			if(sd) {
-				if(map[bl->m].flag.noteleport && skill_lv <= 2) {
+				if( (map[bl->m].flag.noteleport || !guild_canescape(sd)) && skill_lv <= 2 ) {
 					clif_skill_teleportmessage(sd,0);
 					break;
 				}
@@ -6282,13 +6350,13 @@
 				item_tmp.identify = 1;
 				tbl.id = 0;
 				clif_takeitem(&sd->bl,&tbl);
-				eflag = pc_additem(sd,&item_tmp,1,LOG_TYPE_PRODUCE);
-				if(eflag) {
-					clif_additem(sd,0,0,eflag);
-					map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-				}
-			}
-			break;
+			eflag = pc_additem(sd,&item_tmp,1,LOG_TYPE_PRODUCE);
+			if(eflag) {
+				clif_additem(sd,0,0,eflag);
+				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+		}
+		break;
 		case ASC_CDP:
 			if(sd) {
 				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
@@ -6454,12 +6522,15 @@
 					}
 					if(tsc->data[SC_WATER_INSIGNIA] && tsc->data[SC_WATER_INSIGNIA]->val1 == 2) {
 						hp += hp / 10;
-						sp += sp / 10;
-					}
-				}
-				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-				if(hp > 0 || (skill_id == AM_POTIONPITCHER && sp <= 0))
-					clif_skill_nodamage(NULL,bl,AL_HEAL,hp,1);
+					sp += sp / 10;
+				}
+			}
+			if( dstmd && mob_is_battleground(dstmd) )
+				hp = 1;
+
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+			if( hp > 0 || (skill_id == AM_POTIONPITCHER && sp <= 0) )
+				clif_skill_nodamage(NULL,bl,AL_HEAL,hp,1);
 				if(sp > 0)
 					clif_skill_nodamage(NULL,bl,MG_SRECOVERY,sp,1);
 #ifdef RENEWAL
@@ -6820,13 +6891,13 @@
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			status_kill(src); //When suiciding, neither exp nor drops is given.
 			break;
-
-		case NPC_SUMMONSLAVE:
-		case NPC_SUMMONMONSTER:
-			if(md && md->skill_idx >= 0)
-				mob_summonslave(md,md->db->skill[md->skill_idx].val,skill_lv,skill_id);
-			break;
-
+
+	case NPC_SUMMONSLAVE:
+	case NPC_SUMMONMONSTER:
+		if(md && md->skill_idx >= 0 && !md->option.no_slaves)
+			mob_summonslave(md,md->db->skill[md->skill_idx].val,skill_lv,skill_id);
+		break;
+
 		case NPC_CALLSLAVE:
 			mob_warpslave(src,MOB_SLAVEDISTANCE);
 			break;
@@ -6994,9 +7065,9 @@
 									item_tmp.nameid = skill_db[su->group->skill_id].itemid[i];
 									item_tmp.identify = 1;
 									if(item_tmp.nameid && (flag=pc_additem(sd,&item_tmp,skill_db[su->group->skill_id].amount[i],LOG_TYPE_OTHER))) {
-										clif_additem(sd,0,0,flag);
-										map_addflooritem(&item_tmp,skill_db[su->group->skill_id].amount[i],sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-									}
+									clif_additem(sd,0,0,flag);
+									map_addflooritem(&item_tmp,skill_db[su->group->skill_id].amount[i],sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+								}
 								}
 							}
 						} else {
@@ -7006,9 +7077,9 @@
 							item_tmp.nameid = su->group->item_id?su->group->item_id:ITEMID_TRAP;
 							item_tmp.identify = 1;
 							if(item_tmp.nameid && (flag=pc_additem(sd,&item_tmp,1,LOG_TYPE_OTHER))) {
-								clif_additem(sd,0,0,flag);
-								map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-							}
+							clif_additem(sd,0,0,flag);
+							map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+						}
 						}
 					}
 					skill_delunit(su);
@@ -7134,13 +7205,13 @@
 			}
 			break;
 
-			// Slim Pitcher
-		case CR_SLIMPITCHER:
-			// Updated to block Slim Pitcher from working on barricades and guardian stones.
-			if(dstmd && (dstmd->class_ == MOBID_EMPERIUM || (dstmd->class_ >= MOBID_BARRICADE1 && dstmd->class_ <= MOBID_GUARIDAN_STONE2)))
-				break;
-			if(potion_hp || potion_sp) {
-				int hp = potion_hp, sp = potion_sp;
+	// Slim Pitcher
+	case CR_SLIMPITCHER:
+		// Updated to block Slim Pitcher from working on barricades and guardian stones.
+		if( dstmd && (dstmd->class_ == MOBID_EMPERIUM || (dstmd->class_ >= 1905 && dstmd->class_ <= 1915) || (dstmd->class_ >= 2105 && dstmd->class_ <= 2107)) )
+			break;
+		if (potion_hp || potion_sp) {
+			int hp = potion_hp, sp = potion_sp;
 				hp = hp * (100 + (tstatus->vit<<1))/100;
 				sp = sp * (100 + (tstatus->int_<<1))/100;
 				if(dstsd) {
@@ -7227,7 +7298,7 @@
 							status_change_clear_buffs(bl,1);
 							break;
 						case 3: { // 1000 damage, random armor destroyed
-								status_fix_damage(src, bl, 1000, 0);
+								status_fix_damage(src, bl, 1000, 0, skill_id);
 								clif_damage(src,bl,tick,0,0,1000,0,0,0);
 								if(!status_isdead(bl)) {
 									int where[] = { EQP_ARMOR, EQP_SHIELD, EQP_HELM, EQP_SHOES, EQP_GARMENT };
@@ -7263,14 +7334,14 @@
 							sc_start(src,bl,SC_CONFUSION,100,skill_lv,skill_get_time2(skill_id,skill_lv));
 							break;
 						case 10:    // 6666 damage, atk matk halved, cursed
-							status_fix_damage(src, bl, 6666, 0);
+							status_fix_damage(src, bl, 6666, 0, skill_id);
 							clif_damage(src,bl,tick,0,0,6666,0,0,0);
 							sc_start(src,bl,SC_INCATKRATE,100,-50,skill_get_time2(skill_id,skill_lv));
 							sc_start(src,bl,SC_INCMATKRATE,100,-50,skill_get_time2(skill_id,skill_lv));
 							sc_start(src,bl,SC_CURSE,skill_lv,100,skill_get_time2(skill_id,skill_lv));
 							break;
 						case 11:    // 4444 damage
-							status_fix_damage(src, bl, 4444, 0);
+							status_fix_damage(src, bl, 4444, 0, skill_id);
 							clif_damage(src,bl,tick,0,0,4444,0,0,0);
 							break;
 						case 12:    // stun
@@ -7352,74 +7423,133 @@
 				sc_start(src,src,SC_SMA,100,skill_lv,skill_get_time(SL_SMA,skill_lv));
 			break;
 
-			// New guild skills [Celest]
-		case GD_BATTLEORDER:
-			if(flag&1) {
-				if(status_get_guild_id(src) == status_get_guild_id(bl))
-					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
-			} else if(status_get_guild_id(src)) {
-				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-				map_foreachinrange(skill_area_sub, src,
-				                   skill_get_splash(skill_id, skill_lv), BL_PC,
-				                   src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
-				                   skill_castend_nodamage_id);
-				if(sd)
-					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
+	// New guild skills [Celest]
+	case GD_BATTLEORDER:
+	case GD_REGENERATION:
+	case GD_RESTORE:
+		if( flag&1 )
+		{
+			if( (!map[src->m].flag.battleground && status_get_guild_id(src) == status_get_guild_id(bl)) || (map[src->m].flag.battleground && bg_team_get_id(src) == bg_team_get_id(bl)) )
+			{
+				if( skill_id != GD_RESTORE )
+					sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
+				else
+					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
 			}
-			break;
-		case GD_REGENERATION:
-			if(flag&1) {
-				if(status_get_guild_id(src) == status_get_guild_id(bl))
-					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
-			} else if(status_get_guild_id(src)) {
-				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-				map_foreachinrange(skill_area_sub, src,
-				                   skill_get_splash(skill_id, skill_lv), BL_PC,
-				                   src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
-				                   skill_castend_nodamage_id);
-				if(sd)
-					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
+		}
+		else if( !map[src->m].flag.battleground && (i = status_get_guild_id(src)) )
+		{
+			struct guild *g = guild_search(i);
+			struct guild_castle *gc;
+
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+			map_foreachinrange(skill_area_sub, src, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_GUILD|1, skill_castend_nodamage_id);
+
+			guild_block_skill_start(g, skill_id, skill_get_time2(skill_id,skill_lv));
+			if( g && (gc = guild_mapindex2gc(map[src->m].index)) != NULL )
+			{
+				switch( skill_id )
+				{
+				case GD_BATTLEORDER:  add2limit(g->castle[gc->castle_id].skill_battleorder, 1, USHRT_MAX); break;
+				case GD_REGENERATION: add2limit(g->castle[gc->castle_id].skill_regeneration, 1, USHRT_MAX); break;
+				case GD_RESTORE:      add2limit(g->castle[gc->castle_id].skill_restore, 1, USHRT_MAX); break;
+				}
+				g->castle[gc->castle_id].changed = true;
 			}
-			break;
-		case GD_RESTORE:
-			if(flag&1) {
-				if(status_get_guild_id(src) == status_get_guild_id(bl))
-					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
-			} else if(status_get_guild_id(src)) {
-				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-				map_foreachinrange(skill_area_sub, src,
-				                   skill_get_splash(skill_id, skill_lv), BL_PC,
-				                   src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
-				                   skill_castend_nodamage_id);
-				if(sd)
-					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
+		}
+		else if( map[src->m].flag.battleground && (i = bg_team_get_id(src)) )
+		{
+			struct battleground_data *bg = bg_team_search(i);
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+			map_foreachinrange(skill_area_sub, src, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_GUILD|1, skill_castend_nodamage_id);
+			bg_block_skill_start(bg, skill_id, skill_get_time2(skill_id,skill_lv));
+		}
+		break;
+	case GD_EMERGENCYCALL:
+		{
+			int dx[9] = {-1, 1, 0, 0,-1, 1,-1, 1, 0},
+				dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
+
+			int j = 0, count = 0;
+			int in_i = 0, out_i = 0, cas_i = 0;
+			struct guild *g;
+			struct battleground_data *bg = NULL;
+			struct guild_castle *gc = NULL;
+			struct map_session_data
+				*sd_in[MAX_GUILD], // Guild members in the same Castle
+				*sd_cas[MAX_GUILD], // Guild members in other Castles
+				*sd_out[MAX_GUILD], // Guild members in others maps
+				*pl_sd;
+
+			memset(sd_in, 0, sizeof(sd_in));
+			memset(sd_out, 0, sizeof(sd_out));
+			memset(sd_cas, 0, sizeof(sd_cas));
+
+			if( sd && map[src->m].flag.battleground && (bg = sd->bmaster_flag) != NULL )
+			{ // Battleground Usage
+				for( i = 0; i < MAX_BG_MEMBERS; i++ )
+				{
+					if( (dstsd = bg->members[i].sd) == NULL || sd == dstsd || pc_isdead(dstsd) )
+						continue;
+					sd_in[in_i++] = dstsd;
+					count++;
+				}
+
+				bg_block_skill_start(bg, skill_id, skill_get_time2(skill_id,skill_lv));
 			}
-			break;
-		case GD_EMERGENCYCALL: {
-				int dx[9]= {-1, 1, 0, 0,-1, 1,-1, 1, 0};
-				int dy[9]= { 0, 0, 1,-1, 1,-1,-1, 1, 0};
-				int j = 0;
-				struct guild *g;
-				// i don't know if it actually summons in a circle, but oh well. ;P
-				g = sd?sd->state.gmaster_flag:guild_search(status_get_guild_id(src));
-				if(!g)
-					break;
-				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-				for(i = 0; i < g->max_member; i++, j++) {
-					if(j>8) j=0;
-					if((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-						if(map[dstsd->bl.m].flag.nowarp && !map_flag_gvg2(dstsd->bl.m))
-							continue;
-						if(map_getcell(src->m,src->x+dx[j],src->y+dy[j],CELL_CHKNOREACH))
-							dx[j] = dy[j] = 0;
-						pc_setpos(dstsd, map_id2index(src->m), src->x+dx[j], src->y+dy[j], CLR_RESPAWN);
-					}
+			else if( !map[src->m].flag.battleground && (g = (sd ? sd->state.gmaster_flag : guild_search(status_get_guild_id(src)))) != NULL )
+			{ // Normal Field or GvG Usage
+				for( i = 0; i < g->max_member; i++ )
+				{
+					if( (dstsd = g->member[i].sd) == NULL || sd == dstsd || pc_isdead(dstsd) )
+						continue;
+					if( map[dstsd->bl.m].flag.nowarp && !map_flag_gvg2(dstsd->bl.m) )
+						continue;
+					if( map[sd->bl.m].flag.ancient && (!pc_class2ancientwoe(dstsd->status.class_) || dstsd->md) )
+						continue; // Ancient WoE
+
+					if( dstsd->bl.m == src->m )
+						sd_in[in_i++] = dstsd;
+					else if( map[dstsd->bl.m].flag.gvg_castle )
+						sd_cas[cas_i++] = dstsd;
+					else
+						sd_out[out_i++] = dstsd;
+
+					count++;
 				}
-				if(sd)
-					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
+
+				if( map[src->m].guild_max && count >= map[src->m].guild_max )
+					count = map[src->m].guild_max - 1;
+
+				guild_block_skill_start(g, skill_id, skill_get_time2(skill_id,skill_lv));
+				if( (gc = guild_mapindex2gc(map[src->m].index)) != NULL )
+				{
+					add2limit(g->castle[gc->castle_id].skill_emergencycall, 1, USHRT_MAX);
+					g->castle[gc->castle_id].changed = true;
+				}
 			}
-			break;
 
+			clif_skill_nodamage(src, bl, skill_id, skill_lv, 1);
+
+			for( i = 0; i < count; i++, j++ )
+			{
+				if( j > 8 ) j = 0; // Respawn point index
+				if( map_getcell(src->m, src->x + dx[j], src->y + dy[j], CELL_CHKNOREACH) )
+					dx[j] = dy[j] = 0; // Set it to the same source x,y
+				
+				if( i < in_i )
+					pl_sd = sd_in[i];
+				else if( i < in_i + out_i )
+					pl_sd = sd_out[i - in_i];
+				else if( i < in_i + out_i + cas_i )
+					pl_sd = sd_cas[i - (in_i + out_i)];
+				else continue; // Should not
+
+				pc_setpos(pl_sd, map_id2index(src->m), src->x + dx[j], src->y + dy[j], CLR_RESPAWN);
+			}
+		}
+		break;
+
 		case SG_FEEL:
 			//AuronX reported you CAN memorize the same map as all three. [Skotlex]
 			if(sd) {
@@ -8551,28 +8681,28 @@
 			break;
 
 		case WM_SATURDAY_NIGHT_FEVER:
-			if(flag&1) {     // Affect to all targets arround the caster and caster too.
-				if(!(tsc && tsc->data[type]))
+			if( flag&1 ) {	// Affect to all targets arround the caster and caster too.
+				if( !(tsc && tsc->data[type]) )
 					sc_start(src,bl, type, 100, skill_lv,skill_get_time(skill_id, skill_lv));
-			} else if(flag&2) {
-				if(src->id != bl->id && battle_check_target(src,bl,BCT_ENEMY) > 0)
-					status_fix_damage(src,bl,9999,clif_damage(src,bl,tick,0,0,9999,0,0,0));
-			} else if(sd) {
+			} else if( flag&2 ) {
+				if( src->id != bl->id && battle_check_target(src,bl,BCT_ENEMY) > 0 )
+					status_fix_damage(src,bl,9999,clif_damage(src,bl,tick,0,0,9999,0,0,0),skill_id);
+			} else if( sd ) {
 				short chance = sstatus->int_/6 + sd->status.job_level/5 + skill_lv*4;
-				if(!sd->status.party_id || (rnd()%100 > chance)) {
+				if( !sd->status.party_id || (rnd()%100 > chance)) {
 					clif_skill_fail(sd,skill_id,USESKILL_FAIL_NEED_HELPER,0);
 					break;
 				}
-				if(map_foreachinrange(skill_area_sub, bl, skill_get_splash(skill_id,skill_lv),
-				                      BL_PC, src, skill_id, skill_lv, tick, BCT_ENEMY, skill_area_sub_count) > 7)
+				if( map_foreachinrange(skill_area_sub, bl, skill_get_splash(skill_id,skill_lv),
+						BL_PC, src, skill_id, skill_lv, tick, BCT_ENEMY, skill_area_sub_count) > 7 )
 					flag |= 2;
 				else
 					flag |= 1;
 				map_foreachinrange(skill_area_sub, src, skill_get_splash(skill_id,skill_lv),BL_PC, src, skill_id, skill_lv, tick, flag|BCT_ENEMY|BCT_SELF, skill_castend_nodamage_id);
 				clif_skill_nodamage(src, bl, skill_id, skill_lv,
-				                    sc_start(src,src,SC_STOP,100,skill_lv,skill_get_time2(skill_id,skill_lv)));
-				if(flag&2)   // Dealed here to prevent conflicts
-					status_fix_damage(src,bl,9999,clif_damage(src,bl,tick,0,0,9999,0,0,0));
+					sc_start(src,src,SC_STOP,100,skill_lv,skill_get_time2(skill_id,skill_lv)));
+				if( flag&2 ) // Dealed here to prevent conflicts
+					status_fix_damage(src,bl,9999,clif_damage(src,bl,tick,0,0,9999,0,0,0),skill_id);
 			}
 			break;
 
@@ -9049,7 +9179,7 @@
 					if(unit_movepos(bl,x,y,0,0)) {
 						clif_skill_damage(bl,bl,tick, status_get_amotion(src), 0, -30000, 1, skill_id, -1, 6);
 						if(bl->type == BL_PC && pc_issit((TBL_PC *)bl))
-							clif_sitting(bl); //Avoid sitting sync problem
+							clif_sitting(bl,true); //Avoid sitting sync problem
 						clif_slide(bl,x,y) ;
 						sc_start(src,bl,SC_CONFUSION,80,skill_lv,skill_get_time(skill_id,skill_lv));
 					}
@@ -9181,7 +9311,7 @@
 				skill_blockhomun_start(hd, skill_id, skill_get_cooldown(skill_id, skill_lv));
 			break;
 		case MH_SUMMON_LEGION: {
-				int summons[5] = {2158, 2159, 2159, 2160, 2160};
+				int summons[5] = {1004, 1303, 1303, 1994, 1994};
 				int qty[5] =     {3   , 3   , 4   , 4   , 5};
 				struct mob_data *sum_md;
 				int i,c=0;
@@ -9210,12 +9340,30 @@
 			ShowWarning("skill_castend_nodamage_id: Unknown skill used:%d\n",skill_id);
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			map_freeblock_unlock();
-			return 1;
-	}
-
-	if(skill_id != SR_CURSEDCIRCLE) {
-		struct status_change *sc = status_get_sc(src);
-		if(sc && sc->data[SC_CURSEDCIRCLE_ATKER])  //Should only remove after the skill had been casted.
+		return 1;
+	}
+
+	if( skill_get_inf(skill_id)&INF_SUPPORT_SKILL && sd && dstsd && sd != dstsd )
+	{
+		if( map_allowed_woe(src->m) && sd->status.guild_id )
+		{
+			if( sd->status.guild_id == dstsd->status.guild_id || (!map[src->m].flag.gvg_noalliance && guild_isallied(sd->status.guild_id, dstsd->status.guild_id)) )
+				add2limit(sd->status.wstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.wstats.wrong_support_skills_used, 1, UINT_MAX);
+		}
+		else if( map[src->m].flag.battleground && sd->bg_id && dstsd->bg_id )
+		{
+			if( sd->bg_id == dstsd->bg_id )
+				add2limit(sd->status.bgstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.bgstats.wrong_support_skills_used, 1, UINT_MAX);
+		}
+	}
+
+	if(skill_id != SR_CURSEDCIRCLE){
+		struct status_change *sc = status_get_sc(src);
+		if( sc && sc->data[SC_CURSEDCIRCLE_ATKER] )//Should only remove after the skill had been casted.
 			status_change_end(src,SC_CURSEDCIRCLE_ATKER,INVALID_TIMER);
 	}
 
@@ -9452,6 +9600,28 @@
 		}
 		if(battle_config.display_status_timers && sd)
 			clif_status_change(src, SI_ACTIONDELAY, 1, skill_delayfix(src, ud->skill_id, ud->skill_lv), 0, 0, 0);
+		if( sd && sd->skillitem != ud->skill_id )
+		{ // Skill Usage Counter
+			int i;
+			if( map_allowed_woe(sd->bl.m) )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.skillcount[i].id == ud->skill_id || !sd->status.skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.skillcount[i].id = ud->skill_id;
+					sd->status.skillcount[i].count++;
+				}
+			}
+			else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.bg_skillcount[i].id == ud->skill_id || !sd->status.bg_skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.bg_skillcount[i].id = ud->skill_id;
+					sd->status.bg_skillcount[i].count++;
+				}
+			}
+		}
 		if(sd) {
 			switch(ud->skill_id) {
 				case GS_DESPERADO:
@@ -9656,12 +9826,14 @@
 			ShowInfo("Type %d, ID %d skill castend pos [id =%d, lv=%d, (%d,%d)]\n",
 			         src->type, src->id, ud->skill_id, ud->skill_lv, ud->skillx, ud->skilly);
 
-		if(ud->walktimer != INVALID_TIMER)
-			unit_stop_walking(src,1);
-
-		if(!sd || sd->skillitem != ud->skill_id || skill_get_delay(ud->skill_id,ud->skill_lv))
-			ud->canact_tick = tick + skill_delayfix(src, ud->skill_id, ud->skill_lv);
-		if(sd) {  //Cooldown application
+		if (ud->walktimer != INVALID_TIMER)
+			unit_stop_walking(src,1);
+
+		if( sd && skill_get_cooldown(ud->skill_id,ud->skill_lv) > 0 ) // Skill cooldown. [LimitLine]
+			skill_blockpc_start(sd, ud->skill_id, skill_get_cooldown(ud->skill_id, ud->skill_lv));
+		if( !sd || sd->skillitem != ud->skill_id || skill_get_delay(ud->skill_id,ud->skill_lv) )
+			ud->canact_tick = tick + skill_delayfix(src, ud->skill_id, ud->skill_lv);
+		if (sd) { //Cooldown application
 			int i, cooldown = skill_get_cooldown(ud->skill_id, ud->skill_lv);
 			for(i = 0; i < ARRAYLENGTH(sd->skillcooldown) && sd->skillcooldown[i].id; i++) {  // Increases/Decreases cooldown of a skill by item/card bonuses.
 				if(sd->skillcooldown[i].id == ud->skill_id) {
@@ -9671,12 +9843,34 @@
 			}
 			if(cooldown)
 				skill_blockpc_start(sd, ud->skill_id, cooldown);
-		}
-		if(battle_config.display_status_timers && sd)
-			clif_status_change(src, SI_ACTIONDELAY, 1, skill_delayfix(src, ud->skill_id, ud->skill_lv), 0, 0, 0);
-//		if( sd )
-//		{
-//			switch( ud->skill_id )
+		}
+		if( battle_config.display_status_timers && sd )
+			clif_status_change(src, SI_ACTIONDELAY, 1, skill_delayfix(src, ud->skill_id, ud->skill_lv), 0, 0, 0);
+		if( sd && sd->skillitem != ud->skill_id )
+		{ // Skill Usage Counter
+			int i;
+			if( map_allowed_woe(sd->bl.m) )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.skillcount[i].id == ud->skill_id || !sd->status.skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.skillcount[i].id = ud->skill_id;
+					sd->status.skillcount[i].count++;
+				}
+			}
+			else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.bg_skillcount[i].id == ud->skill_id || !sd->status.bg_skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.bg_skillcount[i].id = ud->skill_id;
+					sd->status.bg_skillcount[i].count++;
+				}
+			}
+		}
+//		if( sd )
+//		{
+//			switch( ud->skill_id )
 //			{
 //			case ????:
 //				sd->canequip_tick = tick + ????;
@@ -11246,13 +11440,13 @@
 							working = 1;/* we break it because officials break it, lovely stuff. */
 
 						sg->val1 = (count<<16)|working;
-
-						pc_setpos(sd,m,x,y,CLR_TELEPORT);
-					}
-				} else if(bl->type == BL_MOB && battle_config.mob_warp&2) {
-					int16 m = map_mapindex2mapid(sg->val3);
-					if(m < 0) break;  //Map not available on this map-server.
-					unit_warp(bl,m,sg->val2>>16,sg->val2&0xffff,CLR_TELEPORT);
+
+					pc_setpos(sd,m,x,y,CLR_TELEPORT);
+				}
+			} else if(bl->type == BL_MOB && (battle_config.mob_warp&2 || ((TBL_MOB*)bl)->option.allow_warp == 2)) {
+				int16 m = map_mapindex2mapid(sg->val3);
+				if (m < 0) break; //Map not available on this map-server.
+				unit_warp(bl,m,sg->val2>>16,sg->val2&0xffff,CLR_TELEPORT);
 				}
 			}
 			break;
@@ -11451,16 +11645,16 @@
 				int heal = skill_calc_heal(ss,bl,sg->skill_id,sg->skill_lv,true);
 				struct mob_data *md = BL_CAST(BL_MOB, bl);
 #ifdef RENEWAL
-				if(md && md->class_ == MOBID_EMPERIUM)
-					break;
-#endif
-				if(md && mob_is_battleground(md))
-					break;
-				if(tstatus->hp >= tstatus->max_hp)
-					break;
-				if(status_isimmune(bl))
-					heal = 0;
-				clif_skill_nodamage(&src->bl, bl, AL_HEAL, heal, 1);
+				if( md && md->class_ == MOBID_EMPERIUM )
+					break;
+#endif
+				if( tstatus->hp >= tstatus->max_hp )
+					break;
+				if( md && mob_is_battleground(md) )
+					heal = 1;
+				if( status_isimmune(bl) )
+					heal = 0;
+				clif_skill_nodamage(&src->bl, bl, AL_HEAL, heal, 1);
 				if(tsc && tsc->data[SC_AKAITSUKI] && heal)
 					heal = ~heal + 1;
 				status_heal(bl, heal, 0, 0);
@@ -12336,14 +12530,14 @@
 		return 0;
 
 	if(tsd->sc.data[SC_SILENCE] || (tsd->sc.opt1 && tsd->sc.opt1 != OPT1_BURNING))
-		return 0;
+		return 0;
+
+	if( skill_get_inf2(skill_id)&INF2_CHORUS_SKILL ) {
+		if( skill_check_sameparty(sd,tsd) && (tsd->class_&MAPID_THIRDMASK) == MAPID_MINSTRELWANDERER )
+			p_sd[(*c)++] = tsd->bl.id;
+		return 1;
+	} else {
 
-	if(skill_get_inf2(skill_id)&INF2_CHORUS_SKILL) {
-		if(tsd->status.party_id == sd->status.party_id && (tsd->class_&MAPID_THIRDMASK) == MAPID_MINSTRELWANDERER)
-			p_sd[(*c)++] = tsd->bl.id;
-		return 1;
-	} else {
-
 		switch(skill_id) {
 			case PR_BENEDICTIO: {
 					uint8 dir = map_calc_dir(&sd->bl,tsd->bl.x,tsd->bl.y);
@@ -12376,8 +12570,7 @@
 					   (tsd->class_&MAPID_UPPERMASK) == MAPID_BARDDANCER &&
 					   (skill_lv = pc_checkskill(tsd, skill_id)) > 0 &&
 					   (tsd->weapontype1==W_MUSICAL || tsd->weapontype1==W_WHIP) &&
-					   sd->status.party_id && tsd->status.party_id &&
-					   sd->status.party_id == tsd->status.party_id &&
+					   skill_check_sameparty(sd,tsd) &&
 					   !tsd->sc.data[SC_DANCING]) {
 						p_sd[(*c)++]=tsd->bl.id;
 						return skill_lv;
@@ -12841,29 +13034,38 @@
 				if(status->sp < (unsigned int)require.sp)
 					clif_skill_fail(sd,skill_id,USESKILL_FAIL_SP_INSUFFICIENT,0);
 				else
-					status_zap(&sd->bl, 0, require.sp);
-			}
-			return 0;
-		case GD_BATTLEORDER:
-		case GD_REGENERATION:
-		case GD_RESTORE:
-			if(!map_flag_gvg2(sd->bl.m)) {
+					status_zap(&sd->bl, 0, require.sp);
+			}
+			return 0;
+	case GD_BATTLEORDER:
+	case GD_REGENERATION:
+	case GD_RESTORE:
+		if( !map_flag_gvg2(sd->bl.m) && !map[sd->bl.m].flag.battleground )
+		{
+			clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
+			return 0;
+		}
+	case GD_EMERGENCYCALL:
+		// other checks were already done in skillnotok()
+		if( map[sd->bl.m].flag.battleground )
+		{
+			if( !(sd->bg_id && sd->bmaster_flag) )
+				return 0; // Not Team Leader on Battleground
+		}
+		else
+		{
+			if( !(sd->status.guild_id && sd->state.gmaster_flag) )
+				return 0; // Not Guild Leader
+		}
+		break;
+
+		case GS_GLITTERING:
+			if(sd->spiritball >= 10) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return 0;
 			}
-		case GD_EMERGENCYCALL:
-			// other checks were already done in skillnotok()
-			if(!sd->status.guild_id || !sd->state.gmaster_flag)
-				return 0;
 			break;
 
-		case GS_GLITTERING:
-			if(sd->spiritball >= 10) {
-				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
-				return 0;
-			}
-			break;
-
 		case NJ_ISSEN:
 #ifdef RENEWAL
 			if(status->hp < (status->hp/100)) {
@@ -13305,15 +13507,19 @@
 
 	if(require.sp > 0 && status->sp < (unsigned int)require.sp) {
 		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SP_INSUFFICIENT,0);
-		return 0;
-	}
-
-	if(require.zeny > 0 && sd->status.zeny < require.zeny) {
-		clif_skill_fail(sd,skill_id,USESKILL_FAIL_MONEY,0);
-		return 0;
-	}
-
-	if(require.spiritball > 0 && sd->spiritball < require.spiritball) {
+		return 0;
+	}
+
+	if( require.zeny > 0 && sd->status.zeny < require.zeny )
+	{
+		if( !battle_config.skill_zeny2item || pc_search_inventory(sd,battle_config.skill_zeny2item) < 0 )
+		{ // Item Replacement of Zeny for Skills
+			clif_skill_fail(sd,skill_id,USESKILL_FAIL_MONEY,0);
+			return 0;
+		}
+	}
+
+	if( require.spiritball > 0 && sd->spiritball < require.spiritball) {
 		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SPIRITS,require.spiritball);
 		return 0;
 	}
@@ -13479,30 +13685,61 @@
 
 // type&2: consume items (after skill was used)
 // type&1: consume the others (before skill was used)
-int skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uint16 skill_lv, short type)
-{
-	struct skill_condition req;
-
-	nullpo_ret(sd);
-
-	req = skill_get_requirement(sd,skill_id,skill_lv);
-
+int skill_consume_requirement( struct map_session_data *sd, uint16 skill_id, uint16 skill_lv, short type)
+{
+	struct skill_condition req;
+	int rankFlag = 0;
+
+	nullpo_ret(sd);
+	if( map_allowed_woe(sd->bl.m) && sd->status.guild_id )
+		rankFlag = 1;
+	else if( map[sd->bl.m].flag.battleground && sd->bg_id )
+		rankFlag = 2;
+
+	req = skill_get_requirement(sd,skill_id,skill_lv);
+
 	if(type&1) {
 		if(skill_id == CG_TAROTCARD || sd->state.autocast)
 			req.sp = 0; // TarotCard will consume sp in skill_cast_nodamage_id [Inkfish]
 		if(req.hp || req.sp)
 			status_zap(&sd->bl, req.hp, req.sp);
+			
+		if( req.sp )
+		{
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.sp_used, req.sp, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.sp_used, req.sp, UINT_MAX);
+		}
 
 		if(req.spiritball > 0)
+		{
 			pc_delspiritball(sd,req.spiritball,0);
 
-		if(req.zeny > 0) {
-			if(skill_id == NJ_ZENYNAGE)
-				req.zeny = 0; //Zeny is reduced on skill_attack.
-			if(sd->status.zeny < req.zeny)
-				req.zeny = sd->status.zeny;
-			pc_payzeny(sd,req.zeny,LOG_TYPE_CONSUME,NULL);
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.spiritb_used, req.spiritball, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.spiritb_used, req.spiritball, UINT_MAX);
 		}
+		
+		if(req.zeny > 0 && skill_id != NJ_ZENYNAGE)
+		{
+			int j;
+			if( battle_config.skill_zeny2item && (j = pc_search_inventory(sd,battle_config.skill_zeny2item)) >= 0 )
+				pc_delitem(sd,j,1,0,0,LOG_TYPE_CONSUME);
+			else
+			{
+				if( sd->status.zeny < req.zeny )
+					req.zeny = sd->status.zeny;
+				pc_payzeny(sd,req.zeny,LOG_TYPE_CONSUME,NULL); //@Need proper type
+			}
+
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.zeny_used, req.zeny, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.zeny_used, req.zeny, UINT_MAX);
+			achievement_validate_zeny(sd,ATZ_USE_SKILL,req.zeny);
+		}
 	}
 
 	if(type&2) {
@@ -13540,12 +13777,43 @@
 						continue;
 					break;
 			}
-
-			if((n = pc_search_inventory(sd,req.itemid[i])) >= 0)
-				pc_delitem(sd,n,req.amount[i],0,1,LOG_TYPE_CONSUME);
-		}
-	}
-
+
+			if( (n = pc_search_inventory(sd,req.itemid[i])) >= 0 )
+				pc_delitem(sd,n,req.amount[i],0,1,LOG_TYPE_CONSUME);
+
+			if( rankFlag )
+				switch( req.itemid[i] )
+				{
+				case ITEMID_POISONBOTTLE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.poison_bottles, req.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.poison_bottles, req.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.yellow_gemstones, req.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.yellow_gemstones, req.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.red_gemstones, req.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.red_gemstones, req.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.blue_gemstones, req.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.blue_gemstones, req.amount[i], UINT_MAX);
+					break;
+				}
+
+			achievement_validate_item(sd,AT_ITEM_CONSUME,req.itemid[i],req.amount[i]);
+		}
+	}
+
 	return 1;
 }
 
@@ -13813,16 +14081,14 @@
  *------------------------------------------*/
 int skill_castfix(struct block_list *bl, uint16 skill_id, uint16 skill_lv)
 {
-	int time = skill_get_cast(skill_id, skill_lv);
-
-	nullpo_ret(bl);
-#ifndef RENEWAL_CAST
-	{
-		struct map_session_data *sd;
-
-		sd = BL_CAST(BL_PC, bl);
-
-		// calculate base cast time (reduced by dex)
+	int time = skill_get_cast(skill_id, skill_lv);
+	struct map_session_data *sd;
+
+	nullpo_ret(bl);
+	sd = BL_CAST(BL_PC, bl);
+#ifndef RENEWAL_CAST
+	{
+		// calculate base cast time (reduced by dex)
 		if(!(skill_get_castnodex(skill_id, skill_lv)&1)) {
 			int scale = battle_config.castrate_dex_scale - status_get_dex(bl);
 			if(scale > 0)    // not instant cast
@@ -13846,12 +14112,21 @@
 
 	}
 #endif
-	// config cast time multiplier
-	if(battle_config.cast_rate != 100)
-		time = time * battle_config.cast_rate / 100;
-	// return final cast time
-	time = max(time, 0);
-
+	// config cast time multiplier
+	if (battle_config.cast_rate != 100)
+		time = time * battle_config.cast_rate / 100;
+
+	if( sd && sd->state.showcast )
+	{
+		char output[128];
+		sprintf(output, "- Casted in [%d] ms. -", time);
+		clif_disp_onlyself(sd, output, strlen(output));
+		sd->state.showcast = 0;
+	}
+
+	// return final cast time
+        time = max(time, 0);
+
 //        ShowInfo("Castime castfix = %d\n",time);
 	return time;
 }
@@ -14051,13 +14326,13 @@
 		switch(skill_id) {
 			case CR_SHIELDBOOMERANG:
 				if(sc->data[SC_SPIRIT]->val2 == SL_CRUSADER)
-					time /= 2;
-				break;
-			case AS_SONICBLOW:
-				if(!map_flag_gvg(bl->m) && !map[bl->m].flag.battleground && sc->data[SC_SPIRIT]->val2 == SL_ASSASIN)
-					time /= 2;
-				break;
-		}
+					time /= 2;
+				break;
+			case AS_SONICBLOW:
+				if (!map_flag_gvg3(bl->m) && sc->data[SC_SPIRIT]->val2 == SL_ASSASIN)
+					time /= 2;
+				break;
+		}
 	}
 
 	if(!(delaynodex&2)) {
@@ -14077,13 +14352,20 @@
 		time = time * battle_config.delay_rate / 100;
 
 	//min delay
-	time = max(time, status_get_amotion(bl)); // Delay can never be below amotion [Playtester]
-	time = max(time, battle_config.min_skill_delay_limit);
-
-//        ShowInfo("Delay delayfix = %d\n",time);
-	return time;
-}
-
+	time = max(time, status_get_amotion(bl)); // Delay can never be below amotion [Playtester]
+	time = max(time, battle_config.min_skill_delay_limit);
+
+	if( sd && sd->state.showcastdelay )
+	{
+		char output[128];
+		sprintf(output, "Calculated delay is [ %d ] milliseconds for level %d %s...", time, skill_lv, skill_get_desc(skill_id));
+		clif_disp_onlyself(sd, output, strlen(output));
+		sd->state.showcastdelay = 0;
+	}
+
+	return time;
+}
+
 /*=========================================
  *
  *-----------------------------------------*/
@@ -14369,17 +14651,17 @@
 				   item->card[0] == CARD0_FORGE &&
 				   (int)MakeDWord(item->card[2],item->card[3]) == sd->status.char_id) {
 					// Fame point system [DracoRPG]
-					switch(ditem->wlv) {
-						case 1:
-							pc_addfame(sd,1); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
-							break;
-						case 2:
-							pc_addfame(sd,25); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
-							break;
-						case 3:
-							pc_addfame(sd,1000); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
-							break;
-					}
+					switch(ditem->wlv){
+						case 1:
+							pc_addfame(sd,1,0); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
+							break;
+						case 2:
+							pc_addfame(sd,25,0); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
+							break;
+						case 3:
+							pc_addfame(sd,1000,0); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
+							break;
+					}
 				}
 			} else {
 				item->refine = 0;
@@ -14709,13 +14991,13 @@
 	struct map_session_data *sd=NULL;
 	struct flooritem_data *fitem=NULL;
 
-	nullpo_ret(bl);
-	nullpo_ret(src = va_arg(ap, struct block_list *));
-
-	if(src->type == BL_PC && (sd=(struct map_session_data *)src) && bl->type==BL_ITEM && (fitem=(struct flooritem_data *)bl))
-		pc_takeitem(sd, fitem);
-
-	return 0;
+	nullpo_ret(bl);
+	nullpo_ret(src = va_arg(ap, struct block_list *));
+
+	if(src->type == BL_PC && (sd = (struct map_session_data *)src) && bl->type == BL_ITEM && (fitem = (struct flooritem_data *)bl) && !fitem->no_bsgreed)
+		pc_takeitem(sd, fitem);
+
+	return 0;
 }
 //For Ranger's Detonator [Jobbie/3CeAM]
 int skill_detonator(struct block_list *bl, va_list ap)
@@ -15078,15 +15360,12 @@
 			skill_unitsetmapcell(unit,WZ_ICEWALL,group->skill_lv,CELL_ICEWALL,true);
 			map[unit->bl.m].icewall_num++;
 			break;
-		case SA_LANDPROTECTOR:
-			skill_unitsetmapcell(unit,SA_LANDPROTECTOR,group->skill_lv,CELL_LANDPROTECTOR,true);
-			break;
-		case HP_BASILICA:
-			skill_unitsetmapcell(unit,HP_BASILICA,group->skill_lv,CELL_BASILICA,true);
-			break;
-		case SC_MAELSTROM:
-			skill_unitsetmapcell(unit,SC_MAELSTROM,group->skill_lv,CELL_MAELSTROM,true);
-			break;
+		case SA_LANDPROTECTOR:
+			skill_unitsetmapcell(unit,SA_LANDPROTECTOR,group->skill_lv,CELL_LANDPROTECTOR,true);
+			break;
+		case SC_MAELSTROM:
+			skill_unitsetmapcell(unit,SC_MAELSTROM,group->skill_lv,CELL_MAELSTROM,true);
+			break;
 		default:
 			if(group->state.song_dance&0x1)  //Check for dissonance.
 				skill_dance_overlap(unit, 1);
@@ -15133,15 +15412,12 @@
 			skill_unitsetmapcell(unit,WZ_ICEWALL,group->skill_lv,CELL_ICEWALL,false);
 			map[unit->bl.m].icewall_num--;
 			break;
-		case SA_LANDPROTECTOR:
-			skill_unitsetmapcell(unit,SA_LANDPROTECTOR,group->skill_lv,CELL_LANDPROTECTOR,false);
-			break;
-		case HP_BASILICA:
-			skill_unitsetmapcell(unit,HP_BASILICA,group->skill_lv,CELL_BASILICA,false);
-			break;
-		case RA_ELECTRICSHOCKER: {
-				struct block_list *target = map_id2bl(group->val2);
-				if(target)
+		case SA_LANDPROTECTOR:
+			skill_unitsetmapcell(unit,SA_LANDPROTECTOR,group->skill_lv,CELL_LANDPROTECTOR,false);
+			break;
+		case RA_ELECTRICSHOCKER: {
+				struct block_list* target = map_id2bl(group->val2);
+				if( target )
 					status_change_end(target, SC_ELECTRICSHOCKER, INVALID_TIMER);
 			}
 			break;
@@ -15230,12 +15506,13 @@
 
 	group             = ers_alloc(skill_unit_ers, struct skill_unit_group);
 	group->src_id     = src->id;
-	group->party_id   = status_get_party_id(src);
-	group->guild_id   = status_get_guild_id(src);
-	group->bg_id      = bg_team_get_id(src);
-	group->group_id   = skill_get_new_group_id();
-	group->unit       = (struct skill_unit *)aCalloc(count,sizeof(struct skill_unit));
-	group->unit_count = count;
+	group->party_id   = status_get_party_id(src);
+	group->guild_id   = status_get_guild_id(src);
+	group->bg_id      = bg_team_get_id(src);
+	group->faction_id = status_get_faction_id(src);
+	group->group_id   = skill_get_new_group_id();
+	group->unit       = (struct skill_unit *)aCalloc(count,sizeof(struct skill_unit));
+	group->unit_count = count;
 	group->alive_count = 0;
 	group->val1       = 0;
 	group->val2       = 0;
@@ -15278,24 +15555,9 @@
 		ShowError("skill_delunitgroup: Group's source not found! (src_id: %d skill_id: %d)\n", group->src_id, group->skill_id);
 		return 0;
 	}
-
-	if(!status_isdead(src) && ((TBL_PC *)src)->state.warping && !((TBL_PC *)src)->state.changemap) {
-		switch(group->skill_id) {
-			case BA_DISSONANCE:
-			case BA_POEMBRAGI:
-			case BA_WHISTLE:
-			case BA_ASSASSINCROSS:
-			case BA_APPLEIDUN:
-			case DC_UGLYDANCE:
-			case DC_HUMMING:
-			case DC_DONTFORGETME:
-			case DC_FORTUNEKISS:
-			case DC_SERVICEFORYOU:
-				skill_usave_add(((TBL_PC *)src), group->skill_id, group->skill_lv);
-				break;
-		}
-	}
-
+
+	// Removed Usave by eAmod
+
 	if(skill_get_unit_flag(group->skill_id)&(UF_DANCE|UF_SONG|UF_ENSEMBLE)) {
 		struct status_change *sc = status_get_sc(src);
 		if(sc && sc->data[SC_DANCING]) {
@@ -15531,13 +15793,13 @@
 					if(unit->val1 > 0 && (src = map_id2bl(group->src_id)) != NULL && src->type == BL_PC) {
 						// revert unit back into a trap
 						struct item item_tmp;
-						memset(&item_tmp,0,sizeof(item_tmp));
-						item_tmp.nameid = group->item_id?group->item_id:ITEMID_TRAP;
-						item_tmp.identify = 1;
-						map_addflooritem(&item_tmp,1,bl->m,bl->x,bl->y,0,0,0,0);
-					}
-					skill_delunit(unit);
-				}
+					memset(&item_tmp,0,sizeof(item_tmp));
+					item_tmp.nameid = group->item_id?group->item_id:ITEMID_TRAP;
+					item_tmp.identify = 1;
+					map_addflooritem(&item_tmp,1,bl->m,bl->x,bl->y,0,0,0,0,0);
+				}
+				skill_delunit(unit);
+			}
 				break;
 
 			case UNT_WARP_ACTIVE:
@@ -16393,13 +16655,13 @@
 //TODO update PICKLOG
 
 		if(equip) {
-			clif_produceeffect(sd,0,nameid);
-			clif_misceffect(&sd->bl,3);
-			if(itemdb_wlv(nameid) >= 3 && ((ele? 1 : 0) + sc) >= 3) // Fame point system [DracoRPG]
-				pc_addfame(sd,10); // Success to forge a lv3 weapon with 3 additional ingredients = +10 fame point
-		} else {
-			int fame = 0;
-			tmp_item.amount = 0;
+			clif_produceeffect(sd,0,nameid);
+			clif_misceffect(&sd->bl,3);
+			if(itemdb_wlv(nameid) >= 3 && ((ele? 1 : 0) + sc) >= 3) // Fame point system [DracoRPG]
+				pc_addfame(sd,10,0); // Success to forge a lv3 weapon with 3 additional ingredients = +10 fame point
+		} else {
+			int fame = 0;
+			tmp_item.amount = 0;
 
 			for(i=0; i< qty; i++) {     //Apply quantity modifiers.
 				if((skill_id == GN_MIX_COOKING || skill_id == GN_MAKEBOMB || skill_id == GN_S_PHARMACY) && make_per > 1) {
@@ -16433,13 +16695,13 @@
 					}
 				} else //Failure
 					sd->potion_success_counter = 0;
-			}
-
-			if(fame)
-				pc_addfame(sd,fame);
-			//Visual effects and the like.
-			switch(skill_id) {
-				case AM_PHARMACY:
+			}
+
+			if (fame)
+				pc_addfame(sd,fame,0);
+			//Visual effects and the like.
+			switch (skill_id) {
+				case AM_PHARMACY:
 				case AM_TWILIGHT1:
 				case AM_TWILIGHT2:
 				case AM_TWILIGHT3:
@@ -16474,13 +16736,13 @@
 				if(skill_changematerial_db[i].itemid == nameid) {
 					for(j=0; j<5; j++) {
 						if(rnd()%1000 < skill_changematerial_db[i].qty_rate[j]) {
-							tmp_item.amount = qty * skill_changematerial_db[i].qty[j];
-							if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
-								clif_additem(sd,0,0,flag);
-								map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-							}
-							k++;
-						}
+							tmp_item.amount = qty * skill_changematerial_db[i].qty[j];
+							if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
+								clif_additem(sd,0,0,flag);
+								map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+							}
+							k++;
+						}
 					}
 					break;
 				}
@@ -16488,13 +16750,13 @@
 				clif_msg_skill(sd,skill_id,0x627);
 				return 1;
 			}
-		} else if(tmp_item.amount) {  //Success
-			if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
-				clif_additem(sd,0,0,flag);
-				map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-			}
-			if(skill_id == GN_MIX_COOKING || skill_id == GN_MAKEBOMB || skill_id ==  GN_S_PHARMACY)
-				clif_msg_skill(sd,skill_id,0x627);
+		} else if (tmp_item.amount) { //Success
+			if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
+				clif_additem(sd,0,0,flag);
+				map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+			if( skill_id == GN_MIX_COOKING || skill_id == GN_MAKEBOMB || skill_id ==  GN_S_PHARMACY )
+				clif_msg_skill(sd,skill_id,0x627);
 			return 1;
 		}
 	}
@@ -16540,13 +16802,13 @@
 					else if(rate < 500) i = 0;
 					tmp_item.nameid = compensation[i];
 					tmp_item.amount = qty;
-					tmp_item.identify = 1;
-					if(pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE)) {
-						clif_additem(sd,0,0,flag);
-						map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-					}
-					clif_msg_skill(sd,skill_id,0x628);
-				}
+					tmp_item.identify = 1;
+					if( pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE) ) {
+						clif_additem(sd,0,0,flag);
+						map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+					}
+					clif_msg_skill(sd,skill_id,0x628);
+				}
 				break;
 			case GN_MAKEBOMB:
 			case GN_S_PHARMACY:
@@ -16597,13 +16859,13 @@
 			tmp_item.card[3]=GetWord(sd->status.char_id,1);
 		}
 		if(tmp_item.nameid <= 0 || tmp_item.amount <= 0)
-			continue;
-		if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
-			clif_additem(sd,0,0,flag);
-			map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-		}
-	}
-
+			continue;
+		if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_PRODUCE))) {
+			clif_additem(sd,0,0,flag);
+			map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+
 	return 0;
 }
 int skill_poisoningweapon(struct map_session_data *sd, int nameid)
@@ -16827,13 +17089,13 @@
 		tmp_item.amount = add_amount;
 		tmp_item.identify = 1;
 
-		if(tmp_item.amount) {
-			if((flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_CONSUME))) {
-				clif_additem(sd,0,0,flag);
-				map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0);
-			}
-		}
-
+		if( tmp_item.amount ) {
+			if( (flag = pc_additem(sd,&tmp_item,tmp_item.amount,LOG_TYPE_CONSUME)) ) {
+				clif_additem(sd,0,0,flag);
+				map_addflooritem(&tmp_item,tmp_item.amount,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+			}
+		}
+
 	}
 
 	return 0;
@@ -16920,87 +17182,79 @@
 /*==========================================
  *
  *------------------------------------------*/
+int skill_blockpc_get(struct map_session_data *sd, uint16 skillid)
+{
+	int i;
+	nullpo_retr(-1,sd);
+
+	ARR_FIND(0, MAX_SKILLCOOLDOWN, i, sd->scd[i] && sd->scd[i]->skill_id == skillid);
+	return (i >= MAX_SKILLCOOLDOWN) ? -1 : i;
+}
+
 int skill_blockpc_end(int tid, unsigned int tick, int id, intptr_t data)
 {
 	struct map_session_data *sd = map_id2sd(id);
-	struct skill_cd *cd = NULL;
+	int i = (int)data;
 
-	if(data <= 0 || data >= MAX_SKILL)
+	if( !sd || data < 0 || data >= MAX_SKILLCOOLDOWN )
 		return 0;
-	if(!sd) return 0;
-	if(sd->blockskill[data] != (0x1|(tid&0xFE))) return 0;
-
-	if((cd = idb_get(skillcd_db,sd->status.char_id))) {
-		int i,cursor;
-		ARR_FIND(0, cd->cursor+1, cursor, cd->skidx[cursor] == data);
-		cd->duration[cursor] = 0;
-		cd->skidx[cursor] = 0;
-		cd->nameid[cursor] = 0;
-		// compact the cool down list
-		for(i = 0, cursor = 0; i < cd->cursor; i++) {
-			if(cd->duration[i] == 0)
-				continue;
-			if(cursor != i) {
-				cd->duration[cursor] = cd->duration[i];
-				cd->skidx[cursor] = cd->skidx[i];
-				cd->nameid[cursor] = cd->nameid[i];
-			}
-			cursor++;
-		}
-		if(cursor == 0)
-			idb_remove(skillcd_db,sd->status.char_id);
-		else
-			cd->cursor = cursor;
+	if( !sd->scd[i] || sd->scd[i]->timer != tid )
+	{
+		ShowWarning("skill_blockpc_end: Invalid Timer or not Skill Cooldown.\n");
+		return 0;
 	}
 
-	sd->blockskill[data] = 0;
+	aFree(sd->scd[i]);
+	sd->scd[i] = NULL;
 	return 1;
 }
 
-/**
- * flags a singular skill as being blocked from persistent usage.
- * @param   sd        the player the skill delay affects
- * @param   skill_id   the skill which should be delayed
- * @param   tick      the length of time the delay should last
- * @param   load      whether this assignment is being loaded upon player login
- * @return  0 if successful, -1 otherwise
- */
-int skill_blockpc_start_(struct map_session_data *sd, uint16 skill_id, int tick, bool load)
+int skill_blockpc_start(struct map_session_data *sd, uint16 skill_id, int tick)
 {
-	int oskill_id = skill_id;
-	struct skill_cd *cd = NULL;
-	uint16 idx = skill_get_index(skill_id);
-
-	nullpo_retr(-1, sd);
-
-	if(idx == 0)
+	int i;
+	nullpo_retr(-1,sd);
+	
+	if( skill_id == 0 || tick < 1 )
 		return -1;
 
-	if(tick < 1) {
-		sd->blockskill[idx] = 0;
-		return -1;
+	ARR_FIND(0,MAX_SKILLCOOLDOWN,i,sd->scd[i] && sd->scd[i]->skill_id == skill_id);
+	if( i < MAX_SKILLCOOLDOWN )
+	{ // Skill already with cooldown
+		delete_timer(sd->scd[i]->timer,skill_blockpc_end);
+		aFree(sd->scd[i]);
+		sd->scd[i] = NULL;
 	}
 
-	if(battle_config.display_status_timers)
-		clif_skill_cooldown(sd, idx, tick);
+	ARR_FIND(0,MAX_SKILLCOOLDOWN,i,!sd->scd[i]);
+	if( i < MAX_SKILLCOOLDOWN )
+	{ // Free Slot found
+		CREATE(sd->scd[i],struct skill_cooldown_entry, 1);
+		sd->scd[i]->skill_id = skill_id;
+		sd->scd[i]->timer = add_timer(gettick() + tick, skill_blockpc_end, sd->bl.id, i);
 
-	if(!load) {
-		// not being loaded initially so ensure the skill delay is recorded
-		if(!(cd = idb_get(skillcd_db,sd->status.char_id))) {
-			// create a new skill cooldown object for map storage
-			CREATE(cd, struct skill_cd, 1);
-			idb_put(skillcd_db, sd->status.char_id, cd);
-		}
+		if( battle_config.display_status_timers && tick > 0 )
+			clif_skill_cooldown(sd,skill_id,tick);
 
-		// record the skill duration in the database map
-		cd->duration[cd->cursor] = tick;
-		cd->skidx[cd->cursor] = idx;
-		cd->nameid[cd->cursor] = oskill_id;
-		cd->cursor++;
+		return 1;
+	} else {
+		ShowWarning("skill_blockpc_start: Too many skillcooldowns, increase MAX_SKILLCOOLDOWN.\n");
+		return 0;
 	}
+}
 
-	sd->blockskill[idx] = 0x1|(0xFE&add_timer(gettick()+tick,skill_blockpc_end,sd->bl.id,idx));
-	return 0;
+int skill_blockpc_clear(struct map_session_data *sd)
+{
+	int i;
+	nullpo_ret(sd);
+	for( i = 0; i < MAX_SKILLCOOLDOWN; i++ )
+	{
+		if( !sd->scd[i] )
+			continue;
+		delete_timer(sd->scd[i]->timer,skill_blockpc_end);
+		aFree(sd->scd[i]);
+		sd->scd[i] = NULL;
+	}
+	return 1;
 }
 
 int skill_blockhomun_end(int tid, unsigned int tick, int id, intptr_t data) //[orn]
@@ -17054,39 +17308,7 @@
 	md->blockskill[idx] = 1;
 	return add_timer(gettick() + tick, skill_blockmerc_end, md->bl.id, idx);
 }
-/**
- * Adds a new skill unit entry for this player to recast after map load
- **/
-void skill_usave_add(struct map_session_data *sd, uint16 skill_id, uint16 skill_lv)
-{
-	struct skill_usave *sus = NULL;
 
-	if(idb_exists(skillusave_db,sd->status.char_id)) {
-		idb_remove(skillusave_db,sd->status.char_id);
-	}
-
-	CREATE(sus, struct skill_usave, 1);
-	idb_put(skillusave_db, sd->status.char_id, sus);
-
-	sus->skill_id = skill_id;
-	sus->skill_lv = skill_lv;
-
-	return;
-}
-void skill_usave_trigger(struct map_session_data *sd)
-{
-	struct skill_usave *sus = NULL;
-
-	if(!(sus = idb_get(skillusave_db,sd->status.char_id))) {
-		return;
-	}
-
-	skill_unitsetting(&sd->bl,sus->skill_id,sus->skill_lv,sd->bl.x,sd->bl.y,0);
-
-	idb_remove(skillusave_db,sd->status.char_id);
-
-	return;
-}
 /*
  *
  */
@@ -17515,28 +17737,34 @@
 	return type;
 }
 
-/**
- * reload stored skill cooldowns when a player logs in.
- * @param   sd     the affected player structure
- */
-void skill_cooldown_load(struct map_session_data *sd)
+//
+// Extended Vending System
+//
+int skill_vending(struct map_session_data *sd, int nameid)
 {
-	int i;
-	struct skill_cd *cd = NULL;
+	struct item_data *item;
+	char output[256];
+	nullpo_ret(sd);
 
-	// always check to make sure the session properly exists
-	nullpo_retv(sd);
+	if ( !pc_can_give_items(sd) )
+	{
+		clif_skill_fail(sd,MC_VENDING,USESKILL_FAIL_LEVEL,0);
+		return 0;
+	}
 
-	if(!(cd = idb_get(skillcd_db, sd->status.char_id))) {
-		// no skill cooldown is associated with this character
-		return;
+	if( (item = itemdb_exists(nameid)) == NULL ) {
+		clif_skill_fail(sd,MC_VENDING,USESKILL_FAIL_LEVEL,0);
+		return 0;
 	}
 
-	// process each individual cooldown associated with the character
-	for(i = 0; i < cd->cursor; i++) {
-		// block the skill from usage but ensure it is not recorded (load = true)
-		skill_blockpc_start_(sd, cd->nameid[i], cd->duration[i], true);
-	}
+	sd->state.prevend = 1;
+	sd->vend_coin = nameid;
+	
+	clif_openvendingreq(sd,sd->menuskill_val+2);
+	sprintf(output,msg_txt(713),item->jname);
+	clif_displaymessage(sd->fd,output);
+
+	return 0;
 }
 
 /*==========================================
@@ -17723,8 +17951,20 @@
 
 	return true;
 }
-
-static bool skill_parse_row_unitdb(char *split[], int columns, int current)
+
+static bool skill_parse_row_blockdb(char* split[], int columns, int current)
+{// SkillID,Flag
+	int i = atoi(split[0]);
+	i = skill_get_index(i);
+	if( !i ) // invalid skill id
+		return false;
+
+	skill_db[i].blocked = (bool)atoi(split[1]);
+
+	return true;
+}
+
+static bool skill_parse_row_unitdb(char* split[], int columns, int current)
 {
 	// ID,unit ID,unit ID 2,layout,range,interval,target,flag
 	uint16 skill_id = atoi(split[0]);
@@ -17938,12 +18178,28 @@
 		skill_changematerial_db[current].qty_rate[y] = atoi(split[x+1]);
 	}
 
-	return true;
-}
-
-/*===============================
- * DB reading.
- * skill_db.txt
+	return true;
+}
+
+static bool skill_parse_row_skilldamage(char* split[], int columns, int current)
+{
+	int i = atoi(split[0]);
+	i = skill_get_index(i);
+	if( !i ) // invalid skill id
+		return false;
+		
+	skill_db[i].flag			= atoi(split[1]);
+	skill_db[i].pc_damage		= atoi(split[2]);
+	skill_db[i].mob_damage		= atoi(split[3]);
+	skill_db[i].boss_damage		= atoi(split[4]);
+	skill_db[i].other_damage	= atoi(split[5]);
+
+	return true;
+}
+
+/*===============================
+ * DB reading.
+ * skill_db.txt
  * skill_require_db.txt
  * skill_cast_db.txt
  * skill_castnodex_db.txt
@@ -17984,11 +18240,13 @@
 	sv_readsqldb(get_database_name(6),  NULL, 4+2*MAX_PRODUCE_RESOURCE,  -1, skill_parse_row_producedb);
 	sv_readsqldb(get_database_name(7),  NULL, 1+2*MAX_ARROW_RESOURCE,  -1, skill_parse_row_createarrowdb);
 	sv_readsqldb(get_database_name(8),  NULL, 4,  -1, skill_parse_row_abradb);
+	sv_readdb(db_path, "skill_block_db.txt"    , ',',   2,  2, MAX_SKILL_DB, skill_parse_row_blockdb);
 	sv_readsqldb(get_database_name(9),  NULL, 3,  -1, skill_parse_row_spellbookdb);
 	sv_readsqldb(get_database_name(10), NULL, 1,  -1, skill_parse_row_magicmushroomdb);
 	sv_readsqldb(get_database_name(11), NULL, 1,  -1, skill_parse_row_reproducedb);
 	sv_readsqldb(get_database_name(12), NULL, 2,  -1, skill_parse_row_improvisedb);
 	sv_readsqldb(get_database_name(13), NULL, 4+2*5,  -1, skill_parse_row_changematerialdb);
+	sv_readdb(db_path, "skill_damage_db.txt"   , ',',   5,  6, MAX_SKILL_DB, skill_parse_row_skilldamage);
 
 }
 
@@ -18012,14 +18270,12 @@
 {
 	skilldb_name2id = strdb_alloc(DB_OPT_DUP_KEY|DB_OPT_RELEASE_DATA, 0);
 	skill_readdb();
-
-	group_db = idb_alloc(DB_OPT_BASE);
-	skillunit_db = idb_alloc(DB_OPT_BASE);
-	skillcd_db = idb_alloc(DB_OPT_RELEASE_DATA);
-	skillusave_db = idb_alloc(DB_OPT_RELEASE_DATA);
-	skill_unit_ers = ers_new(sizeof(struct skill_unit_group),"skill.c::skill_unit_ers",ERS_OPT_NONE);
-	skill_timer_ers  = ers_new(sizeof(struct skill_timerskill),"skill.c::skill_timer_ers",ERS_OPT_NONE);
-
+
+	group_db = idb_alloc(DB_OPT_BASE);
+	skillunit_db = idb_alloc(DB_OPT_BASE);
+	skill_unit_ers = ers_new(sizeof(struct skill_unit_group),"skill.c::skill_unit_ers",ERS_OPT_NONE);
+	skill_timer_ers  = ers_new(sizeof(struct skill_timerskill),"skill.c::skill_timer_ers",ERS_OPT_NONE);
+
 	add_timer_func_list(skill_unit_timer,"skill_unit_timer");
 	add_timer_func_list(skill_castend_id,"skill_castend_id");
 	add_timer_func_list(skill_castend_pos,"skill_castend_pos");
@@ -18033,12 +18289,10 @@
 
 int do_final_skill(void)
 {
-	db_destroy(skilldb_name2id);
-	db_destroy(group_db);
-	db_destroy(skillunit_db);
-	db_destroy(skillcd_db);
-	db_destroy(skillusave_db);
-	ers_destroy(skill_unit_ers);
-	ers_destroy(skill_timer_ers);
-	return 0;
+	db_destroy(skilldb_name2id);
+	db_destroy(group_db);
+	db_destroy(skillunit_db);
+	ers_destroy(skill_unit_ers);
+	ers_destroy(skill_timer_ers);
+	return 0;
 }
Index: src/map/skill.h
===================================================================
--- src/map/skill.h	(revision 1953)
+++ src/map/skill.h	(working copy)
@@ -122,12 +122,16 @@
 	int unit_id[2];
 	int unit_layout_type[MAX_SKILL_LEVEL];
 	int unit_range[MAX_SKILL_LEVEL];
-	int unit_interval;
-	int unit_target;
-	int unit_flag;
-};
-extern struct s_skill_db skill_db[MAX_SKILL_DB];
-
+	int unit_interval;
+	int unit_target;
+	int unit_flag;
+
+	int flag;
+	int pc_damage,mob_damage,other_damage,boss_damage;
+	bool blocked; // Allow this skill usage
+};
+extern struct s_skill_db skill_db[MAX_SKILL_DB];
+
 #define MAX_SKILL_UNIT_LAYOUT   50
 #define MAX_SQUARE_LAYOUT       5   // 11*11 Placement of a maximum unit
 #define MAX_SKILL_UNIT_COUNT ((MAX_SQUARE_LAYOUT*2+1)*(MAX_SQUARE_LAYOUT*2+1))
@@ -152,12 +156,13 @@
 #define MAX_SKILLUNITGROUP 25
 struct skill_unit_group {
 	int src_id;
-	int party_id;
-	int guild_id;
-	int bg_id;
-	int map;
-	int target_flag; //Holds BCT_* flag for battle_check_target
-	int bl_flag;    //Holds BL_* flag for map_foreachin* functions
+	int party_id;
+	int guild_id;
+	int bg_id;
+	int faction_id;
+	int map;
+	int target_flag; //Holds BCT_* flag for battle_check_target
+	int bl_flag;	//Holds BL_* flag for map_foreachin* functions
 	unsigned int tick;
 	int limit,interval;
 
@@ -281,12 +286,14 @@
 int skill_get_blewcount(uint16 skill_id ,uint16 skill_lv);
 int skill_get_unit_flag(uint16 skill_id);
 int skill_get_unit_target(uint16 skill_id);
-int skill_tree_get_max(uint16 skill_id, int b_class);    // Celest
-const char *skill_get_name(uint16 skill_id);     // [Skotlex]
-const char *skill_get_desc(uint16 skill_id);     // [Skotlex]
-
-int skill_name2id(const char *name);
-
+int	skill_tree_get_max( uint16 skill_id, int b_class );	// Celest
+const char*	skill_get_name( uint16 skill_id ); 	// [Skotlex]
+const char*	skill_get_desc( uint16 skill_id ); 	// [Skotlex]
+int	skill_get_blocked( uint16 skill_id );
+int	skill_get_cooldown( uint16 skill_id ,uint16 skill_lv );
+
+int skill_name2id(const char* name);
+
 int skill_isammotype(struct map_session_data *sd, int skill);
 int skill_castend_id(int tid, unsigned int tick, int id, intptr_t data);
 int skill_castend_pos(int tid, unsigned int tick, int id, intptr_t data);
@@ -357,12 +364,16 @@
 // Abnormal status
 int skill_enchant_elemental_end(struct block_list *bl, int type);
 int skillnotok(uint16 skill_id, struct map_session_data *sd);
-int skillnotok_hom(uint16 skill_id, struct homun_data *hd);
-int skillnotok_mercenary(uint16 skill_id, struct mercenary_data *md);
-
-int skill_chastle_mob_changetarget(struct block_list *bl,va_list ap);
-
-// Item creation
+int skillnotok_hom(uint16 skill_id, struct homun_data *hd);
+int skillnotok_mercenary(uint16 skill_id, struct mercenary_data *md);
+
+int skill_blockpc_clear(struct map_session_data *sd);
+int skill_blockpc_end(int tid, unsigned int tick, int id, intptr_t data);
+int skill_vending(struct map_session_data *sd, int nameid); // Extended Vending System
+
+int skill_chastle_mob_changetarget(struct block_list *bl,va_list ap);
+
+// Item creation
 int skill_can_produce_mix(struct map_session_data *sd, int nameid, int trigger, int qty);
 int skill_produce_mix(struct map_session_data *sd, uint16 skill_id, int nameid, int slot1, int slot2, int slot3, int qty);
 
@@ -370,18 +381,17 @@
 
 // skills for the mob
 int skill_castend_nodamage_id(struct block_list *src, struct block_list *bl,uint16 skill_id,uint16 skill_lv,unsigned int tick,int flag);
-int skill_castend_damage_id(struct block_list *src, struct block_list *bl,uint16 skill_id,uint16 skill_lv,unsigned int tick,int flag);
-int skill_castend_pos2(struct block_list *src, int x,int y,uint16 skill_id,uint16 skill_lv,unsigned int tick,int flag);
-
-int skill_blockpc_start_(struct map_session_data *, uint16 skill_id, int, bool);
-int skill_blockhomun_start(struct homun_data *,uint16 skill_id,int);
-int skill_blockmerc_start(struct mercenary_data *,uint16 skill_id,int);
-
-#define skill_blockpc_start(sd, skill_id, tick) skill_blockpc_start_( sd, skill_id, tick, false )
-
-// (Epoque:) To-do: replace this macro with some sort of skill tree check (rather than hard-coded skill names)
-#define skill_ischangesex(id) ( \
-                                ((id) >= BD_ADAPTATION     && (id) <= DC_SERVICEFORYOU) || ((id) >= CG_ARROWVULCAN && (id) <= CG_MARIONETTE) || \
+int skill_castend_damage_id( struct block_list* src, struct block_list *bl,uint16 skill_id,uint16 skill_lv,unsigned int tick,int flag );
+int skill_castend_pos2( struct block_list *src, int x,int y,uint16 skill_id,uint16 skill_lv,unsigned int tick,int flag);
+
+int skill_blockpc_start (struct map_session_data*, uint16 skill_id, int);
+int skill_blockpc_get(struct map_session_data *sd, uint16 skill_id);
+int skill_blockhomun_start (struct homun_data*, uint16 skill_id,int);
+int skill_blockmerc_start (struct mercenary_data*, uint16 skill_id,int);
+
+// (Epoque:) To-do: replace this macro with some sort of skill tree check (rather than hard-coded skill names)
+#define skill_ischangesex(id) ( \
+	((id) >= BD_ADAPTATION     && (id) <= DC_SERVICEFORYOU) || ((id) >= CG_ARROWVULCAN && (id) <= CG_MARIONETTE) || \
                                 ((id) >= CG_LONGINGFREEDOM && (id) <= CG_TAROTCARD)     || ((id) >= WA_SWING_DANCE && (id) <= WM_UNLIMITED_HUMMING_VOICE))
 
 // Skill action, (return dmg,heal)
@@ -1844,22 +1854,16 @@
     UNT_GD_GLORYWOUNDS = 0xc2,
     UNT_GD_SOULCOLD = 0xc3,
     UNT_GD_HAWKEYES = 0xc4,
-
-    UNT_MAX = 0x190
-};
-/**
- * Skill Unit Save
- **/
-void skill_usave_add(struct map_session_data *sd, uint16 skill_id, uint16 skill_lv);
-void skill_usave_trigger(struct map_session_data *sd);
-/**
- * Skill Cool Downs - load from pc.c when the character logs in
- **/
-void skill_cooldown_load(struct map_session_data *sd);
-/**
- * Warlock
- **/
-#define MAX_SKILL_SPELLBOOK_DB  17
+
+	UNT_MAX = 0x190
+};
+
+// Removed Usave and Cooldown by eAmod
+
+/**
+ * Warlock
+ **/
+#define MAX_SKILL_SPELLBOOK_DB	17
 enum wl_spheres {
     WLS_FIRE = 0x44,
     WLS_WIND,
Index: src/map/status.c
===================================================================
--- src/map/status.c	(revision 1953)
+++ src/map/status.c	(working copy)
@@ -23,6 +23,7 @@
 #include "../common/utils.h"
 #include "../common/ers.h"
 #include "../common/strlib.h"
+#include "../common/db.h"
 
 #include "map.h"
 #include "path.h"
@@ -44,6 +45,8 @@
 #include "mercenary.h"
 #include "elemental.h"
 #include "vending.h"
+#include "region.h"
+#include "faction.h"
 
 #include <time.h>
 #include <stdio.h>
@@ -824,7 +827,8 @@
 	StatusIconChangeTable[SC_DEF_RATE] = SI_DEF_RATE;
 	StatusIconChangeTable[SC_MDEF_RATE] = SI_MDEF_RATE;
 	StatusIconChangeTable[SC_INCCRI] = SI_INCCRI;
-	StatusIconChangeTable[SC_INCFLEE2] = SI_PLUSAVOIDVALUE;
+	// StatusIconChangeTable[SC_INCFLEE2] = SI_PLUSAVOIDVALUE; -- Removed to use this Status Icon on AutoRefresh feature
+	StatusIconChangeTable[SC_AUTOREFRESH] = SI_PLUSAVOIDVALUE;
 	StatusIconChangeTable[SC_INCHEALRATE] = SI_INCHEALRATE;
 	StatusIconChangeTable[SC_S_LIFEPOTION] = SI_S_LIFEPOTION;
 	StatusIconChangeTable[SC_L_LIFEPOTION] = SI_L_LIFEPOTION;
@@ -1146,7 +1150,7 @@
 //If flag&2, fail if target does not has enough to substract.
 //If flag&4, if killed, mob must not give exp/loot.
 //flag will be set to &8 when damaging sp of a dead character
-int status_damage(struct block_list *src,struct block_list *target,int hp, int sp, int walkdelay, int flag)
+int status_damage_(struct block_list *src,struct block_list *target,int hp, int sp, int walkdelay, int flag, uint16 skill_id)
 {
 	struct status_data *status;
 	struct status_change *sc;
@@ -1206,7 +1210,7 @@
 				if(d_bl &&((d_bl->type == BL_MER && ((TBL_MER *)d_bl)->master && ((TBL_MER *)d_bl)->master->bl.id == target->id)
 				           || (d_bl->type == BL_PC && ((TBL_PC *)d_bl)->devotion[sce->val2] == target->id)) && check_distance_bl(target, d_bl, sce->val3)) {
 					clif_damage(d_bl, d_bl, gettick(), 0, 0, hp, 0, 0, 0);
-					status_fix_damage(NULL, d_bl, hp, 0);
+					status_fix_damage2(NULL, d_bl, hp, 0);
 					return 0;
 				}
 
@@ -1279,6 +1283,8 @@
 	if(src && target->type == BL_PC && ((TBL_PC *)target)->disguise) { // stop walking when attacked in disguise to prevent walk-delay bug
 		unit_stop_walking(target, 1);
 	}
+	
+	pc_record_damage(src, target, hp);
 
 	if(status->hp || (flag&8)) {
 		//Still lives or has been dead before this damage.
@@ -1294,7 +1300,7 @@
 	//&2: Also remove object from map.
 	//&4: Also delete object from memory.
 	switch(target->type) {
-		case BL_PC:  flag = pc_dead((TBL_PC *)target,src); break;
+		case BL_PC:  flag = pc_dead((TBL_PC*)target,src,skill_id); break;
 		case BL_MOB: flag = mob_dead((TBL_MOB *)target, src, flag&4?3:0); break;
 		case BL_HOM: flag = merc_hom_dead((TBL_HOM *)target); break;
 		case BL_MER: flag = mercenary_dead((TBL_MER *)target); break;
@@ -2035,7 +2041,7 @@
 	if(battle_config.mobs_level_up && md->level > md->db->lv)
 		flag|=1;
 
-	if(md->special_state.size)
+	if (md->special_state.size && !md->option.max_hp)
 		flag|=2;
 
 	if(md->guardian_data && md->guardian_data->guardup_lv)
@@ -2048,6 +2054,9 @@
 
 	if(md->master_id && md->special_state.ai>1)
 		flag|=16;
+		
+	if (md->option.max_hp)
+		flag|=32;
 
 	if(!flag) {
 		//No special status required.
@@ -2109,6 +2118,9 @@
 			status->hp = status->max_hp;
 		}
 	}
+	
+	if (flag&32)
+		status->max_hp = status->hp = md->option.max_hp; // Max HP Setting from Event Configuration
 
 	if(flag&1) {
 		// increase from mobs leveling up [Valaris]
@@ -2331,6 +2343,7 @@
 	static int calculating = 0; //Check for recursive call preemption. [Skotlex]
 	struct status_data *status; // pointer to the player's base status
 	const struct status_change *sc = &sd->sc;
+	struct faction_data* fd = NULL; // Faction System
 	struct s_skill b_skill[MAX_SKILL]; // previous skill tree
 	int b_weight, b_max_weight, b_cart_weight_max, // previous weight
 	    i, index, skill,refinedef=0;
@@ -2429,17 +2442,22 @@
 	//Give them all modes except these (useful for clones)
 	status->mode = MD_MASK&~(MD_BOSS|MD_PLANT|MD_DETECTOR|MD_ANGRY|MD_TARGETWEAK);
 
-	status->size = (sd->class_&JOBL_BABY)?SZ_SMALL:SZ_MEDIUM;
-	if(battle_config.character_size && pc_isriding(sd) || pc_isridingwug(sd) || pc_ismadogear(sd) || pc_isridingdragon(sd)) {  //[Lupus]
-		if(sd->class_&JOBL_BABY) {
-			if(battle_config.character_size&SZ_BIG)
-				status->size++;
-		} else if(battle_config.character_size&SZ_MEDIUM)
-			status->size++;
+	if( sd->status.faction_id ) fd = faction_search(sd->status.faction_id);
+	status->aspd_rate = 1000;
+	status->size = fd ? fd->size : SZ_MEDIUM; // Default Size is Medium
+	if( sd->class_&JOBL_BABY && status->size > 0 )
+		status->size--; // Baby reduce size
+	if( status->size < 2 && battle_config.character_size && pc_isriding(sd) )
+	{
+		if( sd->class_&JOBL_BABY  )
+		{
+			if( battle_config.character_size&SZ_BIG ) status->size++;
+		}
+		else if( battle_config.character_size&SZ_MEDIUM ) status->size++;
 	}
-	status->aspd_rate = 1000;
-	status->ele_lv = 1;
-	status->race = RC_DEMIHUMAN;
+	status->def_ele = fd ? fd->def_ele : ELE_NEUTRAL; // Default Element is Neutral
+	status->ele_lv = fd ? fd->ele_lv : 1; // Default Element Level is 1
+	status->race = fd ? fd->race : RC_DEMIHUMAN; // Default Race is Demihuman
 
 	//zero up structures...
 	memset(&sd->autospell,0,sizeof(sd->autospell)
@@ -2477,9 +2495,42 @@
 	pc_delautobonus(sd,sd->autobonus,ARRAYLENGTH(sd->autobonus),true);
 	pc_delautobonus(sd,sd->autobonus2,ARRAYLENGTH(sd->autobonus2),true);
 	pc_delautobonus(sd,sd->autobonus3,ARRAYLENGTH(sd->autobonus3),true);
+	
+	// Parse Faction Bonus
+	if( fd && fd->script )
+	{
+		run_script(fd->script,0,sd->bl.id,0);
+		if( !calculating ) return 1; // Run Script called to status_calc_pc_ again and completed it ( calculating == 0 ).
+	}
+	if( first && fd ) sd->lang_id = fd->lang_id;
 
+	// Parse Regional Bonus
+	if( sd->status.guild_id )
+	{
+		DBMap* region_db;
+
+		if( (region_db = region_get_db()) != NULL )
+		{
+			struct region_data* rd;
+			DBIterator* iter;
+			DBKey key;
+
+			iter = region_db->iterator(region_db);
+			for( rd = (struct region_data*)iter->first(iter,&key); iter->exists(iter); rd = (struct region_data*)iter->next(iter,&key) )
+			{
+				if( !rd->script || rd->guild_id != sd->status.guild_id )
+					continue;
+
+				run_script(rd->script,0,sd->bl.id,0);
+				if( !calculating ) break;
+			}
+			iter->destroy(iter);
+			if( !calculating ) return 1; // Run Script called to status_calc_pc_ again and completed it ( calculating == 0 ).
+		}
+	}
+
 	// Parse equipment.
-	for(i=0; i<EQI_MAX-1; i++) {
+	for(i=0;i<EQI_MAX_BONUS;i++) {
 		current_equip_item_index = index = sd->equip_index[i]; //We pass INDEX to current_equip_item_index - for EQUIP_SCRIPT (new cards solution) [Lupus]
 		if(index < 0)
 			continue;
@@ -2489,10 +2540,6 @@
 			continue;
 		if(i == EQI_HEAD_TOP && (sd->equip_index[EQI_HEAD_MID] == index || sd->equip_index[EQI_HEAD_LOW] == index))
 			continue;
-		if(i == EQI_COSTUME_MID && sd->equip_index[EQI_COSTUME_LOW] == index)
-			continue;
-		if(i == EQI_COSTUME_TOP && (sd->equip_index[EQI_COSTUME_MID] == index || sd->equip_index[EQI_COSTUME_LOW] == index))
-			continue;
 		if(!sd->inventory_data[index])
 			continue;
 
@@ -2618,7 +2665,7 @@
 	status->def += (refinedef+50)/100;
 
 	//Parse Cards
-	for(i=0; i<EQI_MAX-1; i++) {
+	for(i=0;i<EQI_MAX_BONUS;i++) {
 		current_equip_item_index = index = sd->equip_index[i]; //We pass INDEX to current_equip_item_index - for EQUIP_SCRIPT (new cards solution) [Lupus]
 		if(index < 0)
 			continue;
@@ -2640,6 +2687,8 @@
 				current_equip_card_id= c= sd->status.inventory[index].card[j];
 				if(!c)
 					continue;
+				if( j >= sd->inventory_data[index]->slot && !itemdb_isenchant(c) )
+					continue;
 				data = itemdb_exists(c);
 				if(!data)
 					continue;
@@ -2658,9 +2707,9 @@
 						continue;
 					if(map[sd->bl.m].flag.pvp && data->flag.no_equip&2)
 						continue;
-					if(map_flag_gvg(sd->bl.m) && data->flag.no_equip&4)
+					if(map_flag_gvg2(sd->bl.m) && data->flag.no_equip&4)
 						continue;
-					if(map[sd->bl.m].flag.battleground && data->flag.no_equip&8)
+					if((map[sd->bl.m].flag.battleground || map[sd->bl.m].flag.pvp_event) && data->flag.no_equip&8)
 						continue;
 				}
 				if(i == EQI_HAND_L && sd->status.inventory[index].equip == EQP_HAND_L) {
@@ -2680,6 +2729,8 @@
 		struct item_data *data = itemdb_exists(sc->data[SC_ITEMSCRIPT]->val1);
 		if(data && data->script)
 			run_script(data->script,0,sd->bl.id,0);
+		if( !calculating ) //Abort, run_script his function. [Skotlex]
+			return 1;
 	}
 
 	if(sd->pd) {
@@ -2687,6 +2738,8 @@
 		struct pet_data *pd = sd->pd;
 		if(pd && pd->petDB && pd->petDB->equip_script && pd->pet.intimate >= battle_config.pet_equip_min_friendly)
 			run_script(pd->petDB->equip_script,0,sd->bl.id,0);
+		if( !calculating ) //Abort, run_script his function. [Skotlex]
+			return 1;
 		if(pd && pd->pet.intimate > 0 && (!battle_config.pet_equip_required || pd->pet.equip > 0) && pd->state.skillbonus == 1 && pd->bonus)
 			pc_bonus(sd,pd->bonus->type, pd->bonus->val);
 	}
@@ -2753,6 +2806,15 @@
 		status->dex += skill;
 	if((skill = pc_checkskill(sd,RA_RESEARCHTRAP))>0)
 		status->int_ += skill;
+		
+	if (sd->gm_power) {
+		status->str += sd->gm_stats[0];
+		status->agi += sd->gm_stats[1];
+		status->vit += sd->gm_stats[2];
+		status->int_+= sd->gm_stats[3];
+		status->dex += sd->gm_stats[4];
+		status->luk += sd->gm_stats[5];
+	}
 
 	// Bonuses from cards and equipment as well as base stat, remember to avoid overflows.
 	i = status->str + sd->status.str + sd->param_bonus[0] + sd->param_equip[0];
@@ -4813,6 +4875,8 @@
 			flee -= flee * battle_config.gvg_flee_penalty/100;
 		else if(map[bl->m].flag.battleground)
 			flee -= flee * battle_config.bg_flee_penalty/100;
+		else if( map[bl->m].flag.pvp_event && pvpevent_flag )
+			flee -= flee * battle_config.pvpevent_flee_penalty/100;
 	}
 
 	if(!sc || !sc->count)
@@ -5870,6 +5934,62 @@
 	return status_get_status_data(bl)->speed;
 }
 
+struct map_session_data *status_get_master_sd(struct block_list *bl)
+{
+	struct map_session_data *sd = NULL;
+
+	if( bl )
+	switch( bl->type )
+	{
+	case BL_PC:
+		sd = BL_CAST(BL_PC,bl);
+		break;
+	case BL_PET:
+		sd = ((TBL_PET*)bl)->msd;
+		break;
+	case BL_MOB:
+		{
+			struct mob_data *md = BL_CAST(BL_MOB,bl);
+			if( md->master_id > 0 && md->special_state.ai )
+				sd = map_id2sd(md->master_id);
+		}
+		break;
+	case BL_HOM:
+		sd = ((TBL_HOM*)bl)->master;
+		break;
+	case BL_MER:
+		sd = ((TBL_MER*)bl)->master;
+		break;
+	case BL_ELEM:
+		sd = ((TBL_ELEM*)bl)->master;
+		break;
+	}
+
+	return sd;
+}
+
+int status_get_faction_id(struct block_list *bl)
+{
+	if( bl )
+	{
+		struct map_session_data *sd = status_get_master_sd(bl);
+		if( sd ) return sd->status.faction_id;
+
+		// Other Situations
+		switch( bl->type )
+		{
+		case BL_MOB:
+			return ((TBL_MOB*)bl)->option.faction_id;
+		case BL_SKILL:
+			return ((TBL_SKILL*)bl)->group->faction_id;
+		case BL_NPC:
+			return ((TBL_NPC*)bl)->u.scr.faction_id;
+		}
+	}
+
+	return 0;
+}
+
 int status_get_party_id(struct block_list *bl)
 {
 	nullpo_ret(bl);
@@ -5882,6 +6002,8 @@
 			break;
 		case BL_MOB: {
 				struct mob_data *md=(TBL_MOB *)bl;
+				if( md->option.is_event && map[bl->m].flag.pvp && md->option.party_id )
+					return md->option.party_id;
 				if(md->master_id > 0) {
 					struct map_session_data *msd;
 					if(md->special_state.ai && (msd = map_id2sd(md->master_id)) != NULL)
@@ -5925,6 +6047,10 @@
 					return md->guardian_data->guild_id;
 				if(md->special_state.ai && (msd = map_id2sd(md->master_id)) != NULL)
 					return msd->status.guild_id; //Alchemist's mobs [Skotlex]
+				if (md->option.is_event && map[bl->m].flag.gvg)
+					return md->option.guild_id;
+				if (map[bl->m].region_id && md->option.is_war && !map_flag_vs(bl->m))
+					return md->option.guild_id;
 			}
 			break;
 		case BL_HOM:
@@ -5962,6 +6088,8 @@
 		case BL_MOB: {
 				struct map_session_data *msd;
 				struct mob_data *md = (struct mob_data *)bl;
+				if (md->option.is_war && md->option.guild_id)
+					return md->option.guild_emblem_id;
 				if(md->guardian_data)   //Guardian's guild [Skotlex]
 					return md->guardian_data->emblem_id;
 				if(md->special_state.ai && (msd = map_id2sd(md->master_id)) != NULL)
@@ -6508,8 +6636,8 @@
 int status_change_start(struct block_list* src, struct block_list* bl,enum sc_type type,int rate,int val1,int val2,int val3,int val4,int tick,int flag)
 {
 	struct map_session_data *sd = NULL;
-	struct status_change *sc;
-	struct status_change_entry *sce;
+	struct status_change* sc;
+	struct status_change_entry* sce;
 	struct status_data *status;
 	struct view_data *vd;
 	int opt_flag, calc_flag, undead_flag, val_flag = 0, tick_time = 0;
@@ -6519,58 +6647,60 @@
 	sc = status_get_sc(bl);
 	status = status_get_status_data(bl);
 
-	if(type <= SC_NONE || type >= SC_MAX) {
+	if( type <= SC_NONE || type >= SC_MAX )
+	{
 		ShowError("status_change_start: invalid status change (%d)!\n", type);
 		return 0;
 	}
 
-	if(!sc)
+	if( !sc )
 		return 0; //Unable to receive status changes
 
-	if(status_isdead(bl) && type != SC_NOCHAT && type != SC_LIFEINSURANCE)   // SC_NOCHAT should work even on dead characters.
+	if( status_isdead(bl) && type != SC_NOCHAT ) // SC_NOCHAT should work even on dead characters
 		return 0;
 
-	if(bl->type == BL_MOB) {
+	if( bl->type == BL_MOB)
+	{
 		struct mob_data *md = BL_CAST(BL_MOB,bl);
 		if(md && (md->class_ == MOBID_EMPERIUM || mob_is_battleground(md)) && type != SC_SAFETYWALL && type != SC_PNEUMA)
 			return 0; //Emperium/BG Monsters can't be afflicted by status changes
-		//  if(md && mob_is_gvg(md) && status_sc2scb_flag(type)&SCB_MAXHP)
-		//      return 0; //prevent status addinh hp to gvg mob (like bloodylust=hp*3 etc...
+	//	if(md && mob_is_gvg(md) && status_sc2scb_flag(type)&SCB_MAXHP)
+	//		return 0; //prevent status addinh hp to gvg mob (like bloodylust=hp*3 etc...
 	}
 
-	if(sc->data[SC_REFRESH]) {
-		if(type >= SC_COMMON_MIN && type <= SC_COMMON_MAX)  // Confirmed.
+	if( sc->data[SC_REFRESH] ) {
+		if( type >= SC_COMMON_MIN && type <= SC_COMMON_MAX) // Confirmed.
 			return 0; // Immune to status ailements
-		switch(type) {
-			case SC_DEEPSLEEP:
-			case SC_BURNING:
-			case SC_STUN:
-			case SC_SLEEP:
-			case SC_CURSE:
-			case SC_STONE:
-			case SC_POISON:
-			case SC_BLIND:
-			case SC_SILENCE:
-			case SC_BLEEDING:
-			case SC_FREEZE:
-			case SC_FREEZING:
-			//case SC_WHITEIMPRISON://Need confirm. Protected against this in the past. [Rytech]
-			case SC_CRYSTALIZE:
-			case SC_TOXIN:
-			case SC_PARALYSE:
-			case SC_VENOMBLEED:
-			case SC_MAGICMUSHROOM:
-			case SC_DEATHHURT:
-			case SC_PYREXIA:
-			case SC_OBLIVIONCURSE:
-			case SC_MARSHOFABYSS:
-			case SC_MANDRAGORA:
-				return 0;
+		switch( type ) {
+		case SC_DEEPSLEEP:
+		case SC_BURNING:
+		case SC_STUN:
+		case SC_SLEEP:
+		case SC_CURSE:
+		case SC_STONE:
+		case SC_POISON:
+		case SC_BLIND:
+		case SC_SILENCE:
+		case SC_BLEEDING:
+		case SC_FREEZE:
+		case SC_FREEZING:
+		case SC_CRYSTALIZE:
+		case SC_TOXIN:
+		case SC_PARALYSE:
+		case SC_VENOMBLEED:
+		case SC_MAGICMUSHROOM:
+		case SC_DEATHHURT:
+		case SC_PYREXIA:
+		case SC_OBLIVIONCURSE:
+		case SC_MARSHOFABYSS:
+		case SC_MANDRAGORA:
+			return 0;
 		}
-	} else if(sc->data[SC_INSPIRATION]) {
-		if(type >= SC_COMMON_MIN && type <= SC_COMMON_MAX)
+	}
+	else if( sc->data[SC_INSPIRATION] ) {
+		if( type >= SC_COMMON_MIN && type <= SC_COMMON_MAX )
 			return 0; // Immune to status ailements
-		switch(type) {
+		switch( type ) {
 			case SC_DEEPSLEEP:
 			case SC_SATURDAYNIGHTFEVER:
 			case SC_PYREXIA:
@@ -6594,308 +6724,310 @@
 	sd = BL_CAST(BL_PC, bl);
 
 	//Adjust tick according to status resistances
-	if(!(flag&(1|4))) {
+	if( !(flag&(1|4)) )
+	{
 		tick = status_get_sc_def(src, bl, type, rate, tick, flag);
-		if(!tick) return 0;
+		if( !tick ) return 0;
 	}
 
 	undead_flag = battle_check_undead(status->race,status->def_ele);
 	//Check for inmunities / sc fails
-	switch(type) {
-		case SC_ANGRIFFS_MODUS:
-		case SC_GOLDENE_FERSE:
-			if((type==SC_GOLDENE_FERSE && sc->data[SC_ANGRIFFS_MODUS])
-			   || (type==SC_ANGRIFFS_MODUS && sc->data[SC_GOLDENE_FERSE])
-			  )
-				return 0;
-		case SC_STONE:
-			if(sc->data[SC_POWER_OF_GAIA])
-				return 0;
-		case SC_FREEZE:
-			//Undead are immune to Freeze/Stone
-			if(undead_flag && !(flag&1))
-				return 0;
-		case SC_DEEPSLEEP:
-		case SC_SLEEP:
-		case SC_STUN:
-		case SC_FREEZING:
-		case SC_CRYSTALIZE:
-			if(sc->opt1)
-				return 0; //Cannot override other opt1 status changes. [Skotlex]
-			if((type == SC_FREEZE || type == SC_FREEZING || type == SC_CRYSTALIZE) && sc->data[SC_WARMER])
-				return 0; //Immune to Frozen and Freezing status if under Warmer status. [Jobbie]
-			break;
+	switch (type) {
+        case SC_ANGRIFFS_MODUS:
+        case SC_GOLDENE_FERSE:
+             if ((type==SC_GOLDENE_FERSE && sc->data[SC_ANGRIFFS_MODUS])
+                     || (type==SC_ANGRIFFS_MODUS && sc->data[SC_GOLDENE_FERSE])
+                     )
+                return 0;
+	case SC_STONE:
+		if(sc->data[SC_POWER_OF_GAIA])
+			return 0;
+	case SC_FREEZE:
+		//Undead are immune to Freeze/Stone
+		if (undead_flag && !(flag&1))
+			return 0;
+	case SC_DEEPSLEEP:
+	case SC_SLEEP:
+	case SC_STUN:
+	case SC_FREEZING:
+	case SC_CRYSTALIZE:
+		if (sc->opt1)
+			return 0; //Cannot override other opt1 status changes. [Skotlex]
+		if((type == SC_FREEZE || type == SC_FREEZING || type == SC_CRYSTALIZE) && sc->data[SC_WARMER])
+			return 0; //Immune to Frozen and Freezing status if under Warmer status. [Jobbie]
+	break;
 
-			//There all like berserk, do not everlap each other
-		case SC__BLOODYLUST:
-			if(!sd) return 0; //should only affect player
-		case SC_BERSERK:
-			if(((type == SC_BERSERK) && (sc->data[SC_SATURDAYNIGHTFEVER] || sc->data[SC__BLOODYLUST]))
-			   || ((type == SC__BLOODYLUST) && (sc->data[SC_SATURDAYNIGHTFEVER] || sc->data[SC_BERSERK]))
-			  )
-				return 0;
-			break;
+            //There all like berserk, do not everlap each other
+	case SC__BLOODYLUST:
+		if(!sd) return 0; //should only affect player
+	case SC_BERSERK:
+		if (((type == SC_BERSERK) && (sc->data[SC_SATURDAYNIGHTFEVER] || sc->data[SC__BLOODYLUST]))
+		|| ((type == SC__BLOODYLUST) && (sc->data[SC_SATURDAYNIGHTFEVER] || sc->data[SC_BERSERK]))
+		)
+			return 0;
+		break;
 
-		case SC_BURNING:
-			if(sc->opt1 || sc->data[SC_FREEZING])
-				return 0;
-			break;
+	case SC_BURNING:
+		if(sc->opt1 || sc->data[SC_FREEZING])
+			return 0;
+	break;
 
-		case SC_SIGNUMCRUCIS:
-			//Only affects demons and undead element (but not players)
-			if((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC)
-				return 0;
-			break;
-		case SC_AETERNA:
-			if((sc->data[SC_STONE] && sc->opt1 == OPT1_STONE) || sc->data[SC_FREEZE])
-				return 0;
-			break;
-		case SC_KYRIE:
-			if(bl->type == BL_MOB)
-				return 0;
-			break;
-		case SC_OVERTHRUST:
-			if(sc->data[SC_MAXOVERTHRUST])
-				return 0; //Overthrust can't take effect if under Max Overthrust. [Skotlex]
-		case SC_MAXOVERTHRUST:
-			if(sc->option&OPTION_MADOGEAR)
-				return 0;//Overthrust and Overthrust Max cannot be used on Mado Gear [Ind]
-			break;
-		case SC_ADRENALINE:
-			if(sd && !pc_check_weapontype(sd,skill_get_weapontype(BS_ADRENALINE)))
-				return 0;
-			if(sc->data[SC_QUAGMIRE] ||
-			   sc->data[SC_DECREASEAGI] ||
-			   sc->data[SC_ADORAMUS] ||
-			   sc->option&OPTION_MADOGEAR //Adrenaline doesn't affect Mado Gear [Ind]
-			  )
-				return 0;
-			break;
-		case SC_ADRENALINE2:
-			if(sd && !pc_check_weapontype(sd,skill_get_weapontype(BS_ADRENALINE2)))
-				return 0;
-			if(sc->data[SC_QUAGMIRE] ||
-			   sc->data[SC_DECREASEAGI] ||
-			   sc->data[SC_ADORAMUS]
-			  )
-				return 0;
-			break;
-		case SC_MAGNIFICAT:
-			if(sc->option&OPTION_MADOGEAR)   //Mado is immune to magnificat
-				return 0;
-			break;
-		case SC_ONEHAND:
-		case SC_MERC_QUICKEN:
-		case SC_TWOHANDQUICKEN:
-			if(sc->data[SC_DECREASEAGI] || sc->data[SC_ADORAMUS])
-				return 0;
+	case SC_SIGNUMCRUCIS:
+		//Only affects demons and undead element (but not players)
+		if((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC)
+			return 0;
+	break;
+	case SC_AETERNA:
+		if( (sc->data[SC_STONE] && sc->opt1 == OPT1_STONE) || sc->data[SC_FREEZE] )
+			return 0;
+	break;
+	case SC_KYRIE:
+		if (bl->type == BL_MOB)
+			return 0;
+	break;
+	case SC_OVERTHRUST:
+		if (sc->data[SC_MAXOVERTHRUST])
+			return 0; //Overthrust can't take effect if under Max Overthrust. [Skotlex]
+	case SC_MAXOVERTHRUST:
+		if( sc->option&OPTION_MADOGEAR )
+			return 0;//Overthrust and Overthrust Max cannot be used on Mado Gear [Ind]
+	break;
+	case SC_ADRENALINE:
+		if(sd && !pc_check_weapontype(sd,skill_get_weapontype(BS_ADRENALINE)))
+			return 0;
+		if (sc->data[SC_QUAGMIRE] ||
+			sc->data[SC_DECREASEAGI] ||
+			sc->data[SC_ADORAMUS] ||
+			sc->option&OPTION_MADOGEAR //Adrenaline doesn't affect Mado Gear [Ind]
+		)
+			return 0;
+	break;
+	case SC_ADRENALINE2:
+		if(sd && !pc_check_weapontype(sd,skill_get_weapontype(BS_ADRENALINE2)))
+			return 0;
+		if (sc->data[SC_QUAGMIRE] ||
+			sc->data[SC_DECREASEAGI] ||
+			sc->data[SC_ADORAMUS]
+		)
+			return 0;
+	break;
+	case SC_MAGNIFICAT:
+		if( sc->option&OPTION_MADOGEAR ) //Mado is immune to magnificat
+			return 0;
+		break;
+	case SC_ONEHAND:
+	case SC_MERC_QUICKEN:
+	case SC_TWOHANDQUICKEN:
+		if(sc->data[SC_DECREASEAGI] || sc->data[SC_ADORAMUS])
+			return 0;
 
-		case SC_INCREASEAGI:
-			if(sd && pc_issit(sd)) {
-				pc_setstand(sd);
-			}
+	case SC_INCREASEAGI:
+		 if(sd && pc_issit(sd)){
+			 pc_setstand(sd);
+		 }
 
-		case SC_CONCENTRATE:
-		case SC_SPEARQUICKEN:
-		case SC_TRUESIGHT:
-		case SC_WINDWALK:
-		case SC_CARTBOOST:
-		case SC_ASSNCROS:
-			if(sc->data[SC_QUAGMIRE])
+	case SC_CONCENTRATE:
+	case SC_SPEARQUICKEN:
+	case SC_TRUESIGHT:
+	case SC_WINDWALK:
+	case SC_CARTBOOST:
+	case SC_ASSNCROS:
+		if (sc->data[SC_QUAGMIRE])
+			return 0;
+		if(sc->option&OPTION_MADOGEAR)
+			return 0;//Mado is immune to increase agi, wind walk, cart boost, etc (others above) [Ind]
+	break;
+	case SC_CLOAKING:
+		//Avoid cloaking with no wall and low skill level. [Skotlex]
+		//Due to the cloaking card, we have to check the wall versus to known
+		//skill level rather than the used one. [Skotlex]
+		//if (sd && val1 < 3 && skill_check_cloaking(bl,NULL))
+		if( sd && pc_checkskill(sd, AS_CLOAKING) < 3 && !skill_check_cloaking(bl,NULL) )
+			return 0;
+	break;
+	case SC_MODECHANGE:
+	{
+		int mode;
+		struct status_data *bstatus = status_get_base_status(bl);
+		if (!bstatus) return 0;
+		if (sc->data[type])
+		{	//Pile up with previous values.
+			if(!val2) val2 = sc->data[type]->val2;
+			val3 |= sc->data[type]->val3;
+			val4 |= sc->data[type]->val4;
+		}
+		mode = val2?val2:bstatus->mode; //Base mode
+		if (val4) mode&=~val4; //Del mode
+		if (val3) mode|= val3; //Add mode
+		if (mode == bstatus->mode) { //No change.
+			if (sc->data[type]) //Abort previous status
+				return status_change_end(bl, type, INVALID_TIMER);
+			return 0;
+		}
+	}
+	break;
+	//Strip skills, need to divest something or it fails.
+	case SC_STRIPWEAPON:
+		if (sd && !(flag&4)) { //apply sc anyway if loading saved sc_data
+			int i;
+			opt_flag = 0; //Reuse to check success condition.
+			if(sd->bonus.unstripable_equip&EQP_WEAPON)
 				return 0;
-			if(sc->option&OPTION_MADOGEAR)
-				return 0;//Mado is immune to increase agi, wind walk, cart boost, etc (others above) [Ind]
-			break;
-		case SC_CLOAKING:
-			//Avoid cloaking with no wall and low skill level. [Skotlex]
-			//Due to the cloaking card, we have to check the wall versus to known
-			//skill level rather than the used one. [Skotlex]
-			//if (sd && val1 < 3 && skill_check_cloaking(bl,NULL))
-			if(sd && pc_checkskill(sd, AS_CLOAKING) < 3 && !skill_check_cloaking(bl,NULL))
-				return 0;
-			break;
-		case SC_MODECHANGE: {
-				int mode;
-				struct status_data *bstatus = status_get_base_status(bl);
-				if(!bstatus) return 0;
-				if(sc->data[type]) {
-					//Pile up with previous values.
-					if(!val2) val2 = sc->data[type]->val2;
-					val3 |= sc->data[type]->val3;
-					val4 |= sc->data[type]->val4;
-				}
-				mode = val2?val2:bstatus->mode; //Base mode
-				if(val4) mode&=~val4;  //Del mode
-				if(val3) mode|= val3;  //Add mode
-				if(mode == bstatus->mode) {  //No change.
-					if(sc->data[type])  //Abort previous status
-						return status_change_end(bl, type, INVALID_TIMER);
-					return 0;
-				}
+			i = sd->equip_index[EQI_HAND_L];
+			if (i>=0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_WEAPON) {
+				opt_flag|=1;
+				pc_unequipitem(sd,i,3); //L-hand weapon
 			}
-			break;
-			//Strip skills, need to divest something or it fails.
-		case SC_STRIPWEAPON:
-			if(sd && !(flag&4)) {  //apply sc anyway if loading saved sc_data
-				int i;
-				opt_flag = 0; //Reuse to check success condition.
-				if(sd->bonus.unstripable_equip&EQP_WEAPON)
-					return 0;
-				i = sd->equip_index[EQI_HAND_L];
-				if(i>=0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_WEAPON) {
-					opt_flag|=1;
-					pc_unequipitem(sd,i,3); //L-hand weapon
-				}
 
-				i = sd->equip_index[EQI_HAND_R];
-				if(i>=0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_WEAPON) {
-					opt_flag|=2;
-					pc_unequipitem(sd,i,3);
-				}
-				if(!opt_flag) return 0;
-			}
-			if(tick == 1) return 1;  //Minimal duration: Only strip without causing the SC
-			break;
-		case SC_STRIPSHIELD:
-			if(val2 == 1) val2 = 0;   //GX effect. Do not take shield off..
-			else if(sd && !(flag&4)) {
-				int i;
-				if(sd->bonus.unstripable_equip&EQP_SHIELD)
-					return 0;
-				i = sd->equip_index[EQI_HAND_L];
-				if(i < 0 || !sd->inventory_data[i] || sd->inventory_data[i]->type != IT_ARMOR)
-					return 0;
+			i = sd->equip_index[EQI_HAND_R];
+			if (i>=0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_WEAPON) {
+				opt_flag|=2;
 				pc_unequipitem(sd,i,3);
 			}
-			if(tick == 1) return 1;  //Minimal duration: Only strip without causing the SC
-			break;
-		case SC_STRIPARMOR:
-			if(sd && !(flag&4)) {
-				int i;
-				if(sd->bonus.unstripable_equip&EQP_ARMOR)
-					return 0;
-				i = sd->equip_index[EQI_ARMOR];
-				if(i < 0 || !sd->inventory_data[i])
-					return 0;
-				pc_unequipitem(sd,i,3);
-			}
-			if(tick == 1) return 1;  //Minimal duration: Only strip without causing the SC
-			break;
-		case SC_STRIPHELM:
-			if(sd && !(flag&4)) {
-				int i;
-				if(sd->bonus.unstripable_equip&EQP_HELM)
-					return 0;
-				i = sd->equip_index[EQI_HEAD_TOP];
-				if(i < 0 || !sd->inventory_data[i])
-					return 0;
-				pc_unequipitem(sd,i,3);
-			}
-			if(tick == 1) return 1;  //Minimal duration: Only strip without causing the SC
-			break;
-		case SC_MERC_FLEEUP:
-		case SC_MERC_ATKUP:
-		case SC_MERC_HPUP:
-		case SC_MERC_SPUP:
-		case SC_MERC_HITUP:
-			if(bl->type != BL_MER)
-				return 0; // Stats only for Mercenaries
-			break;
-		case SC_STRFOOD:
-			if(sc->data[SC_FOOD_STR_CASH] && sc->data[SC_FOOD_STR_CASH]->val1 > val1)
+			if (!opt_flag) return 0;
+		}
+		if (tick == 1) return 1; //Minimal duration: Only strip without causing the SC
+	break;
+	case SC_STRIPSHIELD:
+		if( val2 == 1 ) val2 = 0; //GX effect. Do not take shield off..
+		else
+		if (sd && !(flag&4)) {
+			int i;
+			if(sd->bonus.unstripable_equip&EQP_SHIELD)
 				return 0;
-			break;
-		case SC_AGIFOOD:
-			if(sc->data[SC_FOOD_AGI_CASH] && sc->data[SC_FOOD_AGI_CASH]->val1 > val1)
+			i = sd->equip_index[EQI_HAND_L];
+			if ( i < 0 || !sd->inventory_data[i] || sd->inventory_data[i]->type != IT_ARMOR )
 				return 0;
-			break;
-		case SC_VITFOOD:
-			if(sc->data[SC_FOOD_VIT_CASH] && sc->data[SC_FOOD_VIT_CASH]->val1 > val1)
+			pc_unequipitem(sd,i,3);
+		}
+		if (tick == 1) return 1; //Minimal duration: Only strip without causing the SC
+	break;
+	case SC_STRIPARMOR:
+		if (sd && !(flag&4)) {
+			int i;
+			if(sd->bonus.unstripable_equip&EQP_ARMOR)
 				return 0;
-			break;
-		case SC_INTFOOD:
-			if(sc->data[SC_FOOD_INT_CASH] && sc->data[SC_FOOD_INT_CASH]->val1 > val1)
+			i = sd->equip_index[EQI_ARMOR];
+			if ( i < 0 || !sd->inventory_data[i] )
 				return 0;
-			break;
-		case SC_DEXFOOD:
-			if(sc->data[SC_FOOD_DEX_CASH] && sc->data[SC_FOOD_DEX_CASH]->val1 > val1)
+			pc_unequipitem(sd,i,3);
+		}
+		if (tick == 1) return 1; //Minimal duration: Only strip without causing the SC
+	break;
+	case SC_STRIPHELM:
+		if (sd && !(flag&4)) {
+			int i;
+			if(sd->bonus.unstripable_equip&EQP_HELM)
 				return 0;
-			break;
-		case SC_LUKFOOD:
-			if(sc->data[SC_FOOD_LUK_CASH] && sc->data[SC_FOOD_LUK_CASH]->val1 > val1)
+			i = sd->equip_index[EQI_HEAD_TOP];
+			if ( i < 0 || !sd->inventory_data[i] )
 				return 0;
-			break;
-		case SC_FOOD_STR_CASH:
-			if(sc->data[SC_STRFOOD] && sc->data[SC_STRFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_FOOD_AGI_CASH:
-			if(sc->data[SC_AGIFOOD] && sc->data[SC_AGIFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_FOOD_VIT_CASH:
-			if(sc->data[SC_VITFOOD] && sc->data[SC_VITFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_FOOD_INT_CASH:
-			if(sc->data[SC_INTFOOD] && sc->data[SC_INTFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_FOOD_DEX_CASH:
-			if(sc->data[SC_DEXFOOD] && sc->data[SC_DEXFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_FOOD_LUK_CASH:
-			if(sc->data[SC_LUKFOOD] && sc->data[SC_LUKFOOD]->val1 > val1)
-				return 0;
-			break;
-		case SC_CAMOUFLAGE:
-			if(sd && pc_checkskill(sd, RA_CAMOUFLAGE) < 3 && !skill_check_camouflage(bl,NULL))
-				return 0;
-			break;
-		case SC__STRIPACCESSORY:
-			if(sd) {
-				int i = -1;
-				if(!(sd->bonus.unstripable_equip&EQI_ACC_L)) {
-					i = sd->equip_index[EQI_ACC_L];
-					if(i >= 0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_ARMOR)
-						pc_unequipitem(sd,i,3); //L-Accessory
-				} if(!(sd->bonus.unstripable_equip&EQI_ACC_R)) {
-					i = sd->equip_index[EQI_ACC_R];
-					if(i >= 0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_ARMOR)
-						pc_unequipitem(sd,i,3); //R-Accessory
-				}
-				if(i < 0)
-					return 0;
+			pc_unequipitem(sd,i,3);
+		}
+		if (tick == 1) return 1; //Minimal duration: Only strip without causing the SC
+	break;
+	case SC_MERC_FLEEUP:
+	case SC_MERC_ATKUP:
+	case SC_MERC_HPUP:
+	case SC_MERC_SPUP:
+	case SC_MERC_HITUP:
+		if( bl->type != BL_MER )
+			return 0; // Stats only for Mercenaries
+	break;
+	case SC_STRFOOD:
+		if (sc->data[SC_FOOD_STR_CASH] && sc->data[SC_FOOD_STR_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_AGIFOOD:
+		if (sc->data[SC_FOOD_AGI_CASH] && sc->data[SC_FOOD_AGI_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_VITFOOD:
+		if (sc->data[SC_FOOD_VIT_CASH] && sc->data[SC_FOOD_VIT_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_INTFOOD:
+		if (sc->data[SC_FOOD_INT_CASH] && sc->data[SC_FOOD_INT_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_DEXFOOD:
+		if (sc->data[SC_FOOD_DEX_CASH] && sc->data[SC_FOOD_DEX_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_LUKFOOD:
+		if (sc->data[SC_FOOD_LUK_CASH] && sc->data[SC_FOOD_LUK_CASH]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_STR_CASH:
+		if (sc->data[SC_STRFOOD] && sc->data[SC_STRFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_AGI_CASH:
+		if (sc->data[SC_AGIFOOD] && sc->data[SC_AGIFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_VIT_CASH:
+		if (sc->data[SC_VITFOOD] && sc->data[SC_VITFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_INT_CASH:
+		if (sc->data[SC_INTFOOD] && sc->data[SC_INTFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_DEX_CASH:
+		if (sc->data[SC_DEXFOOD] && sc->data[SC_DEXFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_FOOD_LUK_CASH:
+		if (sc->data[SC_LUKFOOD] && sc->data[SC_LUKFOOD]->val1 > val1)
+			return 0;
+	break;
+	case SC_CAMOUFLAGE:
+		if( sd && pc_checkskill(sd, RA_CAMOUFLAGE) < 3 && !skill_check_camouflage(bl,NULL) )
+			return 0;
+	break;
+	case SC__STRIPACCESSORY:
+		if( sd ) {
+			int i = -1;
+			if( !(sd->bonus.unstripable_equip&EQI_ACC_L) ) {
+				i = sd->equip_index[EQI_ACC_L];
+				if( i >= 0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_ARMOR )
+					pc_unequipitem(sd,i,3); //L-Accessory
+			} if( !(sd->bonus.unstripable_equip&EQI_ACC_R) ) {
+				i = sd->equip_index[EQI_ACC_R];
+				if( i >= 0 && sd->inventory_data[i] && sd->inventory_data[i]->type == IT_ARMOR )
+					pc_unequipitem(sd,i,3); //R-Accessory
 			}
-			if(tick == 1) return 1;  //Minimal duration: Only strip without causing the SC
-			break;
-		case SC_TOXIN:
-		case SC_PARALYSE:
-		case SC_VENOMBLEED:
-		case SC_MAGICMUSHROOM:
-		case SC_DEATHHURT:
-		case SC_PYREXIA:
-		case SC_OBLIVIONCURSE:
-		case SC_LEECHESEND: {
-				// it doesn't stack or even renewed
-				int i = SC_TOXIN;
-				for(; i<= SC_LEECHESEND; i++)
-					if(sc->data[i]) return 0;
-			}
-			break;
-
-		case SC_SATURDAYNIGHTFEVER:
-			if(sc->data[SC_BERSERK] || sc->data[SC_INSPIRATION] || sc->data[SC__BLOODYLUST])
+			if( i < 0 )
 				return 0;
-			break;
+		}
+		if (tick == 1) return 1; //Minimal duration: Only strip without causing the SC
+	break;
+	case SC_TOXIN:
+	case SC_PARALYSE:
+	case SC_VENOMBLEED:
+	case SC_MAGICMUSHROOM:
+	case SC_DEATHHURT:
+	case SC_PYREXIA:
+	case SC_OBLIVIONCURSE:
+	case SC_LEECHESEND:
+		{ // it doesn't stack or even renewed
+			int i = SC_TOXIN;
+			for(; i<= SC_LEECHESEND; i++)
+				if(sc->data[i])	return 0;
+		}
+	break;
+	case SC_SATURDAYNIGHTFEVER:
+		if (sc->data[SC_BERSERK] || sc->data[SC_INSPIRATION] || sc->data[SC__BLOODYLUST])
+			return 0;
+		break;
 	}
 
 	//Check for BOSS resistances
 	if(status->mode&MD_BOSS && !(flag&1)) {
-		if(type>=SC_COMMON_MIN && type <= SC_COMMON_MAX)
-			return 0;
-		switch(type) {
+		 if (type>=SC_COMMON_MIN && type <= SC_COMMON_MAX)
+			 return 0;
+		 switch (type) {
 			case SC_BLESSING:
 			case SC_DECREASEAGI:
 			case SC_PROVOKE:
@@ -6906,7 +7038,7 @@
 			case SC_ROKISWEIL:
 			case SC_FOGWALL:
 			case SC_FREEZING:
-			case SC_BURNING: 
+			case SC_BURNING:
 			case SC_MARSHOFABYSS:
 			case SC_ADORAMUS:
 			case SC_PARALYSIS:
@@ -6919,7 +7051,7 @@
 			case SC__UNLUCKY:
 			case SC__WEAKNESS:
 
-				// Exploit prevention - kRO Fix
+			// Exploit prevention - kRO Fix
 			case SC_PYREXIA:
 			case SC_DEATHHURT:
 			case SC_TOXIN:
@@ -6929,7 +7061,7 @@
 			case SC_OBLIVIONCURSE:
 			case SC_LEECHESEND:
 
-				// Ranger Effects
+			// Ranger Effects
 			case SC_BITE:
 			case SC_ELECTRICSHOCKER:
 			case SC_MAGNETICFIELD:
@@ -6939,256 +7071,257 @@
 	}
 
 	//Before overlapping fail, one must check for status cured.
-	switch(type) {
-		case SC_BLESSING:
-			//TO-DO Blessing and Agi up should do 1 damage against players on Undead Status, even on PvM
-			//but cannot be plagiarized (this requires aegis investigation on packets and official behavior) [Brainstorm]
-			if((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC) {
-				status_change_end(bl, SC_CURSE, INVALID_TIMER);
-				if(sc->data[SC_STONE] && sc->opt1 == OPT1_STONE)
-					status_change_end(bl, SC_STONE, INVALID_TIMER);
-			}
-			break;
-		case SC_INCREASEAGI:
-			status_change_end(bl, SC_DECREASEAGI, INVALID_TIMER);
-			status_change_end(bl, SC_ADORAMUS, INVALID_TIMER);
-			break;
-		case SC_QUAGMIRE:
-			status_change_end(bl, SC_CONCENTRATE, INVALID_TIMER);
-			status_change_end(bl, SC_TRUESIGHT, INVALID_TIMER);
-			status_change_end(bl, SC_WINDWALK, INVALID_TIMER);
-			//Also blocks the ones below...
-		case SC_DECREASEAGI:
-		case SC_ADORAMUS:
-			status_change_end(bl, SC_CARTBOOST, INVALID_TIMER);
-			//Also blocks the ones below...
-		case SC_DONTFORGETME:
-			status_change_end(bl, SC_INCREASEAGI, INVALID_TIMER);
-			status_change_end(bl, SC_ADRENALINE, INVALID_TIMER);
-			status_change_end(bl, SC_ADRENALINE2, INVALID_TIMER);
-			status_change_end(bl, SC_SPEARQUICKEN, INVALID_TIMER);
+	switch (type) {
+	case SC_BLESSING:
+		//TO-DO Blessing and Agi up should do 1 damage against players on Undead Status, even on PvM
+		//but cannot be plagiarized (this requires aegis investigation on packets and official behavior) [Brainstorm]
+		if ((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC) {
+			status_change_end(bl, SC_CURSE, INVALID_TIMER);
+			if (sc->data[SC_STONE] && sc->opt1 == OPT1_STONE)
+				status_change_end(bl, SC_STONE, INVALID_TIMER);
+		}
+		break;
+	case SC_INCREASEAGI:
+		status_change_end(bl, SC_DECREASEAGI, INVALID_TIMER);
+		status_change_end(bl, SC_ADORAMUS, INVALID_TIMER);
+		break;
+	case SC_QUAGMIRE:
+		status_change_end(bl, SC_CONCENTRATE, INVALID_TIMER);
+		status_change_end(bl, SC_TRUESIGHT, INVALID_TIMER);
+		status_change_end(bl, SC_WINDWALK, INVALID_TIMER);
+		//Also blocks the ones below...
+	case SC_DECREASEAGI:
+	case SC_ADORAMUS:
+		status_change_end(bl, SC_CARTBOOST, INVALID_TIMER);
+		//Also blocks the ones below...
+	case SC_DONTFORGETME:
+		status_change_end(bl, SC_INCREASEAGI, INVALID_TIMER);
+		status_change_end(bl, SC_ADRENALINE, INVALID_TIMER);
+		status_change_end(bl, SC_ADRENALINE2, INVALID_TIMER);
+		status_change_end(bl, SC_SPEARQUICKEN, INVALID_TIMER);
+		status_change_end(bl, SC_TWOHANDQUICKEN, INVALID_TIMER);
+		status_change_end(bl, SC_ONEHAND, INVALID_TIMER);
+		status_change_end(bl, SC_MERC_QUICKEN, INVALID_TIMER);
+		status_change_end(bl, SC_ACCELERATION, INVALID_TIMER);
+		break;
+	case SC_ONEHAND:
+	  	//Removes the Aspd potion effect, as reported by Vicious. [Skotlex]
+		status_change_end(bl, SC_ASPDPOTION0, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION1, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION2, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION3, INVALID_TIMER);
+		break;
+	case SC_MAXOVERTHRUST:
+	  	//Cancels Normal Overthrust. [Skotlex]
+		status_change_end(bl, SC_OVERTHRUST, INVALID_TIMER);
+		break;
+	case SC_KYRIE:
+		//Cancels Assumptio
+		status_change_end(bl, SC_ASSUMPTIO, INVALID_TIMER);
+		break;
+	case SC_DELUGE:
+		if (sc->data[SC_FOGWALL] && sc->data[SC_BLIND])
+			status_change_end(bl, SC_BLIND, INVALID_TIMER);
+		break;
+	case SC_SILENCE:
+		if (sc->data[SC_GOSPEL] && sc->data[SC_GOSPEL]->val4 == BCT_SELF)
+			status_change_end(bl, SC_GOSPEL, INVALID_TIMER);
+		break;
+	case SC_HIDING:
+		status_change_end(bl, SC_CLOSECONFINE, INVALID_TIMER);
+		status_change_end(bl, SC_CLOSECONFINE2, INVALID_TIMER);
+		break;
+	case SC__BLOODYLUST:
+	case SC_BERSERK:
+		if(battle_config.berserk_cancels_buffs) {
+			status_change_end(bl, SC_ONEHAND, INVALID_TIMER);
 			status_change_end(bl, SC_TWOHANDQUICKEN, INVALID_TIMER);
-			status_change_end(bl, SC_ONEHAND, INVALID_TIMER);
+			status_change_end(bl, SC_CONCENTRATION, INVALID_TIMER);
+			status_change_end(bl, SC_PARRYING, INVALID_TIMER);
+			status_change_end(bl, SC_AURABLADE, INVALID_TIMER);
 			status_change_end(bl, SC_MERC_QUICKEN, INVALID_TIMER);
-			status_change_end(bl, SC_ACCELERATION, INVALID_TIMER);
-			break;
-		case SC_ONEHAND:
-			//Removes the Aspd potion effect, as reported by Vicious. [Skotlex]
-			status_change_end(bl, SC_ASPDPOTION0, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION1, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION2, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION3, INVALID_TIMER);
-			break;
-		case SC_MAXOVERTHRUST:
-			//Cancels Normal Overthrust. [Skotlex]
-			status_change_end(bl, SC_OVERTHRUST, INVALID_TIMER);
-			break;
-		case SC_KYRIE:
-			//Cancels Assumptio
-			status_change_end(bl, SC_ASSUMPTIO, INVALID_TIMER);
-			break;
-		case SC_DELUGE:
-			if(sc->data[SC_FOGWALL] && sc->data[SC_BLIND])
-				status_change_end(bl, SC_BLIND, INVALID_TIMER);
-			break;
-		case SC_SILENCE:
-			if(sc->data[SC_GOSPEL] && sc->data[SC_GOSPEL]->val4 == BCT_SELF)
-				status_change_end(bl, SC_GOSPEL, INVALID_TIMER);
-			break;
-		case SC_HIDING:
-			status_change_end(bl, SC_CLOSECONFINE, INVALID_TIMER);
-			status_change_end(bl, SC_CLOSECONFINE2, INVALID_TIMER);
-			break;
-		case SC__BLOODYLUST:
-		case SC_BERSERK:
-			if(battle_config.berserk_cancels_buffs) {
-				status_change_end(bl, SC_ONEHAND, INVALID_TIMER);
-				status_change_end(bl, SC_TWOHANDQUICKEN, INVALID_TIMER);
-				status_change_end(bl, SC_CONCENTRATION, INVALID_TIMER);
-				status_change_end(bl, SC_PARRYING, INVALID_TIMER);
-				status_change_end(bl, SC_AURABLADE, INVALID_TIMER);
-				status_change_end(bl, SC_MERC_QUICKEN, INVALID_TIMER);
-			}
+		}
 #ifdef RENEWAL
-			else {
-				status_change_end(bl, SC_TWOHANDQUICKEN, INVALID_TIMER);
-			}
+		else {
+			status_change_end(bl, SC_TWOHANDQUICKEN, INVALID_TIMER);
+		}
 #endif
-			break;
-		case SC_ASSUMPTIO:
-			status_change_end(bl, SC_KYRIE, INVALID_TIMER);
-			status_change_end(bl, SC_KAITE, INVALID_TIMER);
-			break;
-		case SC_KAITE:
-			status_change_end(bl, SC_ASSUMPTIO, INVALID_TIMER);
-			break;
-		case SC_CARTBOOST:
-			if(sc->data[SC_DECREASEAGI] || sc->data[SC_ADORAMUS]) {
-				//Cancel Decrease Agi, but take no further effect [Skotlex]
-				status_change_end(bl, SC_DECREASEAGI, INVALID_TIMER);
-				status_change_end(bl, SC_ADORAMUS, INVALID_TIMER);
-				return 0;
-			}
-			break;
-		case SC_FUSION:
-			status_change_end(bl, SC_SPIRIT, INVALID_TIMER);
-			break;
-		case SC_ADJUSTMENT:
-			status_change_end(bl, SC_MADNESSCANCEL, INVALID_TIMER);
-			break;
-		case SC_MADNESSCANCEL:
-			status_change_end(bl, SC_ADJUSTMENT, INVALID_TIMER);
-			break;
-			//NPC_CHANGEUNDEAD will debuff Blessing and Agi Up
-		case SC_CHANGEUNDEAD:
-			status_change_end(bl, SC_BLESSING, INVALID_TIMER);
-			status_change_end(bl, SC_INCREASEAGI, INVALID_TIMER);
-			break;
-		case SC_STRFOOD:
-			status_change_end(bl, SC_FOOD_STR_CASH, INVALID_TIMER);
-			break;
-		case SC_AGIFOOD:
-			status_change_end(bl, SC_FOOD_AGI_CASH, INVALID_TIMER);
-			break;
-		case SC_VITFOOD:
-			status_change_end(bl, SC_FOOD_VIT_CASH, INVALID_TIMER);
-			break;
-		case SC_INTFOOD:
-			status_change_end(bl, SC_FOOD_INT_CASH, INVALID_TIMER);
-			break;
-		case SC_DEXFOOD:
-			status_change_end(bl, SC_FOOD_DEX_CASH, INVALID_TIMER);
-			break;
-		case SC_LUKFOOD:
-			status_change_end(bl, SC_FOOD_LUK_CASH, INVALID_TIMER);
-			break;
-		case SC_FOOD_STR_CASH:
-			status_change_end(bl, SC_STRFOOD, INVALID_TIMER);
-			break;
-		case SC_FOOD_AGI_CASH:
-			status_change_end(bl, SC_AGIFOOD, INVALID_TIMER);
-			break;
-		case SC_FOOD_VIT_CASH:
-			status_change_end(bl, SC_VITFOOD, INVALID_TIMER);
-			break;
-		case SC_FOOD_INT_CASH:
-			status_change_end(bl, SC_INTFOOD, INVALID_TIMER);
-			break;
-		case SC_FOOD_DEX_CASH:
-			status_change_end(bl, SC_DEXFOOD, INVALID_TIMER);
-			break;
-		case SC_FOOD_LUK_CASH:
-			status_change_end(bl, SC_LUKFOOD, INVALID_TIMER);
-			break;
-		case SC_FIGHTINGSPIRIT:
-			status_change_end(bl, type, INVALID_TIMER); // Remove previous one.
-			break;
-		case SC_MARSHOFABYSS:
-			status_change_end(bl, SC_INCAGI, INVALID_TIMER);
-			status_change_end(bl, SC_WINDWALK, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION0, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION1, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION2, INVALID_TIMER);
-			status_change_end(bl, SC_ASPDPOTION3, INVALID_TIMER);
-			break;
-		case SC_SWINGDANCE:
-		case SC_SYMPHONYOFLOVER:
-		case SC_MOONLITSERENADE:
-		case SC_RUSHWINDMILL:
-		case SC_ECHOSONG:
-		case SC_HARMONIZE: //group A doesn't overlap
-			if(type != SC_SWINGDANCE) status_change_end(bl, SC_SWINGDANCE, INVALID_TIMER);
-			if(type != SC_SYMPHONYOFLOVER) status_change_end(bl, SC_SYMPHONYOFLOVER, INVALID_TIMER);
-			if(type != SC_MOONLITSERENADE) status_change_end(bl, SC_MOONLITSERENADE, INVALID_TIMER);
-			if(type != SC_RUSHWINDMILL) status_change_end(bl, SC_RUSHWINDMILL, INVALID_TIMER);
-			if(type != SC_ECHOSONG) status_change_end(bl, SC_ECHOSONG, INVALID_TIMER);
-			if(type != SC_HARMONIZE) status_change_end(bl, SC_HARMONIZE, INVALID_TIMER);
-			break;
-		case SC_VOICEOFSIREN:
-		case SC_DEEPSLEEP:
-		case SC_GLOOMYDAY:
-		case SC_SONGOFMANA:
-		case SC_DANCEWITHWUG:
-		case SC_SATURDAYNIGHTFEVER:
-		case SC_LERADSDEW:
-		case SC_MELODYOFSINK:
-		case SC_BEYONDOFWARCRY:
-		case SC_UNLIMITEDHUMMINGVOICE: //group B
-			if(type != SC_VOICEOFSIREN) status_change_end(bl, SC_VOICEOFSIREN, INVALID_TIMER);
-			if(type != SC_DEEPSLEEP) status_change_end(bl, SC_DEEPSLEEP, INVALID_TIMER);
-			if(type != SC_LERADSDEW) status_change_end(bl, SC_LERADSDEW, INVALID_TIMER);
-			if(type != SC_MELODYOFSINK) status_change_end(bl, SC_MELODYOFSINK, INVALID_TIMER);
-			if(type != SC_BEYONDOFWARCRY) status_change_end(bl, SC_BEYONDOFWARCRY, INVALID_TIMER);
-			if(type != SC_UNLIMITEDHUMMINGVOICE) status_change_end(bl, SC_UNLIMITEDHUMMINGVOICE, INVALID_TIMER);
-			if(type != SC_GLOOMYDAY) {
-				status_change_end(bl, SC_GLOOMYDAY, INVALID_TIMER);
-				status_change_end(bl, SC_GLOOMYDAY_SK, INVALID_TIMER);
-			}
-			if(type != SC_SONGOFMANA) status_change_end(bl, SC_SONGOFMANA, INVALID_TIMER);
-			if(type != SC_DANCEWITHWUG) status_change_end(bl, SC_DANCEWITHWUG, INVALID_TIMER);
-			if(type != SC_SATURDAYNIGHTFEVER) {
-				if(sc->data[SC_SATURDAYNIGHTFEVER]) {
-					sc->data[SC_SATURDAYNIGHTFEVER]->val2 = 0; //mark to not lose hp
-					status_change_end(bl, SC_SATURDAYNIGHTFEVER, INVALID_TIMER);
-				}
-			}
-			break;
-		case SC_REFLECTSHIELD:
-			status_change_end(bl, SC_REFLECTDAMAGE, INVALID_TIMER);
-			break;
-		case SC_REFLECTDAMAGE:
-			status_change_end(bl, SC_REFLECTSHIELD, INVALID_TIMER);
-			break;
-		case SC_SHIELDSPELL_DEF:
-		case SC_SHIELDSPELL_MDEF:
-		case SC_SHIELDSPELL_REF:
-			status_change_end(bl, SC_MAGNIFICAT, INVALID_TIMER);
-			if(type != SC_SHIELDSPELL_DEF)
-				status_change_end(bl, SC_SHIELDSPELL_DEF, INVALID_TIMER);
-			if(type != SC_SHIELDSPELL_MDEF)
-				status_change_end(bl, SC_SHIELDSPELL_MDEF, INVALID_TIMER);
-			if(type != SC_SHIELDSPELL_REF)
-				status_change_end(bl, SC_SHIELDSPELL_REF, INVALID_TIMER);
-			break;
-		case SC_GT_ENERGYGAIN:
-		case SC_GT_CHANGE:
-		case SC_GT_REVITALIZE:
-			if(type != SC_GT_REVITALIZE)
-				status_change_end(bl, SC_GT_REVITALIZE, INVALID_TIMER);
-			if(type != SC_GT_ENERGYGAIN)
-				status_change_end(bl, SC_GT_ENERGYGAIN, INVALID_TIMER);
-			if(type != SC_GT_CHANGE)
-				status_change_end(bl, SC_GT_CHANGE, INVALID_TIMER);
-			break;
-		case SC_INVINCIBLE:
-			status_change_end(bl, SC_INVINCIBLEOFF, INVALID_TIMER);
-			break;
-		case SC_INVINCIBLEOFF:
-			status_change_end(bl, SC_INVINCIBLE, INVALID_TIMER);
-			break;
-		case SC_MAGICPOWER:
-			status_change_end(bl, type, INVALID_TIMER);
-			break;
+		break;
+	case SC_ASSUMPTIO:
+		status_change_end(bl, SC_KYRIE, INVALID_TIMER);
+		status_change_end(bl, SC_KAITE, INVALID_TIMER);
+		break;
+	case SC_KAITE:
+		status_change_end(bl, SC_ASSUMPTIO, INVALID_TIMER);
+		break;
+	case SC_CARTBOOST:
+		if(sc->data[SC_DECREASEAGI] || sc->data[SC_ADORAMUS])
+		{	//Cancel Decrease Agi, but take no further effect [Skotlex]
+			status_change_end(bl, SC_DECREASEAGI, INVALID_TIMER);
+			status_change_end(bl, SC_ADORAMUS, INVALID_TIMER);
+			return 0;
+		}
+		break;
+	case SC_FUSION:
+		status_change_end(bl, SC_SPIRIT, INVALID_TIMER);
+		break;
+	case SC_ADJUSTMENT:
+		status_change_end(bl, SC_MADNESSCANCEL, INVALID_TIMER);
+		break;
+	case SC_MADNESSCANCEL:
+		status_change_end(bl, SC_ADJUSTMENT, INVALID_TIMER);
+		break;
+	//NPC_CHANGEUNDEAD will debuff Blessing and Agi Up
+	case SC_CHANGEUNDEAD:
+		status_change_end(bl, SC_BLESSING, INVALID_TIMER);
+		status_change_end(bl, SC_INCREASEAGI, INVALID_TIMER);
+		break;
+	case SC_STRFOOD:
+		status_change_end(bl, SC_FOOD_STR_CASH, INVALID_TIMER);
+		break;
+	case SC_AGIFOOD:
+		status_change_end(bl, SC_FOOD_AGI_CASH, INVALID_TIMER);
+		break;
+	case SC_VITFOOD:
+		status_change_end(bl, SC_FOOD_VIT_CASH, INVALID_TIMER);
+		break;
+	case SC_INTFOOD:
+		status_change_end(bl, SC_FOOD_INT_CASH, INVALID_TIMER);
+		break;
+	case SC_DEXFOOD:
+		status_change_end(bl, SC_FOOD_DEX_CASH, INVALID_TIMER);
+		break;
+	case SC_LUKFOOD:
+		status_change_end(bl, SC_FOOD_LUK_CASH, INVALID_TIMER);
+		break;
+	case SC_FOOD_STR_CASH:
+		status_change_end(bl, SC_STRFOOD, INVALID_TIMER);
+		break;
+	case SC_FOOD_AGI_CASH:
+		status_change_end(bl, SC_AGIFOOD, INVALID_TIMER);
+		break;
+	case SC_FOOD_VIT_CASH:
+		status_change_end(bl, SC_VITFOOD, INVALID_TIMER);
+		break;
+	case SC_FOOD_INT_CASH:
+		status_change_end(bl, SC_INTFOOD, INVALID_TIMER);
+		break;
+	case SC_FOOD_DEX_CASH:
+		status_change_end(bl, SC_DEXFOOD, INVALID_TIMER);
+		break;
+	case SC_FOOD_LUK_CASH:
+		status_change_end(bl, SC_LUKFOOD, INVALID_TIMER);
+		break;
+	case SC_FIGHTINGSPIRIT:
+		status_change_end(bl, type, INVALID_TIMER); // Remove previous one.
+		break;
+	case SC_MARSHOFABYSS:
+		status_change_end(bl, SC_INCAGI, INVALID_TIMER);
+		status_change_end(bl, SC_WINDWALK, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION0, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION1, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION2, INVALID_TIMER);
+		status_change_end(bl, SC_ASPDPOTION3, INVALID_TIMER);
+		break;
+	case SC_SWINGDANCE:
+	case SC_SYMPHONYOFLOVER:
+	case SC_MOONLITSERENADE:
+	case SC_RUSHWINDMILL:
+	case SC_ECHOSONG:
+        case SC_HARMONIZE: //group A doesn't overlap
+            if (type != SC_SWINGDANCE) status_change_end(bl, SC_SWINGDANCE, INVALID_TIMER);
+            if (type != SC_SYMPHONYOFLOVER) status_change_end(bl, SC_SYMPHONYOFLOVER, INVALID_TIMER);
+            if (type != SC_MOONLITSERENADE) status_change_end(bl, SC_MOONLITSERENADE, INVALID_TIMER);
+            if (type != SC_RUSHWINDMILL) status_change_end(bl, SC_RUSHWINDMILL, INVALID_TIMER);
+            if (type != SC_ECHOSONG) status_change_end(bl, SC_ECHOSONG, INVALID_TIMER);
+            if (type != SC_HARMONIZE) status_change_end(bl, SC_HARMONIZE, INVALID_TIMER);
+            break;
+        case SC_VOICEOFSIREN:
+        case SC_DEEPSLEEP:
+        case SC_GLOOMYDAY:
+        case SC_SONGOFMANA:
+        case SC_DANCEWITHWUG:
+        case SC_SATURDAYNIGHTFEVER:
+        case SC_LERADSDEW:
+        case SC_MELODYOFSINK:
+        case SC_BEYONDOFWARCRY:
+        case SC_UNLIMITEDHUMMINGVOICE: //group B
+            if (type != SC_VOICEOFSIREN) status_change_end(bl, SC_VOICEOFSIREN, INVALID_TIMER);
+            if (type != SC_DEEPSLEEP) status_change_end(bl, SC_DEEPSLEEP, INVALID_TIMER);
+            if (type != SC_LERADSDEW) status_change_end(bl, SC_LERADSDEW, INVALID_TIMER);
+            if (type != SC_MELODYOFSINK) status_change_end(bl, SC_MELODYOFSINK, INVALID_TIMER);
+            if (type != SC_BEYONDOFWARCRY) status_change_end(bl, SC_BEYONDOFWARCRY, INVALID_TIMER);
+            if (type != SC_UNLIMITEDHUMMINGVOICE) status_change_end(bl, SC_UNLIMITEDHUMMINGVOICE, INVALID_TIMER);
+            if (type != SC_GLOOMYDAY) {
+                status_change_end(bl, SC_GLOOMYDAY, INVALID_TIMER);
+                status_change_end(bl, SC_GLOOMYDAY_SK, INVALID_TIMER);
+            }
+            if (type != SC_SONGOFMANA) status_change_end(bl, SC_SONGOFMANA, INVALID_TIMER);
+            if (type != SC_DANCEWITHWUG) status_change_end(bl, SC_DANCEWITHWUG, INVALID_TIMER);
+            if (type != SC_SATURDAYNIGHTFEVER) {
+                if (sc->data[SC_SATURDAYNIGHTFEVER]) {
+                    sc->data[SC_SATURDAYNIGHTFEVER]->val2 = 0; //mark to not lose hp
+                    status_change_end(bl, SC_SATURDAYNIGHTFEVER, INVALID_TIMER);
+                }
+            }
+            break;
+	case SC_REFLECTSHIELD:
+		status_change_end(bl, SC_REFLECTDAMAGE, INVALID_TIMER);
+		break;
+	case SC_REFLECTDAMAGE:
+		status_change_end(bl, SC_REFLECTSHIELD, INVALID_TIMER);
+		break;
+	case SC_SHIELDSPELL_DEF:
+	case SC_SHIELDSPELL_MDEF:
+	case SC_SHIELDSPELL_REF:
+		status_change_end(bl, SC_MAGNIFICAT, INVALID_TIMER);
+		if( type != SC_SHIELDSPELL_DEF )
+			status_change_end(bl, SC_SHIELDSPELL_DEF, INVALID_TIMER);
+		if( type != SC_SHIELDSPELL_MDEF )
+			status_change_end(bl, SC_SHIELDSPELL_MDEF, INVALID_TIMER);
+		if( type != SC_SHIELDSPELL_REF )
+			status_change_end(bl, SC_SHIELDSPELL_REF, INVALID_TIMER);
+		break;
+	case SC_GT_ENERGYGAIN:
+	case SC_GT_CHANGE:
+	case SC_GT_REVITALIZE:
+		if( type != SC_GT_REVITALIZE )
+			status_change_end(bl, SC_GT_REVITALIZE, INVALID_TIMER);
+		if( type != SC_GT_ENERGYGAIN )
+			status_change_end(bl, SC_GT_ENERGYGAIN, INVALID_TIMER);
+		if( type != SC_GT_CHANGE )
+			status_change_end(bl, SC_GT_CHANGE, INVALID_TIMER);
+		break;
+	case SC_INVINCIBLE:
+		status_change_end(bl, SC_INVINCIBLEOFF, INVALID_TIMER);
+		break;
+	case SC_INVINCIBLEOFF:
+		status_change_end(bl, SC_INVINCIBLE, INVALID_TIMER);
+		break;
+	case SC_MAGICPOWER:
+		status_change_end(bl, type, INVALID_TIMER);
+		break;
 	}
 
 	//Check for overlapping fails
-	if((sce = sc->data[type])) {
-		switch(type) {
+	if( (sce = sc->data[type]) ) {
+		switch( type ) {
 			case SC_MERC_FLEEUP:
 			case SC_MERC_ATKUP:
 			case SC_MERC_HPUP:
 			case SC_MERC_SPUP:
 			case SC_MERC_HITUP:
-				if(sce->val1 > val1)
+				if( sce->val1 > val1 )
 					val1 = sce->val1;
 				break;
 			case SC_ADRENALINE:
 			case SC_ADRENALINE2:
 			case SC_WEAPONPERFECTION:
 			case SC_OVERTHRUST:
-				if(sce->val2 > val2)
+				if (sce->val2 > val2)
 					return 0;
 				break;
+			case SC_SPREGEN:
 			case SC_S_LIFEPOTION:
 			case SC_L_LIFEPOTION:
 			case SC_BOSSMAPINFO:
@@ -7228,7 +7361,7 @@
 			case SC_ARMOR_RESIST:
 				break;
 			case SC_GOSPEL:
-				//Must not override a casting gospel char.
+				 //Must not override a casting gospel char.
 				if(sce->val4 == BCT_SELF)
 					return 0;
 				if(sce->val1 > val1)
@@ -7243,7 +7376,7 @@
 			case SC_KAAHI:
 				//Kaahi overwrites previous level regardless of existing level.
 				//Delete timer if it exists.
-				if(sce->val4 != INVALID_TIMER) {
+				if (sce->val4 != INVALID_TIMER) {
 					delete_timer(sce->val4,kaahi_heal_timer);
 					sce->val4 = INVALID_TIMER;
 				}
@@ -7255,7 +7388,7 @@
 				val4 = sce->val4;
 				break;
 			case SC_LERADSDEW:
-				if(sc && (sc->data[SC_BERSERK] || sc->data[SC__BLOODYLUST]))
+				if (sc && (sc->data[SC_BERSERK] || sc->data[SC__BLOODYLUST]))
 					return 0;
 			case SC_SHAPESHIFT:
 			case SC_PROPERTYWALK:
@@ -7264,7 +7397,7 @@
 			case SC_GLORYWOUNDS:
 			case SC_SOULCOLD:
 			case SC_HAWKEYES:
-				if(sce->val4 && !val4)  //you cannot override master guild aura
+				if( sce->val4 && !val4 )//you cannot override master guild aura
 					return 0;
 				break;
 			case SC_JOINTBEAT:
@@ -7278,1455 +7411,1493 @@
 	vd = status_get_viewdata(bl);
 	calc_flag = StatusChangeFlagTable[type];
 	if(!(flag&4)) //&4 - Do not parse val settings when loading SCs
-		switch(type) {
-			case SC_DECREASEAGI:
-			case SC_INCREASEAGI:
-			case SC_ADORAMUS:
-				val2 = 2 + val1; //Agi change
-				if(type == SC_ADORAMUS)
-					sc_start(src,bl,SC_BLIND,val1 * 4 + (sd ? sd->status.job_level : 50) / 2,val1,skill_get_time(status_sc2skill(type),val1));
-				break;
-			case SC_ENDURE:
-				val2 = 7; // Hit-count [Celest]
-				if(!(flag&1) && (bl->type&(BL_PC|BL_MER)) && !map_flag_gvg(bl->m) && !map[bl->m].flag.battleground && !val4) {
-					struct map_session_data *tsd;
-					if(sd) {
-						int i;
-						for(i = 0; i < 5; i++) {
-							if(sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])))
-								status_change_start(src,&tsd->bl, type, 10000, val1, val2, val3, val4, tick, 1);
-						}
-					} else if(bl->type == BL_MER && ((TBL_MER *)bl)->devotion_flag && (tsd = ((TBL_MER *)bl)->master))
-						status_change_start(src,&tsd->bl, type, 10000, val1, val2, val3, val4, tick, 1);
+	switch(type)
+	{
+		case SC_DECREASEAGI:
+		case SC_INCREASEAGI:
+		case SC_ADORAMUS:
+			val2 = 2 + val1; //Agi change
+			if( type == SC_ADORAMUS )
+				sc_start(src,bl,SC_BLIND,val1 * 4 + (sd ? sd->status.job_level : 50) / 2,val1,skill_get_time(status_sc2skill(type),val1));
+			break;
+		case SC_ENDURE:
+			val2 = 7; // Hit-count [Celest]
+			if( !(flag&1) && (bl->type&(BL_PC|BL_MER)) && !map_flag_gvg(bl->m) && !map[bl->m].flag.battleground && !val4 )
+			{
+				struct map_session_data *tsd;
+				if( sd )
+				{
+					int i;
+					for( i = 0; i < 5; i++ )
+					{
+						if( sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])) )
+							status_change_start(src,&tsd->bl, type, 10000, val1, val2, val3, val4, tick, 1);
+					}
 				}
-				//val4 signals infinite endure (if val4 == 2 it is infinite endure from Berserk)
-				if(val4)
-					tick = -1;
-				break;
-			case SC_AUTOBERSERK:
-				if(status->hp < status->max_hp>>2 &&
-				   (!sc->data[SC_PROVOKE] || sc->data[SC_PROVOKE]->val2==0))
+				else if( bl->type == BL_MER && ((TBL_MER*)bl)->devotion_flag && (tsd = ((TBL_MER*)bl)->master) )
+					status_change_start(src,&tsd->bl, type, 10000, val1, val2, val3, val4, tick, 1);
+			}
+			//val4 signals infinite endure (if val4 == 2 it is infinite endure from Berserk)
+			if( val4 )
+				tick = -1;
+			break;
+		case SC_AUTOBERSERK:
+			if (status->hp < status->max_hp>>2 &&
+				(!sc->data[SC_PROVOKE] || sc->data[SC_PROVOKE]->val2==0))
 					sc_start4(src,bl,SC_PROVOKE,100,10,1,0,0,60000);
-				tick = -1;
-				break;
-			case SC_SIGNUMCRUCIS:
-				val2 = 10 + 4*val1; //Def reduction
-				tick = -1;
-				clif_emotion(bl,E_SWT);
-				break;
-			case SC_MAXIMIZEPOWER:
-				tick_time = val2 = tick>0?tick:60000;
-				tick = -1; // duration sent to the client should be infinite
-				break;
-			case SC_EDP:    // [Celest]
-				val2 = val1 + 2; //Chance to Poison enemies.
+			tick = -1;
+			break;
+		case SC_SIGNUMCRUCIS:
+			val2 = 10 + 4*val1; //Def reduction
+			tick = -1;
+			clif_emotion(bl,E_SWT);
+			break;
+		case SC_MAXIMIZEPOWER:
+			tick_time = val2 = tick>0?tick:60000;
+			tick = -1; // duration sent to the client should be infinite
+			break;
+		case SC_EDP:	// [Celest]
+			val2 = val1 + 2; //Chance to Poison enemies.
 #ifndef RENEWAL_EDP
-				val3 = 50*(val1+1); //Damage increase (+50 +50*lv%)
+			val3 = 50*(val1+1); //Damage increase (+50 +50*lv%)
 #endif
-				if(sd)  //[Ind] - iROwiki says each level increases its duration by 3 seconds
-					tick += pc_checkskill(sd,GC_RESEARCHNEWPOISON)*3000;
-				break;
-			case SC_POISONREACT:
-				val2=(val1+1)/2 + val1/10; // Number of counters [Skotlex]
-				val3=50; // + 5*val1; //Chance to counter. [Skotlex]
-				break;
-			case SC_MAGICROD:
-				val2 = val1*20; //SP gained
-				break;
-			case SC_KYRIE:
-			if(sd)
+			if( sd )//[Ind] - iROwiki says each level increases its duration by 3 seconds
+				tick += pc_checkskill(sd,GC_RESEARCHNEWPOISON)*3000;
+			break;
+		case SC_POISONREACT:
+			val2=(val1+1)/2 + val1/10; // Number of counters [Skotlex]
+			val3=50; // + 5*val1; //Chance to counter. [Skotlex]
+			break;
+		case SC_MAGICROD:
+			val2 = val1*20; //SP gained
+			break;
+		case SC_KYRIE:
+			if( sd )
 				val1 = min(val1,pc_checkskill(sd,PR_KYRIE)); // use skill level to determine barrier health.
-				val2 = (int64)status->max_hp * (val1 * 2 + 10) / 100; //%Max HP to absorb
-				// val4 holds current amount of party members when casting Praefatio
-				// as Praefatio's barrier has more health and blocks more hits than Kyrie Elesion.
-				if( val4 < 1 ) //== PR_KYRIE
-					val3 = (val1 / 2 + 5);
-				else { //== AB_PRAEFATIO
-					val2 += val4 * 2; //Increase barrier strength per party member.
-					val3 = 6 + val1;
-				}
-				break;
-			case SC_MAGICPOWER:
-				//val1: Skill lv
-				val2 = 1; //Lasts 1 invocation
-				val3 = 5*val1; //Matk% increase
-				val4 = 0; // 0 = ready to be used, 1 = activated and running
-				break;
-			case SC_SACRIFICE:
-				val2 = 5; //Lasts 5 hits
-				tick = -1;
-				break;
-			case SC_ENCPOISON:
-				val2= 250+50*val1;  //Poisoning Chance (2.5+0.5%) in 1/10000 rate
-			case SC_ASPERSIO:
-			case SC_FIREWEAPON:
-			case SC_WATERWEAPON:
-			case SC_WINDWEAPON:
-			case SC_EARTHWEAPON:
-			case SC_SHADOWWEAPON:
-			case SC_GHOSTWEAPON:
-				skill_enchant_elemental_end(bl,type);
-				break;
-			case SC_ELEMENTALCHANGE:
-				// val1 : Element Lvl (if called by skill lvl 1, takes random value between 1 and 4)
-				// val2 : Element (When no element, random one is picked)
-				// val3 : 0 = called by skill 1 = called by script (fixed level)
-				if(!val2) val2 = rnd()%ELE_MAX;
+			val2 = (int64)status->max_hp * (val1 * 2 + 10) / 100; //%Max HP to absorb
+			// val4 holds current amount of party members when casting Praefatio
+			// as Praefatio's barrier has more health and blocks more hits than Kyrie Elesion.
+			if( val4 < 1 ) //== PR_KYRIE
+				val3 = (val1 / 2 + 5);
+			else { //== AB_PRAEFATIO
+				val2 += val4 * 2; //Increase barrier strength per party member.
+				val3 = 6 + val1;
+			}
+			break;
+		case SC_MAGICPOWER:
+			//val1: Skill lv
+			val2 = 1; //Lasts 1 invocation
+			val3 = 5*val1; //Matk% increase
+			val4 = 0; // 0 = ready to be used, 1 = activated and running
+			break;
+		case SC_SACRIFICE:
+			val2 = 5; //Lasts 5 hits
+			tick = -1;
+			break;
+		case SC_ENCPOISON:
+			val2= 250+50*val1;	//Poisoning Chance (2.5+0.5%) in 1/10000 rate
+		case SC_ASPERSIO:
+		case SC_FIREWEAPON:
+		case SC_WATERWEAPON:
+		case SC_WINDWEAPON:
+		case SC_EARTHWEAPON:
+		case SC_SHADOWWEAPON:
+		case SC_GHOSTWEAPON:
+			skill_enchant_elemental_end(bl,type);
+			break;
+		case SC_ELEMENTALCHANGE:
+			// val1 : Element Lvl (if called by skill lvl 1, takes random value between 1 and 4)
+			// val2 : Element (When no element, random one is picked)
+			// val3 : 0 = called by skill 1 = called by script (fixed level)
+			if( !val2 ) val2 = rnd()%ELE_MAX;
 
-				if(val1 == 1 && val3 == 0)
-					val1 = 1 + rnd()%4;
-				else if(val1 > 4)
-					val1 = 4; // Max Level
-				val3 = 0; // Not need to keep this info.
-				break;
-			case SC_PROVIDENCE:
-				val2=val1*5; //Race/Ele resist
-				break;
-			case SC_REFLECTSHIELD:
-				val2=10+val1*3; // %Dmg reflected
-				if(!(flag&1) && (bl->type&(BL_PC|BL_MER))) {
-					struct map_session_data *tsd;
-					if(sd) {
-						int i;
-						for(i = 0; i < 5; i++) {
-							if(sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])))
-								status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
-						}
-					} else if(bl->type == BL_MER && ((TBL_MER *)bl)->devotion_flag && (tsd = ((TBL_MER *)bl)->master))
-						status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
+			if( val1 == 1 && val3 == 0 )
+				val1 = 1 + rnd()%4;
+			else if( val1 > 4 )
+				val1 = 4; // Max Level
+			val3 = 0; // Not need to keep this info.
+			break;
+		case SC_PROVIDENCE:
+			val2=val1*5; //Race/Ele resist
+			break;
+		case SC_REFLECTSHIELD:
+			val2=10+val1*3; // %Dmg reflected
+			if( !(flag&1) && (bl->type&(BL_PC|BL_MER)) )
+			{
+				struct map_session_data *tsd;
+				if( sd )
+				{
+					int i;
+					for( i = 0; i < 5; i++ )
+					{
+						if( sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])) )
+							status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
+					}
 				}
-				break;
-			case SC_STRIPWEAPON:
-				if(!sd)  //Watk reduction
-					val2 = 25;
-				break;
-			case SC_STRIPSHIELD:
-				if(!sd)  //Def reduction
-					val2 = 15;
-				break;
-			case SC_STRIPARMOR:
-				if(!sd)  //Vit reduction
-					val2 = 40;
-				break;
-			case SC_STRIPHELM:
-				if(!sd)  //Int reduction
-					val2 = 40;
-				break;
-			case SC_AUTOSPELL:
-				//Val1 Skill LV of Autospell
-				//Val2 Skill ID to cast
-				//Val3 Max Lv to cast
-				val4 = 5 + val1*2; //Chance of casting
-				break;
-			case SC_VOLCANO:
-				val2 = val1*10; //Watk increase
+				else if( bl->type == BL_MER && ((TBL_MER*)bl)->devotion_flag && (tsd = ((TBL_MER*)bl)->master) )
+					status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
+			}
+			break;
+		case SC_STRIPWEAPON:
+			if (!sd) //Watk reduction
+				val2 = 25;
+			break;
+		case SC_STRIPSHIELD:
+			if (!sd) //Def reduction
+				val2 = 15;
+			break;
+		case SC_STRIPARMOR:
+			if (!sd) //Vit reduction
+				val2 = 40;
+			break;
+		case SC_STRIPHELM:
+			if (!sd) //Int reduction
+				val2 = 40;
+			break;
+		case SC_AUTOSPELL:
+			//Val1 Skill LV of Autospell
+			//Val2 Skill ID to cast
+			//Val3 Max Lv to cast
+			val4 = 5 + val1*2; //Chance of casting
+			break;
+		case SC_VOLCANO:
+			val2 = val1*10; //Watk increase
 #ifndef RENEWAL
-				if(status->def_ele != ELE_FIRE)
-					val2 = 0;
+			if (status->def_ele != ELE_FIRE)
+				val2 = 0;
 #endif
-				break;
-			case SC_VIOLENTGALE:
-				val2 = val1*3; //Flee increase
+			break;
+		case SC_VIOLENTGALE:
+			val2 = val1*3; //Flee increase
+		#ifndef RENEWAL
+			if (status->def_ele != ELE_WIND)
+				val2 = 0;
+		#endif
+			break;
+		case SC_DELUGE:
+			val2 = deluge_eff[val1-1]; //HP increase
 #ifndef RENEWAL
-				if(status->def_ele != ELE_WIND)
-					val2 = 0;
+			if(status->def_ele != ELE_WATER)
+				val2 = 0;
 #endif
+			break;
+		case SC_SUITON:
+			if (!val2 || (sd && (sd->class_&MAPID_BASEMASK) == MAPID_NINJA)) {
+				//No penalties.
+				val2 = 0; //Agi penalty
+				val3 = 0; //Walk speed penalty
 				break;
-			case SC_DELUGE:
-				val2 = deluge_eff[val1-1]; //HP increase
-#ifndef RENEWAL
-				if(status->def_ele != ELE_WATER)
-					val2 = 0;
+			}
+			val3 = 50;
+			val2 = 3*((val1+1)/3);
+			if (val1 > 4) val2--;
+			break;
+		case SC_ONEHAND:
+		case SC_TWOHANDQUICKEN:
+			val2 = 300;
+			if (val1 > 10) //For boss casted skills [Skotlex]
+				val2 += 20*(val1-10);
+			break;
+		case SC_MERC_QUICKEN:
+			val2 = 300;
+			break;
+#ifndef RENEWAL_ASPD
+		case SC_SPEARQUICKEN:
+			val2 = 200+10*val1;
+			break;
 #endif
-				break;
-			case SC_SUITON:
-				if(!val2 || (sd && (sd->class_&MAPID_BASEMASK) == MAPID_NINJA)) {
-					//No penalties.
-					val2 = 0; //Agi penalty
-					val3 = 0; //Walk speed penalty
-					break;
-				}
-				val3 = 50;
-				val2 = 3*((val1+1)/3);
-				if(val1 > 4) val2--;
-				break;
-			case SC_ONEHAND:
-			case SC_TWOHANDQUICKEN:
-				val2 = 300;
-				if(val1 > 10)  //For boss casted skills [Skotlex]
-					val2 += 20*(val1-10);
-				break;
-			case SC_MERC_QUICKEN:
-				val2 = 300;
-				break;
-#ifndef RENEWAL_ASPD 
-			case SC_SPEARQUICKEN:
-				val2 = 200+10*val1;
-				break;
-#endif
-			case SC_DANCING:
-				//val1 : Skill ID + LV
-				//val2 : Skill Group of the Dance.
-				//val3 : Brings the skill_lv (merged into val1 here)
-				//val4 : Partner
-				if(val1 == CG_MOONLIT)
-					clif_status_change(bl,SI_MOONLIT,1,tick,0, 0, 0);
-				val1|= (val3<<16);
-				val3 = tick/1000; //Tick duration
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_LONGING:
-				val2 = 500-100*val1; //Aspd penalty.
-				break;
-			case SC_EXPLOSIONSPIRITS:
-				val2 = 75 + 25*val1; //Cri bonus
-				break;
+		case SC_DANCING:
+			//val1 : Skill ID + LV
+			//val2 : Skill Group of the Dance.
+			//val3 : Brings the skill_lv (merged into val1 here)
+			//val4 : Partner
+			if (val1 == CG_MOONLIT)
+				clif_status_change(bl,SI_MOONLIT,1,tick,0, 0, 0);
+			val1|= (val3<<16);
+			val3 = tick/1000; //Tick duration
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_LONGING:
+			val2 = 500-100*val1; //Aspd penalty.
+			break;
+		case SC_EXPLOSIONSPIRITS:
+			val2 = 75 + 25*val1; //Cri bonus
+			break;
 
-			case SC_ASPDPOTION0:
-			case SC_ASPDPOTION1:
-			case SC_ASPDPOTION2:
-			case SC_ASPDPOTION3:
-				val2 = 50*(2+type-SC_ASPDPOTION0);
-				break;
+		case SC_ASPDPOTION0:
+		case SC_ASPDPOTION1:
+		case SC_ASPDPOTION2:
+		case SC_ASPDPOTION3:
+			val2 = 50*(2+type-SC_ASPDPOTION0);
+			break;
 
-			case SC_WEDDING:
-			case SC_XMAS:
-			case SC_SUMMER:
-			case SC_HANBOK:
-				if(!vd) return 0;
-				//Store previous values as they could be removed.
-				val1 = vd->class_;
-				val2 = vd->weapon;
-				val3 = vd->shield;
-				val4 = vd->cloth_color;
-				unit_stop_attack(bl);
-				clif_changelook(bl,LOOK_WEAPON,0);
-				clif_changelook(bl,LOOK_SHIELD,0);
-				clif_changelook(bl,LOOK_BASE,type==SC_WEDDING?JOB_WEDDING:type==SC_XMAS?JOB_XMAS:type==SC_SUMMER?JOB_SUMMER:JOB_HANBOK);
-				clif_changelook(bl,LOOK_CLOTHES_COLOR,vd->cloth_color);
-				break;
-			case SC_NOCHAT:
-				// [GodLesZ] FIXME: is this correct? a hardcoded interval of 60sec? what about configuration ?_?
-				tick = 60000;
-				val1 = battle_config.manner_system; //Mute filters.
-				if(sd) {
-					clif_changestatus(sd,SP_MANNER,sd->status.manner);
-					clif_updatestatus(sd,SP_MANNER);
-				}
-				break;
+		case SC_WEDDING:
+		case SC_XMAS:
+		case SC_SUMMER:
+			if (!vd) return 0;
+			//Store previous values as they could be removed.
+			val1 = vd->class_;
+			val2 = vd->weapon;
+			val3 = vd->shield;
+			val4 = vd->cloth_color;
+			unit_stop_attack(bl);
+			clif_changelook(bl,LOOK_WEAPON,0);
+			clif_changelook(bl,LOOK_SHIELD,0);
+			clif_changelook(bl,LOOK_BASE,type==SC_WEDDING?JOB_WEDDING:type==SC_XMAS?JOB_XMAS:JOB_SUMMER);
+			clif_changelook(bl,LOOK_CLOTHES_COLOR,vd->cloth_color);
+			break;
+		case SC_NOCHAT:
+			// [GodLesZ] FIXME: is this correct? a hardcoded interval of 60sec? what about configuration ?_?
+			tick = 60000;
+			val1 = battle_config.manner_system; //Mute filters.
+			if (sd)
+			{
+				clif_changestatus(sd,SP_MANNER,sd->status.manner);
+				clif_updatestatus(sd,SP_MANNER);
+			}
+			break;
 
-			case SC_STONE:
-				val3 = tick/1000; //Petrified HP-damage iterations.
-				if(val3 < 1) val3 = 1;
-				tick = val4; //Petrifying time.
-				tick = max(tick, 1000); //Min time
-				calc_flag = 0; //Actual status changes take effect on petrified state.
-				break;
+		case SC_STONE:
+			val3 = tick/1000; //Petrified HP-damage iterations.
+			if(val3 < 1) val3 = 1;
+			tick = val4; //Petrifying time.
+			tick = max(tick, 1000); //Min time
+			calc_flag = 0; //Actual status changes take effect on petrified state.
+			break;
 
-			case SC_DPOISON:
-				//Lose 10/15% of your life as long as it doesn't brings life below 25%
-				if(status->hp > status->max_hp>>2) {
-					int diff = status->max_hp*(bl->type==BL_PC?10:15)/100;
-					if(status->hp - diff < status->max_hp>>2)
-						diff = status->hp - (status->max_hp>>2);
-					if(val2 && bl->type == BL_MOB) {
-						struct block_list *src = map_id2bl(val2);
-						if(src)
-							mob_log_damage((TBL_MOB *)bl,src,diff);
-					}
-					status_zap(bl, diff, 0);
+		case SC_DPOISON:
+		//Lose 10/15% of your life as long as it doesn't brings life below 25%
+		if (status->hp > status->max_hp>>2) {
+			int diff = status->max_hp*(bl->type==BL_PC?10:15)/100;
+			if (status->hp - diff < status->max_hp>>2)
+				diff = status->hp - (status->max_hp>>2);
+			if( val2 && bl->type == BL_MOB ) {
+				struct block_list* src = map_id2bl(val2);
+				if( src )
+					mob_log_damage((TBL_MOB*)bl,src,diff);
+			}
+			status_zap(bl, diff, 0);
+		}
+		// fall through
+		case SC_POISON:
+		val3 = tick/1000; //Damage iterations
+		if(val3 < 1) val3 = 1;
+		tick_time = 1000; // [GodLesZ] tick time
+		//val4: HP damage
+		if (bl->type == BL_PC)
+			val4 = (type == SC_DPOISON) ? 3 + status->max_hp/50 : 3 + status->max_hp*3/200;
+		else
+			val4 = (type == SC_DPOISON) ? 3 + status->max_hp/100 : 3 + status->max_hp/200;
+
+		break;
+		case SC_CONFUSION:
+			clif_emotion(bl,E_WHAT);
+			break;
+		case SC_BLEEDING:
+			val4 = tick/10000;
+			if (!val4) val4 = 1;
+			tick_time = 10000; // [GodLesZ] tick time
+			break;
+		case SC_SPREGEN:
+		case SC_S_LIFEPOTION:
+		case SC_L_LIFEPOTION:
+			if( val1 == 0 ) return 0;
+			// val1 = heal percent/amout
+			// val2 = seconds between heals
+			// val4 = total of heals
+			if( val2 < 1 ) val2 = 1;
+			if( (val4 = tick/(val2 * 1000)) < 1 )
+				val4 = 1;
+			tick_time = val2 * 1000; // [GodLesZ] tick time
+			break;
+		case SC_BOSSMAPINFO:
+			if( sd != NULL )
+			{
+				struct mob_data *boss_md = map_getmob_boss(bl->m); // Search for Boss on this Map
+				if( boss_md == NULL || boss_md->bl.prev == NULL )
+				{ // No MVP on this map - MVP is dead
+					clif_bossmapinfo(sd->fd, boss_md, 1);
+					return 0; // No need to start SC
 				}
-				// fall through
-			case SC_POISON:
-				val3 = tick/1000; //Damage iterations
-				if(val3 < 1) val3 = 1;
-				tick_time = 1000; // [GodLesZ] tick time
-				//val4: HP damage
-				if(bl->type == BL_PC)
-					val4 = (type == SC_DPOISON) ? 3 + status->max_hp/50 : 3 + status->max_hp*3/200;
-				else
-					val4 = (type == SC_DPOISON) ? 3 + status->max_hp/100 : 3 + status->max_hp/200;
-
-				break;
-			case SC_CONFUSION:
-				clif_emotion(bl,E_WHAT);
-				break;
-			case SC_BLEEDING:
-				val4 = tick/10000;
-				if(!val4) val4 = 1;
-				tick_time = 10000; // [GodLesZ] tick time
-				break;
-			case SC_S_LIFEPOTION:
-			case SC_L_LIFEPOTION:
-				if(val1 == 0) return 0;
-				// val1 = heal percent/amout
-				// val2 = seconds between heals
-				// val4 = total of heals
-				if(val2 < 1) val2 = 1;
-				if((val4 = tick/(val2 * 1000)) < 1)
+				val1 = boss_md->bl.id;
+				if( (val4 = tick/1000) < 1 )
 					val4 = 1;
-				tick_time = val2 * 1000; // [GodLesZ] tick time
-				break;
-			case SC_BOSSMAPINFO:
-				if(sd != NULL) {
-					struct mob_data *boss_md = map_getmob_boss(bl->m); // Search for Boss on this Map
-					if(boss_md == NULL || boss_md->bl.prev == NULL) {
-						// No MVP on this map - MVP is dead
-						clif_bossmapinfo(sd->fd, boss_md, 1);
-						return 0; // No need to start SC
-					}
-					val1 = boss_md->bl.id;
-					if((val4 = tick/1000) < 1)
-						val4 = 1;
-					tick_time = 1000; // [GodLesZ] tick time
-				}
-				break;
-			case SC_HIDING:
-				val2 = tick/1000;
 				tick_time = 1000; // [GodLesZ] tick time
-				val3 = 0; // unused, previously speed adjustment
-				val4 = val1+3; //Seconds before SP substraction happen.
-				break;
-			case SC_CHASEWALK:
-				val2 = tick>0?tick:10000; //Interval at which SP is drained.
-				val3 = 35 - 5 * val1; //Speed adjustment.
-				if(sc->data[SC_SPIRIT] && sc->data[SC_SPIRIT]->val2 == SL_ROGUE)
-					val3 -= 40;
-				val4 = 10+val1*2; //SP cost.
-				if(map_flag_gvg(bl->m) || map[bl->m].flag.battleground) val4 *= 5;
-				break;
-			case SC_CLOAKING:
-				if(!sd)  //Monsters should be able to walk with no penalties. [Skotlex]
-					val1 = 10;
-				tick_time = val2 = tick>0?tick:60000; //SP consumption rate.
-				tick = -1; // duration sent to the client should be infinite
-				val3 = 0; // unused, previously walk speed adjustment
-				//val4&1 signals the presence of a wall.
-				//val4&2 makes cloak not end on normal attacks [Skotlex]
-				//val4&4 makes cloak not end on using skills
-				if(bl->type == BL_PC || (bl->type == BL_MOB && ((TBL_MOB *)bl)->special_state.clone))   //Standard cloaking.
-					val4 |= battle_config.pc_cloak_check_type&7;
-				else
-					val4 |= battle_config.monster_cloak_check_type&7;
-				break;
-			case SC_SIGHT:          /* splash status */
-			case SC_RUWACH:
-			case SC_SIGHTBLASTER:
-				val3 = skill_get_splash(val2, val1); //Val2 should bring the skill-id.
-				val2 = tick/250;
-				tick_time = 10; // [GodLesZ] tick time
-				break;
+			}
+			break;
+		case SC_HIDING:
+			val2 = tick/1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			val3 = 0; // unused, previously speed adjustment
+			val4 = val1+3; //Seconds before SP substraction happen.
+			break;
+		case SC_CHASEWALK:
+			val2 = tick>0?tick:10000; //Interval at which SP is drained.
+			val3 = 35 - 5 * val1; //Speed adjustment.
+			if (sc->data[SC_SPIRIT] && sc->data[SC_SPIRIT]->val2 == SL_ROGUE)
+				val3 -= 40;
+			val4 = 10+val1*2; //SP cost.
+			if (map_flag_gvg(bl->m) || map[bl->m].flag.battleground) val4 *= 5;
+			break;
+		case SC_CLOAKING:
+			if (!sd) //Monsters should be able to walk with no penalties. [Skotlex]
+				val1 = 10;
+			tick_time = val2 = tick>0?tick:60000; //SP consumption rate.
+			tick = -1; // duration sent to the client should be infinite
+			val3 = 0; // unused, previously walk speed adjustment
+			//val4&1 signals the presence of a wall.
+			//val4&2 makes cloak not end on normal attacks [Skotlex]
+			//val4&4 makes cloak not end on using skills
+			if (bl->type == BL_PC || (bl->type == BL_MOB && ((TBL_MOB*)bl)->special_state.clone) )	//Standard cloaking.
+				val4 |= battle_config.pc_cloak_check_type&7;
+			else
+				val4 |= battle_config.monster_cloak_check_type&7;
+			break;
+		case SC_SIGHT:			/* splash status */
+		case SC_RUWACH:
+		case SC_SIGHTBLASTER:
+			val3 = skill_get_splash(val2, val1); //Val2 should bring the skill-id.
+			val2 = tick/250;
+			tick_time = 10; // [GodLesZ] tick time
+			break;
 
-				//Permanent effects.
-			case SC_AETERNA:
-			case SC_MODECHANGE:
-			case SC_WEIGHT50:
-			case SC_WEIGHT90:
-			case SC_BROKENWEAPON:
-			case SC_BROKENARMOR:
-			case SC_READYSTORM:
-			case SC_READYDOWN:
-			case SC_READYCOUNTER:
-			case SC_READYTURN:
-			case SC_DODGE:
-			case SC_PUSH_CART:
-				tick = -1;
-				break;
+		//Permanent effects.
+		case SC_AETERNA:
+		case SC_MODECHANGE:
+		case SC_WEIGHT50:
+		case SC_WEIGHT90:
+		case SC_BROKENWEAPON:
+		case SC_BROKENARMOR:
+		case SC_READYSTORM:
+		case SC_READYDOWN:
+		case SC_READYCOUNTER:
+		case SC_READYTURN:
+		case SC_DODGE:
+		case SC_PUSH_CART:
+			tick = -1;
+			break;
 
-			case SC_AUTOGUARD:
-				if(!(flag&1)) {
-					struct map_session_data *tsd;
-					int i,t;
-					for(i = val2 = 0; i < val1; i++) {
-						t = 5-(i>>1);
-						val2 += (t < 0)? 1:t;
-					}
+		case SC_AUTOGUARD:
+			if( !(flag&1) )
+			{
+				struct map_session_data *tsd;
+				int i,t;
+				for( i = val2 = 0; i < val1; i++)
+				{
+					t = 5-(i>>1);
+					val2 += (t < 0)? 1:t;
+				}
 
-					if(bl->type&(BL_PC|BL_MER)) {
-						if(sd) {
-							for(i = 0; i < 5; i++) {
-								if(sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])))
-									status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
-							}
-						} else if(bl->type == BL_MER && ((TBL_MER *)bl)->devotion_flag && (tsd = ((TBL_MER *)bl)->master))
-							status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
+				if( bl->type&(BL_PC|BL_MER) )
+				{
+					if( sd )
+					{
+						for( i = 0; i < 5; i++ )
+						{
+							if( sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])) )
+								status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
+						}
 					}
+					else if( bl->type == BL_MER && ((TBL_MER*)bl)->devotion_flag && (tsd = ((TBL_MER*)bl)->master) )
+						status_change_start(src,&tsd->bl, type, 10000, val1, val2, 0, 0, tick, 1);
 				}
-				break;
+			}
+			break;
 
-			case SC_DEFENDER:
-				if(!(flag&1)) {
-					val2 = 5 + 15*val1; //Damage reduction
-					val3 = 0; // unused, previously speed adjustment
-					val4 = 250 - 50*val1; //Aspd adjustment
+		case SC_DEFENDER:
+			if (!(flag&1))
+			{
+				val2 = 5 + 15*val1; //Damage reduction
+				val3 = 0; // unused, previously speed adjustment
+				val4 = 250 - 50*val1; //Aspd adjustment
 
-					if(sd) {
-						struct map_session_data *tsd;
-						int i;
-						for(i = 0; i < 5; i++) {
-							//See if there are devoted characters, and pass the status to them. [Skotlex]
-							if(sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])))
-								status_change_start(src,&tsd->bl,type,10000,val1,5+val1*5,val3,val4,tick,1);
-						}
+				if (sd)
+				{
+					struct map_session_data *tsd;
+					int i;
+					for (i = 0; i < 5; i++)
+					{	//See if there are devoted characters, and pass the status to them. [Skotlex]
+						if (sd->devotion[i] && (tsd = map_id2sd(sd->devotion[i])))
+							status_change_start(src,&tsd->bl,type,10000,val1,5+val1*5,val3,val4,tick,1);
 					}
 				}
-				break;
+			}
+			break;
 
-			case SC_TENSIONRELAX:
-				if(sd) {
-					pc_setsit(sd);
-					clif_sitting(&sd->bl);
-				}
-				val2 = 12; //SP cost
-				val4 = 10000; //Decrease at 10secs intervals.
-				val3 = tick/val4;
-				tick = -1; // duration sent to the client should be infinite
-				tick_time = val4; // [GodLesZ] tick time
-				break;
-			case SC_PARRYING:
-				val2 = 20 + val1*3; //Block Chance
-				break;
+		case SC_TENSIONRELAX:
+			if (sd) {
+				pc_setsit(sd);
+				clif_sitting(&sd->bl,true);
+			}
+			val2 = 12; //SP cost
+			val4 = 10000; //Decrease at 10secs intervals.
+			val3 = tick/val4;
+			tick = -1; // duration sent to the client should be infinite
+			tick_time = val4; // [GodLesZ] tick time
+			break;
+		case SC_PARRYING:
+		    val2 = 20 + val1*3; //Block Chance
+			break;
 
-			case SC_WINDWALK:
-				val2 = (val1+1)/2; // Flee bonus is 1/1/2/2/3/3/4/4/5/5
-				break;
+		case SC_WINDWALK:
+			val2 = (val1+1)/2; // Flee bonus is 1/1/2/2/3/3/4/4/5/5
+			break;
 
-			case SC_JOINTBEAT:
-				if(val2&BREAK_NECK)
-					sc_start2(src,bl,SC_BLEEDING,100,val1,val3,skill_get_time2(status_sc2skill(type),val1));
-				break;
+		case SC_JOINTBEAT:
+			if( val2&BREAK_NECK )
+				sc_start2(src,bl,SC_BLEEDING,100,val1,val3,skill_get_time2(status_sc2skill(type),val1));
+			break;
 
-			case SC_BERSERK:
-				if(!sc->data[SC_ENDURE] || !sc->data[SC_ENDURE]->val4)
-					sc_start4(src,bl, SC_ENDURE, 100,10,0,0,2, tick);
-			case SC__BLOODYLUST:
-				//HP healing is performing after the calc_status call.
-				//Val2 holds HP penalty
-				if(!val4) val4 = skill_get_time2(status_sc2skill(type),val1);
-				if(!val4) val4 = 10000;  //Val4 holds damage interval
-				val3 = tick/val4; //val3 holds skill duration
-				tick_time = val4; // [GodLesZ] tick time
-				break;
+		case SC_BERSERK:
+			if (!sc->data[SC_ENDURE] || !sc->data[SC_ENDURE]->val4)
+				sc_start4(src,bl, SC_ENDURE, 100,10,0,0,2, tick);
+		case SC__BLOODYLUST:
+			//HP healing is performing after the calc_status call.
+			//Val2 holds HP penalty
+			if (!val4) val4 = skill_get_time2(status_sc2skill(type),val1);
+			if (!val4) val4 = 10000; //Val4 holds damage interval
+			val3 = tick/val4; //val3 holds skill duration
+			tick_time = val4; // [GodLesZ] tick time
+			break;
 
-			case SC_GOSPEL:
-				if(val4 == BCT_SELF) {  // self effect
-					val2 = tick/10000;
-					tick_time = 10000; // [GodLesZ] tick time
-					status_change_clear_buffs(bl,3); //Remove buffs/debuffs
-				}
-				break;
+		case SC_GOSPEL:
+			if(val4 == BCT_SELF) {	// self effect
+				val2 = tick/10000;
+				tick_time = 10000; // [GodLesZ] tick time
+				status_change_clear_buffs(bl,3); //Remove buffs/debuffs
+			}
+			break;
 
-			case SC_MARIONETTE: {
-					int stat;
+		case SC_MARIONETTE:
+		{
+			int stat;
 
-					val3 = 0;
-					val4 = 0;
-					stat = (sd ? sd->status.str : status_get_base_status(bl)->str) / 2; val3 |= cap_value(stat,0,0xFF)<<16;
-					stat = (sd ? sd->status.agi : status_get_base_status(bl)->agi) / 2; val3 |= cap_value(stat,0,0xFF)<<8;
-					stat = (sd ? sd->status.vit : status_get_base_status(bl)->vit) / 2; val3 |= cap_value(stat,0,0xFF);
-					stat = (sd ? sd->status.int_: status_get_base_status(bl)->int_) / 2; val4 |= cap_value(stat,0,0xFF)<<16;
-					stat = (sd ? sd->status.dex : status_get_base_status(bl)->dex) / 2; val4 |= cap_value(stat,0,0xFF)<<8;
-					stat = (sd ? sd->status.luk : status_get_base_status(bl)->luk) / 2; val4 |= cap_value(stat,0,0xFF);
-					break;
-				}
-			case SC_MARIONETTE2: {
-					int stat,max_stat;
-					// fetch caster information
-					struct block_list *pbl = map_id2bl(val1);
-					struct status_change *psc = pbl?status_get_sc(pbl):NULL;
-					struct status_change_entry *psce = psc?psc->data[SC_MARIONETTE]:NULL;
-					// fetch target's stats
-					struct status_data *status = status_get_status_data(bl); // battle status
+			val3 = 0;
+			val4 = 0;
+			stat = ( sd ? sd->status.str : status_get_base_status(bl)->str ) / 2; val3 |= cap_value(stat,0,0xFF)<<16;
+			stat = ( sd ? sd->status.agi : status_get_base_status(bl)->agi ) / 2; val3 |= cap_value(stat,0,0xFF)<<8;
+			stat = ( sd ? sd->status.vit : status_get_base_status(bl)->vit ) / 2; val3 |= cap_value(stat,0,0xFF);
+			stat = ( sd ? sd->status.int_: status_get_base_status(bl)->int_) / 2; val4 |= cap_value(stat,0,0xFF)<<16;
+			stat = ( sd ? sd->status.dex : status_get_base_status(bl)->dex ) / 2; val4 |= cap_value(stat,0,0xFF)<<8;
+			stat = ( sd ? sd->status.luk : status_get_base_status(bl)->luk ) / 2; val4 |= cap_value(stat,0,0xFF);
+			break;
+		}
+		case SC_MARIONETTE2:
+		{
+			int stat,max_stat;
+			// fetch caster information
+			struct block_list *pbl = map_id2bl(val1);
+			struct status_change *psc = pbl?status_get_sc(pbl):NULL;
+			struct status_change_entry *psce = psc?psc->data[SC_MARIONETTE]:NULL;
+			// fetch target's stats
+			struct status_data* status = status_get_status_data(bl); // battle status
 
-					if(!psce)
-						return 0;
+			if (!psce)
+				return 0;
 
-					val3 = 0;
-					val4 = 0;
-					max_stat = battle_config.max_parameter; //Cap to 99 (default)
-					stat = (psce->val3 >>16)&0xFF; stat = min(stat, max_stat - status->str); val3 |= cap_value(stat,0,0xFF)<<16;
-					stat = (psce->val3 >> 8)&0xFF; stat = min(stat, max_stat - status->agi); val3 |= cap_value(stat,0,0xFF)<<8;
-					stat = (psce->val3 >> 0)&0xFF; stat = min(stat, max_stat - status->vit); val3 |= cap_value(stat,0,0xFF);
-					stat = (psce->val4 >>16)&0xFF; stat = min(stat, max_stat - status->int_); val4 |= cap_value(stat,0,0xFF)<<16;
-					stat = (psce->val4 >> 8)&0xFF; stat = min(stat, max_stat - status->dex); val4 |= cap_value(stat,0,0xFF)<<8;
-					stat = (psce->val4 >> 0)&0xFF; stat = min(stat, max_stat - status->luk); val4 |= cap_value(stat,0,0xFF);
-					break;
-				}
-			case SC_REJECTSWORD:
-				val2 = 15*val1; //Reflect chance
-				val3 = 3; //Reflections
-				tick = -1;
-				break;
+			val3 = 0;
+			val4 = 0;
+			max_stat = battle_config.max_parameter; //Cap to 99 (default)
+			stat = (psce->val3 >>16)&0xFF; stat = min(stat, max_stat - status->str ); val3 |= cap_value(stat,0,0xFF)<<16;
+			stat = (psce->val3 >> 8)&0xFF; stat = min(stat, max_stat - status->agi ); val3 |= cap_value(stat,0,0xFF)<<8;
+			stat = (psce->val3 >> 0)&0xFF; stat = min(stat, max_stat - status->vit ); val3 |= cap_value(stat,0,0xFF);
+			stat = (psce->val4 >>16)&0xFF; stat = min(stat, max_stat - status->int_); val4 |= cap_value(stat,0,0xFF)<<16;
+			stat = (psce->val4 >> 8)&0xFF; stat = min(stat, max_stat - status->dex ); val4 |= cap_value(stat,0,0xFF)<<8;
+			stat = (psce->val4 >> 0)&0xFF; stat = min(stat, max_stat - status->luk ); val4 |= cap_value(stat,0,0xFF);
+			break;
+		}
+		case SC_REJECTSWORD:
+			val2 = 15*val1; //Reflect chance
+			val3 = 3; //Reflections
+			tick = -1;
+			break;
 
-			case SC_MEMORIZE:
-				val2 = 5; //Memorized casts.
-				tick = -1;
-				break;
+		case SC_MEMORIZE:
+			val2 = 5; //Memorized casts.
+			tick = -1;
+			break;
 
-			case SC_GRAVITATION:
-				val2 = 50*val1; //aspd reduction
-				break;
+		case SC_GRAVITATION:
+			val2 = 50*val1; //aspd reduction
+			break;
 
-			case SC_REGENERATION:
-				if(val1 == 1)
-					val2 = 2;
-				else
-					val2 = val1; //HP Regerenation rate: 200% 200% 300%
-				val3 = val1; //SP Regeneration Rate: 100% 200% 300%
-				//if val4 comes set, this blocks regen rather than increase it.
-				break;
+		case SC_REGENERATION:
+			if (val1 == 1)
+				val2 = 2;
+			else
+				val2 = val1; //HP Regerenation rate: 200% 200% 300%
+			val3 = val1; //SP Regeneration Rate: 100% 200% 300%
+			//if val4 comes set, this blocks regen rather than increase it.
+			break;
 
-			case SC_DEVOTION: {
-					struct block_list *d_bl;
-					struct status_change *d_sc;
+		case SC_DEVOTION:
+		{
+			struct block_list *d_bl;
+			struct status_change *d_sc;
 
-					if((d_bl = map_id2bl(val1)) && (d_sc = status_get_sc(d_bl)) && d_sc->count) {
-						// Inherits Status From Source
-						const enum sc_type types[] = { SC_AUTOGUARD, SC_DEFENDER, SC_REFLECTSHIELD, SC_ENDURE };
-						enum sc_type type2;
-						int i = (map_flag_gvg(bl->m) || map[bl->m].flag.battleground)?2:3;
-						while(i >= 0) {
-							type2 = types[i];
-							if(d_sc->data[type2])
-								sc_start(d_bl,bl, type2, 100, d_sc->data[type2]->val1, skill_get_time(status_sc2skill(type2),d_sc->data[type2]->val1));
-							i--;
-						}
-					}
-					break;
+			if( (d_bl = map_id2bl(val1)) && (d_sc = status_get_sc(d_bl)) && d_sc->count )
+			{ // Inherits Status From Source
+				const enum sc_type types[] = { SC_AUTOGUARD, SC_DEFENDER, SC_REFLECTSHIELD, SC_ENDURE };
+				enum sc_type type2;
+				int i = (map_flag_gvg(bl->m) || map[bl->m].flag.battleground)?2:3;
+				while( i >= 0 )
+				{
+					type2 = types[i];
+					if( d_sc->data[type2] )
+						sc_start(d_bl,bl, type2, 100, d_sc->data[type2]->val1, skill_get_time(status_sc2skill(type2),d_sc->data[type2]->val1));
+					i--;
 				}
+			}
+			break;
+		}
 
-			case SC_COMA: //Coma. Sends a char to 1HP. If val2, do not zap sp
-				if(val3 && bl->type == BL_MOB) {
-					struct block_list *src = map_id2bl(val3);
-					if(src)
-						mob_log_damage((TBL_MOB *)bl,src,status->hp - 1);
+		case SC_COMA: //Coma. Sends a char to 1HP. If val2, do not zap sp
+			if( val3 && bl->type == BL_MOB ) {
+				struct block_list* src = map_id2bl(val3);
+				if( src )
+					mob_log_damage((TBL_MOB*)bl,src,status->hp - 1);
+			}
+			status_zap(bl, status->hp-1, val2?0:status->sp);
+			return 1;
+			break;
+		case SC_CLOSECONFINE2:
+		{
+			struct block_list *src = val2?map_id2bl(val2):NULL;
+			struct status_change *sc2 = src?status_get_sc(src):NULL;
+			struct status_change_entry *sce2 = sc2?sc2->data[SC_CLOSECONFINE]:NULL;
+			if (src && sc2) {
+				if (!sce2) //Start lock on caster.
+					sc_start4(src,src,SC_CLOSECONFINE,100,val1,1,0,0,tick+1000);
+				else { //Increase count of locked enemies and refresh time.
+					(sce2->val2)++;
+					delete_timer(sce2->timer, status_change_timer);
+					sce2->timer = add_timer(gettick()+tick+1000, status_change_timer, src->id, SC_CLOSECONFINE);
 				}
-				status_zap(bl, status->hp-1, val2?0:status->sp);
-				return 1;
-				break;
-			case SC_CLOSECONFINE2: {
-					struct block_list *src = val2?map_id2bl(val2):NULL;
-					struct status_change *sc2 = src?status_get_sc(src):NULL;
-					struct status_change_entry *sce2 = sc2?sc2->data[SC_CLOSECONFINE]:NULL;
-					if(src && sc2) {
-						if(!sce2)  //Start lock on caster.
-							sc_start4(src,src,SC_CLOSECONFINE,100,val1,1,0,0,tick+1000);
-						else { //Increase count of locked enemies and refresh time.
-							(sce2->val2)++;
-							delete_timer(sce2->timer, status_change_timer);
-							sce2->timer = add_timer(gettick()+tick+1000, status_change_timer, src->id, SC_CLOSECONFINE);
-						}
-					} else //Status failed.
-						return 0;
-				}
-				break;
-			case SC_KAITE:
-				val2 = 1+val1/5; //Number of bounces: 1 + skill_lv/5
-				break;
-			case SC_KAUPE:
-				switch(val1) {
-					case 3: //33*3 + 1 -> 100%
-						val2++;
-					case 1:
-					case 2: //33, 66%
-						val2 += 33*val1;
-						val3 = 1; //Dodge 1 attack total.
-						break;
-					default: //Custom. For high level mob usage, higher level means more blocks. [Skotlex]
-						val2 = 100;
-						val3 = val1-2;
-						break;
-				}
-				break;
+			} else //Status failed.
+				return 0;
+		}
+			break;
+		case SC_KAITE:
+			val2 = 1+val1/5; //Number of bounces: 1 + skill_lv/5
+			break;
+		case SC_KAUPE:
+			switch (val1) {
+				case 3: //33*3 + 1 -> 100%
+					val2++;
+				case 1:
+				case 2: //33, 66%
+					val2 += 33*val1;
+					val3 = 1; //Dodge 1 attack total.
+					break;
+				default: //Custom. For high level mob usage, higher level means more blocks. [Skotlex]
+					val2 = 100;
+					val3 = val1-2;
+					break;
+			}
+			break;
 
-			case SC_COMBO: {
-					//val1: Skill ID
-					//val2: When given, target (for autotargetting skills)
-					//val3: When set, this combo time should NOT delay attack/movement
-					//val3: TK: Last used kick
-					//val4: TK: Combo time
-					struct unit_data *ud = unit_bl2ud(bl);
-					if(ud && !val3) {
-						tick += 300 * battle_config.combo_delay_rate/100;
-						ud->attackabletime = gettick()+tick;
-						unit_set_walkdelay(bl, gettick(), tick, 1);
-					}
-					val3 = 0;
-					val4 = tick;
+		case SC_COMBO: {
+				//val1: Skill ID
+				//val2: When given, target (for autotargetting skills)
+				//val3: When set, this combo time should NOT delay attack/movement
+				//val3: TK: Last used kick
+				//val4: TK: Combo time
+				struct unit_data *ud = unit_bl2ud(bl);
+				if (ud && !val3) {
+					tick += 300 * battle_config.combo_delay_rate/100;
+					ud->attackabletime = gettick()+tick;
+					unit_set_walkdelay(bl, gettick(), tick, 1);
 				}
-				break;
-			case SC_EARTHSCROLL:
-				val2 = 11-val1; //Chance to consume: 11-skill_lv%
-				break;
-			case SC_RUN:
-				val4 = gettick(); //Store time at which you started running.
-				tick = -1;
-				break;
-			case SC_KAAHI:
-				val2 = 200*val1; //HP heal
-				val3 = 5*val1; //SP cost
-				val4 = INVALID_TIMER;   //Kaahi Timer.
-				break;
-			case SC_BLESSING:
-				if((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC)
-					val2 = val1;
-				else
-					val2 = 0; //0 -> Half stat.
-				break;
-			case SC_TRICKDEAD:
-				if(vd) vd->dead_sit = 1;
-				tick = -1;
-				break;
-			case SC_CONCENTRATE:
-				val2 = 2 + val1;
-				if(sd) {  //Store the card-bonus data that should not count in the %
-					val3 = sd->param_bonus[1]; //Agi
-					val4 = sd->param_bonus[4]; //Dex
-				} else {
-					val3 = val4 = 0;
-				}
-				break;
-			case SC_MAXOVERTHRUST:
-				val2 = 20*val1; //Power increase
-				break;
-			case SC_OVERTHRUST:
-				//val2 holds if it was casted on self, or is bonus received from others
-				val3 = 5*val1; //Power increase
-				if(sd && pc_checkskill(sd,BS_HILTBINDING)>0)
-					tick += tick / 10;
-				break;
-			case SC_ADRENALINE2:
-			case SC_ADRENALINE:
-				val3 = (val2) ? 300 : 200; // aspd increase
-			case SC_WEAPONPERFECTION:
-				if(sd && pc_checkskill(sd,BS_HILTBINDING)>0)
-					tick += tick / 10;
-				break;
-			case SC_CONCENTRATION:
-				val2 = 5*val1; //Batk/Watk Increase
-				val3 = 10*val1; //Hit Increase
-				val4 = 5*val1; //Def reduction
-				break;
-			case SC_ANGELUS:
-				val2 = 5*val1; //def increase
-				break;
-			case SC_IMPOSITIO:
-				val2 = 5*val1; //watk increase
-				break;
-			case SC_MELTDOWN:
-				val2 = 100*val1; //Chance to break weapon
-				val3 = 70*val1; //Change to break armor
-				break;
-			case SC_TRUESIGHT:
-				val2 = 10*val1; //Critical increase
-				val3 = 3*val1; //Hit increase
-				break;
-			case SC_SUN_COMFORT:
-				val2 = (status_get_lv(bl) + status->dex + status->luk)/2; //def increase
-				break;
-			case SC_MOON_COMFORT:
-				val2 = (status_get_lv(bl) + status->dex + status->luk)/10; //flee increase
-				break;
-			case SC_STAR_COMFORT:
-				val2 = (status_get_lv(bl) + status->dex + status->luk); //Aspd increase
-				break;
-			case SC_QUAGMIRE:
-				val2 = (sd?5:10)*val1; //Agi/Dex decrease.
-				break;
+				val3 = 0;
+				val4 = tick;
+			}
+			break;
+		case SC_EARTHSCROLL:
+			val2 = 11-val1; //Chance to consume: 11-skill_lv%
+			break;
+		case SC_RUN:
+			val4 = gettick(); //Store time at which you started running.
+			tick = -1;
+			break;
+		case SC_KAAHI:
+			val2 = 200*val1; //HP heal
+			val3 = 5*val1; //SP cost
+			val4 = INVALID_TIMER;	//Kaahi Timer.
+			break;
+		case SC_BLESSING:
+			if ((!undead_flag && status->race!=RC_DEMON) || bl->type == BL_PC)
+				val2 = val1;
+			else
+				val2 = 0; //0 -> Half stat.
+			break;
+		case SC_TRICKDEAD:
+			if (vd) vd->dead_sit = 1;
+			tick = -1;
+			break;
+		case SC_CONCENTRATE:
+			val2 = 2 + val1;
+			if (sd) { //Store the card-bonus data that should not count in the %
+				val3 = sd->param_bonus[1]; //Agi
+				val4 = sd->param_bonus[4]; //Dex
+			} else {
+				val3 = val4 = 0;
+			}
+			break;
+		case SC_MAXOVERTHRUST:
+			val2 = 20*val1; //Power increase
+			break;
+		case SC_OVERTHRUST:
+			//val2 holds if it was casted on self, or is bonus received from others
+			val3 = 5*val1; //Power increase
+			if(sd && pc_checkskill(sd,BS_HILTBINDING)>0)
+				tick += tick / 10;
+			break;
+		case SC_ADRENALINE2:
+		case SC_ADRENALINE:
+			val3 = (val2) ? 300 : 200; // aspd increase
+		case SC_WEAPONPERFECTION:
+			if(sd && pc_checkskill(sd,BS_HILTBINDING)>0)
+				tick += tick / 10;
+			break;
+		case SC_CONCENTRATION:
+			val2 = 5*val1; //Batk/Watk Increase
+			val3 = 10*val1; //Hit Increase
+			val4 = 5*val1; //Def reduction
+			break;
+		case SC_ANGELUS:
+			val2 = 5*val1; //def increase
+			break;
+		case SC_IMPOSITIO:
+			val2 = 5*val1; //watk increase
+			break;
+		case SC_MELTDOWN:
+			val2 = 100*val1; //Chance to break weapon
+			val3 = 70*val1; //Change to break armor
+			break;
+		case SC_TRUESIGHT:
+			val2 = 10*val1; //Critical increase
+			val3 = 3*val1; //Hit increase
+			break;
+		case SC_SUN_COMFORT:
+			val2 = (status_get_lv(bl) + status->dex + status->luk)/2; //def increase
+			break;
+		case SC_MOON_COMFORT:
+			val2 = (status_get_lv(bl) + status->dex + status->luk)/10; //flee increase
+			break;
+		case SC_STAR_COMFORT:
+			val2 = (status_get_lv(bl) + status->dex + status->luk); //Aspd increase
+			break;
+		case SC_QUAGMIRE:
+			val2 = (sd?5:10)*val1; //Agi/Dex decrease.
+			break;
 
-				// gs_something1 [Vicious]
-			case SC_GATLINGFEVER:
-				val2 = 20*val1; //Aspd increase
-				val3 = 20+10*val1; //Batk increase
-				val4 = 5*val1; //Flee decrease
-				break;
+		// gs_something1 [Vicious]
+		case SC_GATLINGFEVER:
+			val2 = 20*val1; //Aspd increase
+			val3 = 20+10*val1; //Batk increase
+			val4 = 5*val1; //Flee decrease
+			break;
 
-			case SC_FLING:
-				if(bl->type == BL_PC)
-					val2 = 0; //No armor reduction to players.
-				else
-					val2 = 5*val1; //Def reduction
-				val3 = 5*val1; //Def2 reduction
-				break;
-			case SC_PROVOKE:
-				//val2 signals autoprovoke.
-				val3 = 2+3*val1; //Atk increase
-				val4 = 5+5*val1; //Def reduction.
-				break;
-			case SC_AVOID:
-				//val2 = 10*val1; //Speed change rate.
-				break;
-			case SC_DEFENCE:
-				val2 = 2*val1; //Def bonus
-				break;
-			case SC_BLOODLUST:
-				val2 = 20+10*val1; //Atk rate change.
-				val3 = 3*val1; //Leech chance
-				val4 = 20; //Leech percent
-				break;
-			case SC_FLEET:
-				val2 = 30*val1; //Aspd change
-				val3 = 5+5*val1; //bAtk/wAtk rate change
-				break;
-			case SC_MINDBREAKER:
-				val2 = 20*val1; //matk increase.
-				val3 = 12*val1; //mdef2 reduction.
-				break;
-			case SC_SKA:
-				val2 = tick/1000;
-				val3 = rnd()%100; //Def changes randomly every second...
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_JAILED:
-				//Val1 is duration in minutes. Use INT_MAX to specify 'unlimited' time.
-				tick = val1>0?1000:250;
-				if(sd) {
-					if(sd->mapindex != val2) {
-						int pos = (bl->x&0xFFFF)|(bl->y<<16),  //Current Coordinates
-						    map =  sd->mapindex; //Current Map
-						//1. Place in Jail (val2 -> Jail Map, val3 -> x, val4 -> y
-						pc_setpos(sd,(unsigned short)val2,val3,val4, CLR_TELEPORT);
-						//2. Set restore point (val3 -> return map, val4 return coords
-						val3 = map;
-						val4 = pos;
-					} else if(!val3 || val3 == sd->mapindex) {  //Use save point.
-						val3 = sd->status.save_point.map;
-						val4 = (sd->status.save_point.x&0xFFFF)
-						       |(sd->status.save_point.y<<16);
-					}
+		case SC_FLING:
+			if (bl->type == BL_PC)
+				val2 = 0; //No armor reduction to players.
+			else
+				val2 = 5*val1; //Def reduction
+			val3 = 5*val1; //Def2 reduction
+			break;
+		case SC_PROVOKE:
+			//val2 signals autoprovoke.
+			val3 = 2+3*val1; //Atk increase
+			val4 = 5+5*val1; //Def reduction.
+			break;
+		case SC_AVOID:
+			//val2 = 10*val1; //Speed change rate.
+			break;
+		case SC_DEFENCE:
+			val2 = 2*val1; //Def bonus
+			break;
+		case SC_BLOODLUST:
+			val2 = 20+10*val1; //Atk rate change.
+			val3 = 3*val1; //Leech chance
+			val4 = 20; //Leech percent
+			break;
+		case SC_FLEET:
+			val2 = 30*val1; //Aspd change
+			val3 = 5+5*val1; //bAtk/wAtk rate change
+			break;
+		case SC_MINDBREAKER:
+			val2 = 20*val1; //matk increase.
+			val3 = 12*val1; //mdef2 reduction.
+			break;
+		case SC_SKA:
+			val2 = tick/1000;
+			val3 = rnd()%100; //Def changes randomly every second...
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_JAILED:
+			//Val1 is duration in minutes. Use INT_MAX to specify 'unlimited' time.
+			tick = val1>0?1000:250;
+			if (sd)
+			{
+				if (sd->mapindex != val2)
+				{
+					int pos =  (bl->x&0xFFFF)|(bl->y<<16), //Current Coordinates
+					map =  sd->mapindex; //Current Map
+					//1. Place in Jail (val2 -> Jail Map, val3 -> x, val4 -> y
+					pc_setpos(sd,(unsigned short)val2,val3,val4, CLR_TELEPORT);
+					//2. Set restore point (val3 -> return map, val4 return coords
+					val3 = map;
+					val4 = pos;
+				} else if (!val3 || val3 == sd->mapindex) { //Use save point.
+					val3 = sd->status.save_point.map;
+					val4 = (sd->status.save_point.x&0xFFFF)
+						|(sd->status.save_point.y<<16);
 				}
-				break;
-			case SC_UTSUSEMI:
-				val2=(val1+1)/2; // number of hits blocked
-				val3=skill_get_blewcount(NJ_UTSUSEMI, val1); //knockback value.
-				break;
-			case SC_BUNSINJYUTSU:
-				val2=(val1+1)/2; // number of hits blocked
-				break;
-			case SC_CHANGE:
-				val2= 30*val1; //Vit increase
-				val3= 20*val1; //Int increase
-				break;
-			case SC_SWOO:
-				if(status->mode&MD_BOSS)
-					tick /= 5; //TODO: Reduce skill's duration. But for how long?
-				break;
-			case SC_SPIDERWEB:
-				if(bl->type == BL_PC)
-					tick /= 2;
-				break;
-			case SC_ARMOR:
-				//NPC_DEFENDER:
-				val2 = 80; //Damage reduction
-				//Attack requirements to be blocked:
-				val3 = BF_LONG; //Range
-				val4 = BF_WEAPON|BF_MISC; //Type
-				break;
-			case SC_ENCHANTARMS:
-				//end previous enchants
-				skill_enchant_elemental_end(bl,type);
-				//Make sure the received element is valid.
-				if(val2 >= ELE_MAX)
-					val2 = val2%ELE_MAX;
-				else if(val2 < 0)
-					val2 = rnd()%ELE_MAX;
-				break;
-			case SC_CRITICALWOUND:
-				val2 = 20*val1; //Heal effectiveness decrease
-				break;
-			case SC_MAGICMIRROR:
-			case SC_SLOWCAST:
-				val2 = 20*val1; //Magic reflection/cast rate
-				break;
+			}
+			break;
+		case SC_UTSUSEMI:
+			val2=(val1+1)/2; // number of hits blocked
+			val3=skill_get_blewcount(NJ_UTSUSEMI, val1); //knockback value.
+			break;
+		case SC_BUNSINJYUTSU:
+			val2=(val1+1)/2; // number of hits blocked
+			break;
+		case SC_CHANGE:
+			val2= 30*val1; //Vit increase
+			val3= 20*val1; //Int increase
+			break;
+		case SC_SWOO:
+			if(status->mode&MD_BOSS)
+				tick /= 5; //TODO: Reduce skill's duration. But for how long?
+			break;
+		case SC_SPIDERWEB:
+			if( bl->type == BL_PC )
+				tick /= 2;
+			break;
+		case SC_ARMOR:
+			//NPC_DEFENDER:
+			val2 = 80; //Damage reduction
+			//Attack requirements to be blocked:
+			val3 = BF_LONG; //Range
+			val4 = BF_WEAPON|BF_MISC; //Type
+			break;
+		case SC_ENCHANTARMS:
+			//end previous enchants
+			skill_enchant_elemental_end(bl,type);
+			//Make sure the received element is valid.
+			if (val2 >= ELE_MAX)
+				val2 = val2%ELE_MAX;
+			else if (val2 < 0)
+				val2 = rnd()%ELE_MAX;
+			break;
+		case SC_CRITICALWOUND:
+			val2 = 20*val1; //Heal effectiveness decrease
+			break;
+		case SC_MAGICMIRROR:
+		case SC_SLOWCAST:
+			val2 = 20*val1; //Magic reflection/cast rate
+			break;
 
-			case SC_ARMORCHANGE:
-				if(val2 == NPC_ANTIMAGIC) {
-					//Boost mdef
-					val2 =-20;
-					val3 = 20;
-				} else { //Boost def
-					val2 = 20;
-					val3 =-20;
-				}
-				val2*=val1; //20% per level
-				val3*=val1;
-				break;
-			case SC_EXPBOOST:
-			case SC_JEXPBOOST:
-				if(val1 < 0)
-					val1 = 0;
-				break;
-			case SC_INCFLEE2:
-			case SC_INCCRI:
-				val2 = val1*10; //Actual boost (since 100% = 1000)
-				break;
-			case SC_SUFFRAGIUM:
-				val2 = 15 * val1; //Speed cast decrease
-				break;
-			case SC_INCHEALRATE:
-				if(val1 < 1)
-					val1 = 1;
-				break;
-			case SC_HALLUCINATION:
-				val2 = 5+val1; //Factor by which displayed damage is increased by
-				break;
-			case SC_DOUBLECAST:
-				val2 = 30+10*val1; //Trigger rate
-				break;
-			case SC_KAIZEL:
-				val2 = 10*val1; //% of life to be revived with
-				break;
-				// case SC_ARMOR_ELEMENT:
-				// case SC_ARMOR_RESIST:
-				// Mod your resistance against elements:
-				// val1 = water | val2 = earth | val3 = fire | val4 = wind
-				// break;
-				//case ????:
-				//Place here SCs that have no SCB_* data, no skill associated, no ICON
-				//associated, and yet are not wrong/unknown. [Skotlex]
-				//break;
+		case SC_ARMORCHANGE:
+			if (val2 == NPC_ANTIMAGIC)
+			{	//Boost mdef
+				val2 =-20;
+				val3 = 20;
+			} else { //Boost def
+				val2 = 20;
+				val3 =-20;
+			}
+			val2*=val1; //20% per level
+			val3*=val1;
+			break;
+		case SC_EXPBOOST:
+		case SC_JEXPBOOST:
+			if (val1 < 0)
+				val1 = 0;
+			break;
+		case SC_INCFLEE2:
+		case SC_INCCRI:
+			val2 = val1*10; //Actual boost (since 100% = 1000)
+			break;
+		case SC_SUFFRAGIUM:
+			val2 = 15 * val1; //Speed cast decrease
+			break;
+		case SC_INCHEALRATE:
+			if (val1 < 1)
+				val1 = 1;
+			break;
+		case SC_HALLUCINATION:
+			val2 = 5+val1; //Factor by which displayed damage is increased by
+			break;
+		case SC_DOUBLECAST:
+			val2 = 30+10*val1; //Trigger rate
+			break;
+		case SC_KAIZEL:
+			val2 = 10*val1; //% of life to be revived with
+			break;
+		// case SC_ARMOR_ELEMENT:
+		// case SC_ARMOR_RESIST:
+			// Mod your resistance against elements:
+			// val1 = water | val2 = earth | val3 = fire | val4 = wind
+			// break;
+		//case ????:
+			//Place here SCs that have no SCB_* data, no skill associated, no ICON
+			//associated, and yet are not wrong/unknown. [Skotlex]
+			//break;
 
-			case SC_MERC_FLEEUP:
-			case SC_MERC_ATKUP:
-			case SC_MERC_HITUP:
-				val2 = 15 * val1;
-				break;
-			case SC_MERC_HPUP:
-			case SC_MERC_SPUP:
-				val2 = 5 * val1;
-				break;
-			case SC_REBIRTH:
-				val2 = 20*val1; //% of life to be revived with
-				break;
+		case SC_MERC_FLEEUP:
+		case SC_MERC_ATKUP:
+		case SC_MERC_HITUP:
+			val2 = 15 * val1;
+			break;
+		case SC_MERC_HPUP:
+		case SC_MERC_SPUP:
+			val2 = 5 * val1;
+			break;
+		case SC_REBIRTH:
+			val2 = 20*val1; //% of life to be revived with
+			break;
 
-			case SC_MANU_DEF:
-			case SC_MANU_ATK:
-			case SC_MANU_MATK:
-				val2 = 1; // Manuk group
-				break;
-			case SC_SPL_DEF:
-			case SC_SPL_ATK:
-			case SC_SPL_MATK:
-				val2 = 2; // Splendide group
-				break;
-				/**
-				 * General
-				 **/
-			case SC_FEAR:
-				val2 = 2;
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_BURNING:
-				val4 = tick / 2000; // Total Ticks to Burn!!
-				tick_time = 2000; // [GodLesZ] tick time
-				break;
-				/**
-				 * Rune Knight
-				 **/
-			case SC_DEATHBOUND:
-				val2 = 500 + 100 * val1;
-				break;
-			case SC_STONEHARDSKIN:
-				if(sd)
+		case SC_MANU_DEF:
+		case SC_MANU_ATK:
+		case SC_MANU_MATK:
+			val2 = 1; // Manuk group
+			break;
+		case SC_SPL_DEF:
+		case SC_SPL_ATK:
+		case SC_SPL_MATK:
+			val2 = 2; // Splendide group
+			break;
+		/**
+		 * General
+		 **/
+		case SC_FEAR:
+			val2 = 2;
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_BURNING:
+			val4 = tick / 2000; // Total Ticks to Burn!!
+			tick_time = 2000; // [GodLesZ] tick time
+			break;
+		/**
+		 * Rune Knight
+		 **/
+		case SC_DEATHBOUND:
+			val2 = 500 + 100 * val1;
+			break;
+		case SC_STONEHARDSKIN:
+			if( sd )
 				val1 = sd->status.job_level * pc_checkskill(sd, RK_RUNEMASTERY) / 4; //DEF/MDEF Increase
-				break;
-			case SC_FIGHTINGSPIRIT:
-				val_flag |= 1|2;
-				break;
-			case SC_ABUNDANCE:
-				val4 = tick / 10000;
-				tick_time = 10000; // [GodLesZ] tick time
-				break;
-			case SC_GIANTGROWTH:
-				val2 = 15; // Triple damage success rate.
-				break;
-				/**
-				 * Arch Bishop
-				 **/
-			case SC_RENOVATIO:
-				val4 = tick / 5000;
-				tick_time = 5000;
-				break;
-			case SC_SECRAMENT:
-				val2 = 10 * val1;
-				break;
-			case SC_VENOMIMPRESS:
-				val2 = 10 * val1;
-				val_flag |= 1|2;
-				break;
-			case SC_POISONINGWEAPON:
-				val_flag |= 1|2|4;
-				break;
-			case SC_WEAPONBLOCKING:
-				val2 = 10 + 2 * val1; // Chance
-				val4 = tick / 3000;
-				tick_time = 3000; // [GodLesZ] tick time
-				val_flag |= 1|2;
-				break;
-			case SC_TOXIN:
-				val4 = tick / 10000;
-				tick_time = 10000; // [GodLesZ] tick time
-				break;
-			case SC_MAGICMUSHROOM:
-				val4 = tick / 4000;
-				tick_time = 4000; // [GodLesZ] tick time
-				break;
-			case SC_PYREXIA:
-				status_change_start(src,bl,SC_BLIND,10000,val1,0,0,0,30000,11); // Blind status that last for 30 seconds
-				val4 = tick / 3000;
-				tick_time = 3000; // [GodLesZ] tick time
-				break;
-			case SC_LEECHESEND:
+			break;
+		case SC_FIGHTINGSPIRIT:
+			val_flag |= 1|2;
+			break;
+		case SC_ABUNDANCE:
+			val4 = tick / 10000;
+			tick_time = 10000; // [GodLesZ] tick time
+			break;
+		case SC_GIANTGROWTH:
+			val2 = 15; // Triple damage success rate.
+			break;
+		/**
+		 * Arch Bishop
+		 **/
+		case SC_RENOVATIO:
+			val4 = tick / 5000;
+			tick_time = 5000;
+			break;
+		case SC_SECRAMENT:
+			val2 = 10 * val1;
+			break;
+		case SC_VENOMIMPRESS:
+			val2 = 10 * val1;
+			val_flag |= 1|2;
+			break;
+		case SC_POISONINGWEAPON:
+			val_flag |= 1|2|4;
+			break;
+		case SC_WEAPONBLOCKING:
+			val2 = 10 + 2 * val1; // Chance
+			val4 = tick / 3000;
+			tick_time = 3000; // [GodLesZ] tick time
+			val_flag |= 1|2;
+			break;
+		case SC_TOXIN:
+			val4 = tick / 10000;
+			tick_time = 10000; // [GodLesZ] tick time
+			break;
+		case SC_MAGICMUSHROOM:
+			val4 = tick / 4000;
+			tick_time = 4000; // [GodLesZ] tick time
+			break;
+		case SC_PYREXIA:
+			status_change_start(src,bl,SC_BLIND,10000,val1,0,0,0,30000,11); // Blind status that last for 30 seconds
+			val4 = tick / 3000;
+			tick_time = 3000; // [GodLesZ] tick time
+			break;
+		case SC_LEECHESEND:
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_OBLIVIONCURSE:
+			val4 = tick / 3000;
+			tick_time = 3000; // [GodLesZ] tick time
+			break;
+		case SC_ROLLINGCUTTER:
+			val_flag |= 1;
+			break;
+		case SC_CLOAKINGEXCEED:
+			val2 = ( val1 + 1 ) / 2; // Hits
+			val3 = 90 + val1 * 10; // Walk speed
+			val_flag |= 1|2|4;
+			if (bl->type == BL_PC)
+				val4 |= battle_config.pc_cloak_check_type&7;
+			else
+				val4 |= battle_config.monster_cloak_check_type&7;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_HALLUCINATIONWALK:
+			val2 = 50 * val1; // Evasion rate of physical attacks. Flee
+			val3 = 10 * val1; // Evasion rate of magical attacks.
+			val_flag |= 1|2|4;
+			break;
+		case SC_WHITEIMPRISON:
+			status_change_end(bl, SC_BURNING, INVALID_TIMER);
+			status_change_end(bl, SC_FREEZING, INVALID_TIMER);
+			status_change_end(bl, SC_FREEZE, INVALID_TIMER);
+			status_change_end(bl, SC_STONE, INVALID_TIMER);
+			break;
+		case SC_FREEZING:
+			status_change_end(bl, SC_BURNING, INVALID_TIMER);
+			break;
+		case SC_READING_SB:
+			// val2 = sp reduction per second
+			tick_time = 5000; // [GodLesZ] tick time
+			break;
+		case SC_SPHERE_1:
+		case SC_SPHERE_2:
+		case SC_SPHERE_3:
+		case SC_SPHERE_4:
+		case SC_SPHERE_5:
+			if( !sd )
+				return 0;	// Should only work on players.
+			val4 = tick / 1000;
+			if( val4 < 1 )
+				val4 = 1;
+			tick_time = 1000; // [GodLesZ] tick time
+			val_flag |= 1;
+			break;
+		case SC_SHAPESHIFT:
+			switch( val1 )
+			{
+				case 1: val2 = ELE_FIRE; break;
+				case 2: val2 = ELE_EARTH; break;
+				case 3: val2 = ELE_WIND; break;
+				case 4: val2 = ELE_WATER; break;
+			}
+			break;
+		case SC_ELECTRICSHOCKER:
+		case SC_CRYSTALIZE:
+		case SC_MEIKYOUSISUI:
+			val4 = tick / 1000;
+			if( val4 < 1 )
+				val4 = 1;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_CAMOUFLAGE:
+			val4 = tick/1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_WUGDASH:
+			val4 = gettick(); //Store time at which you started running.
+			tick = -1;
+			break;
+		case SC__SHADOWFORM: {
+				struct map_session_data * s_sd = map_id2sd(val2);
+				if( s_sd )
+					s_sd->shadowform_id = bl->id;
 				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_OBLIVIONCURSE:
-				val4 = tick / 3000;
-				tick_time = 3000; // [GodLesZ] tick time
-				break;
-			case SC_ROLLINGCUTTER:
-				val_flag |= 1;
-				break;
-			case SC_CLOAKINGEXCEED:
-				val2 = (val1 + 1) / 2;   // Hits
-				val3 = 90 + val1 * 10; // Walk speed
 				val_flag |= 1|2|4;
-				if(bl->type == BL_PC)
-					val4 |= battle_config.pc_cloak_check_type&7;
-				else
-					val4 |= battle_config.monster_cloak_check_type&7;
 				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_HALLUCINATIONWALK:
-				val2 = 50 * val1; // Evasion rate of physical attacks. Flee
-				val3 = 10 * val1; // Evasion rate of magical attacks.
-				val_flag |= 1|2|4;
-				break;
-			case SC_WHITEIMPRISON:
-				status_change_end(bl, SC_BURNING, INVALID_TIMER);
-				status_change_end(bl, SC_FREEZING, INVALID_TIMER);
-				status_change_end(bl, SC_FREEZE, INVALID_TIMER);
-				status_change_end(bl, SC_STONE, INVALID_TIMER);
-				break;
-			case SC_FREEZING:
-				status_change_end(bl, SC_BURNING, INVALID_TIMER);
-				break;
-			case SC_READING_SB:
-				// val2 = sp reduction per second
-				tick_time = 5000; // [GodLesZ] tick time
-				break;
-			case SC_SPHERE_1:
-			case SC_SPHERE_2:
-			case SC_SPHERE_3:
-			case SC_SPHERE_4:
-			case SC_SPHERE_5:
-				if(!sd)
-					return 0;   // Should only work on players.
-				val4 = tick / 1000;
-				if(val4 < 1)
-					val4 = 1;
-				tick_time = 1000; // [GodLesZ] tick time
-				val_flag |= 1;
-				break;
-			case SC_SHAPESHIFT:
-				switch(val1) {
-					case 1: val2 = ELE_FIRE; break;
-					case 2: val2 = ELE_EARTH; break;
-					case 3: val2 = ELE_WIND; break;
-					case 4: val2 = ELE_WATER; break;
-				}
-				break;
-			case SC_ELECTRICSHOCKER:
-			case SC_CRYSTALIZE:
-			case SC_MEIKYOUSISUI:
-				val4 = tick / 1000;
-				if(val4 < 1)
-					val4 = 1;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_CAMOUFLAGE:
-				val4 = tick/1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_WUGDASH:
-				val4 = gettick(); //Store time at which you started running.
-				tick = -1;
-				break;
-			case SC__SHADOWFORM: {
-					struct map_session_data *s_sd = map_id2sd(val2);
-					if(s_sd)
-						s_sd->shadowform_id = bl->id;
-					val4 = tick / 1000;
-					val_flag |= 1|2|4;
-					tick_time = 1000; // [GodLesZ] tick time
-				}
-				break;
-			case SC__STRIPACCESSORY:
-				if(!sd)
-					val2 = 20;
-				break;
-			case SC__INVISIBILITY:
-				val2 = 50 - 10 * val1; // ASPD
-				val3 = 20 * val1; // CRITICAL
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				val_flag |= 1|2;
-				break;
-			case SC__ENERVATION:
-				val2 = 20 + 10 * val1; // ATK Reduction
-				val_flag |= 1|2;
-				if(sd) pc_delspiritball(sd,sd->spiritball,0);
-				break;
-			case SC__GROOMY:
-				val2 = 20 + 10 * val1; //ASPD. Need to confirm if Movement Speed reduction is the same. [Jobbie]
-				val3 = 20 * val1; //HIT
-				val_flag |= 1|2|4;
-				if(sd) {
-					// Removes Animals
-					if(pc_isriding(sd)) pc_setriding(sd, 0);
-					if(pc_isridingdragon(sd)) pc_setoption(sd, sd->sc.option&~OPTION_DRAGON);
-					if(pc_iswug(sd)) pc_setoption(sd, sd->sc.option&~OPTION_WUG);
-					if(pc_isridingwug(sd)) pc_setoption(sd, sd->sc.option&~OPTION_WUGRIDER);
-					if(pc_isfalcon(sd)) pc_setoption(sd, sd->sc.option&~OPTION_FALCON);
-					if(sd->status.pet_id > 0) pet_menu(sd, 3);
-					if(merc_is_hom_active(sd->hd)) merc_hom_vaporize(sd,1);
-					if(sd->md) merc_delete(sd->md,3);
-				}
-				break;
-			case SC__LAZINESS:
-				val2 = 10 + 10 * val1; // Cast reduction
-				val3 = 10 * val1; // Flee Reduction
-				val_flag |= 1|2|4;
-				break;
-			case SC__UNLUCKY:
-				val2 = 10 * val1; // Crit and Flee2 Reduction
-				val_flag |= 1|2|4;
-				break;
-			case SC__WEAKNESS:
-				val2 = 10 * val1;
-				val_flag |= 1|2;
-				// bypasses coating protection and MADO
-				sc_start(src,bl,SC_STRIPWEAPON,100,val1,tick);
-				sc_start(src,bl,SC_STRIPSHIELD,100,val1,tick);
-				break;
-				break;
-			case SC_GN_CARTBOOST:
-				if(val1 < 3)
-					val2 = 50;
-				else if(val1 < 5)
-					val2 = 75;
-				else
-					val2 = 100;
-				break;
-			case SC_PROPERTYWALK:
-				val_flag |= 1|2;
-				val3 = 0;
-				break;
-			case SC_WARMER:
-				status_change_end(bl, SC_FREEZE, INVALID_TIMER);
-				status_change_end(bl, SC_FREEZING, INVALID_TIMER);
-				status_change_end(bl, SC_CRYSTALIZE, INVALID_TIMER);
-				break;
-			case SC_STRIKING:
-				val1 = 6 - val1;//spcost = 6 - level (lvl1:5 ... lvl 5: 1)
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_BLOODSUCKER:
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_VACUUM_EXTREME:
-				tick -= (status->str / 20) * 1000;
-				val4 = val3 = tick / 100;
-				tick_time = 100; // [GodLesZ] tick time
-				break;
-			case SC_SWINGDANCE:
-				val2 = 4 * val1; // Walk speed and aspd reduction.
-				break;
-			case SC_SYMPHONYOFLOVER:
-			case SC_RUSHWINDMILL:
-			case SC_ECHOSONG:
-				val2 = 6 * val1;
-				val2 += val3; //Adding 1% * Lesson Bonus
-				val2 += (int)(val4*2/10); //Adding 0.2% per JobLevel
-				break;
-			case SC_MOONLITSERENADE:
-				val2 = 10 * val1;
-				break;
-			case SC_HARMONIZE:
-				val2 = 5 + 5 * val1;
-				break;
-			case SC_VOICEOFSIREN:
-				val4 = tick / 2000;
-				tick_time = 2000; // [GodLesZ] tick time
-				break;
-			case SC_DEEPSLEEP:
-				val4 = tick / 2000;
-				tick_time = 2000; // [GodLesZ] tick time
-				break;
-			case SC_SIRCLEOFNATURE:
-				val2 = 1 + val1; //SP consume
-				val3 = 40 * val1;   //HP recovery
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_SONGOFMANA:
-				val3 = 10 + (2 * val2);
-				val4 = tick/3000;
-				tick_time = 3000; // [GodLesZ] tick time
-				break;
-			case SC_SATURDAYNIGHTFEVER:
-				if(!val4) val4 = skill_get_time2(status_sc2skill(type),val1);
-				if(!val4) val4 = 3000;
-				val3 = tick/val4;
-				tick_time = val4; // [GodLesZ] tick time
-				break;
-			case SC_GLOOMYDAY:
-				val2 = 20 + 5 * val1; // Flee reduction.
-				val3 = 15 + 5 * val1; // ASPD reduction.
-				if(sd && rand()%100 < val1) {  // (Skill Lv) %
-					val4 = 1; // reduce walk speed by half.
-					if(pc_isriding(sd)) pc_setriding(sd, 0);
-					if(pc_isridingdragon(sd)) pc_setoption(sd, sd->sc.option&~OPTION_DRAGON);
-				}
-				break;
-			case SC_GLOOMYDAY_SK:
-				// Random number between [15 ~ (Voice Lesson Skill Level x 5) + (Skill Level x 10)] %.
-				val2 = 15 + rand()%((sd?pc_checkskill(sd, WM_LESSON)*5:0) + val1*10);
-				break;
-			case SC_SITDOWN_FORCE:
-			case SC_BANANA_BOMB_SITDOWN:
-				if(sd && !pc_issit(sd)) {
-					pc_setsit(sd);
-					skill_sit(sd,1);
-					clif_sitting(bl);
-				}
-				break;
-			case SC_DANCEWITHWUG:
-				val3 = (5 * val1) + (1 * val2); //Still need official value.
-				break;
-			case SC_LERADSDEW:
-				val3 = (5 * val1) + (1 * val2);
-				break;
-			case SC_MELODYOFSINK:
-				val3 = (5 * val1) + (1 * val2);
-				break;
-			case SC_BEYONDOFWARCRY:
-				val3 = (5 * val1) + (1 * val2);
-				break;
-			case SC_UNLIMITEDHUMMINGVOICE: {
-					struct unit_data *ud = unit_bl2ud(bl);
-					if(ud == NULL) return 0;
-					ud->state.skillcastcancel = 0;
-					val3 = 15 - (2 * val2);
-				}
-				break;
-			case SC_REFLECTDAMAGE:
-				val2 = 15 + 5 * val1;
-				val3 = (val1==5)?20:(val1+4)*2; // SP consumption
-				val4 = tick/10000;
-				tick_time = 10000; // [GodLesZ] tick time
-				break;
-			case SC_FORCEOFVANGUARD: // This is not the official way to handle it but I think we should use it. [pakpil]
-				val2 = 20 + 12 * (val1 - 1); // Chance
-				val3 = 5 + (2 * val1); // Max rage counters
-				tick = -1; //endless duration in the client
-				tick_time = 6000; // [GodLesZ] tick time
-				val_flag |= 1|2|4;
-				break;
-			case SC_EXEEDBREAK:
-				val1 *= 150; // 150 * skill_lv
-				if(sd && sd->inventory_data[sd->equip_index[EQI_HAND_R]]) {    // Chars.
-					val1 += (sd->inventory_data[sd->equip_index[EQI_HAND_R]]->weight/10 * sd->inventory_data[sd->equip_index[EQI_HAND_R]]->wlv * status_get_lv(bl) / 100);
-					val1 += 15 * (sd ? sd->status.job_level:50) + 100;
-				} else  // Mobs
-					val1 += (400 * status_get_lv(bl) / 100) + (15 * (status_get_lv(bl) / 2));   // About 1138% at mob_lvl 99. Is an aproximation to a standard weapon. [pakpil]
-				break;
-			case SC_PRESTIGE:   // Bassed on suggested formula in iRO Wiki and some test, still need more test. [pakpil]
-				val2 = ((status->int_ + status->luk) / 6) + 5;  // Chance to evade magic damage.
-				val1 *= 15; // Defence added
-				if(sd)
-					val1 += 10 * pc_checkskill(sd,CR_DEFENDER);
-				val_flag |= 1|2;
-				break;
-			case SC_BANDING:
-				tick_time = 5000; // [GodLesZ] tick time
-				val_flag |= 1;
-				break;
-			case SC_SHIELDSPELL_DEF:
-			case SC_SHIELDSPELL_MDEF:
-			case SC_SHIELDSPELL_REF:
-				val_flag |= 1|2;
-				break;
-			case SC_MAGNETICFIELD:
-				val3 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				break;
-			case SC_INSPIRATION:
-				if(sd) {
-					val2 = (40 * val1) + (3 * sd->status.job_level); // ATK bonus
-					val3 = (sd->status.job_level / 10) * 2 + 12; // All stat bonus
-				}
-				val4 = tick / 1000;
-				tick_time = 1000; // [GodLesZ] tick time
-				status_change_clear_buffs(bl,3); //Remove buffs/debuffs
-				break;
-			case SC_SPELLFIST:
-			case SC_CURSEDCIRCLE_ATKER:
-				val_flag |= 1|2|4;
-				break;
-			case SC_CRESCENTELBOW:
-				val2 = 94 + val1;
-				val_flag |= 1|2;
-				break;
-			case SC_LIGHTNINGWALK: //  [(Job Level / 2) + (40 + 5 * Skill Level)] %
-				val1 = (sd?sd->status.job_level:2)/2 + 40 + 5 * val1;
-				val_flag |= 1;
-				break;
-			case SC_RAISINGDRAGON:
-				val3 = tick / 5000;
-				tick_time = 5000; // [GodLesZ] tick time
-				break;
-			case SC_GT_CHANGE: {
-					// take note there is no def increase as skill desc says. [malufett]
-					struct block_list *src;
-					val3 = status->agi * val1 / 60; // ASPD increase: [(Target's AGI x Skill Level) / 60] %
-					if((src = map_id2bl(val2)))
-						val4 = (200/status_get_int(src)) * val1;  // MDEF decrease: MDEF [(200 / Caster's INT) x Skill Level]
-				}
-				break;
-			case SC_GT_REVITALIZE: {
-					// take note there is no vit,aspd,speed increase as skill desc says. [malufett]
-					struct block_list *src;
-					val3 = val1 * 30 + 150; // Natural HP recovery increase: [(Skill Level x 30) + 50] %
-					if((src = map_id2bl(val2)))   // the stat def is not shown in the status window and it is process differently
-						val4 = (status_get_vit(src)/4) * val1;   // STAT DEF increase: [(Caster's VIT / 4) x Skill Level]
-				}
-				break;
-			case SC_PYROTECHNIC_OPTION:
-				val_flag |= 1|2|4;
-				break;
-			case SC_HEATER_OPTION:
-				val2 = 120; // Watk. TODO: Renewal (Atk2)
-				val3 = 33;  // % Increase effects.
-				val4 = 3;   // Change into fire element.
-				val_flag |= 1|2|4;
-				break;
-			case SC_TROPIC_OPTION:
-				val2 = 180; // Watk. TODO: Renewal (Atk2)
-				val3 = MG_FIREBOLT;
-				break;
-			case SC_AQUAPLAY_OPTION:
-				val2 = 40;
-				val_flag |= 1|2|4;
-				break;
-			case SC_COOLER_OPTION:
-				val2 = 80;  // % Freezing chance
-				val3 = 33;  // % increased damage
-				val4 = 1;   // Change into water elemet
-				val_flag |= 1|2|4;
-				break;
-			case SC_CHILLY_AIR_OPTION:
-				val2 = 120; // Matk. TODO: Renewal (Matk1)
-				val3 = MG_COLDBOLT;
-				val_flag |= 1|2;
-				break;
-			case SC_GUST_OPTION:
-				val_flag |= 1|2;
-				break;
-			case SC_WIND_STEP_OPTION:
-				val2 = 50;  // % Increase speed and flee.
-				break;
-			case SC_BLAST_OPTION:
+			}
+			break;
+		case SC__STRIPACCESSORY:
+			if (!sd)
 				val2 = 20;
-				val3 = ELE_WIND;
-				val_flag |= 1|2|4;
-				break;
-			case SC_WILD_STORM_OPTION:
-				val2 = MG_LIGHTNINGBOLT;
-				val_flag |= 1|2;
-				break;
-			case SC_PETROLOGY_OPTION:
-				val2 = 5;
-				val3 = 50;
-				val_flag |= 1|2|4;
-				break;
-			case SC_CURSED_SOIL_OPTION:
-				val2 = 10;
-				val3 = 33;
-				val4 = 2;
-				val_flag |= 1|2|4;
-				break;
-			case SC_UPHEAVAL_OPTION:
-				val2 = WZ_EARTHSPIKE;
-				val_flag |= 1|2;
-				break;
-			case SC_CIRCLE_OF_FIRE_OPTION:
-				val2 = 300;
-				val_flag |= 1|2;
-				break;
-			case SC_FIRE_CLOAK_OPTION:
-			case SC_WATER_DROP_OPTION:
-			case SC_WIND_CURTAIN_OPTION:
-			case SC_STONE_SHIELD_OPTION:
-				val2 = 20;  // Elemental modifier. Not confirmed.
-				break;
-			case SC_CIRCLE_OF_FIRE:
-			case SC_FIRE_CLOAK:
-			case SC_WATER_DROP:
-			case SC_WATER_SCREEN:
-			case SC_WIND_CURTAIN:
-			case SC_WIND_STEP:
-			case SC_STONE_SHIELD:
-			case SC_SOLID_SKIN:
-				val2 = 10;
-				tick_time = 2000; // [GodLesZ] tick time
-				break;
-			case SC_WATER_BARRIER:
-				val2 = 40;  // Increasement. Mdef1 ???
-				val3 = 20;  // Reductions. Atk2, Flee1, Matk1 ????
-				val_flag |= 1|2|4;
-				break;
-			case SC_ZEPHYR:
-				val2 = 22;  // Flee.
-				break;
-			case SC_TIDAL_WEAPON:
-				val2 = 20; // Increase Elemental's attack.
-				break;
-			case SC_ROCK_CRUSHER:
-			case SC_ROCK_CRUSHER_ATK:
-			case SC_POWER_OF_GAIA:
-				val2 = 33;
-				break;
-			case SC_MELON_BOMB:
-			case SC_BANANA_BOMB:
-				val1 = 15;
-				break;
-			case SC_STOMACHACHE:
-				val2 = 8;   // SP consume.
-				val4 = tick / 10000;
-				tick_time = 10000; // [GodLesZ] tick time
-				break;
-			case SC_KYOUGAKU:
-				val2 = 2*val1 + rand()%val1;
-				clif_status_change(bl,SI_ACTIVE_MONSTER_TRANSFORM,1,0,1002,0,0);
-				break;
-			case SC_IZAYOI:
-				val2 = 25 * val1;// Aumenta Matk.
-				break;
-			case SC_KAGEMUSYA:
-				val3 = val1 * 2;
-			case SC_ZANGETSU:
-				if((status_get_hp(bl)+status_get_sp(bl)) % 2 == 0)
-					val2 = status_get_lv(bl) / 3 + 20;
+			break;
+		case SC__INVISIBILITY:
+			val2 = 50 - 10 * val1; // ASPD
+			val3 = 20 * val1; // CRITICAL
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			val_flag |= 1|2;
+			break;
+		case SC__ENERVATION:
+			val2 = 20 + 10 * val1; // ATK Reduction
+			val_flag |= 1|2;
+			if( sd ) pc_delspiritball(sd,sd->spiritball,0);
+			break;
+		case SC__GROOMY:
+			val2 = 20 + 10 * val1; //ASPD. Need to confirm if Movement Speed reduction is the same. [Jobbie]
+			val3 = 20 * val1; //HIT
+			val_flag |= 1|2|4;
+			if( sd )
+			{ // Removes Animals
+				if( pc_isriding(sd) ) pc_setriding(sd, 0);
+				if( pc_isridingdragon(sd) ) pc_setoption(sd, sd->sc.option&~OPTION_DRAGON);
+				if( pc_iswug(sd) ) pc_setoption(sd, sd->sc.option&~OPTION_WUG);
+				if( pc_isridingwug(sd) ) pc_setoption(sd, sd->sc.option&~OPTION_WUGRIDER);
+				if( pc_isfalcon(sd) ) pc_setoption(sd, sd->sc.option&~OPTION_FALCON);
+				if( sd->status.pet_id > 0 ) pet_menu(sd, 3);
+				if( merc_is_hom_active(sd->hd) ) merc_hom_vaporize(sd,HOM_ST_REST);
+				if( sd->md ) merc_delete(sd->md,3);
+			}
+			break;
+		case SC__LAZINESS:
+			val2 = 10 + 10 * val1; // Cast reduction
+			val3 = 10 * val1; // Flee Reduction
+			val_flag |= 1|2|4;
+			break;
+		case SC__UNLUCKY:
+			val2 = 10 * val1; // Crit and Flee2 Reduction
+			val_flag |= 1|2|4;
+			break;
+		case SC__WEAKNESS:
+			val2 = 10 * val1;
+			val_flag |= 1|2;
+			// bypasses coating protection and MADO
+			sc_start(src,bl,SC_STRIPWEAPON,100,val1,tick);
+			sc_start(src,bl,SC_STRIPSHIELD,100,val1,tick);
+			break;
+			break;
+		case SC_GN_CARTBOOST:
+			if( val1 < 3 )
+				val2 = 50;
+			else if( val1 < 5 )
+				val2 = 75;
+			else
+				val2 = 100;
+			break;
+		case SC_PROPERTYWALK:
+			val_flag |= 1|2;
+			val3 = 0;
+			break;
+		case SC_WARMER:
+			status_change_end(bl, SC_FREEZE, INVALID_TIMER);
+			status_change_end(bl, SC_FREEZING, INVALID_TIMER);
+			status_change_end(bl, SC_CRYSTALIZE, INVALID_TIMER);
+			break;
+		case SC_STRIKING:
+			val1 = 6 - val1;//spcost = 6 - level (lvl1:5 ... lvl 5: 1)
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_BLOODSUCKER:
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_VACUUM_EXTREME:
+			tick -= (status->str / 20) * 1000;
+			val4 = val3 = tick / 100;
+			tick_time = 100; // [GodLesZ] tick time
+			break;
+		case SC_SWINGDANCE:
+			val2 = 4 * val1; // Walk speed and aspd reduction.
+			break;
+		case SC_SYMPHONYOFLOVER:
+		case SC_RUSHWINDMILL:
+		case SC_ECHOSONG:
+			val2 = 6 * val1;
+			val2 += val3; //Adding 1% * Lesson Bonus
+			val2 += (int)(val4*2/10); //Adding 0.2% per JobLevel
+			break;
+		case SC_MOONLITSERENADE:
+			val2 = 10 * val1;
+			break;
+		case SC_HARMONIZE:
+			val2 = 5 + 5 * val1;
+			break;
+		case SC_VOICEOFSIREN:
+			val4 = tick / 2000;
+			tick_time = 2000; // [GodLesZ] tick time
+			break;
+		case SC_DEEPSLEEP:
+			val4 = tick / 2000;
+			tick_time = 2000; // [GodLesZ] tick time
+			break;
+		case SC_SIRCLEOFNATURE:
+			val2 = 1 + val1; //SP consume
+			val3 = 40 * val1;	//HP recovery
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_SONGOFMANA:
+			val3 = 10 + (2 * val2);
+			val4 = tick/3000;
+			tick_time = 3000; // [GodLesZ] tick time
+			break;
+		case SC_SATURDAYNIGHTFEVER:
+			if (!val4) val4 = skill_get_time2(status_sc2skill(type),val1);
+			if (!val4) val4 = 3000;
+			val3 = tick/val4;
+			tick_time = val4; // [GodLesZ] tick time
+			break;
+		case SC_GLOOMYDAY:
+			val2 = 20 + 5 * val1; // Flee reduction.
+			val3 = 15 + 5 * val1; // ASPD reduction.
+			if( sd && rand()%100 < val1 ){ // (Skill Lv) %
+				val4 = 1; // reduce walk speed by half.
+				if( pc_isriding(sd) ) pc_setriding(sd, 0);
+				if( pc_isridingdragon(sd) ) pc_setoption(sd, sd->sc.option&~OPTION_DRAGON);
+			}
+			break;
+		case SC_GLOOMYDAY_SK:
+			// Random number between [15 ~ (Voice Lesson Skill Level x 5) + (Skill Level x 10)] %.
+			val2 = 15 + rand()%( (sd?pc_checkskill(sd, WM_LESSON)*5:0) + val1*10 );
+			break;
+		case SC_SITDOWN_FORCE:
+		case SC_BANANA_BOMB_SITDOWN:
+			if( sd && !pc_issit(sd) )
+			{
+				pc_setsit(sd);
+				skill_sit(sd,1);
+				clif_sitting(bl,true);
+			}
+			break;
+		case SC_DANCEWITHWUG:
+			val3 = (5 * val1) + (1 * val2); //Still need official value.
+			break;
+		case SC_LERADSDEW:
+			val3 = (5 * val1) + (1 * val2);
+			break;
+		case SC_MELODYOFSINK:
+			val3 = (5 * val1) + (1 * val2);
+			break;
+		case SC_BEYONDOFWARCRY:
+			val3 = (5 * val1) + (1 * val2);
+			break;
+		case SC_UNLIMITEDHUMMINGVOICE:
+			{
+				struct unit_data *ud = unit_bl2ud(bl);
+				if( ud == NULL ) return 0;
+				ud->state.skillcastcancel = 0;
+				val3 = 15 - (2 * val2);
+			}
+			break;
+		case SC_REFLECTDAMAGE:
+			val2 = 15 + 5 * val1;
+			val3 = (val1==5)?20:(val1+4)*2; // SP consumption
+			val4 = tick/10000;
+			tick_time = 10000; // [GodLesZ] tick time
+			break;
+		case SC_FORCEOFVANGUARD: // This is not the official way to handle it but I think we should use it. [pakpil]
+			val2 = 20 + 12 * (val1 - 1); // Chance
+			val3 = 5 + (2 * val1); // Max rage counters
+			tick = -1; //endless duration in the client
+			tick_time = 6000; // [GodLesZ] tick time
+			val_flag |= 1|2|4;
+			break;
+		case SC_EXEEDBREAK:
+			val1 *= 150; // 150 * skill_lv
+			if( sd && sd->inventory_data[sd->equip_index[EQI_HAND_R]] ) {  // Chars.
+				val1 += (sd->inventory_data[sd->equip_index[EQI_HAND_R]]->weight/10 * sd->inventory_data[sd->equip_index[EQI_HAND_R]]->wlv * status_get_lv(bl) / 100);
+			val1 += 15 * (sd ? sd->status.job_level:50) + 100;
+			}
+			else	// Mobs
+				val1 += (400 * status_get_lv(bl) / 100) + (15 * (status_get_lv(bl) / 2));	// About 1138% at mob_lvl 99. Is an aproximation to a standard weapon. [pakpil]
+			break;
+		case SC_PRESTIGE:	// Bassed on suggested formula in iRO Wiki and some test, still need more test. [pakpil]
+			val2 = ((status->int_ + status->luk) / 6) + 5;	// Chance to evade magic damage.
+			val1 *= 15; // Defence added
+			if( sd )
+				val1 += 10 * pc_checkskill(sd,CR_DEFENDER);
+			val_flag |= 1|2;
+			break;
+		case SC_BANDING:
+			tick_time = 5000; // [GodLesZ] tick time
+			val_flag |= 1;
+			break;
+		case SC_SHIELDSPELL_DEF:
+		case SC_SHIELDSPELL_MDEF:
+		case SC_SHIELDSPELL_REF:
+			val_flag |= 1|2;
+			break;
+		case SC_MAGNETICFIELD:
+			val3 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			break;
+		case SC_INSPIRATION:
+			if( sd )
+			{
+				val2 = (40 * val1) + (3 * sd->status.job_level); // ATK bonus
+				val3 = (sd->status.job_level / 10) * 2 + 12; // All stat bonus
+			}
+			val4 = tick / 1000;
+			tick_time = 1000; // [GodLesZ] tick time
+			status_change_clear_buffs(bl,3); //Remove buffs/debuffs
+			break;
+		case SC_SPELLFIST:
+		case SC_CURSEDCIRCLE_ATKER:
+			val_flag |= 1|2|4;
+			break;
+		case SC_CRESCENTELBOW:
+			val2 = 94 + val1;
+			val_flag |= 1|2;
+			break;
+		case SC_LIGHTNINGWALK: //  [(Job Level / 2) + (40 + 5 * Skill Level)] %
+			val1 = (sd?sd->status.job_level:2)/2 + 40 + 5 * val1;
+			val_flag |= 1;
+			break;
+		case SC_RAISINGDRAGON:
+			val3 = tick / 5000;
+			tick_time = 5000; // [GodLesZ] tick time
+			break;
+		case SC_GT_CHANGE:
+			{// take note there is no def increase as skill desc says. [malufett]
+				struct block_list * src;
+				val3 = status->agi * val1 / 60; // ASPD increase: [(Target AGI x Skill Level) / 60] %
+				if( (src = map_id2bl(val2)) )
+					val4 = ( 200/status_get_int(src) ) * val1;// MDEF decrease: MDEF [(200 / Caster INT) x Skill Level]
+			}
+			break;
+		case SC_GT_REVITALIZE:
+			{// take note there is no vit,aspd,speed increase as skill desc says. [malufett]
+				struct block_list * src;
+				val3 = val1 * 30 + 150; // Natural HP recovery increase: [(Skill Level x 30) + 50] %
+				if( (src = map_id2bl(val2)) ) // the stat def is not shown in the status window and it is process differently
+					val4 = ( status_get_vit(src)/4 ) * val1; // STAT DEF increase: [(Caster VIT / 4) x Skill Level]
+			}
+			break;
+		case SC_PYROTECHNIC_OPTION:
+			val_flag |= 1|2|4;
+			break;
+		case SC_HEATER_OPTION:
+			val2 = 120; // Watk. TODO: Renewal (Atk2)
+			val3 = 33;	// % Increase effects.
+			val4 = 3;	// Change into fire element.
+			val_flag |= 1|2|4;
+			break;
+		case SC_TROPIC_OPTION:
+			val2 = 180; // Watk. TODO: Renewal (Atk2)
+			val3 = MG_FIREBOLT;
+			break;
+		case SC_AQUAPLAY_OPTION:
+			val2 = 40;
+			val_flag |= 1|2|4;
+			break;
+		case SC_COOLER_OPTION:
+			val2 = 80;	// % Freezing chance
+			val3 = 33;	// % increased damage
+			val4 = 1;	// Change into water elemet
+			val_flag |= 1|2|4;
+			break;
+		case SC_CHILLY_AIR_OPTION:
+			val2 = 120; // Matk. TODO: Renewal (Matk1)
+			val3 = MG_COLDBOLT;
+			val_flag |= 1|2;
+			break;
+		case SC_GUST_OPTION:
+			val_flag |= 1|2;
+			break;
+		case SC_WIND_STEP_OPTION:
+			val2 = 50;	// % Increase speed and flee.
+			break;
+		case SC_BLAST_OPTION:
+			val2 = 20;
+			val3 = ELE_WIND;
+			val_flag |= 1|2|4;
+			break;
+		case SC_WILD_STORM_OPTION:
+			val2 = MG_LIGHTNINGBOLT;
+			val_flag |= 1|2;
+			break;
+		case SC_PETROLOGY_OPTION:
+			val2 = 5;
+			val3 = 50;
+			val_flag |= 1|2|4;
+			break;
+		case SC_CURSED_SOIL_OPTION:
+			val2 = 10;
+			val3 = 33;
+			val4 = 2;
+			val_flag |= 1|2|4;
+			break;
+		case SC_UPHEAVAL_OPTION:
+			val2 = WZ_EARTHSPIKE;
+			val_flag |= 1|2;
+			break;
+		case SC_CIRCLE_OF_FIRE_OPTION:
+			val2 = 300;
+			val_flag |= 1|2;
+			break;
+		case SC_FIRE_CLOAK_OPTION:
+		case SC_WATER_DROP_OPTION:
+		case SC_WIND_CURTAIN_OPTION:
+		case SC_STONE_SHIELD_OPTION:
+			val2 = 20;	// Elemental modifier. Not confirmed.
+			break;
+		case SC_CIRCLE_OF_FIRE:
+		case SC_FIRE_CLOAK:
+		case SC_WATER_DROP:
+		case SC_WATER_SCREEN:
+		case SC_WIND_CURTAIN:
+		case SC_WIND_STEP:
+		case SC_STONE_SHIELD:
+		case SC_SOLID_SKIN:
+			val2 = 10;
+			tick_time = 2000; // [GodLesZ] tick time
+			break;
+		case SC_WATER_BARRIER:
+			val2 = 40;	// Increasement. Mdef1 ???
+			val3 = 20;	// Reductions. Atk2, Flee1, Matk1 ????
+			val_flag |= 1|2|4;
+			break;
+		case SC_ZEPHYR:
+			val2 = 22;	// Flee.
+			break;
+		case SC_TIDAL_WEAPON:
+			val2 = 20; // Increase Elemental's attack.
+			break;
+		case SC_ROCK_CRUSHER:
+		case SC_ROCK_CRUSHER_ATK:
+		case SC_POWER_OF_GAIA:
+			val2 = 33;
+			break;
+		case SC_MELON_BOMB:
+		case SC_BANANA_BOMB:
+			val1 = 15;
+			break;
+		case SC_STOMACHACHE:
+			val2 = 8;	// SP consume.
+			val4 = tick / 10000;
+			tick_time = 10000; // [GodLesZ] tick time
+			break;
+		case SC_KYOUGAKU:
+			val2 = 2*val1 + rand()%val1;
+			clif_status_change(bl,SI_ACTIVE_MONSTER_TRANSFORM,1,0,1002,0,0);
+			break;
+		case SC_KAGEMUSYA:
+			val3 = val1 * 2;
+		case SC_IZAYOI:
+			val2 = tick/1000;
+			tick_time = 1000;
+			break;
+		case SC_ZANGETSU:
+			if( (status_get_hp(bl)+status_get_sp(bl)) % 2 == 0)
+				val2 = status_get_lv(bl) / 2 + 50;
+			else
+				val2 -= 50;
+			break;
+		case SC_GENSOU:
+			{
+				int hp = status_get_hp(bl), lv = 5;
+				short per = 100 / (status_get_max_hp(bl) / hp);
+
+				if( per <= 15 )
+					lv = 1;
+				else if( per <= 30 )
+					lv = 2;
+				else if( per <= 50 )
+					lv = 3;
+				else if( per <= 75 )
+					lv = 4;
+				if( hp % 2 == 0)
+					status_heal(bl, hp * (6-lv) * 4 / 100, status_get_sp(bl) * (6-lv) * 3 / 100, 1);
 				else
-					val2 -= 30;
-				break;
-			case SC_GENSOU: {
-					int hp = status_get_hp(bl), lv = 5;
-					short per = 100 / (status_get_max_hp(bl) / hp);
-
-					if(per <= 15)
-						lv = 1;
-					else if(per <= 30)
-						lv = 2;
-					else if(per <= 50)
-						lv = 3;
-					else if(per <= 75)
-						lv = 4;
-					if(hp % 2 == 0)
-						status_heal(bl, hp * (6-lv) * 4 / 100, status_get_sp(bl) * (6-lv) * 3 / 100, 1);
-					else
-						status_zap(bl, hp * (lv*4) / 100, status_get_sp(bl) * (lv*3) / 100);
-				}
-				break;
+					status_zap(bl, hp * (lv*4) / 100, status_get_sp(bl) * (lv*3) / 100);
+			}
+			break;
 			case SC_ANGRIFFS_MODUS:
-				val2 = 50 + 20 * val1; //atk bonus
-				val3 = 40 + 20 * val1; // Flee reduction.
-				val4 = tick/1000; // hp/sp reduction timer
-				tick_time = 1000;
-				break;
+			    val2 = 50 + 20 * val1; //atk bonus
+			    val3 = 40 + 20 * val1; // Flee reduction.
+			    val4 = tick/1000; // hp/sp reduction timer
+			    tick_time = 1000;
+			    break;
 			case SC_GOLDENE_FERSE:
-				val2 = 10 + 10*val1; //flee bonus
-				val3 = 6 + 4 * val1; // Aspd Bonus
-				val4 = 2 + 2 * val1; // Chance of holy attack
-				break;
+			    val2 = 10 + 10*val1; //flee bonus
+			    val3 = 6 + 4 * val1; // Aspd Bonus
+			    val4 = 2 + 2 * val1; // Chance of holy attack
+			    break;
 			case SC_OVERED_BOOST:
-				val2 = 300 + 40*val1; //flee bonus
-				val3 = 179 + 2*val1; //aspd bonus
-				val4 = 50; //def reduc %
-				break;
+			    val2 = 300 + 40*val1; //flee bonus
+			    val3 = 179 + 2*val1; //aspd bonus
+			    val4 = 50; //def reduc %
+			    break;
 			case SC_GRANITIC_ARMOR:
-				val2 = 2*val1; //dmg reduction
-				val3 = (6*status_get_max_hp(src))/100; //dmg hp on status end
-			   	 val4 = 5 * val1; //unknow formula
-				break;
+			    val2 = 2*val1; //dmg hp reduction
+			    val3 = (6*status_get_max_hp(src))/100; //dmg hp on status end
+			    val4 = 5 * val1; //unknow formula
+			    break;
 			case SC_MAGMA_FLOW:
-				val2 = 3*val1; //activation chance
-				break;
+			    val2 = 3*val1; //activation chance
+			    break;
 			case SC_PYROCLASTIC:
-			   	 val2 += 10*val1*status_get_lv(src); //atk bonus
-			   	 val3 = 2*val1;//Chance To AutoCast Hammer Fall %
-			  	 break;
+			    val2 += 10*val1*status_get_lv(src); //atk bonus
+			    val3 = 2*val1;//Chance To AutoCast Hammer Fall %
+			    break;
 			case SC_PARALYSIS: //[Lighta] need real info
-				val2 = 2*val1; //def reduction
-				val3 = 500*val1; //varcast augmentation
-				break;
+			    val2 = 2*val1; //def reduction
+			    val3 = 500*val1; //varcast augmentation
+			    break;
 			case SC_LIGHT_OF_REGENE: //Yommy leak need confirm
-			    	val2 = 20 * val1; //hp reco on death %
-			   	break;
-			case SC_PAIN_KILLER: // Yommy leak need confirm
-				val2 = 10 * val1; //aspd reduction %
-			    	val3 = (( 200 * val1 ) * status_get_lv(src)) / 150; //dmg reduction linear
-				if(sc->data[SC_PARALYSIS])
-					sc_start(src,bl, SC_ENDURE, 100, val1, tick); //start endure for same duration
-				break;
-			case SC_STYLE_CHANGE: //[Lighta] need real info
-				tick = -1;
-				break;
+			    val2 = 20 * val1; //hp reco on death %
+			    break;
+			case SC_PAIN_KILLER: //Yommy leak need confirm
+			    val2 = 10 * val1; //aspd reduction %
+			    val3 = (( 200 * val1 ) * status_get_lv(src)) / 150; //dmg reduction linear
+			    if(sc->data[SC_PARALYSIS])
+				sc_start(src,bl, SC_ENDURE, 100, val1, tick); //start endure for same duration
+			    break;
+                        case SC_STYLE_CHANGE: //[Lighta] need real info
+                            tick = -1;
+                            break;
 			case SC_CBC:
-			    	val3 = 10; //drain sp % dmg
-			    	val4 = tick/1000; //dmg each sec
-			    	tick = 1000;
-			    	break;
+			    val3 = 10; //drain sp % dmg
+			    val4 = tick/1000; //dmg each sec
+			    tick = 1000;
+			    break;
 			case SC_EQC:
-			    	val2 = 5 * val1; //def % reduc
-			    	val3 = 5 * val1; //atk % reduc
-			    	val4 = 2 * val1; //maxhp % reduc
-			    	break;
+			    val2 = 5 * val1; //def % reduc
+			    val3 = 5 * val1; //atk % reduc
+			    val4 = 2 * val1; //maxhp % reduc
+			    break;
 			case SC_ASH:
-			    	val2 = 50; //hit % reduc
-			    	val3 = 0;//def % reduc
-			    	val4 = 0;//atk flee & reduc
-			    	if(status_get_race(bl) == RC_PLANT) //plant type
-					val3 = 50;
-			    	if(status_get_element(bl) == ELE_WATER) // defense water type
-					val4 = 50;				
-				break;
-			default:
-				if(calc_flag == SCB_NONE && StatusSkillChangeTable[type] == 0 && StatusIconChangeTable[type] == 0) {
-					//Status change with no calc, no icon, and no skill associated...?
-					ShowError("UnknownStatusChange [%d]\n", type);
-					return 0;
-				}
-		}
+			    val2 = 50; //hit % reduc
+			    val3 = 0;//def % reduc
+			    val4 = 0;//atk flee & reduc
+			    if(status_get_race(bl) == RC_PLANT) //plant type
+				val3 = 50;
+			    if(status_get_element(bl) == ELE_WATER) // defense water type
+				val4 = 50;
+			    break;
+		case SC_AUTOREFRESH:
+			val2 = 0;
+			tick_time = val1 * 1000;
+			break;
+
+		default:
+			if( calc_flag == SCB_NONE && StatusSkillChangeTable[type] == 0 && StatusIconChangeTable[type] == 0 )
+			{	//Status change with no calc, no icon, and no skill associated...?
+				ShowError("UnknownStatusChange [%d]\n", type);
+				return 0;
+			}
+	}
 	else //Special considerations when loading SC data.
-		switch(type) {
-			case SC_WEDDING:
-			case SC_XMAS:
-			case SC_SUMMER:
-			case SC_HANBOK:
-				clif_changelook(bl,LOOK_WEAPON,0);
-				clif_changelook(bl,LOOK_SHIELD,0);
-				clif_changelook(bl,LOOK_BASE,type==SC_WEDDING?JOB_WEDDING:type==SC_XMAS?JOB_XMAS:type==SC_SUMMER?JOB_SUMMER:JOB_HANBOK);
-				clif_changelook(bl,LOOK_CLOTHES_COLOR,val4);
-				break;
-			case SC_KAAHI:
-				val4 = INVALID_TIMER;
-				break;
-		}
+	switch( type )
+	{
+		case SC_WEDDING:
+		case SC_XMAS:
+		case SC_SUMMER:
+			clif_changelook(bl,LOOK_WEAPON,0);
+			clif_changelook(bl,LOOK_SHIELD,0);
+			clif_changelook(bl,LOOK_BASE,type==SC_WEDDING?JOB_WEDDING:type==SC_XMAS?JOB_XMAS:JOB_SUMMER);
+			clif_changelook(bl,LOOK_CLOTHES_COLOR,val4);
+			break;
+		case SC_KAAHI:
+			val4 = INVALID_TIMER;
+			break;
+	}
 
 	//Those that make you stop attacking/walking....
 	switch(type) {
@@ -9025,6 +9196,26 @@
 					ud->state.running = unit_wugdash(bl, sd);
 			}
 			break;
+		case SC_INTRAVISION:
+			if( sd && battle_config.anti_mayapurple_hack )
+				map_foreachinrange(clif_insight_bl2tbl,bl,AREA_SIZE,BL_PC,bl);
+			break;
+		case SC_HIDING:
+		case SC_CLOAKING:
+		case SC_CHASEWALK:
+		case SC_CLOAKINGEXCEED:
+		case SC__INVISIBILITY:
+			if( sd )
+			{
+				if( sd->view_aura )
+				{
+					clif_clearunit_area(bl,CLR_OUTSIGHT);
+					map_foreachinrange(clif_insight_tbl2bl,bl,AREA_SIZE,BL_PC,bl); // Return it Visible only for intravision users
+				}
+				else if( battle_config.anti_mayapurple_hack )
+					clif_clearunit_invisible(&sd->bl); // Dissapear the user from others without intravision
+			}
+			break;
 		case SC_COMBO:
 			switch(sce->val1) {
 				case TK_STORMKICK:
@@ -9128,6 +9319,7 @@
 				case SC_HELLPOWER:
 				case SC_JEXPBOOST:
 				case SC_AUTOTRADE:
+				case SC_AUTOREFRESH:
 				case SC_WHISTLE:
 				case SC_ASSNCROS:
 				case SC_POEMBRAGI:
@@ -9574,7 +9766,7 @@
 				struct block_list *src = map_id2bl(sce->val2);
 				if(tid == -1 || !src)
 					break; // Terminated by Damage
-				status_fix_damage(src,bl,400*sce->val1,clif_damage(bl,bl,gettick(),0,0,400*sce->val1,0,0,0));
+				status_fix_damage(src,bl,400*sce->val1,clif_damage(bl,bl,gettick(),0,0,400*sce->val1,0,0,0),WL_WHITEIMPRISON);
 			}
 			break;
 		case SC_WUGDASH: {
@@ -9599,7 +9791,7 @@
 		case SC_SITDOWN_FORCE:
 			if(sd && pc_issit(sd)) {
 				pc_setstand(sd);
-				clif_standing(bl);
+				clif_standing(bl,true);
 			}
 			break;
 		case SC_NEUTRALBARRIER_MASTER:
@@ -9694,6 +9886,8 @@
 		case SC_HIDING:
 			sc->option &= ~OPTION_HIDE;
 			opt_flag|= 2|4; //Check for warp trigger + AoE trigger
+			if( sd && battle_config.anti_mayapurple_hack )
+				map_foreachinrange(clif_insight_tbl2bl,bl,AREA_SIZE,BL_PC,bl);
 			break;
 		case SC_CLOAKING:
 		case SC_CLOAKINGEXCEED:
@@ -9701,10 +9895,14 @@
 			sc->option &= ~OPTION_CLOAK;
 		case SC_CAMOUFLAGE:
 			opt_flag|= 2;
+			if( sd && battle_config.anti_mayapurple_hack )
+				map_foreachinrange(clif_insight_tbl2bl,bl,AREA_SIZE,BL_PC,bl);
 			break;
 		case SC_CHASEWALK:
 			sc->option &= ~(OPTION_CHASEWALK|OPTION_CLOAK);
 			opt_flag|= 2;
+			if( sd && battle_config.anti_mayapurple_hack )
+				map_foreachinrange(clif_insight_tbl2bl,bl,AREA_SIZE,BL_PC,bl);
 			break;
 		case SC_SIGHT:
 			sc->option &= ~OPTION_SIGHT;
@@ -9840,6 +10038,9 @@
 		clif_changeoption2(bl);
 	else if(opt_flag)
 		clif_changeoption(bl);
+		
+	if( sd && sd->view_aura && !battle_config.anti_mayapurple_hack && (type == SC_HIDING || type == SC_CLOAKING || type == SC_CHASEWALK) )
+		clif_sendauras(sd, AREA_WOS); // Refresh Aura
 
 	if(calc_flag)
 		status_calc_bl(bl,calc_flag);
@@ -9929,6 +10130,24 @@
 		ShowError("status_change_timer: Unexpected NULL status change id: %d data: %d\n", id, data)
 
 	switch(type) {
+		case SC_AUTOREFRESH:
+			if( sd )
+			{
+				int duration = sce->val1 * 1000;
+				if( sd->npc_id || sd->state.storage_flag || sd->state.trading || sd->chatID || sd->vender_id )
+					duration = 10000; // Retry in 10 seconds
+				else if( sd->bl.prev && (map[sd->bl.m].flag.battleground || map[sd->bl.m].flag.gvg) )
+				{
+					sce->val2 = 1;
+					clif_refresh(sd);
+					sce->val2 = 0;
+				}
+
+				clif_status_change(&sd->bl,StatusIconChangeTable[type],1,duration,0,0,0);
+				sc_timer_next(tick + duration,status_change_timer,bl->id,data);
+				return 0;
+			}
+			break;
 		case SC_MAXIMIZEPOWER:
 		case SC_CLOAKING:
 			if(!status_charge(bl, 0, 1))
@@ -10054,7 +10273,7 @@
 				int hp =  rnd()%600 + 200;
 				struct block_list* src = map_id2bl(sce->val2);	
 				map_freeblock_lock();
-				status_fix_damage(src, bl, sd||hp<status->hp?hp:status->hp-1, 1);
+				status_fix_damage(src, bl, sd||hp<status->hp?hp:status->hp-1, 1, 0);
 				if(sc->data[type]) {
 					if(status->hp == 1) {
 						map_freeblock_unlock();
@@ -10079,6 +10298,19 @@
 				return 0;
 			}
 			break;
+			
+		case SC_SPREGEN:
+			if( sd && --(sce->val4) >= 0 )
+			{
+				// val1 < 0 = per max% | val1 > 0 = exact amount
+				int sp = 0;
+				if( status->sp < status->max_sp )
+					sp = (sce->val1 < 0) ? (int)(sd->status.max_sp * -1 * sce->val1 / 100.) : sce->val1 ;
+				status_heal(bl, 0, sp, 2);
+				sc_timer_next((sce->val2 * 1000) + tick, status_change_timer, bl->id, data);
+				return 0;
+			}
+			break;
 
 		case SC_BOSSMAPINFO:
 			if(sd && --(sce->val4) >= 0) {
@@ -10230,7 +10462,7 @@
 			if(--(sce->val4) >= 0) {
 				map_freeblock_lock();
 				clif_damage(bl,bl,tick,status_get_amotion(bl),status_get_dmotion(bl)+500,100,0,0,0);
-				status_fix_damage(NULL,bl,100,0);
+				status_fix_damage(NULL,bl,100,0,0);
 				if(sc->data[type]) {
 					sc_timer_next(3000+tick,status_change_timer,bl->id,data);
 				}
@@ -10563,7 +10795,7 @@
 				int damage = status->max_hp / 100; // Suggestion 1% each second
 				if(damage >= status->hp) damage = status->hp - 1;   // Do not kill, just keep you with 1 hp minimum
 				map_freeblock_lock();
-				status_fix_damage(NULL,bl,damage,clif_damage(bl,bl,tick,0,0,damage,0,0,0));
+				status_fix_damage(NULL,bl,damage,clif_damage(bl,bl,tick,0,0,damage,0,0,0),0);
 				if(sc->data[type]) {
 					sc_timer_next(1000 + tick, status_change_timer, bl->id, data);
 				}
@@ -10633,7 +10865,7 @@
 					pc_stop_walking(sd,1|4);
 					pc_stop_attack(sd);
 					pc_setsit(sd);
-					clif_sitting(bl);
+					clif_sitting(bl,true);
 				}
 				sc_timer_next(10000 + tick, status_change_timer, bl->id, data);
 				return 0;
Index: src/map/status.h
===================================================================
--- src/map/status.h	(revision 1953)
+++ src/map/status.h	(working copy)
@@ -17,11 +17,14 @@
 #ifndef _STATUS_H_
 #define _STATUS_H_
 
+#include "../config/const.h"
+
 struct block_list;
 struct mob_data;
 struct pet_data;
 struct homun_data;
 struct mercenary_data;
+struct elemental_data;
 struct status_change;
 
 /**
@@ -334,10 +337,11 @@
     SC_MERC_QUICKEN,
 
     SC_REBIRTH,
-    //SC_SKILLCASTRATE, //285
-    //SC_DEFRATIOATK,
-    //SC_HPDRAIN,
-    //SC_SKILLATKBONUS,
+	
+	// eAmod Custom Stats
+	SC_SPREGEN,
+	SC_AUTOREFRESH,
+	
     SC_ITEMSCRIPT = 289,
     SC_S_LIFEPOTION, //290
     SC_L_LIFEPOTION,
@@ -1492,6 +1496,7 @@
     OPT3_SOULLINK         = 0x00008000,
     OPT3_UNDEAD           = 0x00010000,
     OPT3_CONTRACT         = 0x00020000,
+	OPT3_ALL_RIDING       = 0x00040000,
 };
 
 enum {
@@ -1730,9 +1735,12 @@
 unsigned int status_sc2scb_flag(sc_type sc);
 int status_type2relevant_bl_types(int type);
 
-int status_damage(struct block_list *src,struct block_list *target,int hp,int sp, int walkdelay, int flag);
+int status_damage_(struct block_list *src,struct block_list *target,int hp,int sp, int walkdelay, int flag, uint16 skill);
+//Compatibility with eAmod/eAthena
+#define status_damage(src,target,hp,sp,walkdelay,flag) status_damage_(src,target,hp,sp,walkdelay,flag,0)
 //Define for standard HP damage attacks.
-#define status_fix_damage(src, target, hp, walkdelay) status_damage(src, target, hp, 0, walkdelay, 0)
+#define status_fix_damage(src, target, hp, walkdelay, skill) status_damage_(src, target, hp, 0, walkdelay, 0, skill)
+#define status_fix_damage2(src, target, hp, walkdelay) status_damage(src, target, hp, 0, walkdelay, 0)
 //Define for standard HP/SP damage triggers.
 #define status_zap(bl, hp, sp) status_damage(NULL, bl, hp, sp, 0, 1)
 //Define for standard HP/SP skill-related cost triggers (mobs require no HP/SP to use skills)
@@ -1797,6 +1805,7 @@
 int status_get_party_id(struct block_list *bl);
 int status_get_guild_id(struct block_list *bl);
 int status_get_emblem_id(struct block_list *bl);
+int status_get_faction_id(struct block_list *bl);
 int status_get_mexp(struct block_list *bl);
 int status_get_race2(struct block_list *bl);
 
Index: src/map/storage.c
===================================================================
--- src/map/storage.c	(revision 1953)
+++ src/map/storage.c	(working copy)
@@ -111,14 +111,44 @@
 
 	if(!pc_can_give_items(sd)) {
 		//check is this GM level is allowed to put items to storage
+		clif_displaymessage(sd->fd, msg_txt(246));
+		return 1;
+	}
+	if( map[sd->bl.m].flag.nostorage )
+	{
+		clif_displaymessage(sd->fd, msg_txt(711));
+		return 1;
+	}
+	
+	sd->state.storage_flag = 1;
+	storage_sortitem(sd->status.storage.items, ARRAYLENGTH(sd->status.storage.items));
+	clif_storagelist(sd, sd->status.storage.items, ARRAYLENGTH(sd->status.storage.items));
+	clif_updatestorageamount(sd, sd->status.storage.storage_amount, MAX_STORAGE);
+	return 0;
+}
+
+int ext_storage_open(struct map_session_data *sd)
+{
+	nullpo_ret(sd);
+
+	if(sd->state.storage_flag)
+		return 1;
+
+	if( !pc_can_give_items(sd) )
+  	{ //check is this GM level is allowed to put items to storage
 		clif_displaymessage(sd->fd, msg_txt(246));
 		return 1;
 	}
+	if( map[sd->bl.m].flag.nostorage )
+	{
+		clif_displaymessage(sd->fd, msg_txt(711));
+		return 1;
+	}
 
-	sd->state.storage_flag = 1;
-	storage_sortitem(sd->status.storage.items, ARRAYLENGTH(sd->status.storage.items));
-	clif_storagelist(sd, sd->status.storage.items, ARRAYLENGTH(sd->status.storage.items));
-	clif_updatestorageamount(sd, sd->status.storage.storage_amount, MAX_STORAGE);
+	sd->state.storage_flag = 3;
+	storage_sortitem(sd->status.ext_storage.items, ARRAYLENGTH(sd->status.ext_storage.items));
+	clif_storagelist(sd, sd->status.ext_storage.items, ARRAYLENGTH(sd->status.ext_storage.items));
+	clif_updatestorageamount(sd, sd->status.storage.storage_amount, MAX_EXTRA_STORAGE);
 	return 0;
 }
 
@@ -129,7 +159,9 @@
 	   a->identify == b->identify &&
 	   a->refine == b->refine &&
 	   a->attribute == b->attribute &&
-	   a->expire_time == b->expire_time) {
+	   a->expire_time == b->expire_time &&
+	   a->unique_id == b->unique_id &&
+	   a->bound == b->bound ) {
 		int i;
 		for(i = 0; i < MAX_SLOTS && (a->card[i] == b->card[i]); i++);
 		return (i == MAX_SLOTS);
@@ -137,13 +169,13 @@
 	return 0;
 }
 
-/*==========================================
- * Internal add-item function.
- *------------------------------------------*/
-static int storage_additem(struct map_session_data *sd, struct item *item_data, int amount)
-{
-	struct storage_data *stor = &sd->status.storage;
-	struct item_data *data;
+/*==========================================
+ * Internal add-item function.
+ *------------------------------------------*/
+static int storage_additem(struct map_session_data* sd, struct item* item_data, int amount, int flag)
+{
+	struct storage_data* stor = &sd->status.storage;
+	struct item_data *data;
 	int i;
 
 	if(item_data->nameid <= 0 || amount <= 0)
@@ -167,13 +199,13 @@
 		for(i = 0; i < MAX_STORAGE; i++) {
 			if(compare_item(&stor->items[i], item_data)) {
 				// existing items found, stack them
-				if(amount > MAX_AMOUNT - stor->items[i].amount || (data->stack.storage && amount > data->stack.amount - stor->items[i].amount))
-					return 1;
-				stor->items[i].amount += amount;
-				clif_storageitemadded(sd,&stor->items[i],i,amount);
-				return 0;
-			}
-		}
+				if( amount > MAX_AMOUNT - stor->items[i].amount || ( data->stack.storage && amount > data->stack.amount - stor->items[i].amount ) )
+					return 1;
+				stor->items[i].amount += amount;
+				if( flag ) clif_storageitemadded(sd,&stor->items[i],i,amount);
+				return 0;
+			}
+		}
 	}
 
 	// find free slot
@@ -182,15 +214,64 @@
 		return 1;
 
 	// add item to slot
-	memcpy(&stor->items[i],item_data,sizeof(stor->items[0]));
-	stor->storage_amount++;
-	stor->items[i].amount = amount;
-	clif_storageitemadded(sd,&stor->items[i],i,amount);
-	clif_updatestorageamount(sd, stor->storage_amount, MAX_STORAGE);
+	memcpy(&stor->items[i],item_data,sizeof(stor->items[0]));
+	stor->storage_amount++;
+	stor->items[i].amount = amount;
+	if( flag )
+	{
+		clif_storageitemadded(sd,&stor->items[i],i,amount);
+		clif_updatestorageamount(sd, stor->storage_amount, MAX_STORAGE);
+	}
+	return 0;
+}
+
+static int ext_storage_additem(struct map_session_data* sd, struct item* item_data, int amount)
+{
+	struct extra_storage_data* stor = &sd->status.ext_storage;
+	struct item_data *data;
+	int i;
+
+	if( item_data->nameid <= 0 || amount <= 0 )
+		return 1;
+	
+	data = itemdb_search(item_data->nameid);
+
+	if( !itemdb_canstore(item_data, pc_get_group_level(sd)) )
+	{	//Check if item is storable. [Skotlex]
+		clif_displaymessage (sd->fd, msg_txt(264));
+		return 1;
+	}
+	
+	if( itemdb_isstackable2(data) )
+	{//Stackable
+		for( i = 0; i < MAX_EXTRA_STORAGE; i++ )
+		{
+			if( compare_item(&stor->items[i], item_data) )
+			{// existing items found, stack them
+				if( amount > MAX_AMOUNT - stor->items[i].amount )
+					return 1;
+				stor->items[i].amount += amount;
+				clif_storageitemadded(sd,&stor->items[i],i,amount);
+				return 0;
+			}
+		}
+	}
+
+	// find free slot
+	ARR_FIND( 0, MAX_EXTRA_STORAGE, i, stor->items[i].nameid == 0 );
+	if( i >= MAX_EXTRA_STORAGE )
+		return 1;
+
+	// add item to slot
+	memcpy(&stor->items[i],item_data,sizeof(stor->items[0]));
+	stor->storage_amount++;
+	stor->items[i].amount = amount;
+	clif_storageitemadded(sd,&stor->items[i],i,amount);
+	clif_updatestorageamount(sd, stor->storage_amount, MAX_EXTRA_STORAGE);
+
+	return 0;
+}
 
-	return 0;
-}
-
 /*==========================================
  * Internal del-item function
  *------------------------------------------*/
@@ -208,9 +289,46 @@
 	if(sd->state.storage_flag == 1) clif_storageitemremoved(sd,n,amount);
 	return 0;
 }
-
-/*==========================================
- * Add an item to the storage from the inventory.
+
+int ext_storage_delitem(struct map_session_data* sd, int n, int amount)
+{
+	if( sd->status.ext_storage.items[n].nameid == 0 || sd->status.ext_storage.items[n].amount < amount )
+		return 1;
+
+	sd->status.ext_storage.items[n].amount -= amount;
+
+	if( sd->status.ext_storage.items[n].amount == 0 )
+	{
+		memset(&sd->status.ext_storage.items[n],0,sizeof(sd->status.ext_storage.items[0]));
+		sd->status.ext_storage.storage_amount--;
+		if( sd->state.storage_flag == 3 ) clif_updatestorageamount(sd, sd->status.storage.storage_amount, MAX_EXTRA_STORAGE);
+	}
+	if( sd->state.storage_flag == 3 ) clif_storageitemremoved(sd,n,amount);
+	return 0;
+}
+
+/*==========================================
+ * Add an item to the storage
+ *------------------------------------------*/
+int storage_additem2(struct map_session_data *sd, struct item* item_data, int amount)
+{
+	nullpo_ret(sd);
+	nullpo_ret(item_data);
+
+	if( sd->status.storage.storage_amount > MAX_STORAGE )
+		return 0;
+	if( item_data->nameid <= 0 || amount <= 0 )
+		return 0;
+	if( amount > MAX_AMOUNT )
+		return 0;
+	if( storage_additem(sd,item_data,amount,0) == 0 )
+		return 1;
+
+	return 0;
+}
+
+/*==========================================
+ * Add an item to the storage from the inventory.
  *------------------------------------------*/
 int storage_storageadd(struct map_session_data *sd, int index, int amount)
 {
@@ -227,14 +345,36 @@
 
 	if(amount < 1 || amount > sd->status.inventory[index].amount)
 		return 0;
-
-	if(storage_additem(sd,&sd->status.inventory[index],amount) == 0)
-		pc_delitem(sd,index,amount,0,4,LOG_TYPE_STORAGE);
-
-	return 1;
-}
-
-/*==========================================
+
+	if( storage_additem(sd,&sd->status.inventory[index],amount,1) == 0 )
+		pc_delitem(sd,index,amount,0,4,LOG_TYPE_STORAGE);
+
+	return 1;
+}
+
+int ext_storage_add(struct map_session_data *sd,int index,int amount)
+{
+	nullpo_ret(sd);
+
+	if( sd->status.ext_storage.storage_amount > MAX_EXTRA_STORAGE )
+		return 0; // storage full
+
+	if( index < 0 || index >= MAX_INVENTORY )
+		return 0;
+
+	if( sd->status.inventory[index].nameid <= 0 )
+		return 0; //No item on that spot
+
+	if( amount < 1 || amount > sd->status.inventory[index].amount )
+		return 0;
+
+	if( ext_storage_additem(sd,&sd->status.inventory[index],amount) == 0 )
+		pc_delitem(sd,index,amount,0,4,LOG_TYPE_STORAGE);
+
+	return 1;
+}
+
+/*==========================================
  * Retrieve an item from the storage.
  *------------------------------------------*/
 int storage_storageget(struct map_session_data *sd, int index, int amount)
@@ -256,10 +396,33 @@
 		clif_additem(sd,0,0,flag);
 
 	return 1;
-}
-
-/*==========================================
- * Move an item from cart to storage.
+}
+
+int ext_storage_get(struct map_session_data* sd, int index, int amount)
+{
+	int flag;
+
+	nullpo_ret(sd);
+
+	if( index < 0 || index >= MAX_EXTRA_STORAGE )
+		return 0;
+
+	if( sd->status.ext_storage.items[index].nameid <= 0 )
+		return 0; //Nothing there
+	
+	if( amount < 1 || amount > sd->status.ext_storage.items[index].amount )
+		return 0;
+
+	if( (flag = pc_additem(sd,&sd->status.ext_storage.items[index],amount,LOG_TYPE_STORAGE)) == 0 )
+		ext_storage_delitem(sd,index,amount);
+	else
+		clif_additem(sd,0,0,flag);
+
+	return 1;
+}
+
+/*==========================================
+ * Move an item from cart to storage.
  *------------------------------------------*/
 int storage_storageaddfromcart(struct map_session_data *sd, int index, int amount)
 {
@@ -276,14 +439,36 @@
 
 	if(amount < 1 || amount > sd->status.cart[index].amount)
 		return 0;
-
-	if(storage_additem(sd,&sd->status.cart[index],amount) == 0)
-		pc_cart_delitem(sd,index,amount,0,LOG_TYPE_STORAGE);
-
-	return 1;
-}
-
-/*==========================================
+
+	if( storage_additem(sd,&sd->status.cart[index],amount,1) == 0 )
+		pc_cart_delitem(sd,index,amount,0,LOG_TYPE_STORAGE);
+
+	return 1;
+}
+
+int ext_storage_addfromcart(struct map_session_data* sd, int index, int amount)
+{
+	nullpo_ret(sd);
+
+	if( sd->status.ext_storage.storage_amount > MAX_EXTRA_STORAGE )
+  		return 0; // storage full / storage closed
+
+	if( index < 0 || index >= MAX_CART )
+  		return 0;
+
+	if( sd->status.cart[index].nameid <= 0 )
+		return 0; //No item there.
+	
+	if( amount < 1 || amount > sd->status.cart[index].amount )
+		return 0;
+
+	if( ext_storage_additem(sd,&sd->status.cart[index],amount) == 0 )
+		pc_cart_delitem(sd,index,amount,0,LOG_TYPE_STORAGE);
+
+	return 1;
+}
+
+/*==========================================
  * Get from Storage to the Cart
  *------------------------------------------*/
 int storage_storagegettocart(struct map_session_data *sd, int index, int amount)
@@ -302,13 +487,31 @@
 	if(pc_cart_additem(sd,&sd->status.storage.items[index],amount,LOG_TYPE_STORAGE) == 0)
 		storage_delitem(sd,index,amount);
 
-	return 1;
-}
-
-
-/*==========================================
- * Modified By Valaris to save upon closing [massdriller]
- *------------------------------------------*/
+	return 1;
+}
+
+int ext_storage_gettocart(struct map_session_data* sd, int index, int amount)
+{
+	nullpo_ret(sd);
+
+	if( index < 0 || index >= MAX_EXTRA_STORAGE )
+		return 0;
+	
+	if( sd->status.ext_storage.items[index].nameid <= 0 )
+		return 0; //Nothing there.
+	
+	if( amount < 1 || amount > sd->status.ext_storage.items[index].amount )
+		return 0;
+	
+	if( pc_cart_additem(sd,&sd->status.ext_storage.items[index],amount,LOG_TYPE_STORAGE) == 0 )
+		ext_storage_delitem(sd,index,amount);
+
+	return 1;
+}
+
+/*==========================================
+ * Modified By Valaris to save upon closing [massdriller]
+ *------------------------------------------*/
 void storage_storageclose(struct map_session_data *sd)
 {
 	nullpo_retv(sd);
@@ -377,13 +580,19 @@
 
 	if(!pc_can_give_items(sd)) {   //check is this GM level can open guild storage and store items [Lupus]
 		clif_displaymessage(sd->fd, msg_txt(246));
-		return 1;
+		return 1;
+	}
+
+	if( map[sd->bl.m].flag.noguildstorage )
+	{
+		clif_displaymessage(sd->fd, msg_txt(712));
+		return 1;
+	}
+
+	if((gstor = guild2storage2(sd->status.guild_id)) == NULL) {
+		intif_request_guild_storage(sd->status.account_id,sd->status.guild_id);
+		return 0;
 	}
-
-	if((gstor = guild2storage2(sd->status.guild_id)) == NULL) {
-		intif_request_guild_storage(sd->status.account_id,sd->status.guild_id);
-		return 0;
-	}
 	if(gstor->storage_status)
 		return 1;
 
@@ -423,11 +632,17 @@
 		return 1;
 	}
 
-	if(!itemdb_canguildstore(item_data, pc_get_group_level(sd)) || item_data->expire_time) {
+	if( !itemdb_canguildstore(item_data, pc_get_group_level(sd)) || item_data->expire_time || item_data->bound ) {
 		//Check if item is storable. [Skotlex]
 		clif_displaymessage(sd->fd, msg_txt(264));
 		return 1;
 	}
+	
+	if( sd->state.secure_items )
+	{
+		clif_displaymessage(sd->fd, "You can't store items on Guild Storage. Blocked with @security");
+		return 1;
+	}
 
 	if(itemdb_isstackable2(data)) { //Stackable
 		for(i=0; i<MAX_GUILD_STORAGE; i++) {
Index: src/map/storage.h
===================================================================
--- src/map/storage.h	(revision 1953)
+++ src/map/storage.h	(working copy)
@@ -27,12 +27,23 @@
 int storage_delitem(struct map_session_data* sd, int n, int amount);
 int storage_storageopen(struct map_session_data *sd);
 int storage_storageadd(struct map_session_data *sd,int index,int amount);
-int storage_storageget(struct map_session_data *sd,int index,int amount);
-int storage_storageaddfromcart(struct map_session_data *sd,int index,int amount);
-int storage_storagegettocart(struct map_session_data *sd,int index,int amount);
-void storage_storageclose(struct map_session_data *sd);
-int do_init_storage(void);
-void do_final_storage(void);
+int storage_storageget(struct map_session_data *sd,int index,int amount);
+int storage_storageaddfromcart(struct map_session_data *sd,int index,int amount);
+int storage_storagegettocart(struct map_session_data *sd,int index,int amount);
+int storage_additem2(struct map_session_data *sd, struct item* item_data, int amount);
+
+int compare_item(struct item *a, struct item *b);
+
+int ext_storage_delitem(struct map_session_data* sd, int n, int amount);
+int ext_storage_open(struct map_session_data *sd);
+int ext_storage_add(struct map_session_data *sd,int index,int amount);
+int ext_storage_get(struct map_session_data* sd, int index, int amount);
+int ext_storage_addfromcart(struct map_session_data *sd,int index,int amount);
+int ext_storage_gettocart(struct map_session_data *sd,int index,int amount);
+
+void storage_storageclose(struct map_session_data *sd);
+int do_init_storage(void);
+void do_final_storage(void);
 void do_reconnect_storage(void);
 void storage_storage_quit(struct map_session_data *sd, int flag);
 
Index: src/map/trade.c
===================================================================
--- src/map/trade.c	(revision 1953)
+++ src/map/trade.c	(working copy)
@@ -48,12 +48,28 @@
 		clif_displaymessage(sd->fd, msg_txt(272));
 		return; //Can't trade in notrade mapflag maps.
 	}
+	
+	if( sd->state.secure_items ) {
+		clif_displaymessage(sd->fd, "You can't trade. Blocked with @security");
+		return;
+	}
 
 	if(target_sd == NULL || sd == target_sd) {
 		clif_tradestart(sd, 1); // character does not exist
 		return;
 	}
+	
+	if( target_sd->state.secure_items ) {
+		clif_displaymessage(sd->fd, "Target can't trade. Blocked with @security");
+		return;
+	}
 
+	if( !battle_config.faction_allow_trade && sd->status.faction_id != target_sd->status.faction_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot trade with other faction members.");
+		return;
+	}
+
 	if(target_sd->npc_id) {
 		//Trade fails if you are using an NPC.
 		clif_tradestart(sd, 2);
@@ -374,10 +390,20 @@
 		clif_displaymessage(sd->fd, msg_txt(260));
 		clif_tradeitemok(sd, index+2, 1);
 		return;
-	}
-
-	//Locate a trade position
-	ARR_FIND(0, 10, trade_i, sd->deal.item[trade_i].index == index || sd->deal.item[trade_i].amount == 0);
+	}
+
+	if( (item->bound == 1 || (item->bound == 2 && sd->status.guild_id != target_sd->status.guild_id)) )
+	{ // Account/Guild Bound
+		if( item->bound == 1 )
+			clif_displaymessage (sd->fd, "Can't Trade. Account Bounded Item.");
+		else
+			clif_displaymessage (sd->fd, "Can't Trade. Guild Bounded Item.");
+		clif_tradeitemok(sd, index+2, 1);
+		return;
+	}
+
+	//Locate a trade position
+	ARR_FIND( 0, 10, trade_i, sd->deal.item[trade_i].index == index || sd->deal.item[trade_i].amount == 0 );
 	if(trade_i == 10) { //No space left
 		clif_tradeitemok(sd, index+2, 1);
 		return;
Index: src/map/unit.c
===================================================================
--- src/map/unit.c	(revision 1953)
+++ src/map/unit.c	(working copy)
@@ -30,12 +30,13 @@
 #include "instance.h"
 #include "mercenary.h"
 #include "elemental.h"
-#include "skill.h"
-#include "clif.h"
-#include "duel.h"
-#include "npc.h"
-#include "guild.h"
-#include "status.h"
+#include "skill.h"
+#include "clif.h"
+#include "duel.h"
+#include "channel.h"
+#include "npc.h"
+#include "guild.h"
+#include "status.h"
 #include "unit.h"
 #include "battle.h"
 #include "battleground.h"
@@ -44,12 +45,13 @@
 #include "vending.h"
 #include "party.h"
 #include "intif.h"
-#include "chrif.h"
-#include "script.h"
-#include "storage.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "chrif.h"
+#include "script.h"
+#include "storage.h"
+#include "region.h"
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 
@@ -193,6 +195,9 @@
 				return 0;
 		} else
 			sd->areanpc_id=0;
+			
+		if( map_pvpevent(bl->m) && map[bl->m].pvpe_area && sd->pvpevent_fame && (x < map[bl->m].pvpe_x1 || x > map[bl->m].pvpe_x2 || y < map[bl->m].pvpe_y1 || y > map[bl->m].pvpe_y2) )
+			sd->pvpevent_fame = 0; // Going out of the Area. Reset Fame to 0
 
 		if(sd->md && !check_distance_bl(&sd->bl, &sd->md->bl, MAX_MER_DISTANCE)) {
 			// mercenary should be warped after being 3 seconds too far from the master [greenbox]
@@ -636,6 +641,9 @@
 				return 0;
 		} else
 			sd->areanpc_id=0;
+			
+		if( map_pvpevent(bl->m) && map[bl->m].pvpe_area && sd->pvpevent_fame && (bl->x < map[bl->m].pvpe_x1 || bl->x > map[bl->m].pvpe_x2 || bl->y < map[bl->m].pvpe_y1 || bl->y > map[bl->m].pvpe_y2) )
+			sd->pvpevent_fame = 0; // Going out of the Area. Reset Fame to 0
 
 		if(sd->status.pet_id > 0 && sd->pd && sd->pd->pet.intimate > 0) {
 			// Check if pet needs to be teleported. [Skotlex]
@@ -760,13 +768,13 @@
 	if(m<0) m=bl->m;
 
 	switch(bl->type) {
-		case BL_MOB:
-			if(map[bl->m].flag.monster_noteleport && ((TBL_MOB *)bl)->master_id == 0)
-				return 1;
-			if(m != bl->m && map[m].flag.nobranch && battle_config.mob_warp&4 && !(((TBL_MOB *)bl)->master_id))
-				return 1;
-			break;
-		case BL_PC:
+		case BL_MOB:
+			if (map[bl->m].flag.monster_noteleport && ((TBL_MOB*)bl)->master_id == 0)
+				return 1;
+			if (m != bl->m && map[m].flag.nobranch && battle_config.mob_warp&4 && !(((TBL_MOB *)bl)->master_id || ((TBL_MOB*)bl)->option.allow_warp))
+				return 1;
+			break;
+		case BL_PC:
 			if(map[bl->m].flag.noteleport)
 				return 1;
 			break;
@@ -1043,9 +1051,15 @@
 	}
 
 	if(sd) {
+		struct map_session_data *tsd = map_id2sd(target_id);
+		
 		//Target_id checking.
 		if(skillnotok(skill_id, sd)) // [MouseJstr]
 			return 0;
+			
+		// PK Mode skills block
+		if( tsd && sd != tsd && sd->state.pvpmode != tsd->state.pvpmode )
+			return 0;
 
 		switch(skill_id) {
 				//Check for skills that auto-select target
@@ -1265,10 +1279,22 @@
 		casttime = 0;
 	}
 
-	if(!ud->state.running) //need TK_RUN or WUGDASH handler to be done before that, see bugreport:6026
-		unit_stop_walking(src,1);// eventhough this is not how official works but this will do the trick. bugreport:6829
-	// in official this is triggered even if no cast time.
-	clif_skillcasting(src, src->id, target_id, 0,0, skill_id, skill_get_ele(skill_id, skill_lv), casttime);
+	if(!ud->state.running) //need TK_RUN or WUGDASH handler to be done before that, see bugreport:6026
+		unit_stop_walking(src,1);// eventhough this is not how official works but this will do the trick. bugreport:6829
+	if( sc ) {
+		/**
+		 * why the if else chain: these 3 status do not stack, so its efficient that way.
+		 **/
+ 		if( sc->data[SC_CLOAKING] && !(sc->data[SC_CLOAKING]->val4&4) && skill_id != AS_CLOAKING ) {
+			status_change_end(src, SC_CLOAKING, INVALID_TIMER);
+			if (!src->prev) return 0; //Warped away!
+		} else if( sc->data[SC_CLOAKINGEXCEED] && !(sc->data[SC_CLOAKINGEXCEED]->val4&4) && skill_id != GC_CLOAKINGEXCEED ) {
+			status_change_end(src,SC_CLOAKINGEXCEED, INVALID_TIMER);
+			if (!src->prev) return 0;
+		}
+	}
+	// in official this is triggered even if no cast time.
+	clif_skillcasting(src, src->id, target_id, 0,0, skill_id, skill_get_ele(skill_id, skill_lv), casttime);
 	if(casttime > 0 || temp) {
 		if(sd && target->type == BL_MOB) {
 			TBL_MOB *md = (TBL_MOB *)target;
@@ -1443,19 +1469,6 @@
 	ud->skilly       = skill_y;
 	ud->skilltarget  = 0;
 
-	if(sc) {
-		/**
-		 * why the if else chain: these 3 status do not stack, so its efficient that way.
-		 **/
-		if(sc->data[SC_CLOAKING] && !(sc->data[SC_CLOAKING]->val4&4)) {
-			status_change_end(src, SC_CLOAKING, INVALID_TIMER);
-			if(!src->prev) return 0;  //Warped away!
-		} else if(sc->data[SC_CLOAKINGEXCEED] && !(sc->data[SC_CLOAKINGEXCEED]->val4&4)) {
-			status_change_end(src, SC_CLOAKINGEXCEED, INVALID_TIMER);
-			if(!src->prev) return 0;
-		}
-	}
-
 	unit_stop_walking(src,1);
 	// in official this is triggered even if no cast time.
 	clif_skillcasting(src, src->id, 0, skill_x, skill_y, skill_id, skill_get_ele(skill_id, skill_lv), casttime);
@@ -1743,6 +1756,9 @@
 
 	if(ud->skilltimer != INVALID_TIMER && !(sd && pc_checkskill(sd,SA_FREECAST) > 0))
 		return 0; // can't attack while casting
+		
+	if( sd && map[src->m].flag.battleground )
+		pc_update_last_action(sd,0);
 
 	if(!battle_config.sdelay_attack_enable && DIFF_TICK(ud->canact_tick,tick) > 0 && !(sd && pc_checkskill(sd,SA_FREECAST) > 0)) {
 		// attacking when under cast delay has restrictions:
@@ -1931,13 +1947,13 @@
 {
 	nullpo_ret(target);
 
-	if(damage+damage2 <= 0)
-		return 0;
-
-	return status_fix_damage(src,target,damage+damage2,clif_damage(target,target,tick,sdelay,ddelay,damage,div,type,damage2));
-}
-
-/*==========================================
+	if(damage+damage2 <= 0)
+		return 0;
+
+	return status_fix_damage(src,target,damage+damage2,clif_damage(target,target,tick,sdelay,ddelay,damage,div,type,damage2),0);
+}
+
+/*==========================================
  * To change the size of the char (player or mob only)
  *------------------------------------------*/
 int unit_changeviewsize(struct block_list *bl,short size)
@@ -2024,12 +2040,13 @@
 		skill_cleartimerskill(bl);
 	}
 
-	switch(bl->type) {
-		case BL_PC: {
-				struct map_session_data *sd = (struct map_session_data *)bl;
-
-				if(sd->shadowform_id){
-					struct block_list *d_bl = map_id2bl(sd->shadowform_id);
+	switch( bl->type ) {
+		case BL_PC: {
+			struct map_session_data *sd = (struct map_session_data*)bl;
+		struct region_data* rd = region_search(map[bl->m].region_id);
+
+			if(sd->shadowform_id){
+			    struct block_list *d_bl = map_id2bl(sd->shadowform_id);
 			    	if(d_bl)
 				    	status_change_end(d_bl,SC__SHADOWFORM,INVALID_TIMER);
 				}
@@ -2037,13 +2054,13 @@
 				if(sd->chatID)
 					chat_leavechat(sd,0);
 				if(sd->trade_partner)
-					trade_tradecancel(sd);
-				buyingstore_close(sd);
-				searchstore_close(sd);
-				if(sd->state.storage_flag == 1)
-					storage_storage_quit(sd,0);
-				else if(sd->state.storage_flag == 2)
-					storage_guild_storage_quit(sd,0);
+				trade_tradecancel(sd);
+			buyingstore_close(sd);
+			searchstore_close(sd);
+			if(sd->state.storage_flag == 1 || sd->state.storage_flag == 3)
+				storage_storage_quit(sd,0);
+			else if (sd->state.storage_flag == 2)
+				storage_guild_storage_quit(sd,0);
 				sd->state.storage_flag = 0; //Force close it when being warped.
 				if(sd->party_invite>0)
 					party_reply_invite(sd,sd->party_invite,0);
@@ -2109,22 +2126,21 @@
 				}
 				sd->state.debug_remove_map = 1; // temporary state to track double remove_map's [FlavioJS]
 				sd->debug_file = file;
-				sd->debug_line = line;
-				sd->debug_func = func;
-
-				break;
-			}
-		case BL_MOB: {
+			sd->debug_line = line;
+			sd->debug_func = func;
+
+			if( rd ) rd->users--;
+			break;
+		}
+		case BL_MOB: {
 				struct mob_data *md = (struct mob_data *)bl;
 				// Drop previous target mob_slave_keep_target: no.
-				if(!battle_config.mob_slave_keep_target)
-					md->target_id=0;
-
-				md->attacked_id=0;
-				md->state.skillstate= MSS_IDLE;
-
-				break;
-			}
+			if (!battle_config.mob_slave_keep_target)
+				md->target_id=0;
+
+
+			break;
+		}
 		case BL_PET: {
 				struct pet_data *pd = (struct pet_data *)bl;
 				if(pd->pet.intimate <= 0 && !(pd->msd && !pd->msd->state.active)) {
@@ -2168,11 +2184,11 @@
 				struct elemental_data *ed = (struct elemental_data *)bl;
 				ud->canact_tick = ud->canmove_tick;
 				if(elemental_get_lifetime(ed) <= 0 && !(ed->master && !ed->master->state.active)) {
-					clif_clearunit_area(bl,clrtype);
-					map_delblock(bl);
-					unit_free(bl,0);
-					map_freeblock_unlock();
-					return 0;
+				clif_clearunit_area(bl,clrtype);
+				map_delblock(bl);
+				unit_free(bl,CLR_OUTSIGHT);
+				map_freeblock_unlock();
+				return 0;
 				}
 				break;
 			}
@@ -2228,8 +2244,9 @@
 
 	switch(bl->type) {
 		case BL_PC: {
-				struct map_session_data *sd = (struct map_session_data *)bl;
-				int i;
+			struct map_session_data *sd = (struct map_session_data*)bl;
+			struct npc_data* nd; // Graveyard
+			int i;
 
 				if(status_isdead(bl))
 					pc_setrestartvalue(sd,2);
@@ -2248,13 +2265,21 @@
 				// Notify friends that this char logged out. [Skotlex]
 				map_foreachpc(clif_friendslist_toggle_sub, sd->status.account_id, sd->status.char_id, 0);
 				party_send_logout(sd);
-				guild_send_memberinfoshort(sd,0);
-				pc_cleareventtimer(sd);
-				pc_inventory_rental_clear(sd);
-				pc_delspiritball(sd,sd->spiritball,1);
-				for(i = 1; i < 5; i++)
-					pc_del_talisman(sd, sd->talisman[i], i);
-
+			guild_send_memberinfoshort(sd,0);
+			pc_cleareventtimer(sd);
+			pc_inventory_rental_clear(sd);
+			if( sd->qd ) queue_leaveall(sd);
+			channel_invite_clear(sd);
+			for( i = 0; i < MAX_USER_CHANNELS; i++ )
+				if( sd->cd[i] != NULL ) channel_leave(sd,sd->cd[i]->name, false);
+			if( sd->graveyard_npc_id && (nd = map_id2nd(sd->graveyard_npc_id)) != NULL )
+				npc_unload(nd,true);
+
+			pc_delspiritball(sd,sd->spiritball,1);
+			skill_blockpc_clear(sd);
+			for(i = 1; i < 5; i++)
+				pc_del_talisman(sd, sd->talisman[i], i);
+
 				if(sd->reg) {    //Double logout already freed pointer fix... [Skotlex]
 					aFree(sd->reg);
 					sd->reg = NULL;
@@ -2331,6 +2356,8 @@
 			}
 		case BL_MOB: {
 				struct mob_data *md = (struct mob_data *)bl;
+				struct npc_data* nd;
+				
 				if(md->spawn_timer != INVALID_TIMER) {
 					delete_timer(md->spawn_timer,mob_delayspawn);
 					md->spawn_timer = INVALID_TIMER;
@@ -2356,6 +2383,8 @@
 					aFree(md->guardian_data);
 					md->guardian_data = NULL;
 				}
+				if( md->graveyard_npc_id && (nd = map_id2nd(md->graveyard_npc_id)) != NULL )
+					npc_unload(nd,true);
 				if(md->spawn) {
 					md->spawn->active--;
 					if(!md->spawn->state.dynamic) {
Index: src/map/vending.c
===================================================================
--- src/map/vending.c	(revision 1953)
+++ src/map/vending.c	(working copy)
@@ -17,6 +17,7 @@
 #include "../common/nullpo.h"
 #include "../common/strlib.h"
 #include "../common/utils.h"
+#include "channel.h"
 #include "clif.h"
 #include "itemdb.h"
 #include "atcommand.h"
@@ -28,6 +29,7 @@
 #include "skill.h"
 #include "battle.h"
 #include "log.h"
+#include "achievement.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -48,9 +50,13 @@
 	nullpo_retv(sd);
 
 	if(sd->state.vending) {
-		sd->state.vending = false;
-		clif_closevendingboard(&sd->bl, 0);
-	}
+		sd->state.vending = false;
+		sd->vend_coin = battle_config.vending_zeny_id;
+		clif_closevendingboard(&sd->bl, 0);
+
+		if( map[sd->bl.m].flag.vending_cell ) // Cell becomes available again.
+			map_setcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_NOVENDING, true);
+	}
 }
 
 /*==========================================
@@ -64,31 +70,43 @@
 	if((vsd = map_id2sd(id)) == NULL)
 		return;
 	if(!vsd->state.vending)
-		return; // not vending
-
+		return; // not vending
+	if( !battle_config.faction_allow_vending && vsd->status.faction_id != sd->status.faction_id )
+	{
+		clif_displaymessage(sd->fd,"You cannot purchase from other faction members.");
+		return;
+	}
+
 	if(!pc_can_give_items(sd) || !pc_can_give_items(vsd)) { //check if both GMs are allowed to trade
 		// GM is not allowed to trade
 		clif_displaymessage(sd->fd, msg_txt(246));
 		return;
-	}
+	} 
+
+	sd->vended_id = vsd->vender_id;  // register vending uid
+	if( battle_config.vending_zeny_id && vsd->vend_coin )
+	{ // Extended Vending System
+		char output[256];
+		sprintf(output,msg_txt(714),itemdb_jname(vsd->vend_coin));
+		clif_displaymessage(sd->fd,output);
+	}
+
+	clif_vendinglist(sd, id, vsd->vending);
+}
 
-	sd->vended_id = vsd->vender_id;  // register vending uid
-
-	clif_vendinglist(sd, id, vsd->vending);
-}
-
 /*==========================================
  * Purchase item(s) from a shop
  *------------------------------------------*/
 void vending_purchasereq(struct map_session_data *sd, int aid, int uid, const uint8 *data, int count)
 {
 	int i, j, cursor, w, new_ = 0, blank, vend_list[MAX_VENDING];
-	double z;
-	struct s_vending vending[MAX_VENDING]; // against duplicate packets
-	struct map_session_data *vsd = map_id2sd(aid);
-
-	nullpo_retv(sd);
-	if(vsd == NULL || !vsd->state.vending || vsd->bl.id == sd->bl.id)
+	double z;
+	struct s_vending vending[MAX_VENDING]; // against duplicate packets
+	struct map_session_data* vsd = map_id2sd(aid);
+	char output[256];
+
+	nullpo_retv(sd);
+	if( vsd == NULL || !vsd->state.vending || vsd->bl.id == sd->bl.id )
 		return; // invalid shop
 
 	if(vsd->vender_id != uid) {
@@ -132,14 +150,33 @@
 			vend_list[i] = j;
 
 		z += ((double)vsd->vending[j].value * (double)amount);
-		if(z > (double)sd->status.zeny || z < 0. || z > (double)MAX_ZENY) {
-			clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
-			return;
+		if( !vsd->vend_coin || vsd->vend_coin == battle_config.vending_zeny_id )
+		{ // Normal Vending - Zeny Option
+			if( z > (double)sd->status.zeny || z < 0. || z > (double)MAX_ZENY )
+			{
+				clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
+				return;
+			}
+			if( z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max )
+			{
+				clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
+				return;
+			}
 		}
-		if(z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max) {
-			clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
-			return;
-
+		else if( battle_config.vending_cash_id && vsd->vend_coin == battle_config.vending_cash_id )
+		{ // Cash Shop
+			if( z > (double)sd->cashPoints || z < 0. || z > (double)MAX_ZENY )
+			{
+				sprintf(output,msg_txt(715),itemdb_jname(vsd->vend_coin));
+				clif_displaymessage(sd->fd,output);
+				return;
+			}
+			if( z + (double)vsd->cashPoints > (double)MAX_ZENY && !battle_config.vending_over_max )
+			{
+				sprintf(output,msg_txt(716),itemdb_jname(vsd->vend_coin));
+				clif_displaymessage(sd->fd,output);
+				return;
+			}
 		}
 		w += itemdb_weight(vsd->status.cart[idx].nameid) * amount;
 		if(w + sd->weight > sd->max_weight) {
@@ -174,11 +211,47 @@
 		}
 	}
 
-	pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
-	if(battle_config.vending_tax)
-		z -= z * (battle_config.vending_tax/10000.);
-	pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
+	// Payments
+	if( !vsd->vend_coin || vsd->vend_coin == battle_config.vending_zeny_id )
+	{
+		pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
+		achievement_validate_zeny(sd,ATZ_USE_VENDING,(int)z);
+ 
+		if( battle_config.vending_tax || (vsd->state.autotrade && battle_config.at_tax) )
+			z -= z * ((battle_config.vending_tax + ((vsd->state.autotrade) ? battle_config.at_tax : 0)) / 10000.);
 
+		pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
+		achievement_validate_zeny(vsd,ATZ_GET_VENDING,(int)z);
+	}
+	else if( battle_config.vending_cash_id && vsd->vend_coin == battle_config.vending_cash_id )
+	{
+		pc_paycash(sd,(int)z,0);
+		pc_getcash(vsd,(int)z,0);
+	}
+	else
+	{
+		if( z < 0. || (i = pc_search_inventory(sd,vsd->vend_coin)) < 0 || z > (double)sd->status.inventory[i].amount )
+		{
+			sprintf(output,msg_txt(715),itemdb_jname(vsd->vend_coin));
+			clif_displaymessage(sd->fd,output);
+			return;
+		}
+
+		switch( pc_checkadditem(vsd,vsd->vend_coin,(int)z) )
+		{
+		case ADDITEM_NEW:
+			if( pc_inventoryblank(vsd) > 0 )
+				break;
+		case ADDITEM_OVERAMOUNT:
+			sprintf(output,msg_txt(716),itemdb_jname(vsd->vend_coin));
+			clif_displaymessage(sd->fd,output);
+			return;
+		}
+
+		pc_additem(vsd,&sd->status.inventory[i],(int)z,LOG_TYPE_VENDING);
+		pc_delitem(sd,i,(int)z,0,6,LOG_TYPE_VENDING);
+	}
+
 	for(i = 0; i < count; i++) {
 		short amount = *(uint16 *)(data + 4*i + 0);
 		short idx    = *(uint16 *)(data + 4*i + 2);
@@ -237,7 +310,7 @@
  *------------------------------------------*/
 void vending_openvending(struct map_session_data *sd, const char *message, const uint8 *data, int count)
 {
-	int i, j;
+	int i, j, char_id;
 	int vending_skill_lvl;
 	nullpo_retv(sd);
 
@@ -270,12 +343,14 @@
 		if(index < 0 || index >= MAX_CART  // invalid position
 		   ||  pc_cartitem_amount(sd, index, amount) < 0 // invalid item or insufficient quantity
 		   //NOTE: official server does not do any of the following checks!
-		   ||  !sd->status.cart[index].identify // unidentified item
-		   ||  sd->status.cart[index].attribute == 1 // broken item
-		   ||  sd->status.cart[index].expire_time // It should not be in the cart but just in case
-		   ||  !itemdb_cantrade(&sd->status.cart[index], pc_get_group_level(sd), pc_get_group_level(sd)))  // untradeable item
-			continue;
-
+		||  !sd->status.cart[index].identify // unidentified item
+		||  sd->status.cart[index].attribute == 1 // broken item
+		||  sd->status.cart[index].expire_time // It should not be in the cart but just in case
+		||  sd->status.cart[index].bound // Can't Trade Account bound items
+		||  ( sd->status.cart[index].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->status.cart[index].card[2],sd->status.cart[index].card[3])) > 0 && ((battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id) || (battle_config.ancient_reserved_char_id && char_id == battle_config.ancient_reserved_char_id)) )
+		||  !itemdb_cantrade(&sd->status.cart[index], pc_get_group_level(sd), pc_get_group_level(sd)) ) // untradeable item
+			continue;
+
 		sd->vending[i].index = index;
 		sd->vending[i].amount = amount;
 		sd->vending[i].value = cap_value(value, 0, (unsigned int)battle_config.vending_max_value);
@@ -297,8 +372,19 @@
 	sd->vend_num = i;
 	safestrncpy(sd->message, message, MESSAGE_SIZE);
 
+	pc_stop_walking(sd,1);
 	clif_openvending(sd,sd->bl.id,sd->vending);
 	clif_showvendingboard(&sd->bl,message,0);
+
+	if( battle_config.channel_announces&16 && server_channel[CHN_VENDING] )
+	{
+		char chat_message[256];
+		sprintf(chat_message, msg_txt(820), server_channel[CHN_VENDING]->name, sd->status.name, sd->message, map[sd->bl.m].name, sd->bl.x, sd->bl.y);
+		clif_channel_message(server_channel[CHN_VENDING], chat_message, 27);
+	}
+
+	if( map[sd->bl.m].flag.vending_cell )
+		map_setcell(sd->bl.m, sd->bl.x, sd->bl.y, CELL_NOVENDING, false);
 }
 
 
Index: vcproj-10/char-server.vcxproj
===================================================================
--- vcproj-10/char-server.vcxproj	(revision 1953)
+++ vcproj-10/char-server.vcxproj	(working copy)
@@ -157,6 +157,7 @@
     <ClInclude Include="..\src\common\timer.h" />
     <ClInclude Include="..\src\common\utils.h" />
     <ClInclude Include="..\src\char\char.h" />
+	<ClInclude Include="..\src\char\int_achievement.h" />
     <ClInclude Include="..\src\char\int_auction.h" />
     <ClInclude Include="..\src\char\int_elemental.h" />
     <ClInclude Include="..\src\char\int_guild.h" />
@@ -196,6 +197,7 @@
     <ClCompile Include="..\src\common\timer.c" />
     <ClCompile Include="..\src\common\utils.c" />
     <ClCompile Include="..\src\char\char.c" />
+	<ClCompile Include="..\src\char\int_achievement.c" />
     <ClCompile Include="..\src\char\int_auction.c" />
     <ClCompile Include="..\src\char\int_elemental.c" />
     <ClCompile Include="..\src\char\int_guild.c" />
Index: vcproj-10/char-server.vcxproj.filters
===================================================================
--- vcproj-10/char-server.vcxproj.filters	(revision 1953)
+++ vcproj-10/char-server.vcxproj.filters	(working copy)
@@ -46,6 +46,9 @@
     <ClCompile Include="..\src\char\char.c">
       <Filter>char_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\char\int_achievement.c">
+      <Filter>char_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\char\int_auction.c">
       <Filter>char_sql</Filter>
     </ClCompile>
@@ -162,6 +165,9 @@
     <ClInclude Include="..\src\char\char.h">
       <Filter>char_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\char\int_achievement.h">
+      <Filter>char_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\char\int_auction.h">
       <Filter>char_sql</Filter>
     </ClInclude>
Index: vcproj-10/map-server.vcxproj
===================================================================
--- vcproj-10/map-server.vcxproj	(revision 1953)
+++ vcproj-10/map-server.vcxproj	(working copy)
@@ -158,16 +158,19 @@
     <ClInclude Include="..\src\common\timer.h" />
     <ClInclude Include="..\src\common\utils.h" />
     <ClInclude Include="..\src\common\winapi.h" />
+	<ClInclude Include="..\src\map\achievement.h" />
     <ClInclude Include="..\src\map\atcommand.h" />
     <ClInclude Include="..\src\map\battle.h" />
     <ClInclude Include="..\src\map\battleground.h" />
     <ClInclude Include="..\src\map\buyingstore.h" />
+	<ClInclude Include="..\src\map\channel.h" />
     <ClInclude Include="..\src\map\chat.h" />
     <ClInclude Include="..\src\map\chrif.h" />
     <ClInclude Include="..\src\map\clif.h" />
     <ClInclude Include="..\src\map\date.h" />
     <ClInclude Include="..\src\map\duel.h" />
     <ClInclude Include="..\src\map\elemental.h" />
+	<ClInclude Include="..\src\map\faction.h" />
     <ClInclude Include="..\src\map\guild.h" />
     <ClInclude Include="..\src\map\intif.h" />
     <ClInclude Include="..\src\map\itemdb.h" />
@@ -191,6 +194,7 @@
     <ClInclude Include="..\src\config\renewal.h" />
     <ClInclude Include="..\src\config\secure.h" />
     <ClInclude Include="..\src\config\classes\general.h" />
+	<ClInclude Include="..\src\map\region.h" />
     <ClInclude Include="..\src\map\script.h" />
     <ClInclude Include="..\src\map\searchstore.h" />
     <ClInclude Include="..\src\map\skill.h" />
@@ -228,16 +232,20 @@
     <ClCompile Include="..\src\common\thread.c" />
     <ClCompile Include="..\src\common\timer.c" />
     <ClCompile Include="..\src\common\utils.c" />
+	<ClCompile Include="..\src\map\achievement.c" />
     <ClCompile Include="..\src\map\atcommand.c" />
     <ClCompile Include="..\src\map\battle.c" />
     <ClCompile Include="..\src\map\battleground.c" />
     <ClCompile Include="..\src\map\buyingstore.c" />
+	<ClCompile Include="..\src\map\channel.c" />
     <ClCompile Include="..\src\map\chat.c" />
     <ClCompile Include="..\src\map\chrif.c" />
     <ClCompile Include="..\src\map\clif.c" />
     <ClCompile Include="..\src\map\date.c" />
     <ClCompile Include="..\src\map\duel.c" />
     <ClCompile Include="..\src\map\elemental.c" />
+	<ClCompile Include="..\src\map\faction.c" />
+	<ClCompile Include="..\src\map\region.c" />
     <ClCompile Include="..\src\map\guild.c" />
     <ClCompile Include="..\src\map\intif.c" />
     <ClCompile Include="..\src\map\itemdb.c" />
Index: vcproj-10/map-server.vcxproj.filters
===================================================================
--- vcproj-10/map-server.vcxproj.filters	(revision 1953)
+++ vcproj-10/map-server.vcxproj.filters	(working copy)
@@ -1,6 +1,9 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
+    <ClCompile Include="..\src\map\achievement.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\atcommand.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -13,6 +16,9 @@
     <ClCompile Include="..\src\map\buyingstore.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\channel.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\chat.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -31,6 +37,12 @@
     <ClCompile Include="..\src\map\elemental.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\faction.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\map\region.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\guild.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -85,6 +97,9 @@
     <ClCompile Include="..\src\map\quest.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\region.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\script.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -195,6 +210,9 @@
     </ClCompile>
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="..\src\map\achievement.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\atcommand.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -207,6 +225,9 @@
     <ClInclude Include="..\src\map\buyingstore.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\channel.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\chat.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -225,6 +246,9 @@
     <ClInclude Include="..\src\map\elemental.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\faction.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\guild.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -276,6 +300,9 @@
     <ClInclude Include="..\src\map\quest.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\region.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\script.h">
       <Filter>map_sql</Filter>
     </ClInclude>
Index: vcproj-12/char-server.vcxproj
===================================================================
--- vcproj-12/char-server.vcxproj	(revision 1953)
+++ vcproj-12/char-server.vcxproj	(working copy)
@@ -86,7 +86,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
@@ -128,7 +127,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
@@ -160,6 +158,7 @@
     <ClInclude Include="..\src\common\timer.h" />
     <ClInclude Include="..\src\common\utils.h" />
     <ClInclude Include="..\src\char\char.h" />
+	<ClInclude Include="..\src\char\int_achievement.h" />
     <ClInclude Include="..\src\char\int_auction.h" />
     <ClInclude Include="..\src\char\int_elemental.h" />
     <ClInclude Include="..\src\char\int_guild.h" />
@@ -199,6 +198,7 @@
     <ClCompile Include="..\src\common\timer.c" />
     <ClCompile Include="..\src\common\utils.c" />
     <ClCompile Include="..\src\char\char.c" />
+	<ClCompile Include="..\src\char\int_achievement.c" />
     <ClCompile Include="..\src\char\int_auction.c" />
     <ClCompile Include="..\src\char\int_elemental.c" />
     <ClCompile Include="..\src\char\int_guild.c" />
Index: vcproj-12/char-server.vcxproj.filters
===================================================================
--- vcproj-12/char-server.vcxproj.filters	(revision 1953)
+++ vcproj-12/char-server.vcxproj.filters	(working copy)
@@ -46,6 +46,9 @@
     <ClCompile Include="..\src\char\char.c">
       <Filter>char_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\char\int_achievement.c">
+      <Filter>char_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\char\int_auction.c">
       <Filter>char_sql</Filter>
     </ClCompile>
@@ -162,6 +165,9 @@
     <ClInclude Include="..\src\char\char.h">
       <Filter>char_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\char\int_achievement.h">
+      <Filter>char_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\char\int_auction.h">
       <Filter>char_sql</Filter>
     </ClInclude>
Index: vcproj-12/login-server.vcxproj
===================================================================
--- vcproj-12/login-server.vcxproj	(revision 1953)
+++ vcproj-12/login-server.vcxproj	(working copy)
@@ -85,7 +85,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
@@ -131,7 +130,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
Index: vcproj-12/map-server.vcxproj
===================================================================
--- vcproj-12/map-server.vcxproj	(revision 1953)
+++ vcproj-12/map-server.vcxproj	(working copy)
@@ -84,7 +84,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
@@ -126,7 +125,6 @@
       <DataExecutionPrevention>
       </DataExecutionPrevention>
       <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
@@ -162,16 +160,19 @@
     <ClInclude Include="..\src\common\timer.h" />
     <ClInclude Include="..\src\common\utils.h" />
     <ClInclude Include="..\src\common\winapi.h" />
+	<ClInclude Include="..\src\map\achievement.h" />
     <ClInclude Include="..\src\map\atcommand.h" />
     <ClInclude Include="..\src\map\battle.h" />
     <ClInclude Include="..\src\map\battleground.h" />
     <ClInclude Include="..\src\map\buyingstore.h" />
+	<ClInclude Include="..\src\map\channel.h" />
     <ClInclude Include="..\src\map\chat.h" />
     <ClInclude Include="..\src\map\chrif.h" />
     <ClInclude Include="..\src\map\clif.h" />
     <ClInclude Include="..\src\map\date.h" />
     <ClInclude Include="..\src\map\duel.h" />
     <ClInclude Include="..\src\map\elemental.h" />
+	<ClInclude Include="..\src\map\faction.h" />
     <ClInclude Include="..\src\map\guild.h" />
     <ClInclude Include="..\src\map\intif.h" />
     <ClInclude Include="..\src\map\itemdb.h" />
@@ -195,6 +196,7 @@
     <ClInclude Include="..\src\config\renewal.h" />
     <ClInclude Include="..\src\config\secure.h" />
     <ClInclude Include="..\src\config\classes\general.h" />
+	<ClInclude Include="..\src\map\region.h" />
     <ClInclude Include="..\src\map\script.h" />
     <ClInclude Include="..\src\map\searchstore.h" />
     <ClInclude Include="..\src\map\skill.h" />
@@ -232,16 +234,19 @@
     <ClCompile Include="..\src\common\thread.c" />
     <ClCompile Include="..\src\common\timer.c" />
     <ClCompile Include="..\src\common\utils.c" />
+	<ClCompile Include="..\src\map\achievement.c" />
     <ClCompile Include="..\src\map\atcommand.c" />
     <ClCompile Include="..\src\map\battle.c" />
     <ClCompile Include="..\src\map\battleground.c" />
     <ClCompile Include="..\src\map\buyingstore.c" />
+	<ClCompile Include="..\src\map\channel.c" />
     <ClCompile Include="..\src\map\chat.c" />
     <ClCompile Include="..\src\map\chrif.c" />
     <ClCompile Include="..\src\map\clif.c" />
     <ClCompile Include="..\src\map\date.c" />
     <ClCompile Include="..\src\map\duel.c" />
     <ClCompile Include="..\src\map\elemental.c" />
+	<ClCompile Include="..\src\map\faction.c" />
     <ClCompile Include="..\src\map\guild.c" />
     <ClCompile Include="..\src\map\intif.c" />
     <ClCompile Include="..\src\map\itemdb.c" />
@@ -261,6 +266,7 @@
     <ClCompile Include="..\src\map\pc_groups.c" />
     <ClCompile Include="..\src\map\pet.c" />
     <ClCompile Include="..\src\map\quest.c" />
+	<ClCompile Include="..\src\map\region.c" />
     <ClCompile Include="..\src\map\script.c" />
     <ClCompile Include="..\src\map\searchstore.c" />
     <ClCompile Include="..\src\map\skill.c" />
@@ -273,15 +279,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-  <Target Name="AfterBuild">
-    <Copy SourceFiles="..\conf\import-tmpl\battle_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\battle_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\char_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\char_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\inter_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\inter_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\log_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\log_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\login_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\login_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\map_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\map_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\msg_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\msg_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\packet_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\packet_conf.txt')" />
-    <Copy SourceFiles="..\conf\import-tmpl\script_conf.txt" DestinationFolder="..\conf\import\" ContinueOnError="true" Condition="!Exists('..\conf\import\script_conf.txt')" />
-  </Target>
 </Project>
Index: vcproj-12/map-server.vcxproj.filters
===================================================================
--- vcproj-12/map-server.vcxproj.filters	(revision 1953)
+++ vcproj-12/map-server.vcxproj.filters	(working copy)
@@ -1,6 +1,9 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
+    <ClCompile Include="..\src\map\achievement.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\atcommand.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -13,6 +16,9 @@
     <ClCompile Include="..\src\map\buyingstore.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\channel.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\chat.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -31,6 +37,9 @@
     <ClCompile Include="..\src\map\elemental.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\faction.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\guild.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -85,6 +94,9 @@
     <ClCompile Include="..\src\map\quest.c">
       <Filter>map_sql</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\map\region.c">
+      <Filter>map_sql</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map\script.c">
       <Filter>map_sql</Filter>
     </ClCompile>
@@ -195,6 +207,9 @@
     </ClCompile>
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="..\src\map\achievement.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\atcommand.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -207,6 +222,9 @@
     <ClInclude Include="..\src\map\buyingstore.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\channel.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\chat.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -225,6 +243,9 @@
     <ClInclude Include="..\src\map\elemental.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\faction.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\guild.h">
       <Filter>map_sql</Filter>
     </ClInclude>
@@ -276,6 +297,9 @@
     <ClInclude Include="..\src\map\quest.h">
       <Filter>map_sql</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\map\region.h">
+      <Filter>map_sql</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\map\script.h">
       <Filter>map_sql</Filter>
     </ClInclude>
Index: vcproj-12/mapcache.vcxproj
===================================================================
--- vcproj-12/mapcache.vcxproj	(revision 1953)
+++ vcproj-12/mapcache.vcxproj	(working copy)
@@ -79,13 +79,12 @@
       <ProgramDatabaseFile>$(OutDir)$(ProjectName).pdb</ProgramDatabaseFile>
       <SubSystem>Console</SubSystem>
       <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
@@ -120,13 +119,12 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
       <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
       <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
     <ClCompile Include="..\3rdparty\libconfig\grammar.c" />
     <ClCompile Include="..\3rdparty\libconfig\libconfig.c" />
     <ClCompile Include="..\3rdparty\libconfig\scanctx.c" />
Index: vcproj-12/mapcache.vcxproj.filters
===================================================================
--- vcproj-12/mapcache.vcxproj.filters	(revision 1953)
+++ vcproj-12/mapcache.vcxproj.filters	(working copy)
@@ -105,13 +105,12 @@
     <ClInclude Include="..\src\common\utils.h">
       <Filter>common</Filter>
     </ClInclude>
-    <ClInclude Include="..\src\common\winapi.h">
-      <Filter>common</Filter>
-    </ClInclude>
-    <ClInclude Include="..\src\config\renewal.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <Filter Include="common">
+    <ClInclude Include="..\src\common\winapi.h">
+      <Filter>common</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <Filter Include="common">
       <UniqueIdentifier>{a9c2444c-ffec-4e89-8412-e530231d79dc}</UniqueIdentifier>
     </Filter>
     <Filter Include="mapcache">
